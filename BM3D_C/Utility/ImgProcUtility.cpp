// Utility Functions
// Luhong Liang, IC-ASD, ASTRI
// Setp. 7, 2011


#include "stdafx.h"
#include "ImgProcUtility.h"

#define IPL_SAME_FORMAT(a, b)		\
			( a != NULL && b != NULL && a->width == b->width && a->height == b->height && \
			  a->nChannels == b->nChannels && a->depth == b->depth)

#define CLIP_UP_PIX(a, u) ((a)>(u) ? (u) : (a))
#define CLIP_DOWN_PIX(a, d) ((a)<(d) ? (d) : (a))
#define CLIP_PIX(a, u, d) CLIP_UP_PIX(CLIP_DOWN_PIX(a, d), u)

#ifdef VEUHDFILTER2D_EXPORTS        // December, 2014
int CImageUtility::m_nShowMsg = 0;							// internal messages to show vis callback function; 0 -- no message, 1 -- error message only, 2 -- all messages
VEUHDCore::VEUHD4K_CALLBACK_FUNC CImageUtility::m_pCallback = NULL;	// pointer to the callback function. set NULL to disable the callback function
VEUHDCore::VEUHDCoreMsg *CImageUtility::m_pCallbackMsg = NULL;			// pointer to the message data buffer allocated by DLL caller and used by the callback function
#endif      // #ifdef VEUHDFILTER2D_EXPORTS

#ifdef _SUPPORT_ASTRI_VEUHD_DLL                  // September, 2014
int CImageUtility::m_nShowMsg = 0;							// internal messages to show vis callback function; 0 -- no message, 1 -- error message only, 2 -- all messages
_VEUHD_CALL_BACK_FUNC CImageUtility::m_pCallback = NULL;	// pointer to the callback function. set NULL to disable the callback function
_VEUHD_CALL_BACK_MSG *CImageUtility::m_pCallbackMsg = NULL;			// pointer to the message data buffer allocated by DLL caller and used by the callback function
#endif		// #ifdef _SUPPORT_ASTRI_VEUHD_DLL

#ifdef _USE_MY_DPX_DECODER
#include "DPXFileIO.h"
CDPXFileIO g_dpxFile(false);
#endif      // #ifdef _USE_MY_DPX_DECODER

void CImageUtility::showMessage(char *format, ...)
{
    va_list args;
	va_start(args, format);   
#ifdef _SUPPORT_ASTRI_VEUHD_DLL
	if (m_nShowMsg >= 2 && m_pCallback != NULL && m_pCallbackMsg != NULL) {
		m_pCallbackMsg->msg_type = 1;
		vsprintf(m_pCallbackMsg->msg, format, args);
		(*m_pCallback)(m_pCallbackMsg);
	}
#endif		// #ifdef _SUPPORT_ASTRI_VEUHD_DLL

#ifdef VEUHDFILTER2D_EXPORTS
	if (m_nShowMsg >= 2 && m_pCallback != NULL && m_pCallbackMsg != NULL) {
		m_pCallbackMsg->msg_type = 2;
		vsprintf(m_pCallbackMsg->msg, format, args);
		(*m_pCallback)(m_pCallbackMsg);
	}
#endif      // #ifdef VEUHDFILTER2D_EXPORTS

#ifndef VEUHDFILTER2D_EXPORTS
#ifndef _SUPPORT_ASTRI_VEUHD_DLL
	vprintf (format, args); 
#endif
#endif

    return;
}

void CImageUtility::showMessage1(char *format, ...)
{
    va_list args;
	va_start(args, format);   
#ifdef _SUPPORT_ASTRI_VEUHD_DLL
	if (m_nShowMsg >= 3 && m_pCallback != NULL && m_pCallbackMsg != NULL) {
		m_pCallbackMsg->msg_type = 3;
		vsprintf(m_pCallbackMsg->msg, format, args);
		(*m_pCallback)(m_pCallbackMsg);
	}
#endif		// #ifdef _SUPPORT_ASTRI_VEUHD_DLL

#ifdef VEUHDFILTER2D_EXPORTS
	if (m_nShowMsg >= 3 && m_pCallback != NULL && m_pCallbackMsg != NULL) {
		m_pCallbackMsg->msg_type = 3;
		vsprintf(m_pCallbackMsg->msg, format, args);
		(*m_pCallback)(m_pCallbackMsg);
	}
#endif      // #ifdef VEUHDFILTER2D_EXPORTS

#ifndef VEUHDFILTER2D_EXPORTS
#ifndef _SUPPORT_ASTRI_VEUHD_DLL
	vprintf (format, args); 
#endif
#endif

    return;
}

void CImageUtility::showErrMsg(char *format, ...)
{
    va_list args;
	va_start(args, format);   
#ifdef _SUPPORT_ASTRI_VEUHD_DLL
	if (m_nShowMsg >= 1 && m_pCallback != NULL && m_pCallbackMsg != NULL) {
		m_pCallbackMsg->msg_type = 1;
		vsprintf(m_pCallbackMsg->msg, format, args);
		(*m_pCallback)(m_pCallbackMsg);
	}
#endif		// #ifdef _SUPPORT_ASTRI_VEUHD_DLL

#ifdef VEUHDFILTER2D_EXPORTS
	if (m_nShowMsg >= 1 && m_pCallback != NULL && m_pCallbackMsg != NULL) {
		m_pCallbackMsg->msg_type = 1;
		vsprintf(m_pCallbackMsg->msg, format, args);
		(*m_pCallback)(m_pCallbackMsg);
	}
#endif      // #ifdef VEUHDFILTER2D_EXPORTS

#ifndef VEUHDFILTER2D_EXPORTS
#ifndef _SUPPORT_ASTRI_VEUHD_DLL
	vprintf (format, args); 
#endif
#endif

    return;
}

void CImageUtility::safeReleaseImage(IplImage **iplImage1)
{
	if (*iplImage1 != NULL) releaseImage(iplImage1);
	*iplImage1 = NULL;
	return;
}

void CImageUtility::safeReleaseImage(IplImage **iplImage1, IplImage **iplImage2)
{
	safeReleaseImage(iplImage1);
	safeReleaseImage(iplImage2);
	return;
}

void CImageUtility::safeReleaseImage(IplImage **iplImage1, IplImage **iplImage2, IplImage **iplImage3)
{
	safeReleaseImage(iplImage1, iplImage2);
	safeReleaseImage(iplImage3);
	return;
}

void CImageUtility::safeReleaseImage(IplImage **iplImage1, IplImage **iplImage2, IplImage **iplImage3, IplImage **iplImage4)
{
	safeReleaseImage(iplImage1, iplImage2);
	safeReleaseImage(iplImage3, iplImage4);
	return;
}

void CImageUtility::safeReleaseImage(IplImage **iplImage1, IplImage **iplImage2, IplImage **iplImage3, IplImage **iplImage4, IplImage **iplImage5)
{
	safeReleaseImage(iplImage1, iplImage2);	
	safeReleaseImage(iplImage3, iplImage4, iplImage5);	
	return;
}

void CImageUtility::safeReleaseImage(IplImage **iplImage1, IplImage **iplImage2, IplImage **iplImage3, IplImage **iplImage4, IplImage **iplImage5, IplImage **iplImage6)
{
	safeReleaseImage(iplImage1, iplImage2, iplImage3);
	safeReleaseImage(iplImage4, iplImage5, iplImage6);
	return;
}

IplImage *CImageUtility::createImage( CvSize size, int depth, int channels )
{
	// -------------------------------------------------
	// OpenCV implementations
	// -------------------------------------------------
	
#ifdef __OPENCV_OLD_CV_H__
#ifndef __SR_USE_SIMD
	return cvCreateImage(size, depth, channels);
#endif      // #ifndef __SR_USE_SIMD
#endif		// #ifdef __OPENCV_OLD_CV_H__

    return createImage(size.width, size.height, depth, channels);
}

IplImage *CImageUtility::createImage( IplImage *iplImage)
{
	// -------------------------------------------------
	// OpenCV implementations
	// -------------------------------------------------
    
#ifdef __OPENCV_OLD_CV_H__
#ifndef __SR_USE_SIMD
	return cvCreateImage(cvSize(iplImage->width, iplImage->height), iplImage->depth, iplImage->nChannels);
#endif      // #ifndef __SR_USE_SIMD
#endif		// #ifdef __OPENCV_OLD_CV_H__

    return createImage(iplImage->width, iplImage->height, iplImage->depth, iplImage->nChannels);
}

IplImage *CImageUtility::createImage( int width, int height, int depth, int channels ) 
{
    //const int default_image_row_align = 4;
    IplImage *iplImage = NULL;
	// -------------------------------------------------
	// OpenCV implementations
	// -------------------------------------------------
	
#ifdef __OPENCV_OLD_CV_H__
#ifndef __SR_USE_SIMD
    CvSize s;
    s.width = width;
    s.height = height;
	iplImage = cvCreateImage(s, depth, channels);
    if (iplImage == NULL) return NULL;
    iplImage->align = 4;//default_image_row_align;
    return iplImage;
#endif      // #ifndef __SR_USE_SIMD
#endif		// #ifdef __OPENCV_OLD_CV_H__

    // -------------------------------------------------
	// in-house functions
	// -------------------------------------------------
	const unsigned int depth_sign = 0x80000000;
	const int ipl_orgin_tl = 0;

	// cvCreateImageHeader ()
	iplImage = (IplImage *)new char[sizeof(*iplImage)];

	// cvInitImageHeader()
    if( iplImage == NULL ) {
		showErrMsg("Fail to allocate buffer for image header in CImageUtility::createImage()!\n");
		return NULL;
	}

    memset( iplImage, 0, sizeof(*iplImage) );
    iplImage->nSize = sizeof( *iplImage );

    //icvGetColorModel( channels, &colorModel, &channelSeq );
    static const char* tab[][2] =
    {
        {"GRAY", "GRAY"},
        {"",""},
        {"RGB","BGR"},
        {"RGB","BGRA"}
    };
	int ch_idx = channels - 1;
    if( ch_idx <= 3 ) {
		strncpy( iplImage->colorModel, tab[channels][0], 4 );
		strncpy( iplImage->channelSeq, tab[channels][1], 4 );
    } else {
		iplImage->colorModel[0] = 0;		// ""
		iplImage->channelSeq[0] = 0;
	}
	// end of icvGetColorModel

	if( width < 0 || height < 0 ) {
		showErrMsg("Invalid image size in CImageUtility::createImage()!\n");
		delete iplImage;
		return NULL;
	}

    if( (depth != (int)SR_DEPTH_1U && depth != (int)SR_DEPTH_8U &&
         depth != (int)SR_DEPTH_8S && depth != (int)SR_DEPTH_16U &&
         depth != (int)SR_DEPTH_16S && depth != (int)SR_DEPTH_32S &&
         depth != (int)SR_DEPTH_32F && depth != (int)SR_DEPTH_64F) ||
         channels < 0 ) {
		showErrMsg("Unsupported image data format in CImageUtility::createImage()!\n");
		delete iplImage;
		return NULL;
	}

    iplImage->width = width;
    iplImage->height = height;

    if( iplImage->roi ) {
        iplImage->roi->coi = 0;
        iplImage->roi->xOffset = iplImage->roi->yOffset = 0;
        iplImage->roi->width = width;
        iplImage->roi->height = height;
    }
    iplImage->maskROI =NULL;
    iplImage->imageId = NULL;                 // "           " 
    iplImage->tileInfo = NULL;					// "           " 

    iplImage->nChannels = channels < 1 ? 1 : channels;
    iplImage->depth = depth;

#ifdef __SR_USE_SIMD        // use aligned image data buffer for SIMD implementation
    const int simd_image_row_align = 64;
    iplImage->align = simd_image_row_align;
    iplImage->widthStep = (((iplImage->width * iplImage->nChannels *
						                  (iplImage->depth & ~depth_sign) + 7)/8)+ simd_image_row_align - 1) & (~(simd_image_row_align - 1));
    iplImage->origin = ipl_orgin_tl;
    iplImage->imageSize = iplImage->widthStep * iplImage->height;
    iplImage->imageData = (char *)_aligned_malloc(iplImage->imageSize, 64);
#else
    iplImage->align = 4;//default_image_row_align;
    //iplImage->widthStep = (((iplImage->width * iplImage->nChannels *
	//					   (iplImage->depth & ~depth_sign) + 7)/8)+ default_image_row_align - 1) & (~(default_image_row_align - 1));
    iplImage->widthStep = (((iplImage->width * iplImage->nChannels *
						   (iplImage->depth & ~depth_sign) + 7)/8)+ 4 - 1) & (~(4 - 1));
    iplImage->origin = ipl_orgin_tl;
    iplImage->imageSize = iplImage->widthStep * iplImage->height;
	// end of cvInitImageHeader()
	// end of cvCreateImageHeader ()

	// cvCreateData()
    iplImage->imageData = new char[iplImage->imageSize];
#endif

	if (iplImage->imageData == NULL) {
		showErrMsg("Fail to allocate image buffer in CImageUtility::createImage()!\n");
		delete iplImage;
		return NULL;
	}
	// end of cvCreateData()

	return iplImage;
}

void CImageUtility::releaseImage(IplImage **pImg)
{
	// -------------------------------------------------
	// OpenCV implementations
	// -------------------------------------------------

#ifdef __OPENCV_OLD_CV_H__
#ifndef __SR_USE_SIMD
	cvReleaseImage(pImg);
	return;
#endif      // #ifndef __SR_USE_SIMD
#endif		// #ifdef __OPENCV_OLD_CV_H__

	// -------------------------------------------------
	// in-house functions
	// -------------------------------------------------
	if (pImg == NULL || (*pImg)== NULL) return;

	if ((*pImg)->roi != NULL) delete (*pImg)->roi;
	if ((*pImg)->maskROI != NULL) delete (*pImg)->maskROI;
	if ((*pImg)->imageId != NULL) delete (*pImg)->imageId;
	if ((*pImg)->tileInfo != NULL) delete (*pImg)->tileInfo;
#ifdef __SR_USE_SIMD
    if ((*pImg)->imageData != NULL) _aligned_free((*pImg)->imageData);
#else
	if ((*pImg)->imageData != NULL) delete [] (*pImg)->imageData;
#endif      // #ifndef __SR_USE_SIMD

    delete [] (*pImg);

	(*pImg) = NULL;

	return;

}

bool CImageUtility::copy(unsigned char *pSrc, IplImage *iplDst)
// image copy implemented by OpenCV or in-house function
// Luhong Liang, IC-ASD, ASTRI
// June 4, 2013
{
	if (pSrc == NULL || iplDst == NULL || iplDst->depth != SR_DEPTH_8U) {
		showErrMsg("Mismatched source and destination images in CImageUtility::copy()!\n");
		return false;
	}

	memcpy((unsigned char*)iplDst->imageData, pSrc, iplDst->widthStep * iplDst->height);

	return true;
}

bool CImageUtility::copy(IplImage *iplSrc, unsigned char *pDst)
// image copy implemented by OpenCV or in-house function
// Luhong Liang, IC-ASD, ASTRI
// June 4, 2013
{
	if (pDst == NULL || iplSrc == NULL || iplSrc->depth != SR_DEPTH_8U) {
		showErrMsg("Mismatched source and destination images in CImageUtility::copy()!\n");
		return false;
	}

	memcpy(pDst, (unsigned char*)iplSrc->imageData, iplSrc->widthStep * iplSrc->height);

	return true;
}

bool CImageUtility::copy(IplImage *iplSrc, IplImage *iplDst)
// image copy implemented by OpenCV or in-house function
// Luhong Liang, IC-ASD, ASTRI
// May 31, 2013
{
	if (iplSrc == NULL || iplDst == NULL || iplSrc->width != iplDst->width ||
		iplSrc->nChannels != iplDst->nChannels || iplSrc->depth != iplDst->depth) {
		showErrMsg("Mismatched source and destination images in CImageUtility::copy()!\n");
		return false;
	}

    if (iplSrc == iplDst) {
        // same image
        return true;
    }

	// -------------------------------------------------
	// OpenCV implementations
	// -------------------------------------------------
#ifdef __OPENCV_OLD_CV_H__
#ifndef __SR_USE_SIMD
	cvCopy(iplSrc, iplDst);
	return true;
#endif  // #ifndef __SR_USE_SIMD
#endif		// #ifdef __OPENCV_OLD_CV_H__

	// -------------------------------------------------
	// in-house functions
	// -------------------------------------------------
    for (int y=0; y<iplDst->height; y++) {  // do the copy line by line for alignment
        memcpy((unsigned char*)(iplDst->imageData+ y*iplDst->widthStep), 
               (unsigned char*)(iplSrc->imageData + y*iplSrc->widthStep), 
               iplSrc->widthStep);
    }

	return true;
}

IplImage *CImageUtility::clone(IplImage *iplImage)
// image clone implemented by OpenCV or in-house function
{
	if (iplImage == NULL) {
		showErrMsg("Mismatched source images in CImageUtility::clone()!\n");
		return false;
	}

	// -------------------------------------------------
	// OpenCV implementations
	// -------------------------------------------------
#ifdef __OPENCV_OLD_CV_H__
#ifndef __SR_USE_SIMD
	return cvCloneImage(iplImage);
#endif // #ifndef __SR_USE_SIMD
#endif		// #ifdef __OPENCV_OLD_CV_H__

	// -------------------------------------------------
	// in-house functions
	// -------------------------------------------------
	IplImage *iplDstImage = createImage( iplImage->width, iplImage->height, iplImage->depth, iplImage->nChannels);
	if (iplDstImage == NULL) {
		showErrMsg("Fail to allocate image buffer in CImageUtility::clone()!\n");
		return NULL;
	}

	copy(iplImage, iplDstImage);

	return iplDstImage;
}

IplImage *CImageUtility::clone(float *pImageData, int width, int height)
{
	IplImage *iplDstImage = createImage( width, height, SR_DEPTH_32F, 1);
	if (iplDstImage == NULL) {
		showErrMsg("Fail to allocate image buffer in CImageUtility::clone()!\n");
		return NULL;
	}

    for (int y=0; y<iplDstImage->height; y++) {
        float *pDst = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pSrc = pImageData + y * width;
        for (int x=0; x<iplDstImage->width; x++) {
            pDst[x] = pSrc[x];
        }
    }

    return iplDstImage;
}

bool CImageUtility::setZero(IplImage *iplImage)
// image copy implemented by OpenCV or in-house function
// Luhong Liang, IC-ASD, ASTRI
// May 31, 2013
{
	if (iplImage == NULL || iplImage->widthStep < 1 || iplImage->height < 1) {
		showErrMsg("Invalid input image in CImageUtility::setZero()!\n");
		return false;
	}

	// -------------------------------------------------
	// OpenCV implementations
	// -------------------------------------------------
#ifdef __OPENCV_OLD_CV_H__
	cvSetZero(iplImage);
	return true;
#else		// #ifdef __OPENCV_OLD_CV_H__

	// -------------------------------------------------
	// in-house functions
	// -------------------------------------------------
	memset((unsigned char*)iplImage->imageData, 0, iplImage->widthStep * iplImage->height);

	return true;
#endif		// #ifdef __OPENCV_OLD_CV_H__
}

bool CImageUtility::setValue3(IplImage *iplImage, float R, float G, float B)
{
	if (iplImage == NULL || iplImage->widthStep < 1 || iplImage->height < 1) {
		showErrMsg("Invalid input image in CImageUtility::setValue()!\n");
		return false;
	}

	// -------------------------------------------------
	// OpenCV implementations
	// -------------------------------------------------
#ifdef __OPENCV_OLD_CV_H__
    if (iplImage->depth == SR_DEPTH_32F) {
        if (iplImage->nChannels == 1) {
            cvSet(iplImage, cvScalar(R));
        } else if (iplImage->nChannels == 3) {
            cvSet(iplImage, cvScalar(R, G, B));
        } else if (iplImage->nChannels == 4) {
            cvSet(iplImage, cvScalar(R, G, B, 0.0f));
        } else {
            showErrMsg("Only support input image with 1, 3, or 4 channel(s) in CImageUtility::setValue()!\n");
            return false;
        }
    } else {
		showErrMsg("Only support floating point input image in CImageUtility::setValue()!\n");
		return false;
    }
#else		// #ifdef __OPENCV_OLD_CV_H__
    if (iplImage->depth == SR_DEPTH_32F) {
        if (iplImage->nChannels == 1) {
            for (int y=0; y<iplImage->height; y++) {
                float *pImg = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
                for (int x=0; x<iplImage->width; x++) {
                    pImg[x] = R;
                }
            }
        } else if (iplImage->nChannels == 3) {
            for (int y=0; y<iplImage->height; y++) {
                float *pImg = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
                for (int x=0; x<iplImage->width; x+=3) {
                    pImg[x] = B;
                    pImg[x+1] = G;
                    pImg[x+2] = R;
                }
            }
        } else if (iplImage->nChannels == 4) {
            for (int y=0; y<iplImage->height; y++) {
                float *pImg = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
                for (int x=0; x<iplImage->width; x+=4) {
                    pImg[x] = B;
                    pImg[x+1] = G;
                    pImg[x+2] = R;
                    pImg[x+3] = 0.0f;
                }
            }
        } else {
            showErrMsg("Only support input image with 1, 3, or 4 channel(s) in CImageUtility::setValue()!\n");
            return false;
        }
    } else if (iplImage->depth == SR_DEPTH_8U) {
        int int_r = (int)(R + 0.5f);
        int_r = int_r < 0 ? 0 : int_r;
        int_r = int_r > 255 ? 255 : int_r;
        int int_g = (int)(G + 0.5f);
        int_g = int_g < 0 ? 0 : int_g;
        int_g = int_g > 255 ? 255 : int_g;
        int int_b = (int)(B + 0.5f);
        int_b = int_b < 0 ? 0 : int_b;
        int_b = int_b > 255 ? 255 : int_b;
        if (iplImage->nChannels == 1) {
            for (int y=0; y<iplImage->height; y++) {
                unsigned char *pImg = (unsigned char *)((char *)iplImage->imageData + y * iplImage->widthStep);
                for (int x=0; x<iplImage->width; x++) {
                    pImg[x] = (unsigned char)int_r;
                }
            }
        } else if (iplImage->nChannels == 3) {
            for (int y=0; y<iplImage->height; y++) {
                unsigned char *pImg = (unsigned char *)((char *)iplImage->imageData + y * iplImage->widthStep);
                for (int x=0; x<iplImage->width; x+=3) {
                    pImg[x] = (unsigned char)int_b;
                    pImg[x+1] = (unsigned char)int_g;
                    pImg[x+2] = (unsigned char)int_r;
                }
            }
        } else if (iplImage->nChannels == 4) {
            for (int y=0; y<iplImage->height; y++) {
                unsigned char *pImg = (unsigned char *)((char *)iplImage->imageData + y * iplImage->widthStep);
                for (int x=0; x<iplImage->width; x+=4) {
                    pImg[x] = (unsigned char)int_b;
                    pImg[x+1] = (unsigned char)int_g;
                    pImg[x+2] = (unsigned char)int_r;
                    pImg[x+3] = 0;
                }
            }
        } else {
            showErrMsg("Only support input image with 1, 3, or 4 channel(s) in CImageUtility::setValue()!\n");
            return false;
        }
    } else {
		showErrMsg("Only support floating point input image in CImageUtility::setValue()!\n");
		return false;
    }
#endif		// #ifdef __OPENCV_OLD_CV_H__

    return true;
}

IplImage *CImageUtility::getSubImage(IplImage *iplImage, CvRect rect)
// get a rectange subimage
{
    if (iplImage == NULL || rect.x < 0 || rect.y < 0 || rect.width < 0 || rect.height < 0) {
        showErrMsg("Invalid input image or rectange in CImageUtility::getSubImage()!\n");
        return NULL;
    }

    int right = rect.x + rect.width;
    right = right > iplImage->width ? iplImage->width : right;
    int bottom = rect.y + rect.height;
    bottom = bottom > iplImage->height ? iplImage->height : bottom;
    int width = right - rect.x;
    int height = bottom - rect.y;
    if (width < 1 || height < 1) {
        showErrMsg("ROI out of input image in CImageUtility::getSubImage()!\n");
        return NULL;
    }

    // check data type
    int pix_bytes;
    switch (iplImage->depth) {
        case SR_DEPTH_8U:
        case SR_DEPTH_8S:
            pix_bytes = 1;
            break;
        case SR_DEPTH_16U:
        case SR_DEPTH_16S:
            pix_bytes = 2;
            break;
        case SR_DEPTH_32F:
        case SR_DEPTH_32S:
            pix_bytes = 4;
            break;
        case SR_DEPTH_64F:
            pix_bytes = 8;
            break;
        default:
            showErrMsg("Unsupported image data type in CImageUtility::getSubImage()!\n");
            return NULL;
    }

    // allocate result image
    IplImage *iplROI = createImage(width, height, iplImage->depth, iplImage->nChannels);
    if (iplROI == NULL) return NULL;

    // copy data
    for (int y=0, yy=rect.y; y<height; y++, yy++) {
        char *pSrc = (char *)(iplImage->imageData + yy * iplImage->widthStep) + rect.x * pix_bytes * iplImage->nChannels;
        char *pDst = (char *)(iplROI->imageData + y * iplROI->widthStep);
        memcpy(pDst, pSrc, width * iplImage->nChannels * pix_bytes);
    }

    return iplROI;
}

bool CImageUtility::stitchSubImage(IplImage *iplTarImage, int x, int y, IplImage *iplSubImage, CvRect rect, int method)
// Stitch the ROI part of an subimage into the existing target image at location (x,y)
// method -- 0: blending with the existing non-zero valued pixel
{
    if (iplTarImage == NULL || iplSubImage == NULL || iplTarImage->nChannels != iplSubImage->nChannels ||
        iplTarImage->depth != iplSubImage->depth || rect.x < 0 || rect.y < 0 || rect.width < 1 || rect.height < 1) {
        showErrMsg("Invalid input image or parameter in CImageUtility::stitchSubImage()!\n");
        return false;
    }

    if (method != 0) {
        showErrMsg("Unsupported image stitch method in CImageUtility::stitchSubImage()!\n");
        return false;
    }

    if (x >= iplTarImage->width || y >= iplTarImage->height) return true;
    if (rect.x >= iplSubImage->width || rect.y >= iplSubImage->height) return true;

    // calculate valid regions
    int src_wdith = (rect.x+rect.width) <= iplSubImage->width ? rect.width : (iplSubImage->width-rect.x);
    int src_height = (rect.y+rect.height) <= iplSubImage->height ? rect.height : (iplSubImage->height-rect.y);

    int dst_right = x + src_wdith;
    dst_right = dst_right > iplTarImage->width ? iplTarImage->width : dst_right;
    int dst_bottom = y + src_height;
    dst_bottom = dst_bottom > iplTarImage->height ? iplTarImage->height : dst_bottom;

    // stitch
    if (iplTarImage->depth == SR_DEPTH_8U) {
        for (int yy=y, yyy=rect.y; yy<dst_bottom; yy++, yyy++) {
            unsigned char *pSrc = (unsigned char *)(iplSubImage->imageData + yyy * iplSubImage->widthStep);
            unsigned char *pDst = (unsigned char *)(iplTarImage->imageData + yy * iplTarImage->widthStep);
            for (int xx=x*iplSubImage->nChannels, xxx=rect.x*iplSubImage->nChannels; xx<dst_right*iplSubImage->nChannels; xx++, xxx++) {
                if (pDst[xx] == 0) {
                    pDst[xx] = pSrc[xxx];
                } else {
                    pDst[xx] = (pSrc[xxx] + pDst[xx]) / 2;
                }
            }
        }
    } else if (iplTarImage->depth == SR_DEPTH_16U) {
        for (int yy=y, yyy=rect.y; yy<dst_bottom; yy++, yyy++) {
            unsigned short *pSrc = (unsigned short *)(iplSubImage->imageData + yyy * iplSubImage->widthStep);
            unsigned short *pDst = (unsigned short *)(iplTarImage->imageData + yy * iplTarImage->widthStep);
            for (int xx=x*iplSubImage->nChannels, xxx=rect.x*iplSubImage->nChannels; xx<dst_right*iplSubImage->nChannels; xx++, xxx++) {
                if (pDst[xx] == 0) {
                    pDst[xx] = pSrc[xxx];
                } else {
                    pDst[xx] = (pSrc[xxx] + pDst[xx]) / 2;
                }
            }
        }
    } else if (iplTarImage->depth == SR_DEPTH_32S) {
        for (int yy=y, yyy=rect.y; yy<dst_bottom; yy++, yyy++) {
            int *pSrc = (int *)(iplSubImage->imageData + yyy * iplSubImage->widthStep);
            int *pDst = (int *)(iplTarImage->imageData + yy * iplTarImage->widthStep);
            for (int xx=x*iplSubImage->nChannels, xxx=rect.x*iplSubImage->nChannels; xx<dst_right*iplSubImage->nChannels; xx++, xxx++) {
                if (pDst[xx] == 0) {
                    pDst[xx] = pSrc[xxx];
                } else {
                    pDst[xx] = (pSrc[xxx] + pDst[xx]) / 2;
                }
            }
        }
    } else if (iplTarImage->depth == SR_DEPTH_32F) {
        for (int yy=y, yyy=rect.y; yy<dst_bottom; yy++, yyy++) {
            float *pSrc = (float *)(iplSubImage->imageData + yyy * iplSubImage->widthStep);
            float *pDst = (float *)(iplTarImage->imageData + yy * iplTarImage->widthStep);
            for (int xx=x*iplSubImage->nChannels, xxx=rect.x*iplSubImage->nChannels; xx<dst_right*iplSubImage->nChannels; xx++, xxx++) {
                if (pDst[xx] == 0.0f) {
                    pDst[xx] = pSrc[xxx];
                } else {
                    pDst[xx] = (pSrc[xxx] + pDst[xx]) * 0.5f;
                }
            }
        }
    } else {
        showErrMsg("Unsupported image data type in CImageUtility::stitchSubImage()!\n");
        return false;
    }

    return true;
}

IplImage *CImageUtility::stitchSbS(IplImage *iplLeft, IplImage *iplRight, int r, int g, int b, int thickness)
// Make a side-by-side image
// iplLeft, iplRight -- [I] input left and right image, must be the same height, channel and bit-depth, must be exactly fit iplTarImage
// r, g, b -- [I] color of the vertical seperation line (using r for grayscale images)
// thickness -- [I] shtickness of the vertical seperation line (0 for no seperation line)
{
    if (iplLeft == NULL || iplRight == NULL ||
        iplLeft->nChannels != iplLeft->nChannels || iplLeft->nChannels != iplRight->nChannels  ||
        iplRight->height != iplLeft->height || iplRight->depth != iplLeft->depth) {
        showErrMsg("Invalid input/output image or parameter in CImageUtility::stitchSbS()!\n");
        return false;
    }

    IplImage *iplTarImage = createImage(iplLeft->width+iplRight->width, iplLeft->height+iplRight->height, iplLeft->depth, iplLeft->nChannels);
    if (iplTarImage == NULL) return NULL;

    if (!stitchSbS(iplTarImage, iplLeft, iplRight, r, g, b, thickness)) {
        safeReleaseImage(&iplTarImage);
        return NULL;
    }

    return iplTarImage;
}

bool CImageUtility::stitchSbS(IplImage *iplTarImage, IplImage *iplLeft, IplImage *iplRight, int r, int g, int b, int thickness)
// Make a side-by-side image
// iplTarImage -- [O] result image
// iplLeft, iplRight -- [I] input left and right image, must be the same height, channel and bit-depth, must be exactly fit iplTarImage
// r, g, b -- [I] color of the vertical seperation line (using r for grayscale images)
// thickness -- [I] shtickness of the vertical seperation line (0 for no seperation line)
// support input image that is smaller than the resultant image
{
    if (iplTarImage == NULL || iplLeft == NULL || iplRight == NULL ||
        iplTarImage->nChannels != iplLeft->nChannels || iplTarImage->nChannels != iplRight->nChannels  ||
        iplTarImage->depth != iplLeft->depth || iplTarImage->depth != iplRight->depth ||
        iplTarImage->height < iplLeft->height || iplLeft->height != iplRight->height ||
        (iplLeft->width + iplRight->width) > iplTarImage->width) {  
        showErrMsg("Invalid input/output image or parameter in CImageUtility::stitchSbS()!\n");
        return false;
    }

    int line_left = thickness / 2;
    line_left = iplLeft->width < line_left ? iplLeft->width : line_left;
    int line_right = thickness - line_left;
    line_right = iplLeft->width+line_right > iplTarImage->width ? iplTarImage->width-iplLeft->width : line_right;  // fixed by Luhong, 10/02/2015
    int tar_height = iplLeft->height;

    if (iplTarImage->depth == SR_DEPTH_8U) {
        if (iplTarImage->nChannels == 1) {
            for (int y=0; y<tar_height; y++) {
                unsigned char *pLeft = (unsigned char *)(iplLeft->imageData + y * iplLeft->widthStep);
                unsigned char *pRight = (unsigned char *)(iplRight->imageData + y * iplRight->widthStep);
                unsigned char *pDst = (unsigned char *)(iplTarImage->imageData + y * iplTarImage->widthStep);
                // left
                for (int x=0; x<iplLeft->width-line_left; x++) {
                    pDst[x] = pLeft[x];
                }
                // line
                for (int x=iplLeft->width-line_left; x<iplLeft->width+line_right; x++) {
                    pDst[x] = (unsigned char)r;
                }
                //right
                for (int x=line_right, xx=iplLeft->width+line_right; x<iplRight->width; x++, xx++) {
                    pDst[xx] = pRight[x];
                }
            }
        } else {
            for (int y=0; y<tar_height; y++) {
                unsigned char *pLeft = (unsigned char *)(iplLeft->imageData + y * iplLeft->widthStep);
                unsigned char *pRight = (unsigned char *)(iplRight->imageData + y * iplRight->widthStep);
                unsigned char *pDst = (unsigned char *)(iplTarImage->imageData + y * iplTarImage->widthStep);
                // left
                for (int x=0; x<iplLeft->width-line_left; x++) {
                    pDst[3*x] = pLeft[3*x];
                    pDst[3*x+1] = pLeft[3*x+1];
                    pDst[3*x+2] = pLeft[3*x+2];
                }
                // line
                for (int x=iplLeft->width-line_left; x<iplLeft->width+line_right; x++) {
                    pDst[3*x] = (unsigned char)b;
                    pDst[3*x+1] = (unsigned char)g;
                    pDst[3*x+2] = (unsigned char)r;
                }
                //right
                for (int x=line_right, xx=iplLeft->width+line_right; x<iplRight->width; x++, xx++) {
                    pDst[3*xx] = pRight[3*x];
                    pDst[3*xx+1] = pRight[3*x+1];
                    pDst[3*xx+2] = pRight[3*x+2];
                }
            }
        }
    } else if (iplTarImage->depth == SR_DEPTH_32F) {
        if (iplTarImage->nChannels == 1) {
            for (int y=0; y<tar_height; y++) {
                float *pLeft = (float *)(iplLeft->imageData + y * iplLeft->widthStep);
                float *pRight = (float *)(iplRight->imageData + y * iplRight->widthStep);
                float *pDst = (float *)(iplTarImage->imageData + y * iplTarImage->widthStep);
                // left
                for (int x=0; x<iplLeft->width-line_left; x++) {
                    pDst[x] = pLeft[x];
                }
                // line
                for (int x=iplLeft->width-line_left; x<iplLeft->width+line_right; x++) {
                    pDst[x] = (float)r;
                }
                //right
                for (int x=line_right, xx=iplLeft->width+line_right; x<iplRight->width; x++, xx++) {
                    pDst[xx] = pRight[x];
                }
            }
        } else {
            for (int y=0; y<tar_height; y++) {
                float *pLeft = (float *)(iplLeft->imageData + y * iplLeft->widthStep);
                float *pRight = (float *)(iplRight->imageData + y * iplRight->widthStep);
                float *pDst = (float *)(iplTarImage->imageData + y * iplTarImage->widthStep);
                // left
                for (int x=0; x<iplLeft->width-line_left; x++) {
                    pDst[3*x] = pLeft[3*x];
                    pDst[3*x+1] = pLeft[3*x+1];
                    pDst[3*x+2] = pLeft[3*x+2];
                }
                // line
                for (int x=iplLeft->width-line_left; x<iplLeft->width+line_right; x++) {
                    pDst[3*x] = (float)b;
                    pDst[3*x+1] = (float)g;
                    pDst[3*x+2] = (float)r;
                }
                //right
                for (int x=line_right, xx=iplLeft->width+line_right; x<iplRight->width; x++, xx++) {
                    pDst[3*xx] = pRight[3*x];
                    pDst[3*xx+1] = pRight[3*x+1];
                    pDst[3*xx+2] = pRight[3*x+2];
                }
            }
        }
    } else if (iplTarImage->depth == SR_DEPTH_16U || iplTarImage->depth == SR_DEPTH_16S) {
        if (iplTarImage->nChannels == 1) {
            for (int y=0; y<tar_height; y++) {
                short *pLeft = (short *)(iplLeft->imageData + y * iplLeft->widthStep);
                short *pRight = (short *)(iplRight->imageData + y * iplRight->widthStep);
                short *pDst = (short *)(iplTarImage->imageData + y * iplTarImage->widthStep);
                // left
                for (int x=0; x<iplLeft->width-line_left; x++) {
                    pDst[x] = pLeft[x];
                }
                // line
                for (int x=iplLeft->width-line_left; x<iplLeft->width+line_right; x++) {
                    pDst[x] = (short)r;
                }
                //right
                for (int x=line_right, xx=iplLeft->width+line_right; x<iplRight->width; x++, xx++) {
                    pDst[xx] = pRight[x];
                }
            }
        } else {
            for (int y=0; y<tar_height; y++) {
                short *pLeft = (short *)(iplLeft->imageData + y * iplLeft->widthStep);
                short *pRight = (short *)(iplRight->imageData + y * iplRight->widthStep);
                short *pDst = (short *)(iplTarImage->imageData + y * iplTarImage->widthStep);
                // left
                for (int x=0; x<iplLeft->width-line_left; x++) {
                    pDst[3*x] = pLeft[3*x];
                    pDst[3*x+1] = pLeft[3*x+1];
                    pDst[3*x+2] = pLeft[3*x+2];
                }
                // line
                for (int x=iplLeft->width-line_left; x<iplLeft->width+line_right; x++) {
                    pDst[3*x] = (short)b;
                    pDst[3*x+1] = (short)g;
                    pDst[3*x+2] = (short)r;
                }
                //right
                for (int x=line_right, xx=iplLeft->width+line_right; x<iplRight->width; x++, xx++) {
                    pDst[3*xx] = pRight[3*x];
                    pDst[3*xx+1] = pRight[3*x+1];
                    pDst[3*xx+2] = pRight[3*x+2];
                }
            }
        }
    } else if (iplTarImage->depth == SR_DEPTH_32S) {
        if (iplTarImage->nChannels == 1) {
            for (int y=0; y<tar_height; y++) {
                int *pLeft = (int *)(iplLeft->imageData + y * iplLeft->widthStep);
                int *pRight = (int *)(iplRight->imageData + y * iplRight->widthStep);
                int *pDst = (int *)(iplTarImage->imageData + y * iplTarImage->widthStep);
                // left
                for (int x=0; x<iplLeft->width-line_left; x++) {
                    pDst[x] = pLeft[x];
                }
                // line
                for (int x=iplLeft->width-line_left; x<iplLeft->width+line_right; x++) {
                    pDst[x] = (int)r;
                }
                //right
                for (int x=line_right, xx=iplLeft->width+line_right; x<iplRight->width; x++, xx++) {
                    pDst[xx] = pRight[x];
                }
            }
        } else {
            for (int y=0; y<tar_height; y++) {
                int *pLeft = (int *)(iplLeft->imageData + y * iplLeft->widthStep);
                int *pRight = (int *)(iplRight->imageData + y * iplRight->widthStep);
                int *pDst = (int *)(iplTarImage->imageData + y * iplTarImage->widthStep);
                // left
                for (int x=0; x<iplLeft->width-line_left; x++) {
                    pDst[3*x] = pLeft[3*x];
                    pDst[3*x+1] = pLeft[3*x+1];
                    pDst[3*x+2] = pLeft[3*x+2];
                }
                // line
                for (int x=iplLeft->width-line_left; x<iplLeft->width+line_right; x++) {
                    pDst[3*x] = (int)b;
                    pDst[3*x+1] = (int)g;
                    pDst[3*x+2] = (int)r;
                }
                //right
                for (int x=line_right, xx=iplLeft->width+line_right; x<iplRight->width; x++, xx++) {
                    pDst[3*xx] = pRight[3*x];
                    pDst[3*xx+1] = pRight[3*x+1];
                    pDst[3*xx+2] = pRight[3*x+2];
                }
            }
        }
    } else {
        showErrMsg("Unsupported image data type in CImageUtility::stitchSbS()!\n");
        return false;
    }

    return true;
}

bool CImageUtility::decColorImage(IplImage *iplColorImage, IplImage *iplPlane1, IplImage *iplPlane2, IplImage *iplPlane3)
// Get color planes in an color image (only support 8-bit), TODO: support hybrid output in the future, different to cvSplit();
// arguments:
//			IplColorImage -- [I] input color image with 3 channels
//			IplPlane1 -- [I/O] decomposed color plane 1 (e.g. in YUV image, it is Y; while in RGB image, it is B)
//										user should allocate the image before call this function
//			IplPlane2 -- [I/O] decomposed color plane 2
//			IplPlane3 -- [I/O] decomposed color plane 3
// Luhong Liang, IC-ASD, ASTRI
// Setp. 7, 2011
{
	// check input arguments. TODO: check the size and bit depth
	if (iplColorImage == NULL || iplColorImage->nChannels != 3 || iplColorImage->depth != SR_DEPTH_8U ||
		iplPlane1 == NULL || iplPlane2 == NULL || iplPlane3 == NULL) {
		showErrMsg("Invalid input image in decColorImage()!\n");
		return false;
	}

	int width = iplColorImage->width;
	int height = iplColorImage->height;
	for (int y=0; y<height; y++) {
		unsigned char *pColorImage = (unsigned char *)(iplColorImage->imageData) + y * iplColorImage->widthStep;
		unsigned char *pPlane1 = (unsigned char *)(iplPlane1->imageData) + y * iplPlane1->widthStep;
		unsigned char *pPlane2 = (unsigned char *)(iplPlane2->imageData)+ y * iplPlane1->widthStep;
		unsigned char *pPlane3 = (unsigned char *)(iplPlane3->imageData)+ y * iplPlane1->widthStep;
		int index = 0;
		for (int x=0; x<width; x++) {
			pPlane1[x] = pColorImage[index];		// B, Y
			index ++;
			pPlane2[x] = pColorImage[index];		// G, U
			index ++;
			pPlane3[x] = pColorImage[index];		// R, V
			index ++;
		}
	}

	return true;
}

bool CImageUtility::asmColorImage(IplImage *iplPlane1, IplImage *iplPlane2, IplImage *iplPlane3, IplImage *iplColorImage)
// Get color planes in an color image (only support 8-bit), TODO: support hybrid output in the future, different to cvSplit();
// arguments:
//			IplPlane1 -- [I] decomposed color plane 1 (e.g. in YUV image, it is Y; while in RGB image, it is B)
//			IplPlane2 -- [I] decomposed color plane 2
//			IplPlane3 -- [I] decomposed color plane 3
//			IplColorImage -- [O] output color image with 3 channels
//										user should allocate the image before call this function
// Luhong Liang, IC-ASD, ASTRI
// June 27, 2011
{
	// check input arguments. TODO: check the size and bit depth
	if (iplColorImage == NULL || iplColorImage->nChannels != 3 || iplColorImage->depth != SR_DEPTH_8U ||
		iplPlane1 == NULL || iplPlane2 == NULL || iplPlane3 == NULL) {
		showErrMsg("Invalid input image in asmColorImage()!\n");
		return false;
	}

	int width = iplColorImage->width;
	int height = iplColorImage->height;
	for (int y=0; y<height; y++) {
		unsigned char *pPlane1 = (unsigned char *)(iplPlane1->imageData) + y * iplPlane1->widthStep;
		unsigned char *pPlane2 = (unsigned char *)(iplPlane2->imageData)+ y * iplPlane1->widthStep;
		unsigned char *pPlane3 = (unsigned char *)(iplPlane3->imageData)+ y * iplPlane1->widthStep;
        unsigned char *pColorImage = (unsigned char *)(iplColorImage->imageData) + y * iplColorImage->widthStep;
		int index = 0;
		for (int x=0; x<width; x++) {
			pColorImage[index] = pPlane1[x];		// B, Y
			index ++;
			pColorImage[index] = pPlane2[x];		// G, U
			index ++;
			pColorImage[index] = pPlane3[x];		// R, V
			index ++;
		}
	}

	return true;
}

IplImage *CImageUtility::asmColorImage(IplImage *iplPlane1, IplImage *iplPlane2, IplImage *iplPlane3)
// Assemble color planes to a color image. Different to cvMerge(), this function supports hybird 8U/32F inputs
// NOTE: This function will keep the pixel value in data type conversion, i.e. if a 8U pixel (0~255) is converted to 32f, the data range
//       will still be 0~255!
// arguments:
//			IplPlane1 -- [I] decomposed color plane 1 (e.g. in YUV image, it is Y; while in RGB image, it is B)
//										use should allocate the image before call this function
//			IplPlane2 -- [I] decomposed color plane 2
//			IplPlane3 -- [I] decomposed color plane 3
// return:
//			Return assembled color image. If the bit depth of each plane is different, the return image has the most large bit depth. NULL for failure.
// Luhong Liang, IC-ASD, ASTRI
// Setp. 7, 2011
{
	// check input arguments. TODO: check the size, channel and bit depth
	if (iplPlane1 == NULL || iplPlane2 == NULL || iplPlane3 == NULL) {
		showErrMsg("Invalid input image in asmColorImage()!\n");
		return false;
	}

#ifdef __OPENCV_OLD_CV_H__
	// determine the targe data type (only sider the 8U and 32F type) TODO: support more data types
	int nColorImageDepth;
	if (iplPlane1->depth == SR_DEPTH_32F || iplPlane2->depth == SR_DEPTH_32F || iplPlane3->depth == SR_DEPTH_32F)
		nColorImageDepth = SR_DEPTH_32F;
	else
		nColorImageDepth = SR_DEPTH_8U;

	// create color image
	int width = iplPlane1->width;
	int height = iplPlane1->height;
	IplImage *iplColorImage = createImage( width, height, nColorImageDepth, 3);
	if (iplColorImage == NULL) {
		showErrMsg("Fatal error: fail to allocate image in asmColorImage()!\n");
		return NULL;
	}

	if (nColorImageDepth == SR_DEPTH_32F) {
		// covert image to floating points
		IplImage *iplPlane1f, *iplPlane2f, *iplPlane3f;

		if (iplPlane1 ->depth == SR_DEPTH_32F) {
			iplPlane1f = iplPlane1;
		} else if (iplPlane1->depth == SR_DEPTH_8U) {
			iplPlane1f = cvtImage8Uto32F(iplPlane1);
		} else {	// TODO: support more data type
			iplPlane1f = NULL;
		}

		if (iplPlane2 ->depth == SR_DEPTH_32F) {
			iplPlane2f = iplPlane2;
		} else if (iplPlane2->depth == SR_DEPTH_8U) {
			iplPlane2f = cvtImage8Uto32F(iplPlane2);
		} else {	// TODO: support more data type
			iplPlane2f = NULL;
		}

		if (iplPlane3 ->depth == SR_DEPTH_32F) {
			iplPlane3f = iplPlane3;
		} else if (iplPlane3->depth == SR_DEPTH_8U) {
			iplPlane3f = cvtImage8Uto32F(iplPlane3);
		} else {	// TODO: support more data type
			iplPlane3f = NULL;
		}

		// assemble color image
		if (iplPlane1f != NULL && iplPlane2f != NULL && iplPlane3f != NULL) {
			cvMerge(iplPlane1f, iplPlane2f, iplPlane3f, NULL, iplColorImage);
		} else {
			releaseImage(&iplColorImage);
			iplColorImage = NULL;
		}

		// release temp image
		if (iplPlane1 ->depth != SR_DEPTH_32F && iplPlane1f != NULL)
			releaseImage(&iplPlane1f);

		if (iplPlane2 ->depth != SR_DEPTH_32F && iplPlane2f != NULL)
			releaseImage(&iplPlane2f);

		if (iplPlane3 ->depth != SR_DEPTH_32F && iplPlane3f != NULL)
			releaseImage(&iplPlane3f);
	}

	return iplColorImage;
#else		// #ifdef __OPENCV_OLD_CV_H__
	showErrMsg("OpenCV is necessary in asmColorImage()!\n"); 
	return NULL;
#endif		// #ifdef __OPENCV_OLD_CV_H__
}

IplImage *CImageUtility::cvtToBGR(IplImage *iplPlane1, IplImage *iplPlane2, IplImage *iplPlane3, int code)
// Assemble color planes to a color image and convert to BGR format
// NOTE: This function will keep the pixel value in data type conversion, i.e. if a 8U pixel (0~255) is converted to 32f, the data range
//       will still be 0~255!
// arguments:
//			IplPlane1 -- [I] decomposed color plane 1 (e.g. in YUV image, it is Y; while in RGB image, it is B)
//										use should allocate the image before call this function
//			IplPlane2 -- [I] decomposed color plane 2
//			IplPlane3 -- [I] decomposed color plane 3
//			code -- [I] color conversion code, same as OpenCV
// return:
//			Return assembled color image. If the bit depth of each plane is different, the return image has the most large bit depth. NULL for failure.
// Luhong Liang, IC-ASD, ASTRI
// Nov. 15, 2011
{
	// check input arguments. TODO: check the size, channel and bit depth
	if (iplPlane1 == NULL || iplPlane2 == NULL || iplPlane3 == NULL) {
		showErrMsg("Invalid input image in cvtToBGR()!\n");
		return false;
	}
    if (code < 0) {
		showErrMsg("Invalid input color conversion code in cvtToBGR()!\n");
		return false;
	}

#ifdef __OPENCV_OLD_CV_H__
	// determine the targe data type (only sider the 8U and 32F type) TODO: support more data types
	int nColorImageDepth;
	if (iplPlane1->depth == SR_DEPTH_32F || iplPlane2->depth == SR_DEPTH_32F || iplPlane3->depth == SR_DEPTH_32F)
		nColorImageDepth = SR_DEPTH_32F;
	else
		nColorImageDepth = SR_DEPTH_8U;

	// create color image
	int width = iplPlane1->width;
	int height = iplPlane1->height;
	IplImage *iplColorImage = createImage( width, height, nColorImageDepth, 3);
	if (iplColorImage == NULL) {
		showErrMsg("Fatal error: fail to allocate image in cvtToBGR()!\n");
		return NULL;
	}
	IplImage *iplBGRImage = createImage( width, height, nColorImageDepth, 3);
	if (iplBGRImage == NULL) {
		showErrMsg("Fatal error: fail to allocate image in cvtToBGR()!\n");
		releaseImage(&iplColorImage);
		return NULL;
	}

	// assemble color image
	if (nColorImageDepth == SR_DEPTH_8U) {
		cvMerge(iplPlane1, iplPlane2, iplPlane3, NULL, iplColorImage);
	} else if (nColorImageDepth == SR_DEPTH_32F) {
		// covert image to floating points
		IplImage *iplPlane1f, *iplPlane2f, *iplPlane3f;

		if (iplPlane1 ->depth == SR_DEPTH_32F) {
			iplPlane1f = iplPlane1;
		} else if (iplPlane1->depth == SR_DEPTH_8U) {
			iplPlane1f = cvtImage8Uto32F(iplPlane1);
		} else {	// TODO: support more data type
			iplPlane1f = NULL;
		}

		if (iplPlane2 ->depth == SR_DEPTH_32F) {
			iplPlane2f = iplPlane2;
		} else if (iplPlane2->depth == SR_DEPTH_8U) {
			iplPlane2f = cvtImage8Uto32F(iplPlane2);
		} else {	// TODO: support more data type
			iplPlane2f = NULL;
		}

		if (iplPlane3 ->depth == SR_DEPTH_32F) {
			iplPlane3f = iplPlane3;
		} else if (iplPlane3->depth == SR_DEPTH_8U) {
			iplPlane3f = cvtImage8Uto32F(iplPlane3);
		} else {	// TODO: support more data type
			iplPlane3f = NULL;
		}

		// assemble color image (data range conversion for cvtColor() here!)
		if (iplPlane1f != NULL && iplPlane2f != NULL && iplPlane3f != NULL) {
			for (int y=0; y<height; y++) {
				float *pColorImage = (float *)((char *)(iplColorImage->imageData) + y * iplColorImage->widthStep);
				float *pPlane1 = (float *)((char *)(iplPlane1f->imageData) + y * iplPlane1f->widthStep);
				float *pPlane2 = (float *)((char *)(iplPlane2f->imageData)+ y * iplPlane1f->widthStep);
				float *pPlane3 = (float *)((char *)(iplPlane3f->imageData)+ y * iplPlane1f->widthStep);
				int index = 0;
				for (int x=0; x<width; x++) {
					pColorImage[index] = pPlane1[x] / IMAGE_DYNAMIC_RANGE_32F;		// B, Y
					index ++;
					pColorImage[index] = pPlane2[x] / IMAGE_DYNAMIC_RANGE_32F;		// G, U
					index ++;
					pColorImage[index] = pPlane3[x] / IMAGE_DYNAMIC_RANGE_32F;		// R, V
					index ++;
				}
			}
		} else {
			releaseImage(&iplColorImage);
			releaseImage(&iplBGRImage);
			iplColorImage = NULL;
		}

		// release temp image
		if (iplPlane1 ->depth != SR_DEPTH_32F && iplPlane1f != NULL)
			releaseImage(&iplPlane1f);

		if (iplPlane2 ->depth != SR_DEPTH_32F && iplPlane2f != NULL)
			releaseImage(&iplPlane2f);

		if (iplPlane3 ->depth != SR_DEPTH_32F && iplPlane3f != NULL)
			releaseImage(&iplPlane3f);
	}

	if (iplColorImage == NULL) 
		return NULL;

	// convert to BGR image
	switch (code) {
		case CV_YCrCb2BGR:
			cvCvtColor(iplColorImage, iplBGRImage, CV_YCrCb2BGR);
			break;
		case CV_YUV2BGR:
			cvCvtColor(iplColorImage, iplBGRImage, CV_YUV2BGR);
			break;
		default:
			showErrMsg("Unsupported color space in cvtToBGR()!\n");
			releaseImage(&iplColorImage);
			releaseImage(&iplBGRImage);
			return NULL;
	}
	releaseImage(&iplColorImage);

	// need to convert floating point back to 0~255
	if (nColorImageDepth == SR_DEPTH_32F) {
		for (int y=0; y<height; y++) {
			float *pImage = (float *)((char *)(iplBGRImage->imageData) + y * iplBGRImage->widthStep);
			for (int x=0; x<width*iplBGRImage->nChannels; x++) {
				pImage[x] *= IMAGE_DYNAMIC_RANGE_32F;
			}
		}
	}

	return iplBGRImage;
#else			// #ifdef __OPENCV_OLD_CV_H__
	showErrMsg("OpenCV is necessary in cvtToBGR()!\n");
	return NULL;
#endif			// #ifdef __OPENCV_OLD_CV_H__
}

bool CImageUtility::cvtYUVtoBGR(IplImage *iplPlaneY, IplImage *iplPlaneU, IplImage *iplPlaneV, IplImage *iplBGR, ColorSpaceName color_sp, int bit_depth)
// Convert YUV planar format to BGR planar format, where an optional bicubic interpolation is used internally (for resize and/or 4:2:0/4:2:2 to 4:4:4)
// Arguments: 
//		iplPlaneY, iplPlaneU, iplPlaneV -- [I] Y, U, V planes; must be 1-channel 8U/16U/32F image
//		iplBGR -- [0] BGR image; must be 3-channel 8U/16U/32F image
//		color_sp -- color space (only CHROMA_BT709 supported in 16U/32S/32F images)
//      bit_depth -- [I] actual bit depth of the image (should set it to 8 for 8U and 32F image)
// NOTE: This function uses an equation for analog signal!!!
// by Luhong Liang, ICD-ASD, ASTRI
// Sept 17, 2013
{
	// check input arguments. TODO: check the size, channel and bit depth
	if (iplPlaneY == NULL || iplPlaneU == NULL || iplPlaneV == NULL || iplBGR == NULL ||
		iplPlaneY->nChannels != 1 || iplPlaneU->nChannels != 1 || iplPlaneV->nChannels != 1 || iplBGR->nChannels != 3) {
		showErrMsg("Invalid input image in CImageUtility::cvtYUVtoBGR()!\n");
		return false;
	}

    if (iplPlaneY->depth == SR_DEPTH_8U && iplPlaneU->depth == SR_DEPTH_8U && iplPlaneV->depth == SR_DEPTH_8U && iplBGR->depth == SR_DEPTH_8U) {
        return cvtYUVtoBGR_8U(iplPlaneY, iplPlaneU, iplPlaneV, iplBGR, color_sp);
    } else if (iplPlaneY->depth == SR_DEPTH_16U && iplPlaneU->depth == SR_DEPTH_16U && iplPlaneV->depth == SR_DEPTH_16U && iplBGR->depth == SR_DEPTH_16U) {
        return cvtYUVtoBGR_16U(iplPlaneY, iplPlaneU, iplPlaneV, iplBGR, color_sp, bit_depth);
    } else if (iplPlaneY->depth == SR_DEPTH_32F && iplPlaneU->depth == SR_DEPTH_32F && iplPlaneV->depth == SR_DEPTH_32F && iplBGR->depth == SR_DEPTH_32F) {
        return cvtYUVtoBGR_32F(iplPlaneY, iplPlaneU, iplPlaneV, iplBGR, color_sp);
    } else {
		showErrMsg("Unsupported input image data type in CImageUtility::cvtYUVtoBGR()!\n");
		return false;
	}
}

bool CImageUtility::cvtYUVtoBGR_32F(IplImage *iplPlaneY, IplImage *iplPlaneU, IplImage *iplPlaneV, IplImage *iplBGR, ColorSpaceName color_sp)
// convert YUV planar format to BGR planar format, where an optional bicubic interpolation is used internally (for resize and/or 4:2:0/4:2:2 to 4:4:4)
// Arguments: 
//		iplPlaneY, iplPlaneU, iplPlaneV -- [I] Y, U, V planes; must be 1-channel 32F image
//		iplBGR -- [0] BGR image; must be 3-channel 32F image
//		color_sp -- color space (only CHROMA_BT709 supported)
// by Luhong Liang, ICD-ASD, ASTRI
// Sept 3, 2013
{
	// check input arguments. TODO: check the size, channel and bit depth
	if (iplPlaneY == NULL || iplPlaneU == NULL || iplPlaneV == NULL || iplBGR == NULL ||
		iplPlaneY->nChannels != 1 || iplPlaneU->nChannels != 1 || iplPlaneV->nChannels != 1 || iplBGR->nChannels != 3 ||
		iplPlaneY->depth != SR_DEPTH_32F || iplPlaneU->depth != SR_DEPTH_32F || iplPlaneV->depth != SR_DEPTH_32F || iplBGR->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image in CImageUtility::cvtYUVtoBGR_32F()!\n");
		return false;
	}

	// allocate 4:4:4 buffers
    IplImage *iplImageU = NULL;
    IplImage *iplImageV = NULL;
    if (!(iplPlaneY->width == iplBGR->width && iplPlaneY->height == iplBGR->height &&
          iplPlaneU->width == iplBGR->width && iplPlaneU->height == iplBGR->height &&
          iplPlaneV->width == iplBGR->width && iplPlaneV->height == iplBGR->height)) {
	    iplImageU = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_32F, 1);
	    iplImageV = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_32F, 1);
	    if (iplImageU == NULL || iplImageV == NULL) {
            safeReleaseImage(&iplImageU, &iplImageV);
		    showErrMsg("Fail to allocate buffer in CImageUtility::cvtYUVtoBGR_32F()!\n");
            return false;
	    }
    }

	// resize
    if (iplPlaneY->width == iplBGR->width && iplPlaneY->height == iplBGR->height &&
        iplPlaneU->width == iplBGR->width && iplPlaneU->height == iplBGR->height &&
        iplPlaneV->width == iplBGR->width && iplPlaneV->height == iplBGR->height) {
        // 4:4:4
        iplImageU = iplPlaneU;
        iplImageV = iplPlaneV;
    } else if (iplPlaneY->width == iplBGR->width && iplPlaneY->height == iplBGR->height &&
               iplPlaneU->width*2 == iplBGR->width && iplPlaneU->height == iplBGR->height &&
               iplPlaneV->width*2 == iplBGR->width && iplPlaneV->height == iplBGR->height) {
        // 4:2:2
        cvt422to444_linear(iplPlaneU, iplImageU);
	    cvt422to444_linear(iplPlaneV, iplImageV);
    } else if (iplPlaneY->width == iplBGR->width && iplPlaneY->height == iplBGR->height &&
               iplPlaneU->width*2 == iplBGR->width && iplPlaneU->height*2 == iplBGR->height &&
               iplPlaneV->width*2 == iplBGR->width && iplPlaneV->height*2 == iplBGR->height) {
        // 4:2:0
	    resize(iplPlaneU, iplImageU, SR_INTER_LINEAR);//SR_INTER_CUBIC);
	    resize(iplPlaneV, iplImageV, SR_INTER_LINEAR);//SR_INTER_CUBIC);
    } else {
        showErrMsg("Only support 4:2:0, 4:2:2 and 4:4:4 format in CImageUtility::cvtYUVtoBGR_32F()!\n");
        if (!(iplPlaneY->width == iplBGR->width && iplPlaneY->height == iplBGR->height &&
              iplPlaneU->width == iplBGR->width && iplPlaneU->height == iplBGR->height &&
              iplPlaneV->width == iplBGR->width && iplPlaneV->height == iplBGR->height)) {
            safeReleaseImage(&iplImageU, &iplImageV);
        }
        return false;
    }

    // color conversion (SIMD)
#ifdef __SR_USE_SIMD
    if (cvtYUVtoBGR_32f_SIMD(iplPlaneY, iplImageU, iplImageV, iplBGR, color_sp)) {      // if failure, try non-SIMD
        if (!(iplPlaneY->width == iplBGR->width && iplPlaneY->height == iplBGR->height &&
              iplPlaneU->width == iplBGR->width && iplPlaneU->height == iplBGR->height &&
              iplPlaneV->width == iplBGR->width && iplPlaneV->height == iplBGR->height)) {
            safeReleaseImage(&iplImageU, &iplImageV);
        }
        return true;
    }
#endif      // #define __SR_USE_SIMD

	// color conversion
    if (color_sp == CHROMA_BT709) {		// BT 709 for HD
		for (int y=0; y<iplBGR->height; y++) {
			float *pY = (float *)(iplPlaneY->imageData + y * iplPlaneY->widthStep);
			float *pU = (float *)(iplImageU->imageData + y * iplImageU->widthStep);
			float *pV = (float *)(iplImageV->imageData + y * iplImageV->widthStep);
			float *pBGR = (float *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// B = 1.8556 .* (U - 128) + Y;
                // R = 1.5748 .* (V - 128) + Y;
                // G = (Y - 0.2126 .* R - 0.0722 .* B) ./ 0.7152;
				float Y = pY[x];
				float U = pU[x];
				float V = pV[x];
                float B = 1.8556f * (U - 128.0f) + Y;
				float R = 1.5748f * (V - 128.0f) + Y;
				float G = (Y - 0.2126f * R - 0.0722f * B) / 0.7152f;
				int xx = x * 3;
				pBGR[xx] = clip_0_255(B);
				pBGR[xx+1] = clip_0_255(G);
				pBGR[xx+2] = clip_0_255(R);
			}
		}
    } else if (color_sp == CHROMA_YUVMS) {		// YUV (microsoft)
		for (int y=0; y<iplBGR->height; y++) {
			float *pY = (float *)(iplPlaneY->imageData + y * iplPlaneY->widthStep);
			float *pU = (float *)(iplImageU->imageData + y * iplImageU->widthStep);
			float *pV = (float *)(iplImageV->imageData + y * iplImageV->widthStep);
			float *pBGR = (float *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				float Y = pY[x];
				float U = pU[x];
				float V = pV[x];
                float Yprime = 1.164f * (Y - 16.0f);
                float R = Yprime + 1.596f * (V - 128.0f);
				float G = Yprime - 0.813f * (V - 128.0f) - 0.391f * (U - 128.0f);
				float B = Yprime + 2.018f * (U - 128.0f);
				int xx = x * 3;
				pBGR[xx] = clip_0_255(B);
				pBGR[xx+1] = clip_0_255(G);
				pBGR[xx+2] = clip_0_255(R);
			}
		}
    } else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
        IplImage *iplYuv = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
        if (iplYuv == NULL) return false;
        cvMerge(iplPlaneY, iplImageU, iplImageV, NULL, iplYuv);
        cvCvtColor(iplYuv, iplBGR, CV_YCrCb2BGR);
        safeReleaseImage(&iplYuv);
#else
		showErrMsg("Does not support YCbCr w/o OpenCV in CImageUtility::cvtYUVtoBGR_32F()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
    } else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
        IplImage *iplYuv = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
        if (iplYuv == NULL) return false;
        cvMerge(iplPlaneY, iplImageU, iplImageV, NULL, iplYuv);
        cvCvtColor(iplYuv, iplBGR, CV_YUV2BGR);
        safeReleaseImage(&iplYuv);
#else
		showErrMsg("Does not support YUV w/o OpenCV in CImageUtility::cvtYUVtoBGR_32F()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV, NULL);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
	} else {
		showErrMsg("Unsupported color space denoted in CImageUtility::cvtYUVtoBGR_32F()\n");
        if (!(iplPlaneY->width == iplBGR->width && iplPlaneY->height == iplBGR->height &&
              iplPlaneU->width == iplBGR->width && iplPlaneU->height == iplBGR->height &&
              iplPlaneV->width == iplBGR->width && iplPlaneV->height == iplBGR->height)) {
            safeReleaseImage(&iplImageU, &iplImageV);
        }
		return false;
	}

    if (!(iplPlaneY->width == iplBGR->width && iplPlaneY->height == iplBGR->height &&
          iplPlaneU->width == iplBGR->width && iplPlaneU->height == iplBGR->height &&
          iplPlaneV->width == iplBGR->width && iplPlaneV->height == iplBGR->height)) {
        safeReleaseImage(&iplImageU, &iplImageV);
    }

	return true;
}

bool CImageUtility::cvtYUVtoBGR_16U(IplImage *iplPlaneY, IplImage *iplPlaneU, IplImage *iplPlaneV, IplImage *iplBGR, ColorSpaceName color_sp, int bit_depth)
// Convert YUV planar format to BGR planar format, where an optional bicubic interpolation is used internally (for resize and/or 4:2:0/4:2:2 to 4:4:4)
// Arguments: 
//		iplPlaneY, iplPlaneU, iplPlaneV -- [I] Y, U, V planes; must be 1-channel 16U image
//		iplBGR -- [0] BGR image; must be 3-channel 16U image
//		color_sp -- color space (only CHROMA_BT709 supported)
//      bit_depth -- [I] actual bit depth of the image
// NOTE: This function uses an equation for analog signal!!!
// by Luhong Liang, ICD-ASD, ASTRI
// Sept 17, 2013
{
	// check input arguments. TODO: check the size, channel and bit depth
	if (iplPlaneY == NULL || iplPlaneU == NULL || iplPlaneV == NULL || iplBGR == NULL ||
		iplPlaneY->nChannels != 1 || iplPlaneU->nChannels != 1 || iplPlaneV->nChannels != 1 || iplBGR->nChannels != 3 ||
		iplPlaneY->depth != SR_DEPTH_16U || iplPlaneU->depth != SR_DEPTH_16U || iplPlaneV->depth != SR_DEPTH_16U || iplBGR->depth != SR_DEPTH_16U) {
		showErrMsg("Invalid input image in CImageUtility::cvtYUVtoBGR_16U()!\n");
		return false;
	}
    if (bit_depth < 1 || bit_depth > 16) {
        showErrMsg("Only support bit depth 1~16 in CImageUtility::cvtYUVtoBGR_16U()!\n");
		return false;
	}

	// allocate 4:4:4 buffers
	IplImage *iplImageY = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_16U, 1);
	IplImage *iplImageU = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_16U, 1);
	IplImage *iplImageV = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_16U, 1);
	if (iplImageY == NULL || iplImageU == NULL || iplImageV == NULL) {
		if (iplImageY != NULL) releaseImage(&iplImageY);
		if (iplImageU != NULL) releaseImage(&iplImageU);
		if (iplImageV != NULL) releaseImage(&iplImageV);
		showErrMsg("Fail to allocate buffer in CImageUtility::cvtYUVtoBGR_16U()!\n");
	}

	// resize
    if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
        iplPlaneU->width == iplImageU->width && iplPlaneU->height == iplImageU->height &&
        iplPlaneV->width == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:4:4
        copy(iplPlaneY, iplImageY);
        copy(iplPlaneU, iplImageU);
        copy(iplPlaneV, iplImageV);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:2:2
	    copy(iplPlaneY, iplImageY);
        cvt422to444_linear(iplPlaneU, iplImageU);
	    cvt422to444_linear(iplPlaneV, iplImageV);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height*2 == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height*2 == iplImageV->height) {
        // 4:2:0
	    copy(iplPlaneY, iplImageY);
	    resize(iplPlaneU, iplImageU, SR_INTER_LINEAR);//SR_INTER_CUBIC);
	    resize(iplPlaneV, iplImageV, SR_INTER_LINEAR);//SR_INTER_CUBIC);
    } else {
        showErrMsg("Only support 4:2:0, 4:2:2 and 4:4:4 format in CImageUtility::cvtYUVtoBGR_16U()!\n");
        safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
        return false;
    }
    //saveImage("_420U.bmp", iplPlaneU, 0, 1.0f, 10);
    //saveImage("_420V.bmp", iplPlaneV, 0, 1.0f, 10);
    //saveImage("_ResizeU.bmp", iplImageU, 0, 1.0f, 10);
    //saveImage("_ResizeV.bmp", iplImageV, 0, 1.0f, 10);

	// color conversion
    const int max_val = (1<<bit_depth) - 1;
    const int mid_val_int = 1<<(bit_depth-1);
    const int shift_val_int = mid_val_int >> 3;
    const float mid_val = (float)(1<<(bit_depth-1));
    if (color_sp == CHROMA_BT709) {		// BT 709 for HD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned short *pY = (unsigned short *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned short *pU = (unsigned short *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned short *pV = (unsigned short *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned short *pBGR = (unsigned short *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// B = 1.8556 .* (U - 128) + Y;
                // R = 1.5748 .* (V - 128) + Y;
                // G = (Y - 0.2126 .* R - 0.0722 .* B) ./ 0.7152;
				float Y = (float)pY[x];
				float U = (float)pU[x];
				float V = (float)pV[x];
                float B = 1.8556f * (U - mid_val) + Y;
				float R = 1.5748f * (V - mid_val) + Y;
				float G = (Y - 0.2126f * R - 0.0722f * B) / 0.7152f;
                // rounding
				int xx = x * 3;
                int Rint = (int)(R + 0.5f);     // TODO: use Quantized equation for digital signal!!!
                Rint = Rint < 0 ? 0 : Rint;
                pBGR[xx+2] = (unsigned short)(Rint > max_val ? max_val : Rint);
                int Gint = (int)(G + 0.5f);
                Gint = Gint < 0 ? 0 : Gint;
                pBGR[xx+1] = (unsigned short)(Gint > max_val ? max_val : Gint);
                int Bint = (int)(B + 0.5f);
                Bint = Bint < 0 ? 0 : Bint;
				pBGR[xx] = (unsigned short)(Bint > max_val ? max_val : Bint);
			}
		}
	} else if (color_sp == CHROMA_YUVMS) {		// YUV (Miscrosoft recommended, similar to FFMPEG)
		for (int y=0; y<iplBGR->height; y++) {
			unsigned short *pY = (unsigned short *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned short *pU = (unsigned short *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned short *pV = (unsigned short *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned short *pBGR = (unsigned short *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
                int C = (int)pY[x] - shift_val_int;
                int D = (int)pU[x] - mid_val_int;
                int E = (int)pV[x] - mid_val_int;
                int R = ( 298 * C           + 409 * E + 128) >> 8;
                int G = ( 298 * C - 100 * D - 208 * E + 128) >> 8;
                int B = ( 298 * C + 516 * D           + 128) >> 8;
				int xx = x * 3;
				pBGR[xx] = (unsigned short)clip_int(B, max_val, -max_val);
				pBGR[xx+1] = (unsigned short)clip_int(G, max_val, -max_val);
				pBGR[xx+2] = (unsigned short)clip_int(R, max_val, -max_val);
			}
		}
    } else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
        IplImage *iplYuv = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
        if (iplYuv == NULL) return false;
        cvMerge(iplImageY, iplImageU, iplImageV, NULL, iplYuv);
        cvCvtColor(iplYuv, iplBGR, CV_YCrCb2BGR);
        safeReleaseImage(&iplYuv);
#else
		showErrMsg("Does not support YCbCr w/o OpenCV in CImageUtility::cvtYUVtoBGR_16U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
    } else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
        IplImage *iplYuv = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
        if (iplYuv == NULL) return false;
        cvMerge(iplImageY, iplImageU, iplImageV, NULL, iplYuv);
        cvCvtColor(iplYuv, iplBGR, CV_YUV2BGR);
        safeReleaseImage(&iplYuv);
#else
		showErrMsg("Does not support YUV w/o OpenCV in CImageUtility::cvtYUVtoBGR_16U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV, NULL);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
	} else {
		showErrMsg("Unsupported color space denoted in CImageUtility::cvtYUVtoBGR_16U()\n");
		safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
		return false;
	}

    //saveImage("_Y.bmp", iplImageY, 0, 1.0f, bit_depth);
    //saveImage("_U.bmp", iplImageU, 0, 1.0f, bit_depth);
    //saveImage("_V.bmp", iplImageV, 0, 1.0f, bit_depth);
    //saveImage("_U1.bmp", iplPlaneU, 0, 1.0f, bit_depth);
    //saveImage("_V1.bmp", iplPlaneV, 0, 1.0f, bit_depth);
    //saveImage("_BGR.bmp", iplBGR, 0, 1.0f, bit_depth);
	safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);

	return true;
}

bool CImageUtility::cvtYUVtoBGR_8U(IplImage *iplPlaneY, IplImage *iplPlaneU, IplImage *iplPlaneV, IplImage *iplBGR, ColorSpaceName color_sp)
// convert YUV planar format to BGR planar format, where an optional bicubic interpolation is used internally (for resize and/or 4:2:0/4:2:2 to 4:4:4)
// Arguments: 
//		iplPlaneY, iplPlaneU, iplPlaneV -- [I] Y, U, V planes; must be 1-channel 8U image
//		iplBGR -- [0] BGR image; must be 3-channel 8U image
//		color_sp -- color space (CHROMA_NTSC, CHROMA_BT601 and CHROMA_BT709 supported)
// by Luhong Liang, ICD-ASD, ASTRI
// May 7, 2013
{
	// check input arguments. TODO: check the size, channel and bit depth
	if (iplPlaneY == NULL || iplPlaneU == NULL || iplPlaneV == NULL || iplBGR == NULL ||
		iplPlaneY->nChannels != 1 || iplPlaneU->nChannels != 1 || iplPlaneV->nChannels != 1 || iplBGR->nChannels != 3 ||
		iplPlaneY->depth != SR_DEPTH_8U || iplPlaneU->depth != SR_DEPTH_8U || iplPlaneV->depth != SR_DEPTH_8U || iplBGR->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image in CImageUtility::cvtYUVtoBGR_8U()!\n");
		return false;
	}

	// allocate buffers
	IplImage *iplImageY = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	IplImage *iplImageU = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	IplImage *iplImageV = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	if (iplImageY == NULL || iplImageU == NULL || iplImageV == NULL) {
		if (iplImageY != NULL) releaseImage(&iplImageY);
		if (iplImageU != NULL) releaseImage(&iplImageU);
		if (iplImageV != NULL) releaseImage(&iplImageV);
		showErrMsg("Fail to allocate buffer in CImageUtility::cvtYUVtoBGR_8U()!\n");
	}

	// resize
    if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
        iplPlaneU->width == iplImageU->width && iplPlaneU->height == iplImageU->height &&
        iplPlaneV->width == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:4:4
        copy(iplPlaneY, iplImageY);
        copy(iplPlaneU, iplImageU);
        copy(iplPlaneV, iplImageV);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:2:2
	    copy(iplPlaneY, iplImageY);
        cvt422to444_linear(iplPlaneU, iplImageU);
	    cvt422to444_linear(iplPlaneV, iplImageV);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height*2 == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height*2 == iplImageV->height) {
        // 4:2:0
	    copy(iplPlaneY, iplImageY);
	    resize(iplPlaneU, iplImageU, SR_INTER_LINEAR);//SR_INTER_CUBIC);
	    resize(iplPlaneV, iplImageV, SR_INTER_LINEAR);//SR_INTER_CUBIC);
    } else {
        showErrMsg("Only support 4:2:0, 4:2:2 and 4:4:4 format in CImageUtility::cvtYUVtoBGR_32F()!\n");
        safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
        return false;
    }

	// color conversion
	if (color_sp == CHROMA_NTSC) {
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				int C = (int)pY[x] - 16;
				int D = (int)pU[x] - 128;
				int E = (int)pV[x] - 128;
				int R = (298 * C + 409 * E + 128) >> 8;
				int G = (298 * C - 100 * D - 208 * E + 128) >> 8;
				int B = (298 * C + 516 * D + 128) >> 8;
				int xx = x * 3;
				pBGR[xx] = (unsigned char)clip_0_255(B);
				pBGR[xx+1] = (unsigned char)clip_0_255(G);
				pBGR[xx+2] = (unsigned char)clip_0_255(R);
			}
		}
	} else if (color_sp == CHROMA_YUVMS) {		// YUV (Miscrosoft recommended, similar to FFMPEG)
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
                int C = (int)pY[x] - 16;
                int D = (int)pU[x] - 128;
                int E = (int)pV[x] - 128;
                int R = ( 298 * C           + 409 * E + 128) >> 8;
                int G = ( 298 * C - 100 * D - 208 * E + 128) >> 8;
                int B = ( 298 * C + 516 * D           + 128) >> 8;
				int xx = x * 3;
				pBGR[xx] = (unsigned char)clip_0_255(B);
				pBGR[xx+1] = (unsigned char)clip_0_255(G);
				pBGR[xx+2] = (unsigned char)clip_0_255(R);
			}
		}
	} else if (color_sp == CHROMA_BT601) {		// BT 601 for SD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// R = Y + 350(Cr-128)/256
				// G = Y-(179(Cr-128)+86(Cb-128))/256		<----- Cb <-> U
				// B = Y + 444(Cb-128)/256
                int Y = (int)pY[x];
				int U = (int)pU[x];
				int V = (int)pV[x];
				int R = (Y<<1) + ((350 * (V - 128)) >> 7);   // modified by Luhong, June 30, 2014
				int G = (Y<<1) - ((179 * (V - 128) + 86 * (U - 128)) >> 7);
				int B = (Y<<1) + ((444 * (U - 128)) >> 7);
				int xx = x * 3;
				pBGR[xx] = rndclp_9Uto8U(B);        // modified by Luhong, June 30, 2014
				pBGR[xx+1] = rndclp_9Uto8U(G);
				pBGR[xx+2] = rndclp_9Uto8U(R);
			}
		}
	} else if (color_sp == CHROMA_BT709) {		// BT 709 for HD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// R = Y + 394(Cr-128)/256
				// G = Y-(118(Cr-128)+46(Cb-128))/256
				// B = Y + 464(Cb-128)/256
				int Y = (int)pY[x];
				int U = (int)pU[x];
				int V = (int)pV[x];
				int R = (Y<<1) + ((394 * (V - 128)) >> 7);      // modified by Luhong, June 30, 2014
				int G = (Y<<1) - ((118 * (V - 128) + 46 * (U - 128)) >> 7);
				int B = (Y<<1) + ((464 * (U - 128)) >> 7);
				int xx = x * 3;
				pBGR[xx] = rndclp_9Uto8U(B);        // modified by Luhong, June 30, 2014
				pBGR[xx+1] = rndclp_9Uto8U(G);
				pBGR[xx+2] = rndclp_9Uto8U(R);
			}
		}
    } else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
        IplImage *iplYuv = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
        if (iplYuv == NULL) return false;
        cvMerge(iplImageY, iplImageU, iplImageV, NULL, iplYuv);
        cvCvtColor(iplYuv, iplBGR, CV_YCrCb2BGR);
        safeReleaseImage(&iplYuv);
#else
		showErrMsg("Does not support YCbCr w/o OpenCV in CImageUtility::cvtYUVtoBGR_8U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
    } else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
        IplImage *iplYuv = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
        if (iplYuv == NULL) return false;
        cvMerge(iplImageY, iplImageU, iplImageV, NULL, iplYuv);
        cvCvtColor(iplYuv, iplBGR, CV_YUV2BGR);
        safeReleaseImage(&iplYuv);
#else
		showErrMsg("Does not support YUV w/o OpenCV in CImageUtility::cvtYUVtoBGR_8U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV, NULL);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
	} else {
		showErrMsg("Unsupported color space denoted in CImageUtility::cvtYUVtoBGR_8U()\n");
		safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
		return false;
	}

	safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);

	return true;
}

bool CImageUtility::cvtYUVtoBGR_8U_10U(IplImage *iplPlaneY, IplImage *iplPlaneU, IplImage *iplPlaneV, IplImage *iplBGR, ColorSpaceName color_sp)
// convert YUV planar format to BGR planar format, where an optional bicubic interpolation is used internally (for resize and/or 4:2:0 to 4:4:4)
// Arguments: 
//		iplPlaneY, iplPlaneU, iplPlaneV -- [I] Y, U, V planes; must be 1-channel 8U image
//		iplBGR -- [0] BGR image; must be 3-channel 10-bit(32S) image
//		color_sp -- color space (CHROMA_NTSC, CHROMA_BT601 and CHROMA_BT709 supported)
// by Luhong Liang, ICD-ASD, ASTRI
// Aug 1, 2013, Modified by Tim Wong Sept 11, to match the rtl hardware design
{
	// check input arguments. TODO: check the size, channel and bit depth
	if (iplPlaneY == NULL || iplPlaneU == NULL || iplPlaneV == NULL || iplBGR == NULL ||
		iplPlaneY->nChannels != 1 || iplPlaneU->nChannels != 1 || iplPlaneV->nChannels != 1 || iplBGR->nChannels != 3 ||
		iplPlaneY->depth != SR_DEPTH_8U || iplPlaneU->depth != SR_DEPTH_8U || iplPlaneV->depth != SR_DEPTH_8U || iplBGR->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image in CImageUtility::cvtYUVtoBGR_8U_10U()!\n");
		return false;
	}

	// allocate buffers
	IplImage *iplImageY = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	IplImage *iplImageU = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	IplImage *iplImageV = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	
	if (iplImageY == NULL || iplImageU == NULL || iplImageV == NULL) {
		if (iplImageY != NULL) releaseImage(&iplImageY);
		if (iplImageU != NULL) releaseImage(&iplImageU);
		if (iplImageV != NULL) releaseImage(&iplImageV);
		showErrMsg("Fail to allocate buffer in CImageUtility::cvtYUVtoBGR_8U_10U()!\n");
	}

	//saveImage("D:\\SHIChao\\Work\\SR_Test\\images\\outputImage\\iplImageYHR_B.bmp",iplPlaneY);
	//saveImage("D:\\SHIChao\\Work\\SR_Test\\images\\outputImage\\iplImageUHR_B.bmp",iplPlaneU);
	//saveImage("D:\\SHIChao\\Work\\SR_Test\\images\\outputImage\\iplImageVHR_B.bmp",iplPlaneV);
	// resize
    if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
        iplPlaneU->width == iplImageU->width && iplPlaneU->height == iplImageU->height &&
        iplPlaneV->width == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:4:4
        copy(iplPlaneY, iplImageY);
        copy(iplPlaneU, iplImageU);
        copy(iplPlaneV, iplImageV);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:2:2
	    copy(iplPlaneY, iplImageY);
        cvt422to444_linear(iplPlaneU, iplImageU);
	    cvt422to444_linear(iplPlaneV, iplImageV);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height*2 == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height*2 == iplImageV->height) {
        // 4:2:0
	    copy(iplPlaneY, iplImageY);
	    resize(iplPlaneU, iplImageU, SR_INTER_LINEAR);//SR_INTER_CUBIC);
	    resize(iplPlaneV, iplImageV, SR_INTER_LINEAR);//SR_INTER_CUBIC);
    } else {
        showErrMsg("Only support 4:2:0, 4:2:2 and 4:4:4 format in CImageUtility::cvtYUVtoBGR_32F()!\n");
        safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
        return false;
    }

	// color conversion
	if (color_sp == CHROMA_NTSC) {
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			int *pBGR = (int *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				int C = (int)pY[x] - 16;
				int D = (int)pU[x] - 128;
				int E = (int)pV[x] - 128;

				int R = (298 * C + 409 * E + 128) >> 6;
				int G = (298 * C - 100 * D - 208 * E + 128) >> 6;
				int B = (298 * C + 516 * D + 128) >> 6;
				int xx = x * 3;
				pBGR[xx] = clip_int(B, 1023, 0);
				pBGR[xx+1] = clip_int(G, 1023, 0);
				pBGR[xx+2] = clip_int(R, 1023, 0);
			}
		}
	} else if (color_sp == CHROMA_BT601) {		// BT 601 for SD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			int *pBGR = (int *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// R = Y + 351(Cr-128)/256
				// G = Y-(179(Cr-128)+86(Cb-128))/256		<----- Cb <-> U
				// B = Y + 443(Cb-128)/256
				int Y = (int)pY[x];
				int U = (int)pU[x];
				int V = (int)pV[x];
                int R = 351*(V - 128);
                R = ((Y<<8) + R) >> 6;
				int G = 179 * (V - 128) + 86 * (U - 128);
                G = ((Y<<8) - G) >> 6;	
				int B = 443 * (U - 128);
				B = ((Y<<8) + B) >> 6;
				int xx = x * 3;
				pBGR[xx] = clip_int(B, 1023, 0);
				pBGR[xx+1] = clip_int(G, 1023, 0);
				pBGR[xx+2] = clip_int(R, 1023, 0);
			}
		}
	} else if (color_sp == CHROMA_BT709) {		// BT 709 for HD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			int *pBGR = (int *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// R = Y + 394(Cr-128)/256
				// G = Y-(118(Cr-128)+47(Cb-128))/256
				// B = Y + 465(Cb-128)/256
				int Y = (int)pY[x];
				int U = (int)pU[x];
				int V = (int)pV[x];

				int R = 394 * (V - 128);
				R = ((Y<<8)+ R)>>6;
				int G = 118 * (V - 128) + 46 * (U - 128);
				G = ((Y<<8) - G)>>6;
				int B = 464 * (U - 128);
				B = ((Y<<8) + B) >> 6;

			//Modified by Chao SHI for resource saving
				//int R = 98 * (V - 128);
				//R = ((Y<<6)+ R)>>4;
				//int G = 30 * (V - 128) + 12 * (U - 128);
				//G = ((Y<<6) - G)>>4;
				//int B = 116 * (U - 128);
				//B = ((Y<<6) + B) >> 4;

				int xx = x * 3;
				pBGR[xx] = clip_int(B, 1023, 0);
				pBGR[xx+1] = clip_int(G, 1023, 0);
				pBGR[xx+2] = clip_int(R, 1023, 0);
			}
		}
	} else {
		showErrMsg("Unsupported color space denoted in CImageUtility::cvtYUVtoBGR_8U_10U()\n");
		safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
		return false;
	}

	safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);

	return true;
}
bool CImageUtility::cvtYUVtoBGR_8U_10U_Basic(IplImage *iplPlaneY, IplImage *iplPlaneU, IplImage *iplPlaneV, IplImage *iplBGR, ColorSpaceName color_sp)
	// convert YUV planar format to BGR planar format, where an optional bicubic interpolation is used internally (for resize and/or 4:2:0 to 4:4:4)
	// Arguments: 
	//		iplPlaneY, iplPlaneU, iplPlaneV -- [I] Y, U, V planes; must be 1-channel 8U image
	//		iplBGR -- [0] BGR image; must be 3-channel 10-bit(32S) image
	//		color_sp -- color space (CHROMA_NTSC, CHROMA_BT601 and CHROMA_BT709 supported)
	// by Luhong Liang, ICD-ASD, ASTRI
	// Aug 1, 2013, Modified by Tim Wong Sept 11, to match the rtl hardware design
{
	// check input arguments. TODO: check the size, channel and bit depth
	if (iplPlaneY == NULL || iplPlaneU == NULL || iplPlaneV == NULL || iplBGR == NULL ||
		iplPlaneY->nChannels != 1 || iplPlaneU->nChannels != 1 || iplPlaneV->nChannels != 1 || iplBGR->nChannels != 3 ||
		iplPlaneY->depth != SR_DEPTH_8U || iplPlaneU->depth != SR_DEPTH_8U || iplPlaneV->depth != SR_DEPTH_8U || iplBGR->depth != SR_DEPTH_32S) {
			showErrMsg("Invalid input image in CImageUtility::cvtYUVtoBGR_8U_10U()!\n");
			return false;
	}

	// allocate buffers
	IplImage *iplImageY = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	IplImage *iplImageU = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	IplImage *iplImageV = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);

	if (iplImageY == NULL || iplImageU == NULL || iplImageV == NULL) {
		if (iplImageY != NULL) releaseImage(&iplImageY);
		if (iplImageU != NULL) releaseImage(&iplImageU);
		if (iplImageV != NULL) releaseImage(&iplImageV);
		showErrMsg("Fail to allocate buffer in CImageUtility::cvtYUVtoBGR_8U_10U()!\n");
	}

	//saveImage("D:\\SHIChao\\Work\\SR_Test\\images\\outputImage\\iplImageYHR_B.bmp",iplPlaneY);
	//saveImage("D:\\SHIChao\\Work\\SR_Test\\images\\outputImage\\iplImageUHR_B.bmp",iplPlaneU);
	//saveImage("D:\\SHIChao\\Work\\SR_Test\\images\\outputImage\\iplImageVHR_B.bmp",iplPlaneV);
	// resize
	if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
		iplPlaneU->width == iplImageU->width && iplPlaneU->height == iplImageU->height &&
		iplPlaneV->width == iplImageV->width && iplPlaneV->height == iplImageV->height) {
			// 4:4:4
			copy(iplPlaneY, iplImageY);
			copy(iplPlaneU, iplImageU);
			copy(iplPlaneV, iplImageV);
	} else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
		iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height == iplImageU->height &&
		iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height == iplImageV->height) {
			// 4:2:2
			copy(iplPlaneY, iplImageY);
			cvt422to444_linear(iplPlaneU, iplImageU);
			cvt422to444_linear(iplPlaneV, iplImageV);
	} else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
		iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height*2 == iplImageU->height &&
		iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height*2 == iplImageV->height) {
			// 4:2:0
			copy(iplPlaneY, iplImageY);
			resize(iplPlaneU, iplImageU, SR_INTER_LINEAR);//SR_INTER_CUBIC);
			resize(iplPlaneV, iplImageV, SR_INTER_LINEAR);//SR_INTER_CUBIC);
	} else {
		showErrMsg("Only support 4:2:0, 4:2:2 and 4:4:4 format in CImageUtility::cvtYUVtoBGR_32F()!\n");
		safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
		return false;
	}

	// color conversion
	if (color_sp == CHROMA_NTSC) {
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			int *pBGR = (int *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				int C = (int)pY[x] - 16;
				int D = (int)pU[x] - 128;
				int E = (int)pV[x] - 128;

				int R = (298 * C + 409 * E + 128) >> 6;
				int G = (298 * C - 100 * D - 208 * E + 128) >> 6;
				int B = (298 * C + 516 * D + 128) >> 6;
				int xx = x * 3;
				pBGR[xx] = clip_int(B, 1023, 0);
				pBGR[xx+1] = clip_int(G, 1023, 0);
				pBGR[xx+2] = clip_int(R, 1023, 0);
			}
		}
	} else if (color_sp == CHROMA_BT601) {		// BT 601 for SD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			int *pBGR = (int *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// R = Y + 351(Cr-128)/256
				// G = Y-(179(Cr-128)+86(Cb-128))/256		<----- Cb <-> U
				// B = Y + 443(Cb-128)/256
				int Y = (int)pY[x];
				int U = (int)pU[x];
				int V = (int)pV[x];
				int R = 351*(V - 128);
				R = ((Y<<8) + R) >> 6;
				int G = 179 * (V - 128) + 86 * (U - 128);
				G = ((Y<<8) - G) >> 6;	
				int B = 443 * (U - 128);
				B = ((Y<<8) + B) >> 6;
				int xx = x * 3;
				pBGR[xx] = clip_int(B, 1023, 0);
				pBGR[xx+1] = clip_int(G, 1023, 0);
				pBGR[xx+2] = clip_int(R, 1023, 0);
			}
		}
	} else if (color_sp == CHROMA_BT709) {		// BT 709 for HD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			int *pBGR = (int *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// R = Y + 394(Cr-128)/256
				// G = Y-(118(Cr-128)+47(Cb-128))/256
				// B = Y + 465(Cb-128)/256
				int Y = (int)pY[x];
				int U = (int)pU[x];
				int V = (int)pV[x];

				//int R = 394 * (V - 128);
				//R = ((Y<<8)+ R)>>6;
				//int G = 118 * (V - 128) + 46 * (U - 128);
				//G = ((Y<<8) - G)>>6;
				//int B = 464 * (U - 128);
				//B = ((Y<<8) + B) >> 6;

				//Modified by Chao SHI for resource saving
				int R = 98 * (V - 128);
				R = ((Y<<6)+ R)>>4;
				int G = 30 * (V - 128) + 12 * (U - 128);
				G = ((Y<<6) - G)>>4;
				int B = 116 * (U - 128);
				B = ((Y<<6) + B) >> 4;

				int xx = x * 3;
				pBGR[xx] = clip_int(B, 1023, 0);
				pBGR[xx+1] = clip_int(G, 1023, 0);
				pBGR[xx+2] = clip_int(R, 1023, 0);
			}
		}
	} else {
		showErrMsg("Unsupported color space denoted in CImageUtility::cvtYUVtoBGR_8U_10U()\n");
		safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
		return false;
	}

	safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);

	return true;
}
bool CImageUtility::cvtYUVtoRGB_8U(IplImage *iplPlaneY, IplImage *iplPlaneU, IplImage *iplPlaneV, IplImage *iplRGB, ColorSpaceName color_sp)
// convert YUV planar format to RGB planar format, where an optional bicubic interpolation is used internally (for resize and/or 4:2:0 to 4:4:4)
// Arguments: 
//		iplPlaneY, iplPlaneU, iplPlaneV -- [I] Y, U, V planes; must be 1-channel 8U image
//		iplRGB -- [0] RGB image; must be 3-channel 8U image
//		color_sp -- color space (CHROMA_NTSC supported)
{
	// check input arguments. TODO: check the size, channel and bit depth
	if (iplPlaneY == NULL || iplPlaneU == NULL || iplPlaneV == NULL || iplRGB == NULL ||
		iplPlaneY->nChannels != 1 || iplPlaneU->nChannels != 1 || iplPlaneV->nChannels != 1 || iplRGB->nChannels != 3 ||
		iplPlaneY->depth != SR_DEPTH_8U || iplPlaneU->depth != SR_DEPTH_8U || iplPlaneV->depth != SR_DEPTH_8U || iplRGB->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image in CImageUtility::cvtYUVtoBGR_8U()!\n");
		return false;
	}

	// allocate buffers
	IplImage *iplImageY = createImage(iplRGB->width, iplRGB->height, SR_DEPTH_8U, 1);
	IplImage *iplImageU = createImage(iplRGB->width, iplRGB->height, SR_DEPTH_8U, 1);
	IplImage *iplImageV = createImage(iplRGB->width, iplRGB->height, SR_DEPTH_8U, 1);
	if (iplImageY == NULL || iplImageU == NULL || iplImageV == NULL) {
		if (iplImageY != NULL) releaseImage(&iplImageY);
		if (iplImageU != NULL) releaseImage(&iplImageU);
		if (iplImageV != NULL) releaseImage(&iplImageV);
		showErrMsg("Fail to allocate buffer in CImageUtility::cvtYUVtoBGR_8U()!\n");
	}

	// resize
    if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
        iplPlaneU->width == iplImageU->width && iplPlaneU->height == iplImageU->height &&
        iplPlaneV->width == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:4:4
        copy(iplPlaneY, iplImageY);
        copy(iplPlaneU, iplImageU);
        copy(iplPlaneV, iplImageV);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:2:2
	    copy(iplPlaneY, iplImageY);
        cvt422to444_linear(iplPlaneU, iplImageU);
	    cvt422to444_linear(iplPlaneV, iplImageV);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height*2 == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height*2 == iplImageV->height) {
        // 4:2:0
	    copy(iplPlaneY, iplImageY);
	    resize(iplPlaneU, iplImageU, SR_INTER_LINEAR);//SR_INTER_CUBIC);
	    resize(iplPlaneV, iplImageV, SR_INTER_LINEAR);//SR_INTER_CUBIC);
    } else {
        showErrMsg("Only support 4:2:0, 4:2:2 and 4:4:4 format in CImageUtility::cvtYUVtoBGR_32F()!\n");
        safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
        return false;
    }

	// color conversion
	if (color_sp == CHROMA_NTSC) {
		for (int y=0; y<iplRGB->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned char *pRGB = (unsigned char *)(iplRGB->imageData + y * iplRGB->widthStep);
			for (int x=0; x<iplRGB->width; x++) {
				int C = (int)pY[x] - 16;
				int D = (int)pU[x] - 128;
				int E = (int)pV[x] - 128;
				int R = (298 * C + 409 * E + 128) >> 8;
				int G = (298 * C - 100 * D - 208 * E + 128) >> 8;
				int B = (298 * C + 516 * D + 128) >> 8;
				int xx = x * 3;
				pRGB[xx] = (unsigned char)clip_0_255(R);
				pRGB[xx+1] = (unsigned char)clip_0_255(G);
				pRGB[xx+2] = (unsigned char)clip_0_255(B);
			}
		}
	} else {
		showErrMsg("Unsupported color space denoted in CImageUtility::cvtYUVtoRGB_8U()\n");
		safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
		return false;
	}

	safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);

	return true;
}

bool CImageUtility::cvtBGRtoYUV(IplImage *iplBGR, IplImage *iplPlaneY, IplImage *iplPlaneU, IplImage *iplPlaneV, 
                                ColorSpaceName color_sp, int bit_depth)
// Convert BGR planar format to YUV planar format with conversion to 4:2:0/4:2:2/4:4:4
// Arguments: 
//		iplRGB -- [I] RGB image; must be 3-channel 32F image
//		iplPlaneY, iplPlaneU, iplPlaneV -- [O] Y, U, V planes; must be 1-channel 32F image
//		color_sp -- color space (CHROMA_BT709 supported)
//      bit_depth -- [I] actual bit depth of the input image (should set it to 8 for 8U and 32F image)
// by Luhong Liang, ICD-ASD, ASTRI
// Sept. 17, 2013
{
	// check input arguments
	if (iplPlaneY == NULL || iplPlaneU == NULL || iplPlaneV == NULL || iplBGR == NULL ||
		iplPlaneY->nChannels != 1 || iplPlaneU->nChannels != 1 || iplPlaneV->nChannels != 1 || iplBGR->nChannels != 3) {
		showErrMsg("Invalid input image in CImageUtility::cvtBGRtoYUV()!\n");
		return false;
	}

    if (iplPlaneY->depth == SR_DEPTH_8U && iplPlaneU->depth == SR_DEPTH_8U && iplPlaneV->depth == SR_DEPTH_8U) {
        if (iplBGR->depth == SR_DEPTH_8U) {
            return cvtBGRtoYUV_8U(iplBGR, iplPlaneY, iplPlaneU, iplPlaneV, color_sp);
        } else if (iplBGR->depth == SR_DEPTH_16U) {
            return cvtBGRtoYUV_16U_8U(iplBGR, iplPlaneY, iplPlaneU, iplPlaneV, color_sp, bit_depth);
        }
    } else if (iplPlaneY->depth == SR_DEPTH_16U && iplPlaneU->depth == SR_DEPTH_16U && iplPlaneV->depth == SR_DEPTH_16U && iplBGR->depth == SR_DEPTH_16U) {
        return cvtBGRtoYUV_16U(iplBGR, iplPlaneY, iplPlaneU, iplPlaneV, color_sp, bit_depth);
    } else if (iplPlaneY->depth == SR_DEPTH_32F && iplPlaneU->depth == SR_DEPTH_32F && iplPlaneV->depth == SR_DEPTH_32F && iplBGR->depth == SR_DEPTH_32F) {
        return cvtBGRtoYUV_32F(iplBGR, iplPlaneY, iplPlaneU, iplPlaneV, color_sp);
    }
    
    showErrMsg("Unsupported input image data type in CImageUtility::cvtBGRtoYUV()!\n");

    return false;
}

bool CImageUtility::cvtBGRtoYUV_32F(IplImage *iplBGR, IplImage *iplPlaneY, IplImage *iplPlaneU, IplImage *iplPlaneV, ColorSpaceName color_sp)
// Convert BGR planar format to YUV planar format with conversion to 4:2:0/4:2:2/4:4:4
// Arguments: 
//		iplRGB -- [I] RGB image; must be 3-channel 32F image
//		iplPlaneY, iplPlaneU, iplPlaneV -- [O] Y, U, V planes; must be 1-channel 32F image
//		color_sp -- color space (CHROMA_BT709 supported)
// by Luhong Liang, ICD-ASD, ASTRI
// Aug. 3, 2013
{
	// check input arguments
	if (iplPlaneY == NULL || iplPlaneU == NULL || iplPlaneV == NULL || iplBGR == NULL ||
		iplPlaneY->nChannels != 1 || iplPlaneU->nChannels != 1 || iplPlaneV->nChannels != 1 || iplBGR->nChannels != 3 ||
		iplPlaneY->depth != SR_DEPTH_32F || iplPlaneU->depth != SR_DEPTH_32F || iplPlaneV->depth != SR_DEPTH_32F || iplBGR->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image in CImageUtility::cvtBGRtoYUV_32F()!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    if (cvtBGRtoYUV_32f_SIMD(iplBGR, iplPlaneY, iplPlaneU, iplPlaneV, color_sp)) {
        return true;
    }       // if failure, try non-SIMD
#endif  // #ifndef __SR_USE_SIMD

	// allocate buffers
	IplImage *iplImageU = NULL;
	IplImage *iplImageV = NULL;
    if (!(iplPlaneY->width == iplBGR->width && iplPlaneY->height == iplBGR->height &&
          iplPlaneU->width == iplBGR->width && iplPlaneU->height == iplBGR->height &&
          iplPlaneV->width == iplBGR->width && iplPlaneV->height == iplBGR->height)) {
	    iplImageU = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_32F, 1);
	    iplImageV = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_32F, 1);
	    if (iplImageU == NULL || iplImageV == NULL) {
		    safeReleaseImage(&iplImageU, &iplImageV);
		    showErrMsg("Fail to allocate buffer in CImageUtility::cvtBGRtoYUV_32F()!\n");
            return false;
	    }
    } else {
        iplImageU = iplPlaneU;
        iplImageV = iplPlaneV;
    }

	if (color_sp == CHROMA_BT709) {		// BT 709 for HD
		for (int y=0; y<iplBGR->height; y++) {
			float *pY = (float *)(iplPlaneY->imageData + y * iplPlaneY->widthStep);
			float *pU = (float *)(iplImageU->imageData + y * iplImageU->widthStep);
			float *pV = (float *)(iplImageV->imageData + y * iplImageV->widthStep);
			float *pBGR = (float *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = 0.2126 * R + 0.7152 * G + 0.0722 * B;
                // U = (B - Y) / 1.8556 + 128;
                // V = (R - Y) / 1.5748 + 128;
				int xx = x * 3;
				float B = pBGR[xx];
				float G = pBGR[xx+1];
				float R = pBGR[xx+2];
				float Y= 0.2126f * R + 0.7152f * G + 0.0722f * B;
				float U = (B - Y) / 1.8556f + 128.0f; 
				float V = (R - Y) / 1.5748f + 128.0f;
				pY[x] = clip_0_255(Y);
				pU[x] = clip_0_255(U);
				pV[x] = clip_0_255(V);
			}
		}
    } else if (color_sp == CHROMA_YUVMS) {		// YUV (microsoft)
		for (int y=0; y<iplBGR->height; y++) {
			float *pY = (float *)(iplPlaneY->imageData + y * iplPlaneY->widthStep);
			float *pU = (float *)(iplImageU->imageData + y * iplImageU->widthStep);
			float *pV = (float *)(iplImageV->imageData + y * iplImageV->widthStep);
			float *pBGR = (float *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				int xx = x * 3;
				float B = pBGR[xx];
				float G = pBGR[xx+1];
				float R = pBGR[xx+2];
				float Y= 0.257f * R + 0.504f * G + 0.098f * B + 16.0f;
				float U = - 0.148f * R - 0.291f * G + 0.439f * B + 128.0f; 
				float V = 0.439f * R - 0.368f * G - 0.071f * B + 128.0f;
				pY[x] = clip_0_255(Y);
				pU[x] = clip_0_255(U);
				pV[x] = clip_0_255(V);
			}
		}
    } else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
        IplImage *iplYCbCr = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
        if (iplYCbCr == NULL) return false;
        cvCvtColor(iplBGR, iplYCbCr, CV_BGR2YCrCb);
        cvSplit(iplYCbCr, iplPlaneY, iplImageU, iplImageV, NULL);
        safeReleaseImage(&iplYCbCr);
#else
		showErrMsg("Does not support YCbCr w/o OpenCV in CImageUtility::cvtBGRtoYUV_32F()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
    } else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
        IplImage *iplYUV = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
        if (iplYUV == NULL) return false;
        cvCvtColor(iplBGR, iplYUV, CV_BGR2YUV);
        cvSplit(iplYUV, iplPlaneY, iplImageU, iplImageV, NULL);
        safeReleaseImage(&iplYUV);
#else
		showErrMsg("Does not support YUV w/o OpenCV in CImageUtility::cvtBGRtoYUV_32F()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV, NULL);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
	} else {
		showErrMsg("Unsupported color space denoted in CImageUtility::cvtBGRtoYUV_32F()\n");
        if (!(iplPlaneY->width == iplBGR->width && iplPlaneY->height == iplBGR->height &&
              iplPlaneU->width == iplBGR->width && iplPlaneU->height == iplBGR->height &&
              iplPlaneV->width == iplBGR->width && iplPlaneV->height == iplBGR->height)) {
            safeReleaseImage(&iplImageU, &iplImageV);
        }
		return false;
	}

	// resize
    if (iplPlaneY->width == iplBGR->width && iplPlaneY->height == iplBGR->height &&
        iplPlaneU->width == iplBGR->width && iplPlaneU->height == iplBGR->height &&
        iplPlaneV->width == iplBGR->width && iplPlaneV->height == iplBGR->height) {
        // 4:4:4 
        // do nothing
    } else if (iplPlaneY->width == iplBGR->width && iplPlaneY->height == iplBGR->height &&
               iplPlaneU->width*2 == iplBGR->width && iplPlaneU->height == iplBGR->height &&
               iplPlaneV->width*2 == iplBGR->width && iplPlaneV->height == iplBGR->height) {
        // 4:2:2
        interlaceX(iplImageU, iplPlaneU, true);
	    interlaceX(iplImageV, iplPlaneV, true);
    } else if (iplPlaneY->width == iplBGR->width && iplPlaneY->height == iplBGR->height &&
               iplPlaneU->width*2 == iplBGR->width && iplPlaneU->height*2 == iplBGR->height &&
               iplPlaneV->width*2 == iplBGR->width && iplPlaneV->height*2 == iplBGR->height) {
        // 4:2:0
	    resize(iplImageU, iplPlaneU, SR_INTER_LINEAR);//SR_INTER_CUBIC);
	    resize(iplImageV, iplPlaneV, SR_INTER_LINEAR);//SR_INTER_CUBIC);
    } else {
        showErrMsg("Only support 4:2:0, 4:2:2 and 4:4:4 format in CImageUtility::cvtYUVtoBGR_16U()!\n");
        if (!(iplPlaneY->width == iplBGR->width && iplPlaneY->height == iplBGR->height &&
              iplPlaneU->width == iplBGR->width && iplPlaneU->height == iplBGR->height &&
              iplPlaneV->width == iplBGR->width && iplPlaneV->height == iplBGR->height)) {
            safeReleaseImage(&iplImageU, &iplImageV);
        }
        return false;
    }

    if (!(iplPlaneY->width == iplBGR->width && iplPlaneY->height == iplBGR->height &&
          iplPlaneU->width == iplBGR->width && iplPlaneU->height == iplBGR->height &&
          iplPlaneV->width == iplBGR->width && iplPlaneV->height == iplBGR->height)) {
        safeReleaseImage(&iplImageU, &iplImageV);
    }

	return true;
}

bool CImageUtility::cvtBGRtoYUV_16U(IplImage *iplBGR, IplImage *iplPlaneY, IplImage *iplPlaneU, IplImage *iplPlaneV, ColorSpaceName color_sp, int bit_depth)
// Convert BGR planar format to YUV planar format with conversion to 4:2:0/4:2:2/4:4:4
// Arguments: 
//		iplRGB -- [I] RGB image; must be 3-channel 16U image
//		iplPlaneY, iplPlaneU, iplPlaneV -- [O] Y, U, V planes; must be 1-channel 16U image
//		color_sp -- color space (CHROMA_BT709 supported)
//      bit_depth -- [I] actual bit depth of the image (should set it to 8 for 8U and 32F image)
// NOTE: This function uses an equation for analog signal!!!
// by Luhong Liang, ICD-ASD, ASTRI
// Sept.  17, 2013
{
	// check input arguments
	if (iplPlaneY == NULL || iplPlaneU == NULL || iplPlaneV == NULL || iplBGR == NULL ||
		iplPlaneY->nChannels != 1 || iplPlaneU->nChannels != 1 || iplPlaneV->nChannels != 1 || iplBGR->nChannels != 3 ||
		iplPlaneY->depth != SR_DEPTH_16U || iplPlaneU->depth != SR_DEPTH_16U || iplPlaneV->depth != SR_DEPTH_16U || iplBGR->depth != SR_DEPTH_16U) {
		showErrMsg("Invalid input image in CImageUtility::cvtBGRtoYUV_16U()!\n");
		return false;
	}
    if (bit_depth < 1 || bit_depth > 16) {
        showErrMsg("Only support bit depth 1~16 in CImageUtility::cvtYUVtoBGR_16U()!\n");
		return false;
	}

	// allocate buffers
	IplImage *iplImageY = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_16U, 1);
	IplImage *iplImageU = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_16U, 1);
	IplImage *iplImageV = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_16U, 1);
	if (iplImageY == NULL || iplImageU == NULL || iplImageV == NULL) {
		safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
		showErrMsg("Fail to allocate buffer in CImageUtility::cvtBGRtoYUV_16U()!\n");
	}

    const int max_val = (1<<bit_depth) - 1;
    const int mid_val_int = (1<<(bit_depth-1));
    const int shift_val_int = mid_val_int >> 3;
    const float mid_val = (float)(1<<(bit_depth-1));
	if (color_sp == CHROMA_BT709) {		// BT 709 for HD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned short *pY = (unsigned short *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned short *pU = (unsigned short *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned short *pV = (unsigned short *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned short *pBGR = (unsigned short *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = 0.2126 * R + 0.7152 * G + 0.0722 * B;
                // U = (B - Y) / 1.8556 + 128;
                // V = (R - Y) / 1.5748 + 128;
				int xx = x * 3;
				float B = (float)pBGR[xx];
				float G = (float)pBGR[xx+1];
				float R = (float)pBGR[xx+2];
				float Y= 0.2126f * R + 0.7152f * G + 0.0722f * B;
				float U = (B - Y) / 1.8556f + mid_val; 
				float V = (R - Y) / 1.5748f + mid_val;
                int Yint = (int)(Y + 0.5f);
                Yint = Yint < 0 ? 0 : Yint;
                Yint = Yint > max_val ? max_val : Yint;
				pY[x] = (unsigned short)Yint;
                int Uint = (int)(U + 0.5f);
                Uint = Uint < 0 ? 0 : Uint;
                Uint = Uint > max_val ? max_val : Uint;
				pU[x] = (unsigned short)Uint;
                int Vint = (int)(V + 0.5f);
                Vint = Vint < 0 ? 0 : Vint;
                Vint = Vint > max_val ? max_val : Vint;
				pV[x] = (unsigned short)Vint;
			}
		}
	} else if (color_sp == CHROMA_YUVMS) {		// YUV (microsoft)
		for (int y=0; y<iplBGR->height; y++) {
			unsigned short *pY = (unsigned short *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned short *pU = (unsigned short *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned short *pV = (unsigned short *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned short *pBGR = (unsigned short *)(iplBGR->imageData + y * iplBGR->widthStep);   // bug "unsigned char" fixed, May 20, 2015
			for (int x=0; x<iplBGR->width; x++) {
				// Y = ( (  66 * R + 129 * G +  25 * B + 128) >> 8) +  16
                // U = ( ( -38 * R -  74 * G + 112 * B + 128) >> 8) + 128
                // V = ( ( 112 * R -  94 * G -  18 * B + 128) >> 8) + 128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
                int Y = ( (  66 * R + 129 * G +  25 * B + mid_val_int) >> 8) +  shift_val_int;
                int U = ( ( -38 * R -  74 * G + 112 * B + mid_val_int) >> 8) + mid_val_int;
                int V = ( ( 112 * R -  94 * G -  18 * B + mid_val_int) >> 8) + mid_val_int;
				pY[x] = (unsigned short)clip_int(Y, max_val, -max_val);
				pU[x] = (unsigned short)clip_int(U, max_val, -max_val);
				pV[x] = (unsigned short)clip_int(V, max_val, -max_val);
			}
		}
    } else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
        IplImage *iplYCbCr = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
        if (iplYCbCr == NULL) return false;
        cvCvtColor(iplBGR, iplYCbCr, CV_BGR2YCrCb);
        cvSplit(iplYCbCr, iplImageY, iplImageU, iplImageV, NULL);
        safeReleaseImage(&iplYCbCr);
#else
		showErrMsg("Does not support YCbCr w/o OpenCV in CImageUtility::cvtBGRtoYUV_16U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
    } else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
        IplImage *iplYUV = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
        if (iplYUV == NULL) return false;
        cvCvtColor(iplBGR, iplYUV, CV_BGR2YUV);
        cvSplit(iplYUV, iplImageY, iplImageU, iplImageV, NULL);
        safeReleaseImage(&iplYUV);
#else
		showErrMsg("Does not support YUV w/o OpenCV in CImageUtility::cvtBGRtoYUV_16U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV, NULL);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
	} else {
		showErrMsg("Unsupported color space denoted in CImageUtility::cvtBGRtoYUV_16U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV);
		return false;
	}

	// resize
    if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
        iplPlaneU->width == iplImageU->width && iplPlaneU->height == iplImageU->height &&
        iplPlaneV->width == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:4:4
        copy(iplImageY, iplPlaneY);
        copy(iplImageU, iplPlaneU);
        copy(iplImageV, iplPlaneV);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:2:2
	    copy(iplImageY, iplPlaneY);
        interlaceX(iplImageU, iplPlaneU, true);
	    interlaceX(iplImageV, iplPlaneV, true);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height*2 == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height*2 == iplImageV->height) {
        // 4:2:0
	    copy(iplImageY, iplPlaneY);
	    resize(iplImageU, iplPlaneU, SR_INTER_LINEAR);//SR_INTER_CUBIC);
	    resize(iplImageV, iplPlaneV, SR_INTER_LINEAR);//SR_INTER_CUBIC);
    } else {
        showErrMsg("Only support 4:2:0, 4:2:2 and 4:4:4 format in CImageUtility::cvtYUVtoBGR_16U()!\n");
        safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
        return false;
    }

    safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);

	return true;
}

bool CImageUtility::cvtBGRtoYUV_16U_8U(IplImage *iplBGR, IplImage *iplPlaneY, IplImage *iplPlaneU, IplImage *iplPlaneV, 
                                       ColorSpaceName color_sp, int bit_depth)
// Convert BGR planar format to YUV planar format with conversion to 4:2:0/4:2:2/4:4:4
// Arguments: 
//		iplRGB -- [I] RGB image; must be 3-channel 16U image
//		iplPlaneY, iplPlaneU, iplPlaneV -- [O] Y, U, V planes; must be 1-channel 8U image
//		color_sp -- color space (CHROMA_BT709 supported)
//      bit_depth -- [I] actual bit depth of the image (should set it to 8 for 8U and 32F image)
// NOTE: This function uses an equation for analog signal!!!
// by Luhong Liang, ICD-ASD, ASTRI
// Sept.  17, 2013
{
	// check input arguments
	if (iplPlaneY == NULL || iplPlaneU == NULL || iplPlaneV == NULL || iplBGR == NULL ||
		iplPlaneY->nChannels != 1 || iplPlaneU->nChannels != 1 || iplPlaneV->nChannels != 1 || iplBGR->nChannels != 3 ||
		iplPlaneY->depth != SR_DEPTH_8U || iplPlaneU->depth != SR_DEPTH_8U || iplPlaneV->depth != SR_DEPTH_8U || iplBGR->depth != SR_DEPTH_16U) {
		showErrMsg("Invalid input image in CImageUtility::cvtBGRtoYUV_16U_8U()!\n");
		return false;
	}
    if (bit_depth < 8 || bit_depth > 16) {
        showErrMsg("Only support bit depth 8~16 in CImageUtility::cvtBGRtoYUV_16U_8U()!\n");
		return false;
	}

	// allocate buffers
	IplImage *iplImageY = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	IplImage *iplImageU = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	IplImage *iplImageV = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	if (iplImageY == NULL || iplImageU == NULL || iplImageV == NULL) {
		safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
		showErrMsg("Fail to allocate buffer in CImageUtility::cvtBGRtoYUV_16U_8U()!\n");
	}

    //const int max_val = (1<<bit_depth) - 1;
    const int mid_val_int = (1<<(bit_depth-1));
    const int shift_val_int = mid_val_int >> 3;
    const float mid_val = (float)(1<<(bit_depth-1));
    const int demo_to_8u = 1<<(bit_depth-8);
    const int half_val = demo_to_8u / 2;
	if (color_sp == CHROMA_BT709) {		// BT 709 for HD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned short *pBGR = (unsigned short *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = 0.2126 * R + 0.7152 * G + 0.0722 * B;
                // U = (B - Y) / 1.8556 + 128;
                // V = (R - Y) / 1.5748 + 128;
				int xx = x * 3;
				float B = (float)pBGR[xx];
				float G = (float)pBGR[xx+1];
				float R = (float)pBGR[xx+2];
				float Y= 0.2126f * R + 0.7152f * G + 0.0722f * B;
				float U = (B - Y) / 1.8556f + mid_val; 
				float V = (R - Y) / 1.5748f + mid_val;
                int Yint = (int)(Y/demo_to_8u + 0.5f);
				pY[x] = (unsigned char)clip_0_255(Yint);
                int Uint = (int)(U/demo_to_8u + 0.5f);
				pU[x] = (unsigned char)clip_0_255(Uint);
                int Vint = (int)(V/demo_to_8u + 0.5f);
				pV[x] = (unsigned char)clip_0_255(Vint);
			}
		}
	} else if (color_sp == CHROMA_YUVMS) {		// YUV (microsoft)
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned short *pBGR = (unsigned short *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = ( (  66 * R + 129 * G +  25 * B + 128) >> 8) +  16
                // U = ( ( -38 * R -  74 * G + 112 * B + 128) >> 8) + 128
                // V = ( ( 112 * R -  94 * G -  18 * B + 128) >> 8) + 128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
                int Y = ( (  66 * R + 129 * G +  25 * B + mid_val_int) >> 8) +  shift_val_int;
                int U = ( ( -38 * R -  74 * G + 112 * B + mid_val_int) >> 8) + mid_val_int;
                int V = ( ( 112 * R -  94 * G -  18 * B + mid_val_int) >> 8) + mid_val_int;
				pY[x] = (unsigned char)clip_0_255((Y+half_val)/demo_to_8u);
				pU[x] = (unsigned char)clip_0_255((U+half_val)/demo_to_8u);
				pV[x] = (unsigned char)clip_0_255((V+half_val)/demo_to_8u);
			}
		}
    } else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
        IplImage *iplYCbCr = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
        if (iplYCbCr == NULL) return false;
        cvCvtColor(iplBGR, iplYCbCr, CV_BGR2YCrCb);
        cvSplit(iplYCbCr, iplImageY, iplImageU, iplImageV, NULL);
        safeReleaseImage(&iplYCbCr);
#else
		showErrMsg("Does not support YCbCr w/o OpenCV in CImageUtility::cvtBGRtoYUV_16U_8U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
    } else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
        IplImage *iplYUV = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
        if (iplYUV == NULL) return false;
        cvCvtColor(iplBGR, iplYUV, CV_BGR2YUV);
        cvSplit(iplYUV, iplImageY, iplImageU, iplImageV, NULL);
        safeReleaseImage(&iplYUV);
#else
		showErrMsg("Does not support YUV w/o OpenCV in CImageUtility::cvtBGRtoYUV_16U_8U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV, NULL);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
	} else {
		showErrMsg("Unsupported color space denoted in CImageUtility::cvtBGRtoYUV_16U_8U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV);
		return false;
	}

	// resize
    if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
        iplPlaneU->width == iplImageU->width && iplPlaneU->height == iplImageU->height &&
        iplPlaneV->width == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:4:4
        copy(iplImageY, iplPlaneY);
        copy(iplImageU, iplPlaneU);
        copy(iplImageV, iplPlaneV);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:2:2
	    copy(iplImageY, iplPlaneY);
        interlaceX(iplImageU, iplPlaneU, true);
	    interlaceX(iplImageV, iplPlaneV, true);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height*2 == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height*2 == iplImageV->height) {
        // 4:2:0
	    copy(iplImageY, iplPlaneY);
	    resize(iplImageU, iplPlaneU, SR_INTER_LINEAR);//SR_INTER_CUBIC);
	    resize(iplImageV, iplPlaneV, SR_INTER_LINEAR);//SR_INTER_CUBIC);
    } else {
        showErrMsg("Only support 4:2:0, 4:2:2 and 4:4:4 format in CImageUtility::cvtBGRtoYUV_16U_8U()!\n");
        safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
        return false;
    }

    safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);

	return true;
}

bool CImageUtility::cvtBGRtoYUV_8U(IplImage *iplBGR, IplImage *iplPlaneY, IplImage *iplPlaneU, IplImage *iplPlaneV, ColorSpaceName color_sp)
// Convert BGR planar format to YUV planar format with conversion to 4:2:0/4:2:2/4:4:4
// Arguments: 
//		iplRGB -- [I] RGB image; must be 3-channel 8U image
//		iplPlaneY, iplPlaneU, iplPlaneV -- [O] Y, U, V planes; must be 1-channel 8U image
//		color_sp -- color space (CHROMA_YCC, CHROMA_BT601 and CHROMA_BT709 supported)
// by Luhong Liang, ICD-ASD, ASTRI
// May 7, 2013
{
	// check input arguments
	if (iplPlaneY == NULL || iplPlaneU == NULL || iplPlaneV == NULL || iplBGR == NULL ||
		iplPlaneY->nChannels != 1 || iplPlaneU->nChannels != 1 || iplPlaneV->nChannels != 1 || iplBGR->nChannels != 3 ||
		iplPlaneY->depth != SR_DEPTH_8U || iplPlaneU->depth != SR_DEPTH_8U || iplPlaneV->depth != SR_DEPTH_8U || iplBGR->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image in CImageUtility::cvtBGRtoYUV_8U()!\n");
		return false;
	}

	// allocate buffers
	IplImage *iplImageY = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	IplImage *iplImageU = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	IplImage *iplImageV = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	if (iplImageY == NULL || iplImageU == NULL || iplImageV == NULL) {
		safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
		showErrMsg("Fail to allocate buffer in CImageUtility::cvtBGRtoYUV_8U()!\n");
	}

	if (color_sp == CHROMA_BT601) {		// BT 601 for SD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = (77R+ 150G+29B)/256
				// Cb = (-44R-87G+ 131B)/256+128
				// Cr = (131R-110G -21B)/256+128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
				int Y= (77 * R + 150 * G + 29 * B) >> 7;
				int U = -44 * R - 87 *  G + 131 * B; 
                if (U > 0) {
                    U = (U >> 7) + 256;
                } else {
                    U = - ((-U) >> 7) + 256;
                }
				int V = 131 * R - 110 * G - 21 * B;
                if (V > 0) {
                    V = (V >> 7) + 256;
                } else {
                    V = - ((-V) >> 7) + 256;
                }
                // clipping
				pY[x] = rndclp_9Uto8U(Y);
				pU[x] = rndclp_9Uto8U(U);
				pV[x] = rndclp_9Uto8U(V);
			}
		}
	} else 	if (color_sp == CHROMA_BT624) {		// BT 624 for SD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y =0.299 * R + 0.587 * G + 0.114 * B           Y = (19595 * R + 38470 * G + 7471 * B) >> 16
                // U = 0.877 * (B - Y)                                      U = ((-17185 * R - 33738 * G + 50923 * B) >> 16 ) + 128
				// V = 0.493 * (R - Y)                                      V = ( (22649 * R - 18966 * G - 3683 * B) >> 16 ) + 128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
                int Y = (19595 * R + 38470 * G + 7471 * B) >> 15;
                int U = ((-17185 * R - 33738 * G + 50923 * B) >> 15 ) + 256;
                int V = ( (22649 * R - 18966 * G - 3683 * B) >> 15 ) + 256;
				pY[x] = rndclp_9Uto8U(Y);
				pU[x] = rndclp_9Uto8U(U);
				pV[x] = rndclp_9Uto8U(V);
			}
		}
	} else 	if (color_sp == CHROMA_BT709) {		// BT 709 for HD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = (55R+183G+18B)/256
				// Cb = (-30R-101G+131B)/256+128
				// Cr = (131R-119G-12B)/256+128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
				int Y= (55 * R + 183 * G + 18 * B) >> 7;
				int U = -30 * R - 101 *  G + 131 * B; 
                if (U > 0) {
                    U = (U >> 7) + 256;
                } else {
                    U = - ((-U) >> 7) + 256;
                }
				int V = 131 * R - 119 * G - 12 * B;
                if (V > 0) {
                    V = (V >> 7) + 256;
                } else {
                    V = - ((-V) >> 7) + 256;
                }
				pY[x] = rndclp_9Uto8U(Y);
				pU[x] = rndclp_9Uto8U(U);
				pV[x] = rndclp_9Uto8U(V);
				//pY[x] = (unsigned char)clip_0_255((14*R + 46*G + 4*B)/64);
				//pU[x] = (unsigned char)clip_0_255((-8*R - 25*G + 33*B)/64+128);
				//pV[x] = (unsigned char)clip_0_255((33*R + -30*G - 3*B)/64+128);

				//pY[x] = (unsigned char)clip_0_255((14*R + 46*G + 4*B)/64);
				//pU[x] = (unsigned char)clip_0_255((-8*R - 25*G + 33*B + 128*64)/64);
				//pV[x] = (unsigned char)clip_0_255((33*R + -30*G - 3*B + 128*64)/64);


			}
		}
	} else 	if (color_sp == CHROMA_YUVMS) {		// YUV (microsoft)
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = ( (  66 * R + 129 * G +  25 * B + 128) >> 8) +  16
                // U = ( ( -38 * R -  74 * G + 112 * B + 128) >> 8) + 128
                // V = ( ( 112 * R -  94 * G -  18 * B + 128) >> 8) + 128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
                int Y = ( (  66 * R + 129 * G +  25 * B + 128) >> 8) +  16;
                int U = ( ( -38 * R -  74 * G + 112 * B + 128) >> 8) + 128;
                int V = ( ( 112 * R -  94 * G -  18 * B + 128) >> 8) + 128;
				pY[x] = (unsigned char)clip_0_255(Y);
				pU[x] = (unsigned char)clip_0_255(U);
				pV[x] = (unsigned char)clip_0_255(V);
			}
		}
	} else if (color_sp == CHROMA_YCC) {		// MatLab rgb2gray, only modified Y channel but keep U V channel unchanged
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = (55R+183G+18B)/256
				// Cb = (-30R-101G+131B)/256+128
				// Cr = (131R-119G-12B)/256+128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
				//int Y= (55 * R + 183 * G + 18 * B) >> 8;
				int Y = (int)((0.299f * R + 0.587f * G + 0.114f * B) + 0.5f);	//Coded by Kayton Cheung
				int U = ((-30 * R - 101 *  G + 131 * B) >> 7) + 256; 
				int V = ((131 * R - 119 * G - 12 * B) >> 7) + 256;
				pY[x] = (unsigned char)Y;
				pU[x] = rndclp_9Uto8U(U);
				pV[x] = rndclp_9Uto8U(V);
			}
		}
    } else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
        IplImage *iplYCbCr = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
        if (iplYCbCr == NULL) return false;
        cvCvtColor(iplBGR, iplYCbCr, CV_BGR2YCrCb);
        cvSplit(iplYCbCr, iplImageY, iplImageU, iplImageV, NULL);
        safeReleaseImage(&iplYCbCr);
#else
		showErrMsg("Does not support YCbCr w/o OpenCV in CImageUtility::cvtBGRtoYUV_8U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
    } else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
        IplImage *iplYUV = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
        if (iplYUV == NULL) return false;
        cvCvtColor(iplBGR, iplYUV, CV_BGR2YUV);
        cvSplit(iplYUV, iplImageY, iplImageU, iplImageV, NULL);
        safeReleaseImage(&iplYUV);
#else
		showErrMsg("Does not support YUV w/o OpenCV in CImageUtility::cvtBGRtoYUV_8U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV, NULL);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
	} else {
		showErrMsg("Unsupported color space denoted in CImageUtility::cvtBGRtoYUV_8U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV);
		return false;
	}

    //saveImage("_BGR.bmp", iplBGR);
    //saveImage("_Y.bmp", iplImageY);
    //saveImage("_U.bmp", iplImageU);
    //saveImage("_V.bmp", iplImageV);

	// resize
    if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
        iplPlaneU->width == iplImageU->width && iplPlaneU->height == iplImageU->height &&
        iplPlaneV->width == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:4:4
        copy(iplImageY, iplPlaneY);
        copy(iplImageU, iplPlaneU);
        copy(iplImageV, iplPlaneV);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:2:2
	    copy(iplImageY, iplPlaneY);
        interlaceX(iplImageU, iplPlaneU, true);
	    interlaceX(iplImageV, iplPlaneV, true);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height*2 == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height*2 == iplImageV->height) {
        // 4:2:0
	    copy(iplImageY, iplPlaneY);
	    resize(iplImageU, iplPlaneU, SR_INTER_LINEAR);//SR_INTER_CUBIC);
	    resize(iplImageV, iplPlaneV, SR_INTER_LINEAR);//SR_INTER_CUBIC);
    } else {
        showErrMsg("Only support 4:2:0, 4:2:2 and 4:4:4 format in CImageUtility::cvtYUVtoBGR_16U()!\n");
        safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
        return false;
    }

    //saveImage("_U1.bmp", iplPlaneU);
    //saveImage("_V1.bmp", iplPlaneV);

    safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);

	return true;
}
bool CImageUtility::cvtBGRtoYUV_8U_Basic(IplImage *iplBGR, IplImage *iplPlaneY, IplImage *iplPlaneU, IplImage *iplPlaneV, ColorSpaceName color_sp)
	// Convert BGR planar format to YUV planar format with conversion to 4:2:0/4:2:2/4:4:4
	// Arguments: 
	//		iplRGB -- [I] RGB image; must be 3-channel 8U image
	//		iplPlaneY, iplPlaneU, iplPlaneV -- [O] Y, U, V planes; must be 1-channel 8U image
	//		color_sp -- color space (CHROMA_YCC, CHROMA_BT601 and CHROMA_BT709 supported)
	// by Luhong Liang, ICD-ASD, ASTRI
	// May 7, 2013
{
	// check input arguments
	if (iplPlaneY == NULL || iplPlaneU == NULL || iplPlaneV == NULL || iplBGR == NULL ||
		iplPlaneY->nChannels != 1 || iplPlaneU->nChannels != 1 || iplPlaneV->nChannels != 1 || iplBGR->nChannels != 3 ||
		iplPlaneY->depth != SR_DEPTH_8U || iplPlaneU->depth != SR_DEPTH_8U || iplPlaneV->depth != SR_DEPTH_8U || iplBGR->depth != SR_DEPTH_8U) {
			showErrMsg("Invalid input image in CImageUtility::cvtBGRtoYUV_8U()!\n");
			return false;
	}

	// allocate buffers
	IplImage *iplImageY = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	IplImage *iplImageU = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	IplImage *iplImageV = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	if (iplImageY == NULL || iplImageU == NULL || iplImageV == NULL) {
		safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
		showErrMsg("Fail to allocate buffer in CImageUtility::cvtBGRtoYUV_8U()!\n");
	}

	if (color_sp == CHROMA_BT601) {		// BT 601 for SD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = (77R+ 150G+29B)/256
				// Cb = (-44R-87G+ 131B)/256+128
				// Cr = (131R-110G -21B)/256+128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
				int Y= (77 * R + 150 * G + 29 * B) >> 7;
				int U = -44 * R - 87 *  G + 131 * B; 
				if (U > 0) {
					U = (U >> 7) + 256;
				} else {
					U = - ((-U) >> 7) + 256;
				}
				int V = 131 * R - 110 * G - 21 * B;
				if (V > 0) {
					V = (V >> 7) + 256;
				} else {
					V = - ((-V) >> 7) + 256;
				}
				// clipping
				pY[x] = rndclp_9Uto8U(Y);
				pU[x] = rndclp_9Uto8U(U);
				pV[x] = rndclp_9Uto8U(V);
			}
		}
	} else 	if (color_sp == CHROMA_BT624) {		// BT 624 for SD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y =0.299 * R + 0.587 * G + 0.114 * B           Y = (19595 * R + 38470 * G + 7471 * B) >> 16
				// U = 0.877 * (B - Y)                                      U = ((-17185 * R - 33738 * G + 50923 * B) >> 16 ) + 128
				// V = 0.493 * (R - Y)                                      V = ( (22649 * R - 18966 * G - 3683 * B) >> 16 ) + 128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
				int Y = (19595 * R + 38470 * G + 7471 * B) >> 15;
				int U = ((-17185 * R - 33738 * G + 50923 * B) >> 15 ) + 256;
				int V = ( (22649 * R - 18966 * G - 3683 * B) >> 15 ) + 256;
				pY[x] = rndclp_9Uto8U(Y);
				pU[x] = rndclp_9Uto8U(U);
				pV[x] = rndclp_9Uto8U(V);
			}
		}
	} else 	if (color_sp == CHROMA_BT709) {		// BT 709 for HD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = (55R+183G+18B)/256
				// Cb = (-30R-101G+131B)/256+128
				// Cr = (131R-119G-12B)/256+128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
				//int Y= (55 * R + 183 * G + 18 * B) >> 7;
				//int U = -30 * R - 101 *  G + 131 * B; 
				//if (U > 0) {
				//	U = (U >> 7) + 256;
				//} else {
				//	U = - ((-U) >> 7) + 256;
				//}
				//int V = 131 * R - 119 * G - 12 * B;
				//if (V > 0) {
				//	V = (V >> 7) + 256;
				//} else {
				//	V = - ((-V) >> 7) + 256;
				//}
				//pY[x] = rndclp_9Uto8U(Y);
				//pU[x] = rndclp_9Uto8U(U);
				//pV[x] = rndclp_9Uto8U(V);
				//pY[x] = (unsigned char)clip_0_255((14*R + 46*G + 4*B)/64);
				//pU[x] = (unsigned char)clip_0_255((-8*R - 25*G + 33*B)/64+128);
				//pV[x] = (unsigned char)clip_0_255((33*R + -30*G - 3*B)/64+128);

				pY[x] = (unsigned char)clip_0_255((14*R + 46*G + 4*B)/64);
				pU[x] = (unsigned char)clip_0_255((-8*R - 25*G + 33*B + 128*64)/64);
				pV[x] = (unsigned char)clip_0_255((33*R + -30*G - 3*B + 128*64)/64);


			}
		}
	} else 	if (color_sp == CHROMA_YUVMS) {		// YUV (microsoft)
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = ( (  66 * R + 129 * G +  25 * B + 128) >> 8) +  16
				// U = ( ( -38 * R -  74 * G + 112 * B + 128) >> 8) + 128
				// V = ( ( 112 * R -  94 * G -  18 * B + 128) >> 8) + 128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
				int Y = ( (  66 * R + 129 * G +  25 * B + 128) >> 8) +  16;
				int U = ( ( -38 * R -  74 * G + 112 * B + 128) >> 8) + 128;
				int V = ( ( 112 * R -  94 * G -  18 * B + 128) >> 8) + 128;
				pY[x] = (unsigned char)clip_0_255(Y);
				pU[x] = (unsigned char)clip_0_255(U);
				pV[x] = (unsigned char)clip_0_255(V);
			}
		}
	} else if (color_sp == CHROMA_YCC) {		// MatLab rgb2gray, only modified Y channel but keep U V channel unchanged
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = (55R+183G+18B)/256
				// Cb = (-30R-101G+131B)/256+128
				// Cr = (131R-119G-12B)/256+128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
				//int Y= (55 * R + 183 * G + 18 * B) >> 8;
				int Y = (int)((0.299f * R + 0.587f * G + 0.114f * B) + 0.5f);	//Coded by Kayton Cheung
				int U = ((-30 * R - 101 *  G + 131 * B) >> 7) + 256; 
				int V = ((131 * R - 119 * G - 12 * B) >> 7) + 256;
				pY[x] = (unsigned char)Y;
				pU[x] = rndclp_9Uto8U(U);
				pV[x] = rndclp_9Uto8U(V);
			}
		}
	} else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
		IplImage *iplYCbCr = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
		if (iplYCbCr == NULL) return false;
		cvCvtColor(iplBGR, iplYCbCr, CV_BGR2YCrCb);
		cvSplit(iplYCbCr, iplImageY, iplImageU, iplImageV, NULL);
		safeReleaseImage(&iplYCbCr);
#else
		showErrMsg("Does not support YCbCr w/o OpenCV in CImageUtility::cvtBGRtoYUV_8U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
	} else if (color_sp == CHROMA_YCbCr) {
#ifdef __OPENCV_OLD_CV_H__
		IplImage *iplYUV = createImage(iplBGR->width, iplBGR->height, iplBGR->depth, iplBGR->nChannels);
		if (iplYUV == NULL) return false;
		cvCvtColor(iplBGR, iplYUV, CV_BGR2YUV);
		cvSplit(iplYUV, iplImageY, iplImageU, iplImageV, NULL);
		safeReleaseImage(&iplYUV);
#else
		showErrMsg("Does not support YUV w/o OpenCV in CImageUtility::cvtBGRtoYUV_8U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV, NULL);
		return false;
#endif  //  __OPENCV_OLD_CV_H__
	} else {
		showErrMsg("Unsupported color space denoted in CImageUtility::cvtBGRtoYUV_8U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV);
		return false;
	}

	//saveImage("_BGR.bmp", iplBGR);
	//saveImage("_Y.bmp", iplImageY);
	//saveImage("_U.bmp", iplImageU);
	//saveImage("_V.bmp", iplImageV);

	// resize
	if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
		iplPlaneU->width == iplImageU->width && iplPlaneU->height == iplImageU->height &&
		iplPlaneV->width == iplImageV->width && iplPlaneV->height == iplImageV->height) {
			// 4:4:4
			copy(iplImageY, iplPlaneY);
			copy(iplImageU, iplPlaneU);
			copy(iplImageV, iplPlaneV);
	} else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
		iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height == iplImageU->height &&
		iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height == iplImageV->height) {
			// 4:2:2
			copy(iplImageY, iplPlaneY);
			interlaceX(iplImageU, iplPlaneU, true);
			interlaceX(iplImageV, iplPlaneV, true);
	} else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
		iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height*2 == iplImageU->height &&
		iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height*2 == iplImageV->height) {
			// 4:2:0
			copy(iplImageY, iplPlaneY);
			resize(iplImageU, iplPlaneU, SR_INTER_LINEAR);//SR_INTER_CUBIC);
			resize(iplImageV, iplPlaneV, SR_INTER_LINEAR);//SR_INTER_CUBIC);
	} else {
		showErrMsg("Only support 4:2:0, 4:2:2 and 4:4:4 format in CImageUtility::cvtYUVtoBGR_16U()!\n");
		safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
		return false;
	}

	//saveImage("_U1.bmp", iplPlaneU);
	//saveImage("_V1.bmp", iplPlaneV);

	safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);

	return true;
}

bool CImageUtility::cvtBGRtoYUV_10U_8U(IplImage *iplBGR, IplImage *iplPlaneY, IplImage *iplPlaneU, IplImage *iplPlaneV, ColorSpaceName color_sp)
// Convert BGR planar format to YUV planar format with conversion to 4:2:0/4:2:2/4:4:4
// Arguments: 
//		iplRGB -- [I] RGB image; must be 3-channel 32S (10-bit) image
//		iplPlaneY, iplPlaneU, iplPlaneV -- [O] Y, U, V planes; must be 1-channel 8U image
//		color_sp -- color space (CHROMA_BT601 and CHROMA_BT709 supported)
// by Luhong Liang, ICD-ASD, ASTRI
// Aug 1, 2013
{
	// check input arguments
	if (iplPlaneY == NULL || iplPlaneU == NULL || iplPlaneV == NULL || iplBGR == NULL ||
		iplPlaneY->nChannels != 1 || iplPlaneU->nChannels != 1 || iplPlaneV->nChannels != 1 || iplBGR->nChannels != 3 ||
		iplPlaneY->depth != SR_DEPTH_8U || iplPlaneU->depth != SR_DEPTH_8U || iplPlaneV->depth != SR_DEPTH_8U || iplBGR->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image in CImageUtility::cvtBGRtoYUV_10U_8U()!\n");
		return false;
	}

	// allocate buffers
	IplImage *iplImageY = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	IplImage *iplImageU = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	IplImage *iplImageV = createImage(iplBGR->width, iplBGR->height, SR_DEPTH_8U, 1);
	if (iplImageY == NULL || iplImageU == NULL || iplImageV == NULL) {
		safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
		showErrMsg("Fail to allocate buffer in CImageUtility::cvtBGRtoYUV_10U_8U()!\n");
	}

	if (color_sp == CHROMA_BT601) {		// BT 601 for SD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			int *pBGR = (int *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = (77R+ 150G+29B)/256
				// Cb = (-44R-87G+ 131B)/256+128
				// Cr = (131R-110G -21B)/256+128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
				int Y= (77 * R + 150 * G + 29 * B) >> 9;
				int U = -44 * R - 87 *  G + 131 * B; 
                if (U > 0) {
                    U = (U >> 9) + 256;
                } else {
                    U = - ((-U) >> 9) + 256;
                }
				int V = 131 * R - 110 * G - 21 * B;
                if (V > 0) {
                    V = (V >> 9) + 256;
                } else {
                    V = - ((-V) >> 9) + 256;
                }
                // clipping
				pY[x] = rndclp_9Uto8U(Y);
				pU[x] = rndclp_9Uto8U(U);
				pV[x] = rndclp_9Uto8U(V);
			}
		}
	} else 	if (color_sp == CHROMA_BT709) {		// BT 709 for HD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplImageY->imageData + y * iplImageY->widthStep);
			unsigned char *pU = (unsigned char *)(iplImageU->imageData + y * iplImageU->widthStep);
			unsigned char *pV = (unsigned char *)(iplImageV->imageData + y * iplImageV->widthStep);
			int *pBGR = (int *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = (55R+183G+18B)/256
				// Cb = (-30R-101G+131B)/256+128
				// Cr = (131R-119G-12B)/256+128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
				//int Y= (55 * R + 183 * G + 18 * B) >> 9;
				//int U = -30 * R - 101 *  G + 131 * B; 
                //if (U > 0) {
                //    U = (U >> 9) + 256;
                //} else {
                //    U = - ((-U) >> 9) + 256;
                //}
				//int V = 131 * R - 119 * G - 12 * B;
                //if (V > 0) {
                //    V = (V >> 9) + 256;
                //} else {
                //    V = - ((-V) >> 9) + 256;
                //}
				//pY[x] = rndclp_9Uto8U(Y);
				//pU[x] = rndclp_9Uto8U(U);
				//pV[x] = rndclp_9Uto8U(V);

				// XJ on Aug07: to match RTL
				int Y = ((55*R)>>6) + ((183*G)>>6) + ((18*B)>>6);
				int U = -((30*R)>>6) - ((101*G)>>6) + ((131*B)>>6) + 128*16;
				int V = ((131*R)>>6) - ((119*G)>>6) - ((12*B)>>6) + 128*16;


				// rounding 
				Y = ((Y + 8) >> 4);
				if (U<0)
					U = 0;
				else 
					U = ((U+8)>>4);
				if (V<0)
					V = 0;
				else 
					V = ((V+8)>>4);

				// clipping
				pY[x] = (unsigned char)((Y>255) ? 255 : Y);
				pU[x] = (unsigned char)((U>255) ? 255 : U);
				pV[x] = (unsigned char)((V>255) ? 255 : V);
			}
		}
	} else {
		showErrMsg("Unsupported color space denoted in CImageUtility::cvtBGRtoYUV_10U_8U()\n");
		safeReleaseImage(&iplImageV, &iplImageV, &iplImageV);
		return false;
	}

	// resize
    if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
        iplPlaneU->width == iplImageU->width && iplPlaneU->height == iplImageU->height &&
        iplPlaneV->width == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:4:4
        copy(iplImageY, iplPlaneY);
        copy(iplImageU, iplPlaneU);
        copy(iplImageV, iplPlaneV);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height == iplImageV->height) {
        // 4:2:2
	    copy(iplImageY, iplPlaneY);
        interlaceX(iplImageU, iplPlaneU, true);
	    interlaceX(iplImageV, iplPlaneV, true);
    } else if (iplPlaneY->width == iplImageY->width && iplPlaneY->height == iplImageY->height &&
               iplPlaneU->width*2 == iplImageU->width && iplPlaneU->height*2 == iplImageU->height &&
               iplPlaneV->width*2 == iplImageV->width && iplPlaneV->height*2 == iplImageV->height) {
        // 4:2:0
	    copy(iplImageY, iplPlaneY);
	    resize(iplImageU, iplPlaneU, SR_INTER_LINEAR);//SR_INTER_CUBIC);
	    resize(iplImageV, iplPlaneV, SR_INTER_LINEAR);//SR_INTER_CUBIC);
    } else {
        showErrMsg("Only support 4:2:0, 4:2:2 and 4:4:4 format in CImageUtility::cvtYUVtoBGR_16U()!\n");
        safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);
        return false;
    }

    safeReleaseImage(&iplImageY, &iplImageU, &iplImageV);

	return true;
}

bool CImageUtility::cvtBGRtoGray_8U(IplImage *iplBGR, IplImage *iplGray, ColorSpaceName color_sp)
// Convert a BGR image to an one-channel gray scale image
// Arguments:
//      iplBGR -- [I] BGR image, must be 3-channel, 8U
//      iplGray -- [O] gray scale image, must be 1-channel, 8U
// by Luhong Liang, ICD-ASD, ASTRI
// July 7, 2014
// June, 2015: add support on BT.624 and Microsoft YUV color space
{
	// check input arguments
	if (iplGray == NULL || iplBGR == NULL || iplGray->nChannels != 1 || iplBGR->nChannels != 3 ||
		iplGray->depth != SR_DEPTH_8U || iplBGR->depth != SR_DEPTH_8U ||
        iplBGR->width != iplGray->width || iplBGR->height != iplGray->height) {
		showErrMsg("Invalid input image in CImageUtility::cvtBGRtoGray_8U()!\n");
		return false;
	}

	// allocate buffers
	if (color_sp == CHROMA_BT601) {		// BT 601 for SD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplGray->imageData + y * iplGray->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = (77R+ 150G+29B)/256
				// Cb = (-44R-87G+ 131B)/256+128
				// Cr = (131R-110G -21B)/256+128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
				int Y= (77 * R + 150 * G + 29 * B) >> 7;
                // clipping
				pY[x] = rndclp_9Uto8U(Y);
			}
		}
	} else 	if (color_sp == CHROMA_BT624) {		// BT 624 for SD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplGray->imageData + y * iplGray->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y =0.299 * R + 0.587 * G + 0.114 * B           Y = (19595 * R + 38470 * G + 7471 * B) >> 16
                // U = 0.877 * (B - Y)                                      U = ((-17185 * R - 33738 * G + 50923 * B) >> 16 ) + 128
				// V = 0.493 * (R - Y)                                      V = ( (22649 * R - 18966 * G - 3683 * B) >> 16 ) + 128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
                int Y = (19595 * R + 38470 * G + 7471 * B) >> 15;
				pY[x] = rndclp_9Uto8U(Y);
			}
		}
	} else if (color_sp == CHROMA_BT709) {		// BT 709 for HD
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplGray->imageData + y * iplGray->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = (55R+183G+18B)/256
				// Cb = (-30R-101G+131B)/256+128
				// Cr = (131R-119G-12B)/256+128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
				int Y= (55 * R + 183 * G + 18 * B) >> 7;
				pY[x] = rndclp_9Uto8U(Y);
			}
		}
	} else 	if (color_sp == CHROMA_YUVMS) {		// YUV (microsoft)
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplGray->imageData + y * iplGray->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = ( (  66 * R + 129 * G +  25 * B + 128) >> 8) +  16
                // U = ( ( -38 * R -  74 * G + 112 * B + 128) >> 8) + 128
                // V = ( ( 112 * R -  94 * G -  18 * B + 128) >> 8) + 128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
                int Y = ( (  66 * R + 129 * G +  25 * B + 128) >> 8) +  16;
				pY[x] = (unsigned char)clip_0_255(Y);
			}
		}
	} else if (color_sp == CHROMA_YCC) {		// MatLab rgb2gray, only modified Y channel but keep U V channel unchanged
		for (int y=0; y<iplBGR->height; y++) {
			unsigned char *pY = (unsigned char *)(iplGray->imageData + y * iplGray->widthStep);
			unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
			for (int x=0; x<iplBGR->width; x++) {
				// Y = (55R+183G+18B)/256
				// Cb = (-30R-101G+131B)/256+128
				// Cr = (131R-119G-12B)/256+128
				int xx = x * 3;
				int B = pBGR[xx];
				int G = pBGR[xx+1];
				int R = pBGR[xx+2];
				//int Y= (55 * R + 183 * G + 18 * B) >> 8;
				int Y = (int)((0.299f * R + 0.587f * G + 0.114f * B) + 0.5f);	//Coded by Kayton Cheung
				pY[x] = (unsigned char)Y;
			}
		}
	} else {
		showErrMsg("Unsupported color space in CImageUtility::cvtBGRtoGray_8U()\n");
		return false;
	}

    return true;
}

bool CImageUtility::cvtGraytoBGR_8U(IplImage *iplBGR, IplImage *iplGray)
// Expand the gray scale image to BGR format
// Arguments:
//      iplGray -- [I] gray scale image, must be 1-channel, 8U
//      iplBGR -- [O] BGR image, must be 3-channel, 8U
// by Luhong Liang, ICD-ASD, ASTRI
// July 7, 2014
{
	// check input arguments
	if (iplGray == NULL || iplBGR == NULL || iplGray->nChannels != 1 || iplBGR->nChannels != 3 ||
		iplGray->depth != SR_DEPTH_8U || iplBGR->depth != SR_DEPTH_8U ||
        iplBGR->width != iplGray->width || iplBGR->height != iplGray->height) {
		showErrMsg("Invalid input image in CImageUtility::cvtGraytoBGR_8U()!\n");
		return false;
	}

    for (int y=0; y<iplBGR->height; y++) {
        unsigned char *pY = (unsigned char *)(iplGray->imageData + y * iplGray->widthStep);
        unsigned char *pBGR = (unsigned char *)(iplBGR->imageData + y * iplBGR->widthStep);
        for (int x=0; x<iplBGR->width; x++) {
            int xx = x * 3;
            pBGR[xx] = pY[x];
            pBGR[xx+1] = pY[x];
            pBGR[xx+2] = pY[x];
		}
	}

    return true;
}

bool CImageUtility::cvtBGRtoHSV_32f(IplImage *iplBGR, IplImage *iplH, IplImage *iplS, IplImage *iplV)
// Convert BGR to HSV color space. This function use the algorithm in Matlab.
// Arguments: 
//		iplRGB -- [I] RGB image; must be 3-channel 32f image, ranging 0~255
//		iplH, iplS, iplV -- [O] H, S, V planes, ranging 0~1
// by Luhong Liang, ICD-ASD, ASTRI
// Feb 25, 2014
{
    if (iplBGR == NULL || iplH == NULL || iplS == NULL || iplV == NULL ||
        iplBGR->nChannels != 3 || iplH->nChannels != 1 || iplS->nChannels != 1 || iplV->nChannels != 1 ||
        iplBGR->depth != SR_DEPTH_32F || iplH->depth != SR_DEPTH_32F || iplS->depth != SR_DEPTH_32F || iplV->depth != SR_DEPTH_32F ||
        iplBGR->width != iplS->width || iplBGR->width != iplH->width || iplBGR->width != iplV->width ||
        iplBGR->height != iplS->height || iplBGR->height != iplH->height || iplBGR->height != iplV->height) {
        showErrMsg("Invalid input/output image size, depth or channel number in CImageUtility::cvtBGRtoHSV_32f()!\n");
        return false;
    }

    for (int y=0; y<iplBGR->height; y++) {
        float *pH = (float *)(iplH->imageData + y * iplH->widthStep);
        float *pS = (float *)(iplS->imageData + y * iplS->widthStep);
        float *pV = (float *)(iplV->imageData + y * iplV->widthStep);
        float *pBGR = (float *)(iplBGR->imageData + y * iplBGR->widthStep);
        for (int x=0; x<iplBGR->width; x++) {
            float r = pBGR[x*3+2] / 255;
            float g = pBGR[x*3+1] / 255;
            float b = pBGR[x*3] /  255;
            // transform
            float v, h, s;
            if (r >= g && r >= b) {
                // max = r
                v = r;
                s = v - (g > b ? b : g);        // s = (v - min(min(r,g),b));
                if (s > 0.0f) {                 // h(k) = (g(k) - b(k))./s(k);
                    h = (g - b) / s;
                } else {
                    h = g - b;
                }
            } else if (g >= r && g >= b) {
                // max = g
                v = g;
                s = v - (r > b ? b : r);        // s = (v - min(min(r,g),b));
                if (s > 0.0f) {
                    h = 2.0f + (b - r) / s;     // h(k) = 2 + (b(k) - r(k))./s(k);
                } else {
                    h = 2.0f + (b - r);
                }
            } else {
                // max = b
                v = b;
                s = v - (g > r ? r : g);        // s = (v - min(min(r,g),b));
                if (s > 0.0f) {
                    h = 4.0f + (r - g) / s;     // h(k) = 4 + (r(k) - g(k))./s(k);
                } else {
                    h = 4.0f + (r - g);
                }
            }
            h = h / 6.0f;
            h = h<0.0f ? h+1.0f : h;            // k = find(h < 0);  h(k) = h(k) + 1;
            if (s <= 0.0f) {
                h = 0.0f;
            }
            if (v > 0.0f) {
                s = s / v;                      // s(k) = (~z(k)).*s(k)./v(k);
            } else {
                s = 0.0f;
            }
            // write back
            pH[x] = h;
            pS[x] = s;
            pV[x] = v;
        }
    }

    return true;
}

bool CImageUtility::cvtHSVtoBGR_32f(IplImage *iplH, IplImage *iplS, IplImage *iplV, IplImage *iplBGR)
// Convert HSV to BGR color space. This function use the algorithm in Matlab.
// Arguments: 
//		iplH, iplS, iplV -- [I] H, S, V planes, ranging 0~1
//		iplRGB -- [O] RGB image; must be 3-channel 32f image, ranging 0~255
// by Luhong Liang, ICD-ASD, ASTRI
// Feb 25, 2014
{
    if (iplBGR == NULL || iplH == NULL || iplS == NULL || iplV == NULL ||
        iplBGR->nChannels != 3 || iplH->nChannels != 1 || iplS->nChannels != 1 || iplV->nChannels != 1 ||
        iplBGR->depth != SR_DEPTH_32F || iplH->depth != SR_DEPTH_32F || iplS->depth != SR_DEPTH_32F || iplV->depth != SR_DEPTH_32F ||
        iplBGR->width != iplS->width || iplBGR->width != iplH->width || iplBGR->width != iplV->width ||
        iplBGR->height != iplS->height || iplBGR->height != iplH->height || iplBGR->height != iplV->height) {
        showErrMsg("Invalid input/output image size, depth or channel number in CImageUtility::cvtHSVtoBGR_32f()!\n");
        return false;
    }

    for (int y=0; y<iplBGR->height; y++) {
        float *pH = (float *)(iplH->imageData + y * iplH->widthStep);
        float *pS = (float *)(iplS->imageData + y * iplS->widthStep);
        float *pV = (float *)(iplV->imageData + y * iplV->widthStep);
        float *pBGR = (float *)(iplBGR->imageData + y * iplBGR->widthStep);
        for (int x=0; x<iplBGR->width; x++) {
            float h = pH[x];
            float s = pS[x];
            float v = pV[x];
            // transform
            float r, g, b;
            h = 6.0f * h;
            int k = (int)h;                 // k = floor(h);
            float p = h - (float)k;
            float t = 1.0f - s;
            float n = 1.0f - s * p;
            p = 1 - (s * (1.0f-p));
            // k0 = (k==0 | k==6); k1 = (k==1); k2 = (k==2);
            // k3 = (k==3); k4 = (k==4); k5 = (k==5);
            if (k == 1) {
                r = n;                      // r = k0    + k1.*n + k2.*t + k3.*t + k4.*p + k5;
                g = 1.0f;                   // g = k0.*p + k1    + k2    + k3.*n + k4.*t + k5.*t;
                b = t;                      // b = k0.*t + k1.*t + k2.*p + k3    + k4    + k5.*n;
            } else if (k == 2) {
                r = t;                      // r = k0    + k1.*n + k2.*t + k3.*t + k4.*p + k5;
                g = 1.0f;                   // g = k0.*p + k1    + k2    + k3.*n + k4.*t + k5.*t;
                b = p;                      // b = k0.*t + k1.*t + k2.*p + k3    + k4    + k5.*n;
            } else if (k == 3) {
                r = t;                      // r = k0    + k1.*n + k2.*t + k3.*t + k4.*p + k5;
                g = n;                      // g = k0.*p + k1    + k2    + k3.*n + k4.*t + k5.*t;
                b = 1.0f;                   // b = k0.*t + k1.*t + k2.*p + k3    + k4    + k5.*n;
            } else if (k == 4) {
                r = p;                      // r = k0    + k1.*n + k2.*t + k3.*t + k4.*p + k5;
                g = t;                      // g = k0.*p + k1    + k2    + k3.*n + k4.*t + k5.*t;
                b = 1.0f;                   // b = k0.*t + k1.*t + k2.*p + k3    + k4    + k5.*n;
            } else if (k == 5) {
                r = 1.0f;                   // r = k0    + k1.*n + k2.*t + k3.*t + k4.*p + k5;
                g = t;                      // g = k0.*p + k1    + k2    + k3.*n + k4.*t + k5.*t;
                b = n;                      // b = k0.*t + k1.*t + k2.*p + k3    + k4    + k5.*n;
            } else {        //            if (k == 0 || k == 6) {
                r = 1.0f;                   // r = k0    + k1.*n + k2.*t + k3.*t + k4.*p + k5;
                g = p;                      // g = k0.*p + k1    + k2    + k3.*n + k4.*t + k5.*t;
                b = t;                      // b = k0.*t + k1.*t + k2.*p + k3    + k4    + k5.*n;
            }
            // RGB = bsxfun(@times, v./max(rout(:)), rout);
            r = r * v;
            g = g * v;
            b = b * v;
            // write back
            pBGR[x*3+2] = r * 255.0f;
            pBGR[x*3+1] = g * 255.0f;
            pBGR[x*3] = b * 255.0f;
        }
    }

    return true;
}

bool CImageUtility::swapRGB(IplImage *iplImage)
// convert the RGB format to BGR or vice versa
{
    if (iplImage == NULL || iplImage->nChannels != 3) {
        showErrMsg("Invalid input image in CImageUtility::swapRGB()!\n");
        return false;
    }

    if (iplImage->depth == SR_DEPTH_32F) {
        for (int y=0; y<iplImage->height; y++) {
            float *pImg = (float *)(iplImage->imageData + y * iplImage->widthStep);
            for (int x=0; x<iplImage->width*iplImage->nChannels; x+=iplImage->nChannels) {
                float tmp = pImg[x];
                pImg[x] = pImg[x+2];
                pImg[x+2] = tmp;
            }
        }
    } else if (iplImage->depth == SR_DEPTH_64F) {
        for (int y=0; y<iplImage->height; y++) {
            double *pImg = (double *)(iplImage->imageData + y * iplImage->widthStep);
            for (int x=0; x<iplImage->width*iplImage->nChannels; x+=iplImage->nChannels) {
                double tmp = pImg[x];
                pImg[x] = pImg[x+2];
                pImg[x+2] = tmp;
            }
        }
    } else if (iplImage->depth == SR_DEPTH_32S) {
        for (int y=0; y<iplImage->height; y++) {
            int *pImg = (int *)(iplImage->imageData + y * iplImage->widthStep);
            for (int x=0; x<iplImage->width*iplImage->nChannels; x+=iplImage->nChannels) {
                int tmp = pImg[x];
                pImg[x] = pImg[x+2];
                pImg[x+2] = tmp;
            }
        }
    } else if (iplImage->depth == SR_DEPTH_16S || iplImage->depth == SR_DEPTH_16U) {
        for (int y=0; y<iplImage->height; y++) {
            short int *pImg = (short int *)(iplImage->imageData + y * iplImage->widthStep);
            for (int x=0; x<iplImage->width*iplImage->nChannels; x+=iplImage->nChannels) {
                short int tmp = pImg[x];
                pImg[x] = pImg[x+2];
                pImg[x+2] = tmp;
            }
        }
    } else if (iplImage->depth == SR_DEPTH_8S || iplImage->depth == SR_DEPTH_8U) {
        for (int y=0; y<iplImage->height; y++) {
            unsigned char *pImg = (unsigned char *)(iplImage->imageData + y * iplImage->widthStep);
            for (int x=0; x<iplImage->width*iplImage->nChannels; x+=iplImage->nChannels) {
                unsigned char tmp = pImg[x];
                pImg[x] = pImg[x+2];
                pImg[x+2] = tmp;
            }
        }
    } else {
        showErrMsg("Unsupported image data type in CImageUtility::swapRGB()!\n");
        return false;
    }

    return true;
}

bool CImageUtility::scaling(IplImage *iplSrcY, IplImage *iplSrcU, IplImage *iplSrcV, IplImage *iplDstY, IplImage *iplDstU, IplImage *iplDstV)
// scaling a YUV planar image
// May 20, 2015: improve the chroma format conversion
{
	if (iplSrcY == NULL || iplSrcU == NULL || iplSrcV == NULL || iplDstY == NULL || iplDstU == NULL || iplDstV == NULL ||
		iplSrcY->nChannels != 1 || iplSrcU->nChannels != 1 || iplSrcV->nChannels != 1 || iplDstY->nChannels != 1 || iplDstU->nChannels != 1 || iplDstV->nChannels != 1 ||
		iplSrcY->depth != iplDstY->depth || iplSrcU->depth != iplDstU->depth || iplSrcV->depth != iplDstV->depth) {
		showErrMsg("Unsupported or invalid input image format in CImageUtility::scaling()!\n");
		return false;
	}

	// resize
    if (iplSrcY->width == iplDstY->width && iplSrcY->height == iplDstY->height &&
        iplSrcU->width == iplDstU->width && iplSrcU->height == iplDstU->height &&
        iplSrcV->width == iplDstV->width && iplSrcV->height == iplDstV->height) {
        // 4:4:4
        copy(iplSrcY, iplDstY);
        copy(iplSrcU, iplDstU);
        copy(iplSrcV, iplDstV);
    } else if (iplSrcY->width == iplDstY->width && iplSrcY->height == iplDstY->height &&
               iplSrcU->width*2 == iplDstU->width && iplSrcU->height == iplDstU->height &&
               iplSrcV->width*2 == iplDstV->width && iplSrcV->height == iplDstV->height) {
        // 4:2:2
	    copy(iplSrcY, iplDstY);
        cvt422to444_linear(iplSrcU, iplDstU);
	    cvt422to444_linear(iplSrcV, iplDstV);
    } else if (iplSrcY->width == iplDstY->width && iplSrcY->height == iplDstY->height &&
               iplSrcU->width*2 == iplDstU->width && iplSrcU->height*2 == iplDstU->height &&
               iplSrcV->width*2 == iplDstV->width && iplSrcV->height*2 == iplDstV->height) {
        // 4:2:0
	    copy(iplSrcY, iplDstY);
	    resize(iplSrcU, iplDstU, SR_INTER_LINEAR);//SR_INTER_CUBIC);
	    resize(iplSrcV, iplDstV, SR_INTER_LINEAR);//SR_INTER_CUBIC);
    } else {
        showErrMsg("Only support 4:2:0, 4:2:2 and 4:4:4 format in CImageUtility::cvtYUVtoBGR_32F()!\n");
        safeReleaseImage(&iplDstY, &iplDstU, &iplDstV);
        return false;
    }

	return true;
}

IplImage *CImageUtility::assembleGreyImage(unsigned char *pImage, int nWidth, int nHeight)
// Create an IPL image by copying the given raw data. Only support greyscale images.
// Luhong Liang, IC-ASD, ASTRI
// Nov. 25, 2011
{
	if (pImage == NULL || nWidth < 1 || nHeight < 1) {
		showErrMsg("Invalid input argument found in CImageUtility::assembleGreyImage()!\n");
		return NULL;
	}

	IplImage *iplImage = createImage( nWidth, nHeight, SR_DEPTH_8U, 1);
	if (iplImage == NULL) {
		showErrMsg("Fail to allocate image in CImageUtility::assembleGreyImage()!\n");
		return NULL;
	}

	// should copy the data considering the alignment problem
	for (int y=0; y<iplImage->height; y++) {
		unsigned char *pDst = (unsigned char *)(iplImage->imageData + y * iplImage->widthStep);
		memcpy(pDst, pImage + y * nWidth, nWidth);
	}

	return iplImage;
}

bool CImageUtility::saveImage(char stFilename[], IplImage *iplImage, short bias, float mag_factor, int bit_depth)
// Save image to file. 
//  For 8-bit image, directly call cvSaveImage();
//  For 16-bit image, a bias value will ADD to the pixel and saturation will be done before save the image
//  For 32-bit floating point image, suppose the data range is 0~255, a bias value can also
//						be added. NOTE: the bias is still ranging 0~255
//  For 32-bit signed interger image, the input image intensity is limited to N-bit.
//  Supposing the input image is 12-bit singed value I, the output value will be (I >> (bit_depth-8)) * mag_factor + bias.
// arguments:
//			stFilename -- [I] image file name
//			iplImage -- [I] a 8-bit, 16-bit or 32-bit floating point image
//			bias -- [I] Bias will added to pixels before save, used for 16-bit image
//			mag_factor -- [I] magnitude factor of the intensitiy, the final pixel value is (org_pixel_value * mag_factor) + bias
//			bit_depth -- [I] the bit depth of the input image, should be 8~32
// Luhong Liang, IC-ASD, ASTRI
// Sept. 7, 2011; Oct. 15, 2012; Aug. 30,2013 (color image for 16U and 32S images, more flexible 16U image save)
{
	if (iplImage == NULL || stFilename == NULL) {
		showErrMsg("Invalid input argument in CImageUtility::saveImage()!\n");
		return false;
	}

	// save as matlab data file
	char szFileExt[256];
	getFileExt(stFilename, szFileExt);
	if (strcmp(szFileExt, "dat") == 0 || strcmp(szFileExt, "DAT") == 0) {
		return writeImageMat(iplImage, stFilename);
	}

    // save DPX file
#ifdef _USE_MY_DPX_DECODER
    if (strcmp(strlwr(szFileExt), "dpx") == 0) {
        return g_dpxFile.saveDPXImage(stFilename, iplImage, bit_depth);
    }
#endif      // #ifdef _USE_MY_DPX_DECODER

	// save as image file
	if (iplImage->depth == SR_DEPTH_8U) {
		IplImage *iplImage8U = cvtImage8Uto8U(iplImage, bias, mag_factor);
		if (iplImage8U == NULL) return false;
		saveImage8U(stFilename, iplImage8U);
		safeReleaseImage(&iplImage8U);
		return true;
	} else if (iplImage->depth == SR_DEPTH_16U) {
		return saveImage16U(stFilename, iplImage, bias, mag_factor, bit_depth);
	} else if (iplImage->depth == SR_DEPTH_32F) {
		IplImage *iplImage8U = cvtImage32Fto8U(iplImage, bias, mag_factor);
		if (iplImage8U == NULL)
			return false;
		saveImage8U(stFilename, iplImage8U);
		releaseImage(&iplImage8U);
		return true;
	} else if (iplImage->depth == SR_DEPTH_32S) {
		IplImage *iplImage8U = cvtImageIntto8U(iplImage, bit_depth, bias, mag_factor);
		if (iplImage8U == NULL) return false;
		saveImage8U(stFilename, iplImage8U);
		releaseImage(&iplImage8U);
		return true;
	} else {
		showErrMsg("Unsupported image data type in saveImage()!\n");
		return false;
	}
}

#ifdef __OPENCV_OLD_CV_H__
bool CImageUtility::saveImage(char stFilename[], IplImage *iplImage, CvRect rect, short bias)
// Save a region of image to file. 
//  For 8-bit image, directly call cvSaveImage();
//  For 16-bit image, a bias value will ADD to the pixel and saturation will be done before save the image
//  For 32-bit floating point image, suppose the data range is 0~255, a bias value can also
//						be added. NOTE: the bias is still ranging 0~255
// arguments:
//			stFilename -- [I] image file name
//			iplImage -- [I] a 8-bit, 16-bit or 32-bit floating point image
//			rect -- [I] rectangle of the region to save
//			bias -- [I] Bias will added to pixels before save, used for 16-bit image
// Luhong Liang, IC-ASD, ASTRI
// Jan. 17, 2012
{
	if (iplImage == NULL || stFilename == NULL) {
		showErrMsg("Invalid input argument in saveImage()!\n");
		return false;
	}

	// save as matlab data file
	char FileExt[256];
	getFileExt(stFilename, FileExt);
	if (strcmp(FileExt, "dat") == 0 || strcmp(FileExt, "DAT") == 0) {
		return writeImageMat(iplImage, stFilename);
	}

	// save as image file
	if (iplImage->depth == SR_DEPTH_8U) {
		CvRect rect_old = cvGetImageROI(iplImage);
		cvSetImageROI(iplImage, rect );
		IplImage *iplROI = createImage(rect.width, rect.height, SR_DEPTH_8U, 1);
		if (iplROI == NULL)
			return false;
		cvCopyImage(iplImage, iplROI);
		cvSetImageROI(iplImage, rect_old);
		saveImage8U(stFilename, iplROI);
		releaseImage(&iplROI);
		return true;
	} else if (iplImage->depth == SR_DEPTH_16U && iplImage->nChannels == 1) {
		//return saveImage16U(stFilename, iplImage, bias);
		showErrMsg("Unsupported image data type in saveImage()!\n");
		return false;
	} else if (iplImage->depth == SR_DEPTH_32F) {
		IplImage *iplImage8U = cvtImage32Fto8U(iplImage, bias);
		if (iplImage8U == NULL)
			return false;
		cvSetImageROI(iplImage8U, rect );
		rect = cvGetImageROI(iplImage8U);
		IplImage *iplROI = createImage(rect.width, rect.height, SR_DEPTH_8U, 1);
		if (iplROI == NULL) {
			releaseImage(&iplImage8U);
			return false;
		}
		cvCopyImage(iplImage8U, iplROI);
		saveImage8U(stFilename, iplROI);
		releaseImage(&iplImage8U);
		releaseImage(&iplROI);
		return true;
	} else {
		showErrMsg("Unsupported image data type in saveImage()!\n");
		return false;
	}
}
#endif		// #ifdef __OPENCV_OLD_CV_H__

bool CImageUtility::saveImage8U(char stFilename[], IplImage *iplImage, int quality)
// Save an 8U image to file. This is a wrapper of cvSaveImage() with a quality control for JPEG format
// arguments:
//			stFilename -- [I] image file name
//			iplImage -- [I] a 8-bit, 16-bit or 32-bit floating point image
//			quality-- [I] quality of the JPGE image, default = 97
// Luhong Liang, IC-ASD, ASTRI
// Jan. 17, 2012
{
	static char ppSupportedImageExt[][16] = { "bmp", "dib", "jpg", "jpeg", "jpe", "jp2", "png", "pbm", 
											  "pgm", "ppm", "sr", "ras", "tiff", "tif", "dat"};	
	static int nVideoExtListLen = 15;

	if (iplImage == NULL || stFilename == NULL || iplImage->depth != SR_DEPTH_8U || quality < 0 || quality > 100) {
		showErrMsg("Invalid input argument in CImageUtility::saveImage8U()!\n");
		return false;
	}
	
	// check file extension supported
	char stFileExt[256];
	getFileExt(stFilename, stFileExt);
	bool bFind = false;
	for (int i=0; i<nVideoExtListLen; i++) {
		if (strcmp(strlwr(stFileExt), ppSupportedImageExt[i]) == 0) {
			bFind = true;
			break;
		}
	}
	if (!bFind) {
		showErrMsg("Unsupported image file with extension \"%s\" in CImageUtility::saveImage8U()!\n", stFileExt);
		return false;
	}

	if (strcmp(strlwr(stFileExt), "dat") == 0) {
		// save as matlab data file
		return writeImageMat(iplImage, stFilename);
	} else {
#ifdef __OPENCV_OLD_CV_H__
		// save as image file (OpenCV)
		if (strcmp(strlwr(stFileExt), "jpg") == 0 || strcmp(strlwr(stFileExt), "jpeg") == 0) {
			int p[3];
			p[0] = CV_IMWRITE_JPEG_QUALITY;
			p[1] = quality;
			p[2] = 0;
			cvSaveImage(stFilename, iplImage, p);
			return true;
		} else {
			cvSaveImage(stFilename, iplImage);
			return true;
		}
#else		//#ifdef __OPENCV_OLD_CV_H__
		if (strcmp(strlwr(stFileExt), "bmp") == 0) {
			saveToBMP(stFilename, iplImage);
			return true;
		} else {
			showErrMsg("Only support BMP file without OpenCV in CImageUtility::saveImage8U()!\n");
			return false;
		}
#endif		//#ifdef __OPENCV_OLD_CV_H__
	}
}

IplImage *CImageUtility::loadImage(char stFilename[], int &bit_depth)
// General image loading function
// Support all formats supported by OpenCV and DPX format (with plug-in decoder)
// arguments:
//	    stFilename -- [I] image file name
//      bit_depht -- [O] bit depth of the image
// Luhong Liang, IC-ASD, ASTRI
// June. 3, 2013
{
#ifdef _USE_MY_DPX_DECODER
    static char ppSupportedImageExt[][16] = { "bmp", "dib", "jpg", "jpeg", "jpe", "jp2", "png", "pbm", 
											  "pgm", "ppm", "sr", "ras", "tiff", "tif", "dat", "dpx"};	
	static int nVideoExtListLen = 16;
#else      // #ifdef _USE_MY_DPX_DECODER
    static char ppSupportedImageExt[][16] = { "bmp", "dib", "jpg", "jpeg", "jpe", "jp2", "png", "pbm", 
											  "pgm", "ppm", "sr", "ras", "tiff", "tif", "dat"};	
	static int nVideoExtListLen = 15;
#endif      // #ifdef _USE_MY_DPX_DECODER

	if (stFilename == NULL || stFilename[0] == 0) {
		showErrMsg("Invalid input file name in CImageUtility::loadImage()!\n");
		return false;
	}
	
	// check file extension supported
	char stFileExt[256];
	getFileExt(stFilename, stFileExt);
	bool bFind = false;
	for (int i=0; i<nVideoExtListLen; i++) {
		if (strcmp(strlwr(stFileExt), ppSupportedImageExt[i]) == 0) {
			bFind = true;
			break;
		}
	}
	if (!bFind) {
        showErrMsg("Unsupported image file with extension \"%s\" in CImageUtility::loadImage()!\n", stFileExt);
		return false;
	}

	if (strcmp(strlwr(stFileExt), "dat") == 0) {
		// load a matlab data file
		return readImageMat(stFilename, bit_depth);
	} else {
        bit_depth = 8;
        // dpx file format
#ifdef _USE_MY_DPX_DECODER
        if (strcmp(strlwr(stFileExt), "dpx") == 0) {
            IplImage *iplImage = g_dpxFile.loadDPXImage(stFilename);
            bit_depth = g_dpxFile.getBitDepth();
            return iplImage;
        }
#endif      // #ifdef _USE_MY_DPX_DECODER

        // other formats
#ifdef __OPENCV_OLD_CV_H__
		IplImage *iplTempImage = cvLoadImage(stFilename, CV_LOAD_IMAGE_UNCHANGED);
#ifdef __SR_USE_SIMD
        IplImage *iplAlgined = clone(iplTempImage);
        cvReleaseImage(&iplTempImage);
        return iplAlgined;
#else
        return iplTempImage;
#endif //#ifdef __SR_USE_SIMD
#else		//#ifdef __OPENCV_OLD_CV_H__
		if (strcmp(strlwr(stFileExt), "bmp") == 0) {
			return loadFromBMP(stFilename);
		} else {
			showErrMsg("Only support BMP file without OpenCV in CImageUtility::loadImage()!\n");
			return NULL;
		}
#endif		//#ifdef __OPENCV_OLD_CV_H__
	}
}

bool CImageUtility::saveImage16U(char stFilename[], IplImage *iplImage16U, short bias, float mag_factor, int bit_depth)
// Save a 16-bit image as 8-bit one. A bias value will ADD to the pixel and saturation will be done before save the image
// An alternative to cvSaveImage() for saving 16U image
// arguments:
//			stFilename -- [I] image file name
//			iplImage16U -- [I] a 16-bit image
//			bias -- [I] Bias will added to pixels before save, used for 16-bit image
//			mag_factor -- [I] magnitude factor of the intensitiy, the final pixel value is Truncation(org_pixel_value * mag_factor * bit_depth_factor) + bias,
//                            where bit_depth_factor = 256 / (2^bit_depth)
//			bit_depth -- [I] the bit depth of the input image, should be 8~32
// Luhong Liang, IC-ASD, ASTRI
// Setp. 7, 2011; Aug. 30, 2013
{
	// check input parameters
	if (iplImage16U == NULL ||  stFilename == NULL) {
		showErrMsg("Invalid input parameter in saveImage16U()!\n");
		return false;
	}
	
	// check datatype
	//if (sizeof(unsigned short) != 2) {
	//	showErrMsg("ERROR: Can not run this program on OS that 'short' data type is not 16-bit!\n");
	//	return NULL;
	//}

	// allocate temp image
	int width = iplImage16U->width;
	int height = iplImage16U->height;
    IplImage *ipl8U = createImage( width, height, SR_DEPTH_8U, iplImage16U->nChannels);
	if (ipl8U == NULL) {
		showErrMsg("Fail to allocate intermediate images in save16UImage()!\n");
		return false;
	}

	// convert image to 8-bit
    float bit_depth_factor = 256.0f / (1<<bit_depth);
    float factor = mag_factor * bit_depth_factor;
	for (int y=0; y<height; y++) {	// have to write a customized substraction fuction, since different data types in I/O
		unsigned char *p8UImage = (unsigned char *)(ipl8U->imageData) + y * ipl8U->widthStep;
		unsigned short *p16UImage = (unsigned short *)((char *)iplImage16U->imageData + y * iplImage16U->widthStep);		// NOTE: widthStep is counted in bytes!
		for (int x=0; x<width*iplImage16U->nChannels; x++) {
			int src = p16UImage[x];
			int dst = (int)(src * factor) + bias;
			// saturation
			dst = dst < 0 ? 0 : dst;			// TODO: use LUT for faster saturation here!
			dst = dst > IMAGE_DYNAMIC_RANGE_8U ? IMAGE_DYNAMIC_RANGE_8U : dst;
			p8UImage[x] = (unsigned char)dst;
		}
	}

	// save result image
	saveImage(stFilename, ipl8U);	

	releaseImage(&ipl8U);

	return true;
}

IplImage *CImageUtility::loadFromBMP(char stFilename[])
{
	if (stFilename == NULL || stFilename[0] == 0) {
		showErrMsg("Invalid image file name in CImageUtility::loadFromBMP()!\n");
		return NULL;
	}

	unsigned short type;
   	BMPFileHeader headOfFile;     // type defined in windows: Bitmap file header
	BMPInfoHeader headOfInfo;     // Bitmap information header

	FILE *fp = fopen(stFilename, "rb");
	if (fp == NULL) {
		showErrMsg("Fail to open image file in CImageUtility::loadFromBMP()!\n");
		return NULL;
	}

	// load the header of BMP file
	if (fread(&type, sizeof(short), 1, fp) != 1) {
		showErrMsg("Fail to load BMP image header in CImageUtility::loadFromBMP()!\n");
		fclose(fp);
		return NULL;
	}

	if (fread(&headOfFile, sizeof(BMPFileHeader), 1, fp) != 1) {
		showErrMsg("Fail to load BMP image header in CImageUtility::loadFromBMP()!\n");
		fclose(fp);
		return NULL;
	}
	
	// read the BMP information
	if (fread(&headOfInfo, sizeof(BMPInfoHeader), 1, fp) != 1) {
		showErrMsg("Fail to load BMP file information in CImageUtility::loadFromBMP()!\n");
		fclose(fp);
		return NULL;
	}

	if (headOfInfo.biBitCount == 8) {
		// allocate memory for Image and Palette
		RGBQuad *rgbQuad = new RGBQuad[256];    // (RGBQuad *)malloc( 256 * sizeof(RGBQuad) );
		if (rgbQuad == NULL) {
			showErrMsg("Fail to allocate buffer for palette in CImageUtility::loadFromBMP()!\n");
			fclose(fp);
			return NULL;
		}
		// read the palette (discard)
		if (fread(rgbQuad, sizeof(rgbQuad), 256, fp) != 256) {
			showErrMsg("Fail to load palette in CImageUtility::loadFromBMP()!\n");
			fclose(fp);
			return NULL;
		}
		delete [] rgbQuad;

		// create image
		IplImage *iplImage = createImage(headOfInfo.biWidth, headOfInfo.biHeight, SR_DEPTH_8U, 1);
		if (iplImage == NULL) {
			showErrMsg("Fail to create image in memory in CImageUtility::loadFromBMP()!\n");
			fclose(fp);
			return NULL;
		}

		// read BMP raw data
		fseek(fp, headOfFile.bfOffBits, SEEK_SET);
		for (unsigned long i=0; i<headOfInfo.biHeight; i++) {
			char *pImg = iplImage->imageData + (headOfInfo.biHeight-i-1) * iplImage->widthStep;
			if (fread(pImg, sizeof(char), iplImage->widthStep, fp) != (size_t)iplImage->widthStep) {
				safeReleaseImage(&iplImage);
				showErrMsg("Fail to read image data in CImageUtility::loadFromBMP()!\n");
				fclose(fp);
				return NULL;
			}
		}

		fclose(fp);

		return iplImage;
	} else if (headOfInfo.biBitCount == 24) {		// true color image
		// create image
		IplImage *iplImage = createImage(headOfInfo.biWidth, headOfInfo.biHeight, SR_DEPTH_8U, 3);
		if (iplImage == NULL) {
			showErrMsg("Fail to create image in memory in CImageUtility::loadFromBMP()!\n");
			fclose(fp);
			return NULL;
		}

		// read BMP raw data
		fseek(fp, headOfFile.bfOffBits, SEEK_SET);
		for (unsigned long i=0; i<headOfInfo.biHeight; i++) {
			char *pImg = iplImage->imageData + (headOfInfo.biHeight-i-1) * iplImage->widthStep;
			if (fread(pImg, sizeof(char), iplImage->widthStep, fp) != (size_t)iplImage->widthStep) {
				safeReleaseImage(&iplImage);
				showErrMsg("Fail to read image data in CImageUtility::loadFromBMP()!\n");
				fclose(fp);
				return NULL;
			}
		}

		fclose(fp);

		return iplImage;
	} else if (headOfInfo.biBitCount == 32) {		// true color image with alpha plane (discard the alpha plane)
		// create image
		IplImage *iplImage = createImage(headOfInfo.biWidth, headOfInfo.biHeight, SR_DEPTH_8U, 3);
        unsigned char *pImg = new unsigned char[iplImage->width*4*iplImage->height];
		if (iplImage == NULL || pImg == NULL) {
			showErrMsg("Fail to create image in memory in CImageUtility::loadFromBMP()!\n");
            safeReleaseImage(&iplImage);
            if (pImg != NULL) delete [] pImg;
			fclose(fp);
			return NULL;
		}
        
		// read BMP raw data
		fseek(fp, headOfFile.bfOffBits, SEEK_SET);
		for (unsigned long i=0; i<headOfInfo.biHeight; i++) {
			unsigned char *pImgBuf = pImg + (headOfInfo.biHeight-i-1) * headOfInfo.biWidth * 4;
			if (fread(pImgBuf, sizeof(unsigned char), headOfInfo.biWidth*4, fp) != (size_t)headOfInfo.biWidth*4) {
				showErrMsg("Fail to read image data in CImageUtility::loadFromBMP()!\n", stFilename);
                delete pImg;
				safeReleaseImage(&iplImage);
				fclose(fp);
				return false;
			}
		}

        // convert to BGR image
        for (long y=0; y<iplImage->height; y++) {
			unsigned char *pSrcBuf = pImg + y * headOfInfo.biWidth * 4;
            unsigned char *pDstBuf = (unsigned char *)(iplImage->imageData + y * iplImage->widthStep);
            for (long x=0, xx=0; x<iplImage->width*4; x+=4, xx+=3) {
                pDstBuf[xx] = pSrcBuf[x];
                pDstBuf[xx+1] = pSrcBuf[x+1];
                pDstBuf[xx+2] = pSrcBuf[x+2];
            }
        }

        delete [] pImg;
		fclose(fp);

		return iplImage;
	} else {
		showErrMsg("Only support 8-bit and 24-bit BMP file in CImageUtility::loadFromBMP()!\n");
		fclose(fp);
		return NULL;		
	}
}

bool CImageUtility::saveToBMP(char stFilename[], IplImage *iplImage)
// Aug 2015: Fixed a misalignment problem in SIMD implementation by Luhong
{
	if (stFilename == NULL || iplImage == NULL) {
		showErrMsg("Invalid input parameter in CImageUtility::saveToBMP()!\n");
		return false;
	}

	FILE *fp = fopen(stFilename, "wb");
	if (fp == NULL) {
		showErrMsg("Fail to create image file in CImageUtility::saveToBMP()!\n");
		return false;
	}

	// set BMP header
   	BMPFileHeader headOfFile;     // type defined in windows: Bitmap file header
	const long bi_rgb = 0L;
	unsigned short type = 0x4d42;
	headOfFile.bfReserved1 = 0;      
	headOfFile.bfReserved2 = 0;
	if (iplImage->nChannels == 1) {
		headOfFile.bfOffBits = sizeof(BMPFileHeader) + sizeof(BMPInfoHeader) + 256 * sizeof(RGBQuad) + sizeof(type);
	} else if (iplImage->nChannels == 3) {
		headOfFile.bfOffBits = sizeof(BMPFileHeader) + sizeof(BMPInfoHeader) + sizeof(type);
	} else {
		showErrMsg("Invalid input image format in CImageUtility::saveToBMP()!\n");
		fclose(fp);
		return false;
	}
	headOfFile.bfSize = headOfFile.bfOffBits +  iplImage->widthStep * iplImage->height;

	// set BMP information
	BMPInfoHeader headOfInfo;     // Bitmap information header
	//SetBmpInfo(dwBand, dwWidth, dwHeight, &, rgbQuad);
	//LPBITMAPINFOHEADER lpbih, LPRGBQUAD lprgbQuad)
  	headOfInfo.biSize = sizeof(BMPInfoHeader);
	headOfInfo.biWidth = iplImage->width; 
	headOfInfo.biHeight = iplImage->height;
    headOfInfo.biPlanes = 1;
	headOfInfo.biCompression = bi_rgb;
	headOfInfo.biSizeImage = iplImage->height * iplImage->widthStep;
	headOfInfo.biXPelsPerMeter = 0;
	headOfInfo.biYPelsPerMeter = 0;
	headOfInfo.biClrUsed = 0;
	headOfInfo.biClrImportant = 0;  
	int i;
	if (iplImage->nChannels == 1) {
       headOfInfo.biBitCount = 8; 
	   // fill the palette
		RGBQuad rgbQuad[256];
		for(i = 0; i < 256; i ++) {
			rgbQuad[i].rgbBlue = (unsigned char)i;
			rgbQuad[i].rgbGreen = (unsigned char)i;
			rgbQuad[i].rgbRed = (unsigned char)i;
			rgbQuad[i].rgbReserved = 0;
		}
		// write header
		if (fwrite(&type, sizeof(type), 1, fp) != 1) {
			showErrMsg("Fail to write BMP header in CImageUtility::saveToBMP()!\n");
			fclose(fp);
			return false;
		}
		if (fwrite(&headOfFile, sizeof(BMPFileHeader), 1, fp) != 1) {
			showErrMsg("Fail to write BMP header in CImageUtility::saveToBMP()!\n");
			fclose(fp);
			return false;
		}
		if (fwrite(&headOfInfo, sizeof(BMPInfoHeader), 1, fp) != 1) {
			showErrMsg("Fail to write BMP information in CImageUtility::saveToBMP()!\n");
			fclose(fp);
			return false;
		}
		if (fwrite(rgbQuad, sizeof(RGBQuad), 256, fp) != 256) {
			showErrMsg("Fail to write palette in CImageUtility::saveToBMP()!\n");
			fclose(fp);
			return false;
		}
		// write raw data
        int line_size = ((iplImage->width + 3) / 4) * 4;        // to fix misalignment problem in SIMD implementation
		for (i=iplImage->height-1; i>=0; i--) {
			char *pImg = iplImage->imageData + iplImage->widthStep * i;
			if (fwrite(pImg, sizeof(char), line_size, fp) != (size_t)line_size) {
				showErrMsg("Fail to write image raw data in CImageUtility::saveToBMP()!\n");
				fclose(fp);
				return false;
			}
		}

		fclose(fp);
		return true;
	} else if (iplImage->nChannels == 3) {
       headOfInfo.biBitCount = 24; 
		// write header
		if (fwrite(&type, sizeof(type), 1, fp) != 1) {
			showErrMsg("Fail to write BMP header in CImageUtility::saveToBMP()!\n");
			fclose(fp);
			return false;
		}
		if (fwrite(&headOfFile, sizeof(BMPFileHeader), 1, fp) != 1) {
			showErrMsg("Fail to write BMP header in CImageUtility::saveToBMP()!\n");
			fclose(fp);
			return false;
		}
		if (fwrite(&headOfInfo, sizeof(BMPInfoHeader), 1, fp) != 1) {
			showErrMsg("Fail to write BMP information in CImageUtility::saveToBMP()!\n");
			fclose(fp);
			return false;
		}
		// write raw data
        int line_size = ((iplImage->width*3 + 3) / 4) * 4;        // to fix misalignment problem in SIMD implementation
		for (i=iplImage->height-1; i>=0; i--) {
			char *pImg = iplImage->imageData + iplImage->widthStep * i;
			if (fwrite(pImg, sizeof(char), line_size, fp) != (size_t)line_size) {
				showErrMsg("Fail to write image raw data in CImageUtility::saveToBMP()!\n");
				fclose(fp);
				return false;
			}
		}

		fclose(fp);
		return true;
	} else {
		showErrMsg("Only support 8-bit and 24-bit BMP file in CImageUtility::saveToBMP()!\n");
		fclose(fp);
		return false;		
	}
}

bool CImageUtility::saveImagePatch(char stFilename[], IplImage *iplImage, int left, int top, int width, int height, int scaling = 8)
// Save an image region to file. 
//  For 8-bit image, directly call cvSaveImage();
//  For 32-bit floating point image, suppose the data range is 0~255
//  Has not supported other data type
// arguments:
//			stFilename -- [I] image file name
//			iplImage -- [I] a 8-bit or 32-bit floating point image
//			left, top, width, height -- describes the region
//			scaling -- enlarge scaling before saving
// Luhong Liang, IC-ASD, ASTRI
// Setp. 26, 2011
// Major Modifications: 
//		Change data range of floating point pixel to 0~255, Nov. 15, 2011
{
	if (iplImage == NULL || stFilename == NULL || stFilename[0] == 0) {
		showErrMsg("Invalid input argument in saveImagePatch()!\n");
		return false;
	}

	width = width + left > iplImage->width ? iplImage->width - left : width;
	height = height + top > iplImage->height ? iplImage->height - top : height;
	if (width < 1 || height < 1) {
		showErrMsg("Invalid input region in saveImagePatch()!\n");
		return false;
	}

	// allocate image region
	IplImage *iplRegion = createImage(width*scaling, height*scaling, SR_DEPTH_8U, 1);
	if (iplRegion == NULL) {
		showErrMsg("Error: Fail to allocate buffer in saveImagePatch()!\n");
		return false;
	}

	// build region image
	if (iplImage->depth == SR_DEPTH_8U) {
		for (int y=0; y<iplRegion->height; y++) {
			unsigned char *pSrc = (unsigned char *)iplImage->imageData + ((y / scaling) + top) * iplImage->widthStep + left * iplImage->nChannels;
			unsigned char *pDst = (unsigned char *)iplRegion->imageData + y * iplRegion->widthStep;
			for (int x = 0; x<iplRegion->width; x++) {
				pDst[x] = pSrc[x/scaling];
			}
		}
	} else if (iplImage->depth == SR_DEPTH_32F) {
		for (int y=0; y<iplRegion->height; y++) {
			float *pSrc = (float *)((unsigned char *)iplImage->imageData + ((y / scaling) + top) * iplImage->widthStep) + left * iplImage->nChannels;
			unsigned char *pDst = (unsigned char *)iplRegion->imageData + y * iplRegion->widthStep;
			for (int x = 0; x<iplRegion->width; x++) {
				float temp = pSrc[x/scaling];		// * 255;
                pDst[x] = (unsigned char)clip_0_255(temp);
			}
		}
	} else {
		showErrMsg("Unsupport image data type in saveImagePatch()!\n");
		releaseImage(&iplRegion);
		return false;
	}

	// Save region image
	saveImage8U(stFilename, iplRegion);

	releaseImage(&iplRegion);

	return true;
}

bool CImageUtility::saveImagePatch_32f(char stFilename[], float *pData, int width, int height, int scaling)
// Save an image region to file. 
//  For 8-bit image, directly call cvSaveImage();
//  For 32-bit floating point image, suppose the data range is 0~255
//  Has not supported other data type
// arguments:
//			stFilename -- [I] image file name
//			pData -- [I] a 8-bit or 32-bit floating point image raw data
//			width, height -- describes the region
//			scaling -- enlarge scaling before saving
// Luhong Liang, IC-ASD, ASTRI
// Setp. 26, 2011
// Major Modifications: 
//		Change data range of floating point pixel to 0~255, Nov. 15, 2011
{
	if (pData == NULL || stFilename == NULL || width < 1 || height < 1) {
		showErrMsg("Invalid input argument in saveImagePatch()!\n");
		return false;
	}

	// allocate image region
	IplImage *iplRegion = createImage(width*scaling, height*scaling, SR_DEPTH_8U, 1);
	if (iplRegion == NULL) {
		showErrMsg("Error: Fail to allocate buffer in saveImagePatch()!\n");
		return false;
	}

	// build region image
	for (int y=0; y<iplRegion->height; y++) {
		float *pSrc = pData + (y / scaling) * width;
		unsigned char *pDst = (unsigned char *)iplRegion->imageData + y * iplRegion->widthStep;
		for (int x = 0; x<iplRegion->width; x++) {
			float temp = pSrc[x/scaling];		// * 255;
            pDst[x] = (unsigned char)clip_0_255(temp);
		}
	}

	// Save region image
	saveImage8U(stFilename, iplRegion);

	releaseImage(&iplRegion);

	return true;
}

bool CImageUtility::cvtImage8Uto32F(IplImage *iplImage8U, IplImage *iplImage32F)
// Convert a 8U image (0~255) to a 32F image (0~255)
// arguments:
//		iplImage8U -- [I] input image, must be 8U data type
//		iplImage32F -- [O] output image, must be 32F data type
// Return:
//		converted image, NULL for failure
// Major Modifications: 
//		Change data range of floating point pixel to 0~255, Nov. 15, 2011
{
	// check input image
	if (iplImage8U == NULL || iplImage8U->depth != SR_DEPTH_8U || 
		iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F ||
		iplImage8U->width != iplImage32F->width || iplImage8U->height != iplImage32F->height || 
		iplImage8U->nChannels != iplImage32F->nChannels) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage8Uto32F!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    return cvtImage8Uto32F_SIMD(iplImage8U, iplImage32F);
#endif      // #ifdef __SR_USE_SIMD

	// convert
	for (int y=0; y<iplImage32F->height; y++) {	
		unsigned char *pSrc = (unsigned char *)(iplImage8U->imageData) + y * iplImage8U->widthStep;
		float *pDst = (float *)((char*)iplImage32F->imageData + y * iplImage32F->widthStep);		// NOTE: widthStep is counted in bytes!
		for (int x=0; x<iplImage32F->width * iplImage32F->nChannels; x++) {
			pDst[x] = (float)pSrc[x];		// / 255.0f;
		}
	}

	return true;
}

bool CImageUtility::cvtImage8Uto32F(unsigned char *pImage8U, IplImage *iplImage32F)
// Convert a 8U image (0~255) to a 32F image (0~255)
// arguments:
//		pImage8U -- [I] buffer of input image, must be word-aligned (32-bit) and with appropriate size
//		iplImage32F -- [O] output image, must be 32F data type
// Return:
//		converted image, NULL for failure
{
	// check input image
	if (pImage8U == NULL ||	iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage8Uto32F!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    return cvtImage8Uto32F_SIMD(pImage8U, iplImage32F);
#endif      //#ifdef __SR_USE_SIMD

	// convert
    int widthStep = ((iplImage32F->width * iplImage32F->nChannels + 3) / 4) * 4;     // 32-bit aligned
	for (int y=0; y<iplImage32F->height; y++) {	
		float *pDst = (float *)((char*)iplImage32F->imageData + y * iplImage32F->widthStep);		// NOTE: widthStep is counted in bytes!
		for (int x=0; x<iplImage32F->width * iplImage32F->nChannels; x++) {
			pDst[x] = (float)pImage8U[x];		// / 255.0f;
		}
        pImage8U += widthStep;
	}

	return true;
}

bool CImageUtility::cvtImage8UtoInt(IplImage *iplImage8U, IplImage *iplImage32S, int bit_depth, int cvt_method)
// Convert a 8U image (0~255) to a 32S image with significant data of N bits. For example, 
// given a pixel value in iplImage8U I, the pixel value in the 12-bit iplImage32S is I<<4.
// arguments:
//		iplImage8U -- [I] input image, must be 8U data type
//		iplImage32S -- [O] output image, must be 32S data type
//		bit_depth -- [I] bit depth of the output image, should be 8~31
//      exp_method -- [I] method to expend the bit-depth when bit_depth > 8
//                          0 -- add zero bits
//                          1 -- add random bits
// Return:
//		converted image, NULL for failure
// Luhong Liang, ICD-ASD, ASTRI
// Dec. 19, 2012
// Aug. 1, 2013
{
	// check input image
	if (iplImage8U == NULL || iplImage8U->depth != SR_DEPTH_8U || 
		iplImage32S == NULL || iplImage32S->depth != SR_DEPTH_32S ||
		iplImage8U->width != iplImage32S->width || iplImage8U->height != iplImage32S->height || 
		iplImage8U->nChannels != iplImage32S->nChannels) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage8UtoInt!\n");
		return false;
	}
	if (bit_depth > 31 || bit_depth < 8) {
		showErrMsg("Only support bit depth between 8 and 31 in CImageUtility::cvtImage8UtoInt!\n");
		return false;
	}

	// convert
	int shift_bit = bit_depth - 8;
    if (shift_bit > 0 && (cvt_method & SR_DEPTHCVT_RANDOM) != 0) {      // add random noise
        const int seed_val = 31;
        int mask = ~(0xFFFFFFFF << shift_bit );
        srand (seed_val);
	    for (int y=0; y<iplImage32S->height; y++) {	
		    unsigned char *pSrc = (unsigned char *)(iplImage8U->imageData) + y * iplImage8U->widthStep;
		    int *pDst = (int *)((char*)iplImage32S->imageData + y * iplImage32S->widthStep);		// NOTE: widthStep is counted in bytes!
		    for (int x=0; x<iplImage32S->width * iplImage32S->nChannels; x++) {
			    int value = pSrc[x];
                unsigned int lsb = (unsigned int)rand() & mask;
                value = (value << shift_bit) + lsb;
			    pDst[x] = value;
		    }
	    }
    } else if ((cvt_method & SR_DEPTHCVT_ZEROS) != 0) {                  // add zero bits
	    for (int y=0; y<iplImage32S->height; y++) {	
		    unsigned char *pSrc = (unsigned char *)(iplImage8U->imageData) + y * iplImage8U->widthStep;
		    int *pDst = (int *)((char*)iplImage32S->imageData + y * iplImage32S->widthStep);		// NOTE: widthStep is counted in bytes!
		    for (int x=0; x<iplImage32S->width * iplImage32S->nChannels; x++) {
			    int value = pSrc[x];
			    pDst[x] = value << shift_bit;
		    }
	    }
    } else {
		showErrMsg("Unsupported bit-depth conversion method in CImageUtility::cvtImage8UtoInt!\n");
		return false;
    }

	return true;
}

IplImage *CImageUtility::cvtImage8UtoInt(IplImage *iplImage8U, int bit_depth, int cvt_method)
// Convert a 8U image (0~255) to a 32S image with significant data of N bits. For example, 
// given a pixel value in iplImage8U I, the pixel value in the 12-bit iplImage32S is I<<4.
// arguments:
//		iplImage8U -- [I] input image, must be 8U data type
//		bit_depth -- [I] bit depth of the output image, should be 8~31
//      exp_method -- [I] method to expend the bit-depth when bit_depth > 8
//                          0 -- add zero bits
//                          1 -- add random bits
// Return:
//		converted image in 32S data format, NULL for failure
// Luhong Liang, ICD-ASD, ASTRI
// Dec. 19, 2012
// Aug. 1, 2013
{
	// check input image
	if (iplImage8U == NULL || iplImage8U->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage8UtoInt!\n");
		return NULL;
	}
	if (bit_depth > 31 || bit_depth < 8) {
		showErrMsg("Only support bit depth between 8 and 31 in CImageUtility::cvtImage8UtoInt!\n");
		return NULL;
	}

	// create target image
	IplImage *iplImage32S = createImage( iplImage8U->width, iplImage8U->height, SR_DEPTH_32S, iplImage8U->nChannels);
	if (iplImage32S == NULL) {
		showErrMsg("Fatal error: fail to allocate image in CImageUtility::cvtImage8UtoInt()!\n");
		return NULL;
	}

	if (!cvtImage8UtoInt(iplImage8U, iplImage32S, bit_depth, cvt_method)) {
		safeReleaseImage(&iplImage32S);
		return NULL;
	}

	return iplImage32S;
}

bool CImageUtility::cvtImage8Uto16U(IplImage *iplImage8U, IplImage *iplImage16U, int bit_depth, int cvt_method)
// Covert a 8U image (8-bit) to 16U image (9~16-bit)
// Arguments:
//      iplImage8U -- [I] input 8U image
//      iplImage16U -- [O] output 16U image, must has the same size and channel number as the 8U image
//      bit_depth -- [I] bit_depth of the result image, must be 9~16
//      cvt_method -- [I] method for covnersion, could be: SR_DEPTHCVT_ZEROS and SR_DEPTHCVT_RANDOM
// by Luhong Liang, ICD-ASD, ASTRI
// Sept. 17, 2013
{
    if (iplImage8U == NULL || iplImage16U == NULL || iplImage8U->depth != SR_DEPTH_8U || iplImage16U->depth != SR_DEPTH_16U ||
        iplImage8U->nChannels != iplImage16U->nChannels || iplImage8U->width != iplImage16U->width || iplImage8U->height != iplImage16U->height) {
        showErrMsg("Invalid input or output image in CImageUtility::cvtImage8Uto16U()!\n");
        return false;
    }
    if (bit_depth < 9 || bit_depth > 16) {
        showErrMsg("Invalid output bit depth in CImageUtility::cvtImage8Uto16U()!\n");
        return false;
    }

    int left_shift = bit_depth - 8;
    int max_val = (1<<bit_depth) - 1;
    if ((cvt_method & SR_DEPTHCVT_ZEROS) != 0) {
        for (int y=0; y<iplImage16U->height; y++) {
            unsigned char *pSrc = (unsigned char *)(iplImage8U->imageData + y * iplImage8U->widthStep);
            unsigned short *pDst = (unsigned short *)(iplImage16U->imageData + y * iplImage16U->widthStep);
            for (int x=0; x<iplImage16U->width*iplImage16U->nChannels; x++) {
                unsigned short pix = pSrc[x];
                pDst[x] = pix << left_shift;
            }
        }
    } else if ((cvt_method & SR_DEPTHCVT_RANDOM) != 0) {
        const int seed_val = 31;
        unsigned short mask = ~(0xFFFF << left_shift);
        srand (seed_val);
        for (int y=0; y<iplImage16U->height; y++) {
            unsigned char *pSrc = (unsigned char *)(iplImage8U->imageData + y * iplImage8U->widthStep);
            unsigned short *pDst = (unsigned short *)(iplImage16U->imageData + y * iplImage16U->widthStep);
            for (int x=0; x<iplImage16U->width*iplImage16U->nChannels; x++) {
                unsigned short pix = pSrc[x];
                unsigned short lsb = ((unsigned short)rand()) & mask;
                pix = (pix << left_shift) + lsb;
                pDst[x] = (unsigned short)clip_int(pix, max_val, 0);
            }
        }
    } else {
        showErrMsg("Unsupported bit depth conversion method in CImageUtility::cvtImage8Uto16U()!\n");
        return false;
    }

    return true;
}

bool CImageUtility::cvtImage16Uto8U(IplImage *iplImage16U, int bit_depth, IplImage *iplImage8U, int cvt_method)
// Covert a 16U image (9~16-bit) to 8U image (8-bit)
// Arguments:
//      iplImage16U -- [I] input 16U image
//      bit_depth -- [I] bit_depth of the input image, must be 9~16
//      iplImage8U -- [O] output 8U image, must has the same size and channel number as the 8U image
//      cvt_method -- [I] method for covnersion, could be: SR_DEPTHCVT_ROUND and SR_DEPTHCVT_TRUNC
// by Luhong Liang, ICD-ASD, ASTRI
// Sept. 17, 2013
{
    if (iplImage8U == NULL || iplImage16U == NULL || iplImage8U->depth != SR_DEPTH_8U || iplImage16U->depth != SR_DEPTH_16U ||
        iplImage8U->nChannels != iplImage16U->nChannels || iplImage8U->width != iplImage16U->width || iplImage8U->height != iplImage16U->height) {
        showErrMsg("Invalid input or output image in CImageUtility::cvtImage16Uto8U()!\n");
        return false;
    }
    if (bit_depth < 9 || bit_depth > 16) {
        showErrMsg("Invalid input bit depth in CImageUtility::cvtImage16Uto8U()!\n");
        return false;
    }

    int right_shift = bit_depth - 8;
    //int max_val = (1<<bit_depth) - 1;
    if ((cvt_method & SR_DEPTHCVT_ROUND) != 0) {
        for (int y=0; y<iplImage8U->height; y++) {
            unsigned short *pSrc = (unsigned short *)(iplImage16U->imageData + y * iplImage16U->widthStep);
            unsigned char *pDst = (unsigned char *)(iplImage8U->imageData + y * iplImage8U->widthStep);
            for (int x=0; x<iplImage8U->width*iplImage8U->nChannels; x++) {
                unsigned short pix = pSrc[x];
                pix = pix >> (right_shift - 1);
                pix = ((pix&0x00000001)==0) ? (pix>>1) : ((pix>>1)+1);
                pDst[x] = (unsigned char)clip_0_255(pix);               // clipping to stop the overflow from input
            }
        }
    } else if ((cvt_method & SR_DEPTHCVT_TRUNC) != 0) {
        for (int y=0; y<iplImage8U->height; y++) {
            unsigned short *pSrc = (unsigned short *)(iplImage16U->imageData + y * iplImage16U->widthStep);
            unsigned char *pDst = (unsigned char *)(iplImage8U->imageData + y * iplImage8U->widthStep);
            for (int x=0; x<iplImage8U->width*iplImage8U->nChannels; x++) {
                unsigned short pix = pSrc[x];
                pDst[x] = (unsigned char)clip_0_255(pix >> right_shift); // clipping to stop the overflow from input
            }
        }
    } else {
        showErrMsg("Unsupported bit depth conversion method in CImageUtility::cvtImage16Uto8U()!\n");
        return false;
    }

    return true;
}

bool CImageUtility::cvtImage16Uto16U(IplImage *iplSrc16U, int src_bit_depth, IplImage *iplDst16U, int dst_bit_depth, int cvt_method)
// Change the bit depth of a 16U image (9~16-bit)
// This function supports in-place operation
// Arguments:
//      iplSrc16U -- [I] input 16U image
//      src_bit_depth -- [I] bit_depth of the input image, must be 9~16
//      iplDst16U -- [O] output 16U image, must has the same size and channel number as the input image
//      dst_bit_depth -- [I] bit_depth of the result image, must be 9~16
//      cvt_method -- [I] method for covnersion, could be: SR_DEPTHCVT_ZEROS/SR_DEPTHCVT_RANDOM (for bit depth increase)
//                        or SR_DEPTHCVT_ROUND/SR_DEPTHCVT_TRUNC (for bit depth reduction)
// by Luhong Liang, ICD-ASD, ASTRI
// Sept. 17, 2013
{
    if (iplSrc16U == NULL || iplDst16U == NULL || iplSrc16U->depth != SR_DEPTH_16U || iplDst16U->depth != SR_DEPTH_16U ||
        iplSrc16U->nChannels != iplDst16U->nChannels || iplSrc16U->width != iplDst16U->width || iplSrc16U->height != iplDst16U->height) {
        showErrMsg("Invalid input or output image in CImageUtility::cvtImage16Uto16U()!\n");
        return false;
    }
    if (src_bit_depth < 9 || src_bit_depth > 16 || dst_bit_depth < 9 || dst_bit_depth > 16) {
        showErrMsg("Invalid input or output bit depth in CImageUtility::cvtImage16Uto16U()!\n");
        return false;
    }

    int max_val = (1 << dst_bit_depth) - 1;
    if (dst_bit_depth > src_bit_depth) {
        // increase bit_depth
        int left_shift = dst_bit_depth - src_bit_depth;
        if ((cvt_method & SR_DEPTHCVT_ZEROS) != 0) {
            for (int y=0; y<iplDst16U->height; y++) {
                unsigned short *pSrc = (unsigned short *)(iplSrc16U->imageData + y * iplSrc16U->widthStep);
                unsigned short *pDst = (unsigned short *)(iplDst16U->imageData + y * iplDst16U->widthStep);
                for (int x=0; x<iplDst16U->width*iplDst16U->nChannels; x++) {
                    unsigned short pix = pSrc[x];
                    pDst[x] = (unsigned short)clip_int(pix << left_shift, max_val, 0); // clip to stop the possible overflow from input
                }
            }
        } else if ((cvt_method & SR_DEPTHCVT_RANDOM) != 0) {
            const int seed_val = 31;
            unsigned short mask = ~(0xFFFF << left_shift);
            srand (seed_val);
            for (int y=0; y<iplDst16U->height; y++) {
                unsigned short *pSrc = (unsigned short *)(iplSrc16U->imageData + y * iplSrc16U->widthStep);
                unsigned short *pDst = (unsigned short *)(iplDst16U->imageData + y * iplDst16U->widthStep);
                for (int x=0; x<iplDst16U->width*iplDst16U->nChannels; x++) {
                    unsigned short pix = pSrc[x];
                    unsigned short lsb = ((unsigned short)rand()) & mask;
                    pix = (pix << left_shift) + lsb;
                    pDst[x] = (unsigned short)clip_int(pix, max_val, 0);            // clip to stop the possible overflow from input
                }
            }
        } else {
            showErrMsg("Unsupported bit depth conversion method in CImageUtility::cvtImage16Uto16U()!\n");
            return false;
        }
    } else if (dst_bit_depth < src_bit_depth) {
        // bit depth reduction
        int right_shift = src_bit_depth - dst_bit_depth;
        if ((cvt_method & SR_DEPTHCVT_ROUND) != 0) {
            for (int y=0; y<iplDst16U->height; y++) {
                unsigned short *pSrc = (unsigned short *)(iplSrc16U->imageData + y * iplSrc16U->widthStep);
                unsigned short *pDst = (unsigned short *)(iplDst16U->imageData + y * iplDst16U->widthStep);
                for (int x=0; x<iplDst16U->width*iplDst16U->nChannels; x++) {
                    unsigned short pix = pSrc[x];
                    pix = pix >> (right_shift - 1);
                    pix = ((pix&0x00000001)==0) ? (pix>>1) : ((pix>>1)+1);
                    pDst[x] = (unsigned short)(pix > max_val ? max_val : pix);
                }
            }
        } else if ((cvt_method & SR_DEPTHCVT_TRUNC) != 0) {
            for (int y=0; y<iplDst16U->height; y++) {
                unsigned short *pSrc = (unsigned short *)(iplSrc16U->imageData + y * iplSrc16U->widthStep);
                unsigned short *pDst = (unsigned short *)(iplDst16U->imageData + y * iplDst16U->widthStep);
                for (int x=0; x<iplDst16U->width*iplDst16U->nChannels; x++) {
                    unsigned short pix = pSrc[x];
                    pDst[x] = pix >> right_shift;
                }
            }
        } else {
            showErrMsg("Unsupported bit depth conversion method in CImageUtility::cvtImage16Uto16U()!\n");
            return false;
        }
    } else {
        copy(iplSrc16U, iplDst16U);
    }

    return true;
}

IplImage *CImageUtility::cvtImage8Uto8U(IplImage *iplImage8U, short bias, float mag_factor)
// Convert a 8U image (0~255) to a 8U image (0~255)
// out = in * mag_factor + bias
// arguments:
//		iplImage8U -- [I] input image, must be 8U data type
//		bias -- [I] a bias added to the pixel value, ranging 0~255
//		mag_factor -- [I] magnitude factor of the intensitiy, the final pixel value is (org_pixel_value * mag_factor) + bias
// Return:
//		converted image, NULL for failure
//	by Luhong Liang, Jan. 28, 2013
{
	// check input image
	if (iplImage8U == NULL || iplImage8U->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage8Uto8U!\n");
		return NULL;
	}

	// allocate target image
	IplImage *iplDst = createImage( iplImage8U->width, iplImage8U->height, SR_DEPTH_8U, iplImage8U->nChannels);
	if (iplDst == NULL) {
		showErrMsg("Fatal error: fail to allocate image in CImageUtility::cvtImage8Uto8U!\n");
		return NULL;
	}

	if (!cvtImage8Uto8U(iplImage8U, iplDst, bias, mag_factor)) {
		releaseImage(&iplDst);
		return NULL;
	}

	return iplDst;
}

bool CImageUtility::cvtImage8Uto8U(IplImage *iplImage8U, IplImage *iplDst8U, short bias, float mag_factor)
// Convert a 8U image (0~255) to a 8U image (0~255)
// out = in * mag_factor + bias
// arguments:
//		iplImage8U -- [I] input image, must be 8U data type
//		iplDst8U -- [O] output image, must be 32F data type
//		bias -- [I] a bias added to the pixel value, ranging 0~255
//		mag_factor -- [I] magnitude factor of the intensitiy, the final pixel value is (org_pixel_value * mag_factor) + bias
// Return:
//		converted image, false for failure
//	by Luhong Liang, Jan. 28, 2013
{
	// check input image
	if (iplImage8U == NULL || iplImage8U->depth != SR_DEPTH_8U || 
		iplDst8U == NULL || iplDst8U->depth != SR_DEPTH_8U ||
		iplImage8U->width != iplDst8U->width || iplImage8U->height != iplDst8U->height || 
		iplImage8U->nChannels != iplDst8U->nChannels) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage8Uto8U!\n");
		return false;
	}

    if (bias == 0 && mag_factor == 1) {
        copy(iplImage8U, iplDst8U);
    } else {
	    // convert
	    for (int y=0; y<iplDst8U->height; y++) {	
		    unsigned char *pSrc = (unsigned char *)(iplImage8U->imageData + y * iplImage8U->widthStep);
		    unsigned char *pDst = (unsigned char *)(iplDst8U->imageData + y * iplDst8U->widthStep);
		    for (int x=0; x<iplDst8U->width * iplDst8U->nChannels; x++) {
			    int val = (int)(pSrc[x] * mag_factor + bias + 0.5f);
			    pDst[x] = (unsigned char)clip_0_255(val);
		    }
	    }
    }

	return true;
}

IplImage *CImageUtility::cvtImage8Uto32F(IplImage *iplImage8U)
// Convert a 8U image (0~255) to a 32F image (0~255)
// arguments:
//		iplImage8U -- [I] input image, must be 8U data type
// Return:
//		converted image, NULL for failure
// Major Modifications: 
//		Change data range of floating point pixel to 0~255, Nov. 15, 2011
{
	// check input image
	if (iplImage8U == NULL || iplImage8U->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage8Uto32F!\n");
		return NULL;
	}

	// allocate target image
	IplImage *iplImage32F = createImage( iplImage8U->width, iplImage8U->height, SR_DEPTH_32F, iplImage8U->nChannels);
	if (iplImage32F == NULL) {
		showErrMsg("Fatal error: fail to allocate image in CImageUtility::cvtImage8Uto32F!\n");
		return NULL;
	}

	if (!cvtImage8Uto32F(iplImage8U, iplImage32F)) {
		releaseImage(&iplImage32F);
		return NULL;
	}

	return iplImage32F;
}

IplImage *CImageUtility::cvtImage32Fto8U(IplImage *iplImage32F, short bias, float mag_factor, int cvt_method)
// Convert a 32F image (0~255) to a 8U image (0~255)
// out = Cvt(in * mag_factor + bias)
// arguments:
//		iplImage8U -- [I] input image, must be 32F data type
//		bias -- [I] a bias added to the pixel value, ranging 0~255
//		mag_factor -- [I] magnitude factor of the intensitiy, the final pixel value is (org_pixel_value * mag_factor) + bias
//      cvt_method -- [I] method to covert bitdepth (only support truncation and rounding)
// Return:
//		converted image, NULL for failure
// Major Modifications: 
//		Change data range of floating point pixel to 0~255, Nov. 15, 2011
//      Add option for covnersion method, Aug. 25, 2013
{
	// check input image
	if (iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage32Fto8U()!\n");
		return NULL;
	}

	// allocate target image
	IplImage *iplImage8U = createImage( iplImage32F->width, iplImage32F->height, SR_DEPTH_8U, iplImage32F->nChannels);
	if (iplImage8U == NULL) {
		showErrMsg("Fatal error: fail to allocate image in CImageUtility::cvtImage32Fto8U()!\n");
		return NULL;
	}

    //cvtImage32Fto8U(iplImage32F, iplImage8U, bias, mag_factor, SR_DEPTHCVT_TRUNC);    // for debug only
    //IplImage *iplImage8U1 = clone(iplImage8U);
    //cvtImage32Fto8U_SIMD(iplImage32F, iplImage8U1, bias, mag_factor, SR_DEPTHCVT_TRUNC);
    //cmpImages(iplImage8U, iplImage8U1);

	// convert
	if (cvtImage32Fto8U(iplImage32F, iplImage8U, bias, mag_factor, cvt_method)) {
		return iplImage8U;
	} else {
		safeReleaseImage(&iplImage8U);
		return NULL;
	}
}

 bool CImageUtility::cvtImage32Fto8U(IplImage *iplImage32F, IplImage *iplImage8U, short bias, float mag_factor, int cvt_method)
// Convert a 32F image (0~255) to a 8U image (0~255)
// out = Cvt(in * mag_factor + bias)
// arguments:
//		iplImage32F -- [I] input image, must be 32F data type
//		iplImage8U -- [O] input image, must be 8U data type
//		bias -- [I] a bias added to the pixel value, ranging 0~255
//		mag_factor -- [I] magnitude factor of the intensitiy, the final pixel value is (org_pixel_value * mag_factor) + bias
//      cvt_method -- [I] method to covert bitdepth (only support truncation and rounding)
// Return:
//		converted image, NULL for failure
// Major Modifications: 
//		Change data range of floating point pixel to 0~255, Nov. 15, 2011
//      Add option for covnersion method, Aug. 25, 2013
{
	// check input image
	if (iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F || iplImage8U == NULL || iplImage8U->depth != SR_DEPTH_8U ||
		iplImage32F->width != iplImage8U->width || iplImage32F->height != iplImage8U->height || iplImage32F->nChannels != iplImage8U->nChannels) {
		showErrMsg("Invalid or unmatched input/output image format in CImageUtility::cvtImage32Fto8U()!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    return cvtImage32Fto8U_SIMD(iplImage32F, iplImage8U, bias, mag_factor, cvt_method);
#endif      // #ifdef __SR_USE_SIMD

	// convert
    if ((cvt_method & SR_DEPTHCVT_TRUNC) != 0) {
        // truncation
	    for (int y=0; y<iplImage8U->height; y++) {	
		    float *pSrc = (float *)((char*)iplImage32F->imageData + y * iplImage32F->widthStep);		// NOTE: widthStep is counted in bytes!
		    unsigned char *pDst = (unsigned char *)(iplImage8U->imageData) + y * iplImage8U->widthStep;
		    for (int x=0; x<iplImage8U->width * iplImage8U->nChannels; x++) {
			    int pix = (int)(pSrc[x] * mag_factor + bias);
                // clipping
                pDst[x] = (unsigned char)clip_0_255(pix);
            }
	    }
    } else if ((cvt_method & SR_DEPTHCVT_ROUND) != 0) {
        // rounding
	    for (int y=0; y<iplImage8U->height; y++) {	
		    float *pSrc = (float *)((char*)iplImage32F->imageData + y * iplImage32F->widthStep);		// NOTE: widthStep is counted in bytes!
		    unsigned char *pDst = (unsigned char *)(iplImage8U->imageData) + y * iplImage8U->widthStep;
		    for (int x=0; x<iplImage8U->width * iplImage8U->nChannels; x++) {
			    int pix = (int)(pSrc[x] * mag_factor + bias + 0.5f);
			    // clipping
                pDst[x] = (unsigned char)clip_0_255(pix);
            }
	    }
    } else {
        showErrMsg("Not implemented or unknown bit depth converion method in CImageUtility::cvtImage32Fto8U()!\n");
        return false;
    }

	return true;
}

bool CImageUtility::cvtImage32Fto8U(IplImage *iplImage32F, unsigned char *pImage8U, short bias, float mag_factor, int cvt_method)
// Convert a 32F image (0~255) to a 8U image (0~255)
// out = Cvt(in * mag_factor + bias)
// arguments:
//		iplImage32F -- [I] input image, must be 32F data type
//		pImage8U -- [O] input image, must be word-aligned (32-bit) and with appropriate size
//		bias -- [I] a bias added to the pixel value, ranging 0~255
//		mag_factor -- [I] magnitude factor of the intensitiy, the final pixel value is (org_pixel_value * mag_factor) + bias
//      cvt_method -- [I] method to covert bitdepth (only support truncation and rounding)
// Return:
//		converted image, NULL for failure
{
	// check input image
	if (iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F || pImage8U == NULL) {
		showErrMsg("Invalid or unmatched input/output image format in CImageUtility::cvtImage32Fto8U()!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    return cvtImage32Fto8U_SIMD(iplImage32F, pImage8U, bias, mag_factor, cvt_method);
#endif  // #ifdef __SR_USE_SIMD

	// convert
    int widthStep = ((iplImage32F->width * iplImage32F->nChannels + 3) / 4) * 4;     // 32-bit aligned
    if ((cvt_method & SR_DEPTHCVT_TRUNC) != 0) {
        // truncation
	    for (int y=0; y<iplImage32F->height; y++) {	
		    float *pSrc = (float *)((char*)iplImage32F->imageData + y * iplImage32F->widthStep);		// NOTE: widthStep is counted in bytes!
		    for (int x=0; x<iplImage32F->width * iplImage32F->nChannels; x++) {
			    int pix = (int)(pSrc[x] * mag_factor + bias);
                // clipping
                pImage8U[x] = (unsigned char)clip_0_255(pix);
            }
            pImage8U += widthStep;
	    }
    } else if ((cvt_method & SR_DEPTHCVT_ROUND) != 0) {
        // rounding
	    for (int y=0; y<iplImage32F->height; y++) {	
		    float *pSrc = (float *)((char*)iplImage32F->imageData + y * iplImage32F->widthStep);		// NOTE: widthStep is counted in bytes!
		    for (int x=0; x<iplImage32F->width * iplImage32F->nChannels; x++) {
			    int pix = (int)(pSrc[x] * mag_factor + bias + 0.5f);
                // clipping
                pImage8U[x] = (unsigned char)clip_0_255(pix);
            }
            pImage8U += widthStep;
	    }
    } else {
        showErrMsg("Not implemented or unknown bit depth converion method in CImageUtility::cvtImage32Fto8U()!\n");
        return false;
    }

	return true;
}

bool CImageUtility::cvtImageIntto8U(IplImage *iplImage32S, int bit_depth, IplImage *iplImage8U, short bias, float mag_factor, int cvt_method)
// Convert an integer image with bit depth N (in 32S data format) to a 8U image (0~255). 
// out = rounding_to_8U(in * mag_factor) + bias
// arguments:
//		iplImage32S -- [I] input image, must be 32S data type
//		bit_depth -- [I] the bit depth of the input image, should be 8~32
//		iplImage8U -- [O] input image, must be 8U data type
//		bias -- [I] a bias added to the pixel value, ranging 0~255
//		mag_factor -- [I] magnitude factor of the intensitiy, the final pixel value is rounding_to_8U(in * mag_factor) + bias
//      cvt_method -- [I] method to covert bitdepth:
//                        SR_DEPTHCVT_TRUNC       // truncation
//                        SR_DEPTHCVT_ROUND       // rounding
// Return:
//		converted image, NULL for failure
// Major Modifications: 
//		Change data range of floating point pixel to 0~255, Nov. 15, 2012
//		Use rounding instead of truncation, Jan. 29, 2013
//		Add support on 8-bit input, Feb. 21, 2013
{
	// check input image
	if (iplImage32S == NULL || iplImage32S->depth != SR_DEPTH_32S || iplImage8U == NULL || iplImage8U->depth != SR_DEPTH_8U ||
		iplImage32S->width != iplImage8U->width || iplImage32S->height != iplImage8U->height || iplImage32S->nChannels != iplImage8U->nChannels) {
		showErrMsg("Invalid or unmatched input/output image format in CImageUtility::cvtImageIntto8U()!\n");
		return false;
	}
	if (bit_depth > 32 || bit_depth < 8) {
		showErrMsg("Only support bit depth between 8 and 31 in CImageUtility::cvtImageIntto8U!\n");
		return false;
	}

	// convert
	int shift_bit = bit_depth - 8;
	if (shift_bit > 0) {
        if ((cvt_method & SR_DEPTHCVT_ROUND) != 0) {
		    for (int y=0; y<iplImage8U->height; y++) {	
			    int *pSrc = (int *)((char*)iplImage32S->imageData + y * iplImage32S->widthStep);		// NOTE: widthStep is counted in bytes!
			    unsigned char *pDst = (unsigned char *)(iplImage8U->imageData) + y * iplImage8U->widthStep;
			    for (int x=0; x<iplImage8U->width * iplImage8U->nChannels; x++) {
				    // amplify
				    int pix = (int)(pSrc[x] * mag_factor + 0.5f);
				    // rounding to 8U
				    pix = pix >> (shift_bit - 1);
				    pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
				    // add bias
				    pix = pix + bias;
				    // clipping
				    if (pix < 0)
					    pDst[x] = 0;
				    else if (pix > IMAGE_DYNAMIC_RANGE_8U)
					    pDst[x] = IMAGE_DYNAMIC_RANGE_8U;
				    else
					    pDst[x] = (unsigned char)pix;
			    }
		    }
        } else if ((cvt_method & SR_DEPTHCVT_TRUNC) != 0) {
		    for (int y=0; y<iplImage8U->height; y++) {	
			    int *pSrc = (int *)((char*)iplImage32S->imageData + y * iplImage32S->widthStep);		// NOTE: widthStep is counted in bytes!
			    unsigned char *pDst = (unsigned char *)(iplImage8U->imageData) + y * iplImage8U->widthStep;
			    for (int x=0; x<iplImage8U->width * iplImage8U->nChannels; x++) {
				    // amplify
				    int pix = (int)(pSrc[x] * mag_factor + 0.5f);
				    // truncate to 8U
				    pix = pix >> shift_bit;
				    // add bias
				    pix = pix + bias;
				    // clipping
				    if (pix < 0)
					    pDst[x] = 0;
				    else if (pix > IMAGE_DYNAMIC_RANGE_8U)
					    pDst[x] = IMAGE_DYNAMIC_RANGE_8U;
				    else
					    pDst[x] = (unsigned char)pix;
			    }
		    }
        } else {
	        showErrMsg("Unsupported conversion method in CImageUtility::cvtImageIntto8U!\n");
	        return false;
        }
	} else {		// 8-bit input
		for (int y=0; y<iplImage8U->height; y++) {	
			int *pSrc = (int *)((char*)iplImage32S->imageData + y * iplImage32S->widthStep);		// NOTE: widthStep is counted in bytes!
			unsigned char *pDst = (unsigned char *)(iplImage8U->imageData) + y * iplImage8U->widthStep;
			for (int x=0; x<iplImage8U->width * iplImage8U->nChannels; x++) {
				// amplify
				int pix = (int)(pSrc[x] * mag_factor + 0.5f);
				// add bias
				pix = pix + bias;
				// clipping
				if (pix < 0)
					pDst[x] = 0;
				else if (pix > IMAGE_DYNAMIC_RANGE_8U)
					pDst[x] = IMAGE_DYNAMIC_RANGE_8U;
				else
					pDst[x] = (unsigned char)pix;
			}
		}
	}

	return true;
}

 IplImage *CImageUtility::cvtImageIntto8U(IplImage *iplImage32S, int bit_depth, short bias, float mag_factor, int cvt_method)
// Convert an integer image with bit depth N (in 32S data format) to a 8U image (0~255).
// out = rounding_to_8U(in * mag_factor) + bias
// arguments:
//		iplImage32S -- [I] input image, must be 32S data type
//		bit_depth -- [I] the bit depth of the input image, should be 8~32
//		bias -- [I] a bias added to the pixel value, ranging 0~255
//		mag_factor -- [I] magnitude factor of the intensitiy, the final pixel value is (org_pixel_value * mag_factor) + bias
//      cvt_method -- [I] method to covert bitdepth:
//                        SR_DEPTHCVT_TRUNC       // truncation
//                        SR_DEPTHCVT_ROUND       // rounding
// Return:
//		converted image, NULL for failure
// Major Modifications: 
//		Change data range of floating point pixel to 0~255, Nov. 15, 2011
{
	// check input image
	if (iplImage32S == NULL || iplImage32S->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid or unmatched input/output image format in CImageUtility::cvtImage32Sto8U()!\n");
		return false;
	}
	if (bit_depth > 32 || bit_depth < 8) {
		showErrMsg("Only support bit depth between 8 and 31 in CImageUtility::cvtImage32Sto8U!\n");
		return false;
	}

	// allocate target image
	IplImage *iplImage8U = createImage( iplImage32S->width, iplImage32S->height, SR_DEPTH_8U, iplImage32S->nChannels);
	if (iplImage8U == NULL) {
		showErrMsg("Fatal error: fail to allocate image in CImageUtility::cvtImage32Sto8U()!\n");
		return NULL;
	}

	// convert
	if (!cvtImageIntto8U(iplImage32S, bit_depth, iplImage8U, bias, mag_factor, cvt_method)) {
		safeReleaseImage(&iplImage8U);
		return NULL;
	}

	return iplImage8U;
}

bool CImageUtility::cvtImage32Fto32U(IplImage *iplImage32F, IplImage *ipImage32U, int bit_depth, int cvt_method)
// Convert a 32F image (0~255) to a 32U image with significant data of N bits. For example, 
// given a floating pixel value in iplImage32F I, the pixel value in the 12-bit pImage32U is Cvt(I*16).
// arguments:
//		iplImage32F -- [I] input image, must be 32F data type
//		ipImage32U -- [O]  output image, must be 32U data type
//		bit_depth -- [I] bit depth of the output image, should be 1~16
//      cvt_method -- [I] method to covert bitdepth:
//                        SR_DEPTHCVT_TRUNC       // truncation
//                        SR_DEPTHCVT_ROUND       // rounding
//                        SR_DEPTHCVT_EDFS        // Floyd-Steinberg error diffusion
//                        SR_DEPTHCVT_EDJJN       // Jarvis-Judice-Ninke error diffusion
//                        SR_DEPTHCVT_ED2x2       // 2x2 simplified error diffusion
// Return:
//		converted image, NULL for failure
// Luhong Liang, ICD-ASD, ASTRI
// Aug. 8, 2013
{
	// check input image
	if (iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F || ipImage32U == NULL || ipImage32U->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage32Fto32U()!\n");
		return false;
	}
	if (bit_depth > 31 || bit_depth < 1) {
		showErrMsg("Only support bit depth between 1 and 31 in CImageUtility::cvtImage32Fto32U()!\n");
		return false;
	}
  
    return cvtImage32Fto32U(iplImage32F, (unsigned int*)(ipImage32U->imageData), ipImage32U->widthStep, bit_depth, cvt_method);
 }

 bool CImageUtility::cvtImage32Fto32U(IplImage *iplImage32F, unsigned int *pImage32U, int bit_depth, int cvt_method)
// Convert a 32F image (0~255) to a 32U image with significant data of N bits. For example, 
// given a floating pixel value in iplImage32F I, the pixel value in the 12-bit pImage32U is Cvt(I*16).
// NOTE: this function suppose the target image buffer is 4-byte aligned!!!!
// arguments:
//		iplImage32F -- [I] input image, must be 32F data type
//		pImage32U -- [O]  output image, must be 32U data type must be word-aligned (32-bit) and with appropriate size
//		bit_depth -- [I] bit depth of the output image, should be 1~16
//      cvt_method -- [I] method to covert bitdepth:
//                        SR_DEPTHCVT_TRUNC       // truncation
//                        SR_DEPTHCVT_ROUND       // rounding
//                        SR_DEPTHCVT_EDFS        // Floyd-Steinberg error diffusion
//                        SR_DEPTHCVT_EDJJN       // Jarvis-Judice-Ninke error diffusion
//                        SR_DEPTHCVT_ED2x2       // 2x2 simplified error diffusion
// Return:
//		converted image, NULL for failure
// Luhong Liang, ICD-ASD, ASTRI
// Aug. 8, 2013
{
	// check input image
	if (iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F || pImage32U == NULL) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage32Fto32U()!\n");
		return false;
	}
	if (bit_depth > 31 || bit_depth < 1) {
		showErrMsg("Only support bit depth between 1 and 31 in CImageUtility::cvtImage32Fto32U()!\n");
		return false;
	}

    int widthStep = ((iplImage32F->width * iplImage32F->nChannels + 3) / 4) * 4;     // 32-bit aligned
  
    return cvtImage32Fto32U(iplImage32F, pImage32U, widthStep, bit_depth, cvt_method);
 }

bool CImageUtility::cvtImage32Fto32U(IplImage *iplImage32F, unsigned int *pImage32U, int widthStep, int bit_depth, int cvt_method)
// Convert a 32F image (0~255) to a 32U image with significant data of N bits. For example, 
// given a floating pixel value in iplImage32F I, the pixel value in the 12-bit pImage32U is Cvt(I*16).
// arguments:
//		iplImage32F -- [I] input image, must be 32F data type
//		pImage32U -- [O]  output image, must be 32U data type must be word-aligned (32-bit) and with appropriate size
//		bit_depth -- [I] bit depth of the output image, should be 1~16
//      cvt_method -- [I] method to covert bitdepth:
//                        SR_DEPTHCVT_TRUNC       // truncation
//                        SR_DEPTHCVT_ROUND       // rounding
//                        SR_DEPTHCVT_EDFS        // Floyd-Steinberg error diffusion
//                        SR_DEPTHCVT_EDJJN       // Jarvis-Judice-Ninke error diffusion
//                        SR_DEPTHCVT_ED2x2       // 2x2 simplified error diffusion
// Return:
//		converted image, NULL for failure
// Luhong Liang, ICD-ASD, ASTRI
// Setp. 2, 2013
{
	// check input image
	if (iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F || pImage32U == NULL) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage32Fto32U()!\n");
		return false;
	}
	if (bit_depth > 31 || bit_depth < 1) {
		showErrMsg("Only support bit depth between 1 and 31 in CImageUtility::cvtImage32Fto32U()!\n");
		return false;
	}

	// convert
    float factor = (1 << bit_depth) / 256.0f;
	unsigned int max_val = 1;
    if (bit_depth < 32) {
        max_val = (max_val << bit_depth) - 1;
    } else {
        max_val = 0xFFFFFFFF;
    }

    if ((cvt_method & SR_DEPTHCVT_TRUNC) != 0) {
        // truncation
	    for (int y=0; y<iplImage32F->height; y++) {	
		    float *pSrc = (float *)((char *)iplImage32F->imageData + y * iplImage32F->widthStep);
		    for (int x=0; x<iplImage32F->width * iplImage32F->nChannels; x++) {
			    float pix = floor(pSrc[x] * factor);
			    // clipping
                pix = pix < 0 ? 0 : pix;
                pix = pix > max_val ? max_val : pix;
                pImage32U[x] = (unsigned int)pix;
		    }
            pImage32U += widthStep;
	    }
    } else if ((cvt_method & SR_DEPTHCVT_ROUND) != 0) {
        // rounding
	    for (int y=0; y<iplImage32F->height; y++) {	
		    float *pSrc = (float *)((char *)iplImage32F->imageData + y * iplImage32F->widthStep);
		    for (int x=0; x<iplImage32F->width * iplImage32F->nChannels; x++) {
			    float pix = floor(pSrc[x] * factor + 0.5f);
			    // clipping
                pix = pix < 0 ? 0 : pix;
                pix = pix > max_val ? max_val : pix;
                pImage32U[x] = (unsigned int)pix;
		    }
            pImage32U += widthStep;
	    }
    } else if ((cvt_method & SR_DEPTHCVT_EDFS) != 0) {
        // Floyd-Steinberg error diffusion
        // | - # 7 |  /
        // | 3 5 1 | / 16
        if (iplImage32F->nChannels != 1) {
            showErrMsg("Only support 1-channel error diffusion in CImageUtility::cvtImage32Fto32U()!\n");
            return false;
        }
        // allocate line buffer
        float *pErrBuf = new float[iplImage32F->width + 2];     // 2 more row to simplify the process
        if (pErrBuf == NULL) {
            showErrMsg("Fail to allocate buffer in CImageUtility::cvtImage32Fto32U()!\n");
            return false;
        }
        for (int i=0; i<iplImage32F->width+2; i++) {
            pErrBuf[i] = 0.0f;
        }
        // error diffusion
	    for (int y=0; y<iplImage32F->height; y++) {	
		    float *pSrc = (float *)((char *)iplImage32F->imageData + y * iplImage32F->widthStep);
            float err_x1 = 0.0f;
            float err = 0.0f;
            pErrBuf[0] = 0.0f;
            pErrBuf[1] = 0.0f;
            for (int x=0; x<iplImage32F->width; x++) {
			    float val = pSrc[x] * factor + err_x1 / 16.0f;
                float pix = floor(val + 0.5f);
			    // clipping and calculate error (do not spread the error when it is overflow)
                if (pix < 0) {
                    pImage32U[x] = 0;
                    err = 0.0f;
                } else if (pix > max_val) {
                    pImage32U[x] = max_val;
                    err = 0.0f;
                } else {
                    pImage32U[x] = (unsigned int)pix;
                    err = val - pix;
                }
                // diffuse
                err_x1 = pErrBuf[x+2] + err * 7;        // backup current diffused error
                pErrBuf[x] += err * 3;
                pErrBuf[x+1] += err * 5;
                pErrBuf[x+2] = err;                     // should refresh buffer
		    }
            // next line
            pImage32U += widthStep;
	    }
    } else if ((cvt_method & SR_DEPTHCVT_EDJJN) != 0) {
        // Jarvis-Judice-Ninke error diffusion
        // | - - # 7 5 |   /
        // | 3 5 7 5 3 |  / 48     
        // | 1 3 5 3 1 | /
        if (iplImage32F->nChannels != 1) {
            showErrMsg("Only support 1-channel error diffusion in CImageUtility::cvtImage32Fto32U()!\n");
            return false;
        }
        if (iplImage32F->nChannels != 1) {
            showErrMsg("Only support 1-channel error diffusion in CImageUtility::cvtImage32Fto32U()!\n");
            return false;
        }
        // allocate line buffer
        float *pErrBuf = new float[(iplImage32F->width+4)*3];     // 4 more row to simplify the process
        if (pErrBuf == NULL) {
            showErrMsg("Fail to allocate buffer in CImageUtility::cvtImage32Fto32U()!\n");
            return false;
        }
        for (int i=0; i<(iplImage32F->width+4)*3; i++) {
            pErrBuf[i] = 0;
        }
        // error diffusion
        float *pErrBuf0 = pErrBuf + 2;
        float *pErrBuf1 = pErrBuf + (iplImage32F->width + 4) + 2;
        float *pErrBuf2 = pErrBuf + (iplImage32F->width + 4) * 2 + 2;
	    for (int y=0; y<iplImage32F->height; y++) {	
		    float *pSrc = (float *)((char *)iplImage32F->imageData + y * iplImage32F->widthStep);
            pErrBuf2[-2] = 0.0f;
            pErrBuf2[-1] = 0.0f;
            pErrBuf2[0] = 0.0f;
            pErrBuf2[1] = 0.0f;
            float err = 0.0f;
            for (int x=0; x<iplImage32F->width; x++) {
			    float val = pSrc[x] * factor + pErrBuf0[x] / 48.0f;
                float pix = floor(val + 0.5f);
			    // clipping and calculate error (do not spread error when it is overflow)
                if (pix < 0) {
                    pImage32U[x] = 0;
                    err = 0.0f;
                } else if (pix > max_val) {
                    pImage32U[x] = max_val;
                    err = 0.0f;
                } else {
                    pImage32U[x] = (unsigned int)pix;
                    err = val - pix;
                }
                // diffuse
                pErrBuf0[x+1] += err*7; pErrBuf0[x+2] += err*5;
                pErrBuf1[x-2] += err*3; pErrBuf1[x-1] += err*5; pErrBuf1[x] += err*7; pErrBuf1[x+1] += err*5; pErrBuf1[x+2] += err*3;
                pErrBuf2[x-2] += err;   pErrBuf2[x-1] += err*3; pErrBuf2[x] += err*5; pErrBuf2[x+1] += err*3; pErrBuf2[x+2] = err;        // should referesh buffer
		    }
            // swap buffer
            float *temp = pErrBuf0;
            pErrBuf0 = pErrBuf1;
            pErrBuf1 = pErrBuf2;
            pErrBuf2 = temp;
            // next line
            pImage32U += widthStep;
	    }
    } else if ((cvt_method & SR_DEPTHCVT_ED2x2) != 0) {
        // 2x2 simplified error diffusion
        // | # 2 |  /
        // | 1 1 | / 4
        if (iplImage32F->nChannels != 1) {
            showErrMsg("Only support 1-channel error diffusion in CImageUtility::cvtImage32Fto32U()!\n");
            return false;
        }
        // allocate line buffer
        float *pErrBuf = new float[iplImage32F->width + 1];     // 2 more row to simplify the process
        if (pErrBuf == NULL) {
            showErrMsg("Fail to allocate buffer in CImageUtility::cvtImage32Fto32U()!\n");
            return false;
        }
        for (int i=0; i<iplImage32F->width+1; i++) {
            pErrBuf[i] = 0.0f;
        }
        // error diffusion
	    for (int y=0; y<iplImage32F->height; y++) {	
		    float *pSrc = (float *)((char *)iplImage32F->imageData + y * iplImage32F->widthStep);
            float err_x1 = 0.0f;
            float err = 0.0f;
            pErrBuf[0] = 0.0f;
            for (int x=0; x<iplImage32F->width; x++) {
			    float val = pSrc[x] * factor + err_x1 / 4.0f;
                float pix = floor(val + 0.5f);
			    // clipping and calculate error (do not spread the error when it is overflow)
                if (pix < 0) {
                    pImage32U[x] = 0;
                    err = 0.0f; 
                } else if (pix > max_val) {
                    pImage32U[x] = max_val;
                    err = 0.0f;
                } else {
                    pImage32U[x] = (unsigned int)pix;
                    err = val - pix;
                }
                // diffuse
                err_x1 = pErrBuf[x+1] + err * 2;        // backup current diffused error
                pErrBuf[x] += err;
                pErrBuf[x+1] = err;                   // should refresh buffer
		    }
            // next line
            pImage32U += widthStep;
	    }
    } else {
        showErrMsg("Not implemented or unknown bit depth converion method in CImageUtility::cvtImage32Fto32U()!\n");
        return false;
    }

	return true;
}

bool CImageUtility::cvtImage32Fto31U(IplImage *iplImage32F, IplImage *iplImage32S, int bit_depth, int cvt_method)
// Convert a 32F image (0~255) to a 32S image with significant data of N bits. For example, 
// given a floating pixel value in iplImage32F I, the pixel value in the 12-bit iplImage32S is Cvt(I*16).
// arguments:
//		iplImage32F -- [I] input image, must be 32F data type
//		iplImage32S -- [O] output image, must be 32S data type
//		bit_depth -- [I] bit depth of the output image, should be 1~31
//      cvt_method -- [I] method to covert bitdepth:
//                        SR_DEPTHCVT_TRUNC       // truncation
//                        SR_DEPTHCVT_ROUND       // rounding
//                        SR_DEPTHCVT_EDFS        // Floyd-Steinberg error diffusion
//                        SR_DEPTHCVT_EDJJN       // Jarvis-Judice-Ninke error diffusion
//                        SR_DEPTHCVT_ED2x2       // 2x2 simplified error diffusion
// Return:
//		converted image, NULL for failure
// Luhong Liang, ICD-ASD, ASTRI, Dec. 19, 2012
{
	// check input image
	if (iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F || iplImage32S == NULL || iplImage32S->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage32Fto31U()!\n");
		return false;
	}
    if (iplImage32F->width != iplImage32S->width || iplImage32F->height != iplImage32S->height) {
		showErrMsg("Unmatched input and output image sizes in CImageUtility::cvtImage32Fto31U()!\n");
		return false;
	}
	if (bit_depth > 31 || bit_depth < 1) {
		showErrMsg("Only support bit depth between 1 and 31 in CImageUtility::cvtImage32Fto32U()!\n");
		return false;
	}

    // covnersion
    return cvtImage32Fto32U(iplImage32F, (unsigned int *)iplImage32S->imageData, bit_depth, cvt_method);
}

IplImage *CImageUtility::cvtImage32Fto31U(IplImage *iplImage32F, int bit_depth, int cvt_method)
// Convert a 32F image (0~255) to a 32S image with significant data of N bits. For example, 
// given a floating pixel value in iplImage32F I, the pixel value in the 12-bit iplImage32S is Cvt(I*16).
// arguments:
//		iplImage32F -- [I] input image, must be 32F data type
//		bit_depth -- [I] bit depth of the output image, should be 8~31
//      cvt_method -- [I] method to covert bitdepth:
//                        SR_DEPTHCVT_TRUNC       // truncation
//                        SR_DEPTHCVT_ROUND       // rounding
//                        SR_DEPTHCVT_EDFS        // Floyd-Steinberg error diffusion
//                        SR_DEPTHCVT_EDJJN       // Jarvis-Judice-Ninke error diffusion
//                        SR_DEPTHCVT_ED2x2       // 2x2 simplified error diffusion
// Return:
//		converted image (32S data type), NULL for failure
// Luhong Liang, ICD-ASD, ASTRI, Dec. 19, 2012
//		Add support on 8-bit input, Feb. 21, 2013
{
	// check input image
	if (iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage32Fto31U!\n");
		return NULL;
	}
	if (bit_depth > 31 || bit_depth < 8) {
		showErrMsg("Only support bit depth between 8 and 31 in CImageUtility::cvtImage32Fto31U!\n");
		return NULL;
	}

	// create target image
	IplImage *iplImage32S = createImage( iplImage32F->width, iplImage32F->height, SR_DEPTH_32S, iplImage32F->nChannels);
	if (iplImage32S == NULL) {
		showErrMsg("Fatal error: fail to allocate image in CImageUtility::cvtImage32Fto31U()!\n");
		return NULL;
	}

	if (!cvtImage32Fto31U(iplImage32F, iplImage32S, bit_depth, cvt_method)) {
		safeReleaseImage(&iplImage32S);
		return NULL;
	}

	return iplImage32S;
}

IplImage *CImageUtility::cvtImage32FtoUint(IplImage *iplImage32F, int bit_depth,  int dst_data_type, int cvt_method)
// Convert a 32F image (0~255) to a integer image (8U, 16U or 32S) with significant data of N bits. For example, 
// given a floating pixel value in iplImage32F I, the pixel value in the 12-bit integer image is Cvt(I*16).
// arguments:
//		iplImage32F -- [I] input image, must be 32F data type
//		iplImage32S -- [O] output image, must be 8U, 16U or 32S data type
//		bit_depth -- [I] bit depth of the output image, should be 1~31
//      dst_data_type [I] depth data type, could be
//                        SR_DEPTH_8U  
//                        SR_DEPTH_16U
//                        SR_DEPTH_32S
//      cvt_method -- [I] method to covert bitdepth:
//                        SR_DEPTHCVT_TRUNC       // truncation
//                        SR_DEPTHCVT_ROUND       // rounding
//                        SR_DEPTHCVT_EDFS        // Floyd-Steinberg error diffusion
//                        SR_DEPTHCVT_EDJJN       // Jarvis-Judice-Ninke error diffusion
//                        SR_DEPTHCVT_ED2x2       // 2x2 simplified error diffusion
// Return:
//		converted image, NULL for failure
// Luhong Liang, ICD-ASD, ASTRI, Sept. 2, 2013
{
	// check input image
	if (iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage32FtoUint()!\n");
		return NULL;
	}
	if (bit_depth > 31 || bit_depth < 1) {
		showErrMsg("Only support bit depth between 1 and 31 in CImageUtility::cvtImage32FtoUint()!\n");
		return NULL;
	}

    // allocate image buffer
    IplImage *iplImageUint = createImage(iplImage32F->width, iplImage32F->height, dst_data_type, iplImage32F->nChannels);
    if (iplImageUint == NULL) {
        showErrMsg("Fail to allocate image buffer in CImageUtility::cvtImage32FtoUint()!\n");
        return NULL;
    }

    // convert
    cvtImage32FtoUint(iplImage32F, iplImageUint, bit_depth, cvt_method);

    return iplImageUint;
}

bool CImageUtility::cvtImage32FtoUint(IplImage *iplImage32F, IplImage *iplImageUint, int bit_depth, int cvt_method)
// Convert a 32F image (0~255) to a integer image (8U, 16U or 32S) with significant data of N bits. For example, 
// given a floating pixel value in iplImage32F I, the pixel value in the 12-bit integer image is Cvt(I*16).
// arguments:
//		iplImage32F -- [I] input image, must be 32F data type
//		iplImage32S -- [O] output image, must be 8U, 16U or 32S data type
//		bit_depth -- [I] bit depth of the output image, should be 1~31
//      cvt_method -- [I] method to covert bitdepth:
//                        SR_DEPTHCVT_TRUNC       // truncation
//                        SR_DEPTHCVT_ROUND       // rounding
//                        SR_DEPTHCVT_EDFS        // Floyd-Steinberg error diffusion
//                        SR_DEPTHCVT_EDJJN       // Jarvis-Judice-Ninke error diffusion
//                        SR_DEPTHCVT_ED2x2       // 2x2 simplified error diffusion
// Return:
//		true for success
// Luhong Liang, ICD-ASD, ASTRI, Sept. 2, 2013
{
	// check input image
	if (iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F || iplImageUint == NULL) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage32FtoUint()!\n");
		return false;
	}
    if (iplImage32F->width != iplImageUint->width || iplImage32F->height != iplImageUint->height) {
		showErrMsg("Unmatched input and output image sizes in CImageUtility::cvtImage32FtoUint()!\n");
		return false;
	}
	if (bit_depth > 31 || bit_depth < 1) {
		showErrMsg("Only support bit depth between 1 and 31 in CImageUtility::cvtImage32FtoUint()!\n");
		return false;
	}

    // covnersion
    if (iplImageUint->depth == SR_DEPTH_8U) {
        if (bit_depth != 8) {
            showErrMsg("Only support 8-bit data in conversion to 8U image in CImageUtility::cvtImage32FtoUint()!\n");
            return false;
        }
        if ((cvt_method & SR_DEPTHCVT_TRUNC) == 0 && (cvt_method & SR_DEPTHCVT_ROUND) == 0) {
            showErrMsg("Only support rounding or truncation method in conversion to 8U image in CImageUtility::cvtImage32FtoUint()!\n");
            return false;
        }
        return cvtImage32Fto8U(iplImage32F, iplImageUint, 0, 1.0f, cvt_method);     
    } else if (iplImageUint->depth == SR_DEPTH_16U) {
        return cvtImage32Fto16U(iplImage32F,iplImageUint, bit_depth, cvt_method);
    } else if (iplImageUint->depth == SR_DEPTH_32S) {
        //return cvtImage32Fto32U(iplImage32F, (unsigned int *)iplImageUint->imageData, bit_depth, cvt_method); // Fixed by Luhong, Aug 8 2014 (incorrect alignment in SIMD!)
        return cvtImage32Fto32U(iplImage32F, iplImageUint, bit_depth, cvt_method); 
    } else {
        showErrMsg("Only support 8U, 16U or 32S in output image in CImageUtility::cvtImage32FtoUint()!\n");
        return false;
    }
}

bool CImageUtility::cvtImage32Sto32F(IplImage *iplImage32S, IplImage *iplImage32F, int bit_depth)
// Convert an singed or unsigned integer image with bit depth N (in 32S data format) to a 32F image [-256~255]. For example, 
// supposing the input image is 12-bit singed value I, the 32F value will be (I/16).
// arguments:
//		iplImage32S -- [I] input image, must be 32S data type
//		iplImage32F -- [O] input image, must be 32F data type
//		bit_depth -- [I] the bit depth of the input image, should be 8~32
// Return:
//		converted image, NULL for failure
// Luhong Liang, ICD-ASD, ASTRI
// Dec. 19, 2012; Setp. 2, 2013 (changed function name);
{
	// check input image
	if (iplImage32S == NULL || iplImage32S->depth != SR_DEPTH_32S || iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F ||
		iplImage32S->width != iplImage32F->width || iplImage32S->height != iplImage32F->height || iplImage32S->nChannels != iplImage32F->nChannels) {
		showErrMsg("Invalid or unmatched input/output image format in CImageUtility::cvtImage32Sto32F()!\n");
		return false;
	}
	if (bit_depth > 32 || bit_depth < 8) {
		showErrMsg("Only support bit depth between 8 and 31 in CImageUtility::cvtImage32Sto32F!\n");
		return false;
	}

	// convert
	int factor = 1;
	factor = factor << (bit_depth - 8);
	for (int y=0; y<iplImage32F->height; y++) {	
		int *pSrc = (int *)((char*)iplImage32S->imageData + y * iplImage32S->widthStep);		// NOTE: widthStep is counted in bytes!
		float *pDst = (float *)((char*)iplImage32F->imageData + y * iplImage32F->widthStep);	
		for (int x=0; x<iplImage32F->width * iplImage32F->nChannels; x++) {
			// saturation
			float pix = (float)(pSrc[x]);
			pDst[x] = pix / factor;
		}
	}

	return true;
}

IplImage *CImageUtility::cvtImage32Sto32F(IplImage *iplImage32S, int bit_depth)
// Convert an singed or unsigned integer image with bit depth N (in 32S data format) to a 32F image [-256~255]. For example, 
// supposing the input image is 12-bit singed value I, the 32F value will be (I/16).
// arguments:
//		iplImage32S -- [I] input image, must be 32S data type
//		bit_depth -- [I] the bit depth of the input image, should be 8~32
// Return:
//		converted image, NULL for failure
// Luhong Liang, ICD-ASD, ASTRI
// Dec. 19, 2012; Setp. 2, 2013 (changed function name);
{
	// check input image
	if (iplImage32S == NULL || iplImage32S->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid or unmatched input/output image format in CImageUtility::cvtImage32Sto32F()!\n");
		return false;
	}
	if (bit_depth > 32 || bit_depth < 8) {
		showErrMsg("Only support bit depth between 8 and 31 in CImageUtility::cvtImage32Sto32F!\n");
		return false;
	}

	// allocate target image
	IplImage *iplImage32F = createImage( iplImage32S->width, iplImage32S->height, SR_DEPTH_32F, iplImage32S->nChannels);
	if (iplImage32F == NULL) {
		showErrMsg("Fatal error: fail to allocate image in CImageUtility::cvtImage32Sto32F()!\n");
		return NULL;
	}

	// convert
	if (!cvtImageIntto32F(iplImage32S, iplImage32F, bit_depth)) {
		safeReleaseImage(&iplImage32F);
		return NULL;
	}

	return iplImage32F;
}

bool CImageUtility::cvtImageIntto32F(IplImage *iplImageInt, IplImage *iplImage32F, int bit_depth)
// Convert an singed or unsigned integer image with bit depth N (in 32S data format) to a 32F image [-256~255]. For example, 
// supposing the input image is 12-bit singed value I, the 32F value will be (I/16).
// arguments:
//		iplImageInt -- [I] input image, must be 8U, 16U or 32S data type
//		iplImage32F -- [O] input image, must be 32F data type
//		bit_depth -- [I] the bit depth of the input image, should be 8~32
// Return:
//		converted image, NULL for failure
// Luhong Liang, ICD-ASD, ASTRI
// Setp. 2, 2013
{
	// check input image
	if (iplImageInt == NULL || iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F ||
		iplImageInt->width != iplImage32F->width || iplImageInt->height != iplImage32F->height || iplImageInt->nChannels != iplImage32F->nChannels) {
		showErrMsg("Invalid or unmatched input/output image format in CImageUtility::cvtImageIntto32F()!\n");
		return false;
	}
	if (bit_depth > 32 || bit_depth < 8) {
		showErrMsg("Only support bit depth between 8 and 3 in CImageUtility::cvtImageIntto32F!\n");
		return false;
	}

	// convert
    if (iplImageInt->depth == SR_DEPTH_8U) {
        if (bit_depth != 8) {
            showErrMsg("Only support 8-bit 8U data in CImageUtility::cvtImageIntto32F!\n");
            return false;
        } else {
            return cvtImage8Uto32F(iplImageInt, iplImageInt);
        }
    } else if (iplImageInt->depth == SR_DEPTH_16U) {
        return cvtImage16Uto32F(iplImageInt, iplImage32F, bit_depth);
    } else if (iplImageInt->depth == SR_DEPTH_32S) {
        return cvtImage32Sto32F(iplImageInt, iplImage32F, bit_depth);
    } else {
        showErrMsg("Unsupported input data type in CImageUtility::cvtImageIntto32F!\n");
        return false;
    }
}

IplImage *CImageUtility::cvtImageIntto32F(IplImage *iplImageInt, int bit_depth)
// Convert an singed or unsigned integer image with bit depth N (in 32S data format) to a 32F image [-256~255]. For example, 
// supposing the input image is 12-bit singed value I, the 32F value will be (I/16).
// arguments:
//		iplImageInt -- [I] input image, must be 8U, 16U or 32S data type
//		bit_depth -- [I] the bit depth of the input image, should be 8~32
// Return:
//		converted image, NULL for failure
// Luhong Liang, ICD-ASD, ASTRI
// Setp. 2, 2013
{
	// check input image
	if (iplImageInt == NULL || (iplImageInt->depth != SR_DEPTH_8U && iplImageInt->depth != SR_DEPTH_16U && iplImageInt->depth != SR_DEPTH_32S)) {
		showErrMsg("Invalid or unmatched input/output image format in CImageUtility::cvtImageIntto32F()!\n");
		return false;
	}
	if (bit_depth > 32 || bit_depth < 8) {
		showErrMsg("Only support bit depth between 8 and 32 in CImageUtility::cvtImageIntto32F!\n");
		return false;
	}

	// allocate target image
	IplImage *iplImage32F = createImage( iplImageInt->width, iplImageInt->height, SR_DEPTH_32F, iplImageInt->nChannels);
	if (iplImage32F == NULL) {
		showErrMsg("Fatal error: fail to allocate image in CImageUtility::cvtImageIntto32F()!\n");
		return NULL;
	}

	// convert
    bool rlt;
	// convert
    if (iplImageInt->depth == SR_DEPTH_8U) {
        if (bit_depth != 8) {
            showErrMsg("Only support 8-bit 8U data in CImageUtility::cvtImageIntto32F!\n");
            rlt = false;
        } else {
            rlt = cvtImage8Uto32F(iplImageInt, iplImage32F);
            //IplImage *iplImg2 = createImage(iplImage32F);
            //cvtImage8Uto32F_SIMD(iplImageInt, iplImg2);
            //cmpImages(iplImage32F, iplImg2);
        }
    } else if (iplImageInt->depth == SR_DEPTH_16U) {
        rlt = cvtImage16Uto32F(iplImageInt, iplImage32F, bit_depth);
    } else if (iplImageInt->depth == SR_DEPTH_32S) {
        rlt = cvtImage32Sto32F(iplImageInt, iplImage32F, bit_depth);
    } else {
        showErrMsg("Unsupported input data type in CImageUtility::cvtImageIntto32F!\n");
        rlt = false;
    }
	if (!rlt) {
		safeReleaseImage(&iplImage32F);
		return NULL;
	}

	return iplImage32F;
}

bool CImageUtility::cvtImage32Fto16U(IplImage *iplImage32F, unsigned short *pImage16U, int bit_depth, int cvt_method)
// Convert a 32F image (0~255) to a 32S image with significant data of N bits. For example, 
// given a floating pixel value in iplImage32F I, the pixel value in the 12-bit iplImage32S is Cvt(I*16).
// arguments:
//		iplImage32F -- [I] input image, must be 32F data type
//		pImage16U -- [O]  output image, must be 16U data type must be word-aligned (32-bit) and with appropriate size
//		bit_depth -- [I] bit depth of the output image, should be 1~16
//      cvt_method -- [I] method to covert bitdepth:
//                        SR_DEPTHCVT_TRUNC       // truncation
//                        SR_DEPTHCVT_ROUND       // rounding
//                        SR_DEPTHCVT_EDFS        // Floyd-Steinberg error diffusion
//                        SR_DEPTHCVT_EDJJN       // Jarvis-Judice-Ninke error diffusion
//                        SR_DEPTHCVT_ED2x2       // 2x2 simplified error diffusion
// Return:
//		converted image, NULL for failure
// Luhong Liang, ICD-ASD, ASTRI
// Aug. 27, 2013
{
	// check input image
	if (iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F || pImage16U == NULL) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage32Fto16U()!\n");
		return false;
	}
	if (bit_depth > 16 || bit_depth < 1) {
		showErrMsg("Only support bit depth between 1 and 16 in CImageUtility::cvtImage32Fto16U()!\n");
		return false;
	}

	// convert
    float factor = (1 << bit_depth) / 256.0f;
	int max_val = 1;
	max_val = (max_val << bit_depth) - 1;
    int widthStep = ((iplImage32F->width * iplImage32F->nChannels + 3) / 4) * 4;     // 32-bit aligned

    if ((cvt_method & SR_DEPTHCVT_TRUNC) != 0) {
        // truncation
	    for (int y=0; y<iplImage32F->height; y++) {	
		    float *pSrc = (float *)((char *)iplImage32F->imageData + y * iplImage32F->widthStep);
		    for (int x=0; x<iplImage32F->width * iplImage32F->nChannels; x++) {
			    int pix = (int)(pSrc[x] * factor);
			    // clipping
                pImage16U[x] = (unsigned short)clip_int(pix, max_val, 0);
		    }
            pImage16U += widthStep;
	    }
    } else if ((cvt_method & SR_DEPTHCVT_ROUND) != 0) {
        // rounding
	    for (int y=0; y<iplImage32F->height; y++) {	
		    float *pSrc = (float *)((char *)iplImage32F->imageData + y * iplImage32F->widthStep);
		    for (int x=0; x<iplImage32F->width * iplImage32F->nChannels; x++) {
			    int pix = (int)(pSrc[x] * factor + 0.5f);
			    // clipping
                pImage16U[x] = (unsigned short)clip_int(pix, max_val, 0);
		    }
            pImage16U += widthStep;
	    }
    } else if ((cvt_method & SR_DEPTHCVT_EDFS) != 0) {
        // Floyd-Steinberg error diffusion
        // | - # 7 |  /
        // | 3 5 1 | / 16
        if (iplImage32F->nChannels != 1) {
            showErrMsg("Only support 1-channel error diffusion in CImageUtility::cvtImage32Fto16U()!\n");
            return false;
        }
        // allocate line buffer
        float *pErrBuf = new float[iplImage32F->width + 2];     // 2 more row to simplify the process
        if (pErrBuf == NULL) {
            showErrMsg("Fail to allocate buffer in CImageUtility::cvtImage32Fto16U()!\n");
            return false;
        }
        for (int i=0; i<iplImage32F->width+2; i++) {
            pErrBuf[i] = 0.0f;
        }
        // error diffusion
	    for (int y=0; y<iplImage32F->height; y++) {	
		    float *pSrc = (float *)((char *)iplImage32F->imageData + y * iplImage32F->widthStep);
            float err_x1 = 0.0f;
            float err = 0.0f;
            pErrBuf[0] = 0.0f;
            pErrBuf[1] = 0.0f;
            for (int x=0; x<iplImage32F->width; x++) {
			    float val = pSrc[x] * factor + err_x1 / 16.0f;
                int pix = (int)(val + 0.5f);
			    // clipping and calculate error (do not spread the error when it is overflow)
                if (pix < 0) {
                    pImage16U[x] = 0;
                    err = 0.0f;
                } else if (pix > max_val) {
                    pImage16U[x] = (unsigned short)max_val;
                    err = 0.0f;
                } else {
                    pImage16U[x] = (unsigned short)pix;
                    err = val - (float)pix;
                }
                // diffuse
                err_x1 = pErrBuf[x+2] + err * 7;        // backup current diffused error
                pErrBuf[x] += err * 3;
                pErrBuf[x+1] += err * 5;
                pErrBuf[x+2] = err;                     // should refresh buffer
		    }
            // next line
            pImage16U += widthStep;
	    }
    } else if ((cvt_method & SR_DEPTHCVT_EDJJN) != 0) {
        // Jarvis-Judice-Ninke error diffusion
        // | - - # 7 5 |   /
        // | 3 5 7 5 3 |  / 48     
        // | 1 3 5 3 1 | /
        if (iplImage32F->nChannels != 1) {
            showErrMsg("Only support 1-channel error diffusion in CImageUtility::cvtImage32Fto16U()!\n");
            return false;
        }
        if (iplImage32F->nChannels != 1) {
            showErrMsg("Only support 1-channel error diffusion in CImageUtility::cvtImage32Fto16U()!\n");
            return false;
        }
        // allocate line buffer
        float *pErrBuf = new float[(iplImage32F->width+4)*3];     // 4 more row to simplify the process
        if (pErrBuf == NULL) {
            showErrMsg("Fail to allocate buffer in CImageUtility::cvtImage32Fto16U()!\n");
            return false;
        }
        for (int i=0; i<(iplImage32F->width+4)*3; i++) {
            pErrBuf[i] = 0;
        }
        // error diffusion
        float *pErrBuf0 = pErrBuf + 2;
        float *pErrBuf1 = pErrBuf + (iplImage32F->width + 4) + 2;
        float *pErrBuf2 = pErrBuf + (iplImage32F->width + 4) * 2 + 2;
	    for (int y=0; y<iplImage32F->height; y++) {	
		    float *pSrc = (float *)((char *)iplImage32F->imageData + y * iplImage32F->widthStep);
            pErrBuf2[-2] = 0.0f;
            pErrBuf2[-1] = 0.0f;
            pErrBuf2[0] = 0.0f;
            pErrBuf2[1] = 0.0f;
            float err = 0.0f;
            for (int x=0; x<iplImage32F->width; x++) {
			    float val = pSrc[x] * factor + pErrBuf0[x] / 48.0f;
                int pix = (int)(val + 0.5f);
			    // clipping and calculate error (do not spread error when it is overflow)
                if (pix < 0) {
                    pImage16U[x] = 0;
                    err = 0.0f;
                } else if (pix > max_val) {
                    pImage16U[x] = (unsigned short)max_val;
                    err = 0.0f;
                } else {
                    pImage16U[x] = (unsigned short)pix;
                    err = val - (float)pix;
                }
                // diffuse
                pErrBuf0[x+1] += err*7; pErrBuf0[x+2] += err*5;
                pErrBuf1[x-2] += err*3; pErrBuf1[x-1] += err*5; pErrBuf1[x] += err*7; pErrBuf1[x+1] += err*5; pErrBuf1[x+2] += err*3;
                pErrBuf2[x-2] += err;   pErrBuf2[x-1] += err*3; pErrBuf2[x] += err*5; pErrBuf2[x+1] += err*3; pErrBuf2[x+2] = err;        // should referesh buffer
		    }
            // swap buffer
            float *temp = pErrBuf0;
            pErrBuf0 = pErrBuf1;
            pErrBuf1 = pErrBuf2;
            pErrBuf2 = temp;
            // next line
            pImage16U += widthStep;
	    }
    } else if ((cvt_method & SR_DEPTHCVT_ED2x2) != 0) {
        // 2x2 simplified error diffusion
        // | # 2 |  /
        // | 1 1 | / 4
        if (iplImage32F->nChannels != 1) {
            showErrMsg("Only support 1-channel error diffusion in CImageUtility::cvtImage32Fto16U()!\n");
            return false;
        }
        // allocate line buffer
        float *pErrBuf = new float[iplImage32F->width + 1];     // 2 more row to simplify the process
        if (pErrBuf == NULL) {
            showErrMsg("Fail to allocate buffer in CImageUtility::cvtImage32Fto16U()!\n");
            return false;
        }
        for (int i=0; i<iplImage32F->width+1; i++) {
            pErrBuf[i] = 0.0f;
        }
        // error diffusion
	    for (int y=0; y<iplImage32F->height; y++) {	
		    float *pSrc = (float *)((char *)iplImage32F->imageData + y * iplImage32F->widthStep);
            float err_x1 = 0.0f;
            float err = 0.0f;
            pErrBuf[0] = 0.0f;
            for (int x=0; x<iplImage32F->width; x++) {
			    float val = pSrc[x] * factor + err_x1 / 4.0f;
                int pix = (int)(val + 0.5f);
			    // clipping and calculate error (do not spread the error when it is overflow)
                if (pix < 0) {
                    pImage16U[x] = 0;
                    err = 0.0f; 
                } else if (pix > max_val) {
                    pImage16U[x] = (unsigned short)max_val;
                    err = 0.0f;
                } else {
                    pImage16U[x] = (unsigned short)pix;
                    err = val - (float)pix;
                }
                // diffuse
                err_x1 = pErrBuf[x+1] + err * 2;        // backup current diffused error
                pErrBuf[x] += err;
                pErrBuf[x+1] = err;                   // should refresh buffer
		    }
            // next line
            pImage16U += widthStep;
	    }
    } else {
        showErrMsg("Not implemented or unknown bit depth converion method in CImageUtility::cvtImage32Fto16U()!\n");
        return false;
    }

	return true;
}

bool CImageUtility::cvtImage32Fto16U(IplImage *iplImage32F, IplImage *iplImage16U, int bit_depth, int cvt_method)
// Convert a 32F image (0~255) to a 32S image with significant data of N bits. For example, 
// given a floating pixel value in iplImage32F I, the pixel value in the 12-bit iplImage32S is Cvt(I*16).
// arguments:
//		iplImage32F -- [I] input image, must be 32F data type
//		iplImage16U -- [O] output image, must be 16U data type must be word-aligned (32-bit) and with appropriate size
//		bit_depth -- [I] bit depth of the output image, should be 1~16
//      cvt_method -- [I] method to covert bitdepth:
//                        SR_DEPTHCVT_TRUNC       // truncation
//                        SR_DEPTHCVT_ROUND       // rounding
//                        SR_DEPTHCVT_EDFS        // Floyd-Steinberg error diffusion
//                        SR_DEPTHCVT_EDJJN       // Jarvis-Judice-Ninke error diffusion
//                        SR_DEPTHCVT_ED2x2       // 2x2 simplified error diffusion
// Return:
//		converted image, NULL for failure
// Luhong Liang, ICD-ASD, ASTRI
// Aug. 30, 2013
{
	// check input image
	if (iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F || iplImage16U == NULL || iplImage16U->depth != SR_DEPTH_16U) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage32Fto16U()!\n");
		return false;
	}
    if (iplImage32F->width != iplImage16U->width || iplImage32F->height != iplImage16U->height) {
		showErrMsg("Unmatched input and output image sizes in CImageUtility::cvtImage32Fto16U()!\n");
		return false;
	}

    // covnersion
    return cvtImage32Fto16U(iplImage32F, (unsigned short *)iplImage16U->imageData, bit_depth, cvt_method);
}

bool CImageUtility::cvtImage16Uto32F(unsigned short *pImage16U, IplImage *iplImage32F, int bit_depth)
// Convert an singed or unsigned integer image with bit depth N (in 32S data format) to a 32F image [-256~255]. For example, 
// supposing the input image is 12-bit singed value I, the 32F value will be (I/16).
// arguments:
//		pImage16U -- [I] input image, must be 16U data type
//		iplImage32F -- [O] input image, must be 32F data type
//		bit_depth -- [I] the bit depth of the input image, should be 1~16
// Return:
//		converted image, NULL for failure
// Luhong Liang, ICD-ASD, ASTRI
// Aug. 27, 2013
{
	// check input image
	if (pImage16U == NULL || iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid or unmatched input/output image format in CImageUtility::cvtImage16Uto32F()!\n");
		return false;
	}
	if (bit_depth > 16 || bit_depth < 1) {
		showErrMsg("Only support bit depth between 8 and 31 in CImageUtility::cvtImage16Uto32F()!\n");
		return false;
	}

	// convert
	float factor = (1 << bit_depth) / 256.0f;
    int widthStep = ((iplImage32F->width * iplImage32F->nChannels + 3) / 4) * 4;     // 32-bit aligned
    for (int y=0; y<iplImage32F->height; y++) {	
		float *pDst = (float *)((char*)iplImage32F->imageData + y * iplImage32F->widthStep);	
		for (int x=0; x<iplImage32F->width * iplImage32F->nChannels; x++) {
			// saturation
			float pix = (float)(pImage16U[x]);
			pDst[x] = pix / factor;
		}
        pImage16U += widthStep;
	}

	return true;
}

bool CImageUtility::cvtImage16Uto32F(IplImage *iplImage16U, IplImage *iplImage32F, int bit_depth)
// Convert an singed or unsigned integer image with bit depth N (in 32S data format) to a 32F image [-256~255]. For example, 
// supposing the input image is 12-bit singed value I, the 32F value will be (I/16).
// arguments:
//		iplImage16U -- [I] input image, must be 16U data type
//		iplImage32F -- [O] input image, must be 32F data type
//		bit_depth -- [I] the bit depth of the input image, should be 1~16
// Return:
//		converted image, NULL for failure
// Luhong Liang, ICD-ASD, ASTRI
// Aug. 30, 2013
{
	// check input image
	if (iplImage32F == NULL || iplImage32F->depth != SR_DEPTH_32F || iplImage16U == NULL || iplImage16U->depth != SR_DEPTH_16U) {
		showErrMsg("Invalid input image data type in CImageUtility::cvtImage16Uto32F()!\n");
		return false;
	}
    if (iplImage32F->width != iplImage16U->width || iplImage32F->height != iplImage16U->height) {
		showErrMsg("Unmatched input and output image sizes in CImageUtility::cvtImage16Uto32F()!\n");
		return false;
	}

    // conversion
    return cvtImage16Uto32F((unsigned short *)iplImage16U->imageData, iplImage32F, bit_depth);
}

bool CImageUtility::cvtImage16UtoMSB8U(IplImage *iplImage16U, IplImage *iplImage8U, int left_shift)
// Extract the MSB of the 16U and store as a 8U image
// Arguments:
//      iplImage16U -- [I] input 16U image
//      iplImage8U -- [O] output 8U image, must has the same size and channel number as the input image
//      left_shift -- [I] number of bits of left shifting before extract the MSB/LSB from the 16U
// Return: true for success
// by Luhong Liang, ICD-ASD, ASTRI, Sept. 3, 2013
{
    if (iplImage16U == NULL || iplImage16U->depth != SR_DEPTH_16U ||
        iplImage8U == NULL || iplImage8U->depth != SR_DEPTH_8U ||
        iplImage16U->width != iplImage8U->width || iplImage16U->height != iplImage8U->height || 
        iplImage16U->nChannels != iplImage8U->nChannels) {
        showErrMsg("Invalid input or output image in CImageUtility::cvtImage16UtoMSB8U()!\n");
        return false;
    }

    // extract MSB
    int right_shift_bits = 8 - left_shift;
    if (right_shift_bits > 0) {
        for (int y=0; y<iplImage8U->height; y++) {
            unsigned short *pSrc = (unsigned short *)((char *)iplImage16U->imageData + y * iplImage16U->widthStep);
            unsigned char *pDst = (unsigned char *)((char *)iplImage8U->imageData + y * iplImage8U->widthStep);
            for (int x=0; x<iplImage8U->width*iplImage8U->nChannels; x++) {
                unsigned short val = pSrc[x];
                val = val >> right_shift_bits;
                val = val > 255 ? 255 : val;
                pDst[x] = (unsigned char)(val);
            }
        }
    } else if (right_shift_bits < 0) {
        for (int y=0; y<iplImage8U->height; y++) {
            unsigned short *pSrc = (unsigned short *)((char *)iplImage16U->imageData + y * iplImage16U->widthStep);
            unsigned char *pDst = (unsigned char *)((char *)iplImage8U->imageData + y * iplImage8U->widthStep);
            for (int x=0; x<iplImage8U->width*iplImage8U->nChannels; x++) {
                unsigned short val = pSrc[x];
                val = val << (-right_shift_bits);
                val = val > 255 ? 255 : val;
                pDst[x] = (unsigned char)(val);
            }
        }
    } else {
        for (int y=0; y<iplImage8U->height; y++) {
            unsigned short *pSrc = (unsigned short *)((char *)iplImage16U->imageData + y * iplImage16U->widthStep);
            unsigned char *pDst = (unsigned char *)((char *)iplImage8U->imageData + y * iplImage8U->widthStep);
            for (int x=0; x<iplImage8U->width*iplImage8U->nChannels; x++) {
                unsigned short val = pSrc[x];
                val = val >> 8;
                pDst[x] = (unsigned char)(val);
            }
        }
    }

    return true;
}

IplImage *CImageUtility::cvtImage16UtoMSB8U(IplImage *iplImage16U, int left_shift)
// Extract the MSB of the 16U and store as a 8U image
// Arguments:
//      iplImage16U -- [I] input 16U image in 16U or 32F data format
//      left_shift -- [I] number of bits of left shifting before extract the MSB/LSB from the 16U
// Return: output 8U image
// by Luhong Liang, ICD-ASD, ASTRI, Sept. 3, 2013
{
    if (iplImage16U == NULL || (iplImage16U->depth != SR_DEPTH_16U && iplImage16U->depth != SR_DEPTH_32F)) {
        showErrMsg("Invalid input image in CImageUtility::cvtImage16UtoMSB8U()!\n");
        return false;
    }

    // allocate buffer
    IplImage *iplImage8U = createImage(iplImage16U->width, iplImage16U->height, SR_DEPTH_8U, iplImage16U->nChannels);
    if (iplImage8U == NULL) {
        showErrMsg("Fail to allocate image in CImageUtility::cvtImage16UtoMSB8U()!\n");
        return false;
    }
    
    if (iplImage16U->depth == SR_DEPTH_16U) {
        // extract MSB
        if (!cvtImage16UtoMSB8U(iplImage16U, iplImage8U, left_shift)) {
            safeReleaseImage(&iplImage8U);
            return NULL;
        } else {
            return iplImage8U;
        }
    } else {
        // convert to 16U
        IplImage *ipl16U = cvtImage32FtoUint(iplImage16U, 16, SR_DEPTH_16U, SR_DEPTHCVT_ROUND);
        if (ipl16U == NULL) {
            safeReleaseImage(&iplImage8U);
            return NULL;
        }
        // extract MSB
        if (!cvtImage16UtoMSB8U(ipl16U, iplImage8U, left_shift)) {
            safeReleaseImage(&iplImage8U, &iplImage8U);
            return NULL;
        } else {
            safeReleaseImage(&ipl16U);
            return iplImage8U;
        }
    }
}

bool CImageUtility::cvtImage16UtoLSB8U(IplImage *iplImage16U, IplImage *iplImage8U, bool clipping, int left_shift)
// Extract the LSB of the 16U and store as a 8U image
// Arguments:
//      iplImage16U -- [I] input 16U image
//      iplImage8U -- [O] output 8U image, must has the same size and channel number as the input image
//      clipping -- [I] if it is true, all the values larger than 255 is set to 255,otherwise the lower
//                      8 bits are directly extracts. For example, when it is 'true', LSB of 257 is 255;
//                      while when it is 'false', LSB of 257 becomes 1
//      left_shift -- [I] number of bits of left shifting before extract the MSB/LSB from the 16U
// Return: true for success
// by Luhong Liang, ICD-ASD, ASTRI, Sept. 3, 2013
// Added clipping on Sept. 17, 2013
{
    if (iplImage16U == NULL || iplImage16U->depth != SR_DEPTH_16U ||
        iplImage8U == NULL || iplImage8U->depth != SR_DEPTH_8U ||
        iplImage16U->width != iplImage8U->width || iplImage16U->height != iplImage8U->height || 
        iplImage16U->nChannels != iplImage8U->nChannels) {
        showErrMsg("Invalid input or output image in CImageUtility::cvtImage16UtoLSB8U()!\n");
        return false;
    }
    if (left_shift < 0) {
        showErrMsg("Only supports positive or zero left shift bit number in CImageUtility::cvtImage16UtoLSB8U()!\n");
        return false;
    }

    // extract LSB
    if (clipping) {
        for (int y=0; y<iplImage8U->height; y++) {
            unsigned short *pSrc = (unsigned short *)((char *)iplImage16U->imageData + y * iplImage16U->widthStep);
            unsigned char *pDst = (unsigned char *)((char *)iplImage8U->imageData + y * iplImage8U->widthStep);
            for (int x=0; x<iplImage8U->width*iplImage8U->nChannels; x++) {
                unsigned short val = pSrc[x];
                val = val << left_shift;
                val = val > 255 ? 255 : val;
                pDst[x] = (unsigned char)val;
            }
        }
    } else {
        for (int y=0; y<iplImage8U->height; y++) {
            unsigned short *pSrc = (unsigned short *)((char *)iplImage16U->imageData + y * iplImage16U->widthStep);
            unsigned char *pDst = (unsigned char *)((char *)iplImage8U->imageData + y * iplImage8U->widthStep);
            for (int x=0; x<iplImage8U->width*iplImage8U->nChannels; x++) {
                unsigned short val = pSrc[x];
                val = val << left_shift;
                pDst[x] = (unsigned char)(val & 0x000000FF);
            }
        }
    }

    return true;
}

IplImage *CImageUtility::cvtImage16UtoLSB8U(IplImage *iplImage16U, bool clipping, int left_shift)
// Extract the LSB of the 16U and store as a 8U image
// Arguments:
//      iplImage16U -- [I] input 16U image
//      clipping -- [I] if it is true, all the values larger than 255 is set to 255,otherwise the lower
//                      8 bits are directly extracts. For example, when it is 'true', LSB of 257 is 255;
//                      while when it is 'false', LSB of 257 becomes 1
//      left_shift -- [I] number of bits of left shifting before extract the MSB/LSB from the 16U
// Return: true for success
// by Luhong Liang, ICD-ASD, ASTRI, Sept. 3, 2013
// Added clipping on Sept. 17, 2013
{
    if (iplImage16U == NULL || (iplImage16U->depth != SR_DEPTH_16U && iplImage16U->depth != SR_DEPTH_32F)) {
        showErrMsg("Invalid input image in CImageUtility::cvtImage16UtoLSB8U()!\n");
        return false;
    }
    if (left_shift < 0) {
        showErrMsg("Only supports positive or zero left shift bit number in CImageUtility::cvtImage16UtoLSB8U()!\n");
        return false;
    }

    // allocate buffer
    IplImage *iplImage8U = createImage(iplImage16U->width, iplImage16U->height, SR_DEPTH_8U, iplImage16U->nChannels);
    if (iplImage8U == NULL) {
        showErrMsg("Fail to allocate image in CImageUtility::cvtImage16UtoLSB8U()!\n");
        return false;
    }
    
    if (iplImage16U->depth == SR_DEPTH_16U) {
        // extract LSB
        if (!cvtImage16UtoLSB8U(iplImage16U, iplImage8U, clipping, left_shift)) {
            safeReleaseImage(&iplImage8U);
            return NULL;
        } else {
            return iplImage8U;
        }
    } else {
        // convert to 16U
        IplImage *ipl16U = cvtImage32FtoUint(iplImage16U, 16, SR_DEPTH_16U, SR_DEPTHCVT_ROUND);
        if (ipl16U == NULL) {
            safeReleaseImage(&iplImage8U);
            return NULL;
        }
        // extract LSB
        if (!cvtImage16UtoLSB8U(ipl16U, iplImage8U, clipping, left_shift)) {
            safeReleaseImage(&iplImage8U, &iplImage8U);
            return NULL;
        } else {
            safeReleaseImage(&ipl16U);
            return iplImage8U;
        }
    }
}

IplImage *CImageUtility::diffusionImage32Fto8U(IplImage *iplImage32F)
// Convert a 32F image to a 8U image using error diffusion
// arguments:
//		iplImage8U -- [I] input image, must be 32F data type
// Return:
//		converted image, NULL for failure
{
    if (iplImage32F == NULL) {
        showErrMsg("Invalid input image in CImageUtility::diffusionImage32Fto8U()!\n");
        return NULL;
    }
    showErrMsg("Function not implemented in CImageUtility::diffusionImage32Fto8U()!\n");
	return NULL;
}

IplImage *CImageUtility::readImageMat(char stFilename[], int &bit_depth)
// Read a image from Matlab matrix data
// The file format is Height(uint16), Width(uint16), ColorPlane(uint16), DataType(uint16), ImageData(M x N x Channels raw data)
// Data type code:  'double', 'logical', 'single', 'uint8', 'int16', 'uint16' 
//						1			2		3			4		5		6
// Major Modifications: 
//		Change data range of floating point pixel to 0~255, Nov. 15, 2011
{
	// open file
	FILE *fp = fopen(stFilename, "rb");
	if (fp == NULL) {
		showErrMsg("Cannot open file %s!\n", stFilename);
		return NULL;
	}

	// read file header
	unsigned short header[4];
	int counts = (int)fread(header, sizeof(unsigned short), 4, fp);
	if (counts != 4) {
		showErrMsg("Fail to read image header in file %s!\n", stFilename);
		fclose(fp);
		return NULL;
	}

	// check file header
	int height = header[0];
	int width = header[1];
	int channels = header[2];
	int datatype = header[3];
	if (channels != 1 && channels != 3) {
		showErrMsg("Invalid channel number in image file %s!\n", stFilename);
		fclose(fp);
		return NULL;
	}
	
	// allocate image 
	IplImage *iplImage = NULL;
	int datasize = 0;
	switch (datatype) {
		case 1:		// double
            bit_depth = 64;
			iplImage = createImage(width, height, SR_DEPTH_64F, channels);
			datasize = sizeof(double);
			break;
		case 2:		// logical, actually uint8
		case 4:		// uint8
            bit_depth = 8;
			iplImage = createImage(width, height, SR_DEPTH_8U, channels);
			datasize = sizeof(unsigned char);
			break;
		case 3:		// single/float
            bit_depth = 32;
			iplImage = createImage(width, height, SR_DEPTH_32F, channels);
			datasize = sizeof(float);
			break;
		case 5:		// int16
            bit_depth = 16;
			iplImage = createImage(width, height, SR_DEPTH_16S, channels);
			datasize = sizeof(short);
			break;
		case 6:		// uint16
            bit_depth = 16;
			iplImage = createImage(width, height, SR_DEPTH_16U, channels);
			datasize = sizeof(unsigned short);
			break;
		default:
            bit_depth = 0;
			showErrMsg("Unsupported data type in image file %s!\n", stFilename);
			fclose(fp);
			return NULL;
	}
	if (iplImage == NULL) {
		showErrMsg("Fail to allocate image of size %dx%d with %d channels!\n", width, height, channels);
		fclose(fp);
		return NULL;
	}

	// allocate buffer
	unsigned char *pBuf = new unsigned char[width*height*channels*datasize];
	if (pBuf == NULL) {
		showErrMsg("Fail to allocate buffer!\n");
		releaseImage(&iplImage);
		fclose(fp);
		return NULL;
	}

	// load data
	counts = (int)fread(pBuf, datasize, width*height*channels, fp);
	if (counts != width*height*channels) {
		showErrMsg("Fail to load image raw data!\n");
		releaseImage(&iplImage);
		fclose(fp);
		return NULL;
	}
	fclose(fp);

	// convert data
	if (channels == 1) {	// grey scale image
		if (iplImage->depth == SR_DEPTH_64F) {
			double *pSrc = (double *)pBuf;
			for (int y=0; y<height; y++) {
				double *pDst = (double *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[x] = pSrc[y+x*height];			// / 255.0;
				}
			}
		} else if (iplImage->depth == SR_DEPTH_32F){
			float *pSrc = (float *)pBuf;
			for (int y=0; y<height; y++) {
				float *pDst = (float *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[x] = pSrc[y+x*height];			// / 255.0f;
				}
			}
		} else if (iplImage->depth == SR_DEPTH_16U){
			unsigned short *pSrc = (unsigned short *)pBuf;
			for (int y=0; y<height; y++) {
				unsigned short *pDst = (unsigned short *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[x] = pSrc[y+x*height];
				}
			}
		} else if (iplImage->depth == SR_DEPTH_16S){
			short *pSrc = (short *)pBuf;
			for (int y=0; y<height; y++) {
				short *pDst = (short *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[x] = pSrc[y+x*height];
				}
			}
		} else if (iplImage->depth == SR_DEPTH_8U){
			unsigned char *pSrc = (unsigned char *)pBuf;
			for (int y=0; y<height; y++) {
				unsigned char *pDst = (unsigned char *)iplImage->imageData + y*iplImage->widthStep;		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[x] = pSrc[y+x*height];
				}
			}
		}
	
	} else {		// true-color image
		if (iplImage->depth == SR_DEPTH_64F) {
			double *pSrc = (double *)pBuf;
			for (int y=0; y<height; y++) {
				double *pDst = (double *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[x*3+2] = pSrc[y+x*height];					// / 255.0;
					pDst[x*3+1] = pSrc[width*height+y+x*height];	// / 255.0;
					pDst[x*3] = pSrc[width*height*2+y+x*height];	// / 255.0;
				}
			}
		} else if (iplImage->depth == SR_DEPTH_32F){
			float *pSrc = (float *)pBuf;
			for (int y=0; y<height; y++) {
				float *pDst = (float *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[x*3+2] = pSrc[y+x*height];					// / 255.0f;
					pDst[x*3+1] = pSrc[width*height+y+x*height];	// / 255.0f;
					pDst[x*3] = pSrc[width*height*2+y+x*height];	// / 255.0f;
				}
			}
		} else if (iplImage->depth == SR_DEPTH_16U){
			unsigned short *pSrc = (unsigned short *)pBuf;
			for (int y=0; y<height; y++) {
				unsigned short *pDst = (unsigned short *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[x*3+2] = pSrc[y+x*height];
					pDst[x*3+1] = pSrc[width*height+y+x*height];
					pDst[x*3] = pSrc[width*height*2+y+x*height];
				}
			}
		} else if (iplImage->depth == SR_DEPTH_16S){
			short *pSrc = (short *)pBuf;
			for (int y=0; y<height; y++) {
				short *pDst = (short *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[x*3+2] = pSrc[y+x*height];
					pDst[x*3+1] = pSrc[width*height+y+x*height];
					pDst[x*3] = pSrc[width*height*2+y+x*height];
				}
			}
		} else if (iplImage->depth == SR_DEPTH_8U){
			unsigned char *pSrc = (unsigned char *)pBuf;
			for (int y=0; y<height; y++) {
				unsigned char *pDst = (unsigned char *)iplImage->imageData + y*iplImage->widthStep;		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[x*3+2] = pSrc[y+x*height];
					pDst[x*3+1] = pSrc[width*height+y+x*height];
					pDst[x*3] = pSrc[width*height*2+y+x*height];
				}
			}
		}
	}

	delete [] pBuf;

	return iplImage;
}

bool CImageUtility::writeImageMat(IplImage *iplImage, char stFilename[])
// Write a image to Matlab matrix data
// The file format is Height(uint16), Width(uint16), ColorPlane(uint16), DataType(uint16), ImageData(M x N x Channels raw data)
// Data type code:  'double', 'logical', 'single', 'uint8', 'int16', 'uint16' 
//						1			2		3			4		5		6
// Major Modifications: 
//		Change data range of floating point pixel to 0~255, Nov. 15, 2011
{
	// check image
	if (iplImage == NULL) {
		showErrMsg("Invalid input image!\n");
		return false;
	}
	int width = iplImage->width;
	int height = iplImage->height;
	int channels = iplImage->nChannels;
	if (channels != 1 && channels != 3) {
		showErrMsg("Invalid channel number in input image!\n");
		return false;
	}

	// open file
	FILE *fp = fopen(stFilename, "wb+");
	if (fp == NULL) {
		showErrMsg("Cannot open/create file %s!\n", stFilename);
		return false;
	}

	// write file header
	unsigned short header[4];
	header[0] = (unsigned short)height;
	header[1] = (unsigned short)width;
	header[2] = (unsigned short)channels;
	int datasize = 0;
	switch (iplImage->depth) {
		case SR_DEPTH_64F:		// double
			datasize = sizeof(double);
			header[3] = 1;
			break;
		case SR_DEPTH_32F:		// single/float
			datasize = sizeof(float);
			header[3] = 3;
			break;
		case SR_DEPTH_8U:		// uint8
			datasize = sizeof(unsigned char);
			header[3] = 4;
			break;
		case SR_DEPTH_16S:		// int16
			datasize = sizeof(short);
			header[3] = 5;
			break;
		case SR_DEPTH_16U:		// uint16
			datasize = sizeof(unsigned short);
			header[3] = 6;
			break;
		default:
			showErrMsg("Unsupported data type in image file %s!\n", stFilename);
			fclose(fp);
			return NULL;
	}
	int counts = (int)fwrite(header, sizeof(unsigned short), 4, fp);
	if (counts != 4) {
		showErrMsg("Fail to write image header to file %s!\n", stFilename);
		fclose(fp);
		return false;
	}

	// allocate buffer
	unsigned char *pBuf = new unsigned char[width*height*channels*datasize];
	if (pBuf == NULL) {
		showErrMsg("Fail to allocate buffer!\n");
		releaseImage(&iplImage);
		fclose(fp);
		return false;
	}

	// convert data
	if (channels == 1) {	// grey scale image
		if (iplImage->depth == SR_DEPTH_64F) {
			double *pDst = (double *)pBuf;
			for (int y=0; y<height; y++) {
				double *pSrc = (double *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[y+x*height] = pSrc[x];				// * 255.0;
				}
			}
		} else if (iplImage->depth == SR_DEPTH_32F){
			float *pDst = (float *)pBuf;
			for (int y=0; y<height; y++) {
				float *pSrc = (float *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[y+x*height] = pSrc[x];				// * 255.0f;
				}
			}
		} else if (iplImage->depth == SR_DEPTH_16U){
			unsigned short *pDst = (unsigned short *)pBuf;
			for (int y=0; y<height; y++) {
				unsigned short *pSrc = (unsigned short *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[y+x*height] = pSrc[x];
				}
			}
		} else if (iplImage->depth == SR_DEPTH_16S){
			short *pDst = (short *)pBuf;
			for (int y=0; y<height; y++) {
				short *pSrc = (short *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[y+x*height] = pSrc[x];
				}
			}
		} else if (iplImage->depth == SR_DEPTH_8U){
			unsigned char *pDst = (unsigned char *)pBuf;
			for (int y=0; y<height; y++) {
				unsigned char *pSrc = (unsigned char *)iplImage->imageData + y*iplImage->widthStep;		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[y+x*height] = pSrc[x];
				}
			}
		}
	
	} else {		// true-color image
		if (iplImage->depth == SR_DEPTH_64F) {
			double *pDst = (double *)pBuf;
			for (int y=0; y<height; y++) {
				double *pSrc = (double *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[y+x*height] = pSrc[x*3+2];					// * 255.0;
					pDst[width*height+y+x*height] = pSrc[x*3+1];	// * 255.0;
					pDst[width*height*2+y+x*height] = pSrc[x*3];	// * 255.0;
				}
			}
		} else if (iplImage->depth == SR_DEPTH_32F){
			float *pDst = (float *)pBuf;
			for (int y=0; y<height; y++) {
				float *pSrc = (float *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[y+x*height] = pSrc[x*3+2];					// * 255.0f;
					pDst[width*height+y+x*height] = pSrc[x*3+1];	// * 255.0f;
					pDst[width*height*2+y+x*height] = pSrc[x*3];	// * 255.0f;
				}
			}
		} else if (iplImage->depth == SR_DEPTH_16U){
			unsigned short *pDst = (unsigned short *)pBuf;
			for (int y=0; y<height; y++) {
				unsigned short *pSrc = (unsigned short *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[y+x*height] = pSrc[x*3+2];
					pDst[width*height+y+x*height] = pSrc[x*3+1];
					pDst[width*height*2+y+x*height] = pSrc[x*3];
				}
			}
		} else if (iplImage->depth == SR_DEPTH_16S){
			short *pDst = (short *)pBuf;
			for (int y=0; y<height; y++) {
				short *pSrc = (short *)((char *)iplImage->imageData + y*iplImage->widthStep);		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[y+x*height] = pSrc[x*3+2];
					pDst[width*height+y+x*height] = pSrc[x*3+1];
					pDst[width*height*2+y+x*height] = pSrc[x*3];
				}
			}
		} else if (iplImage->depth == SR_DEPTH_8U){
			unsigned char *pDst = (unsigned char *)pBuf;
			for (int y=0; y<height; y++) {
				unsigned char *pSrc = (unsigned char *)iplImage->imageData + y*iplImage->widthStep;		// NOTE: widthStep is counted by BYTE!
				for (int x=0; x<width; x++) {
					pDst[y+x*height] = pSrc[x*3+2];
					pDst[width*height+y+x*height] = pSrc[x*3+1];
					pDst[width*height*2+y+x*height] = pSrc[x*3];
				}
			}
		}
	}

	// write data
	counts = (int)fwrite(pBuf, datasize, width*height*channels, fp);
	if (counts != width*height*channels) {
		showErrMsg("Fail to write image raw data!\n");
		releaseImage(&iplImage);
		fclose(fp);
		return false;
	}
	fclose(fp);

	delete [] pBuf;

	return true;
}

bool CImageUtility::writeImageMat(float *pImage, int nWidth, int nHeight, char stFilename[])
// Write a image to Matlab matrix data
// The file format is Height(uint16), Width(uint16), ColorPlane(uint16), DataType(uint16), ImageData(M x N x Channels raw data)
// Data type code:  'double', 'logical', 'single', 'uint8', 'int16', 'uint16' 
//						1			2		3			4		5		6
{
	// check image
	if (pImage == NULL) {
		showErrMsg("Invalid input image!\n");
		return false;
	}

	// allocate buffer
	float *pBuf = new float[nWidth*nHeight];
	if (pBuf == NULL) {
		showErrMsg("Fail to allocate buffer!\n");
		return false;
	}


	// open file
	FILE *fp = fopen(stFilename, "wb+");
	if (fp == NULL) {
		showErrMsg("Cannot open/create file %s!\n", stFilename);
		delete [] pBuf;
		return false;
	}

	// write file header
	unsigned short header[4];
	header[0] = (unsigned short)nHeight;
	header[1] = (unsigned short)nWidth;
	header[2] = 1;
	int datasize = 0;
	datasize = sizeof(float);		// single/float
	header[3] = 3;
	int counts = (int)fwrite(header, sizeof(unsigned short), 4, fp);
	if (counts != 4) {
		showErrMsg("Fail to write image header to file %s!\n", stFilename);
		delete [] pBuf;
		fclose(fp);
		return false;
	}

	// modify data order
	for (int y=0; y<nHeight; y++) {
		float *pSrc = pImage + y * nWidth;
		for (int x=0; x<nWidth; x++) {
			pBuf[y+x*nHeight] = pSrc[x];
		}
	}

	// write data
	counts = (int)fwrite((void*)pBuf, datasize, nWidth*nHeight, fp);
	fclose(fp);
	delete [] pBuf;
	if (counts != nWidth*nHeight) {
		showErrMsg("Fail to write image raw data!\n");
		return false;
	}

	return true;
}

IplImage *CImageUtility::loadImageVector(char stFilename[], int width, int height, int channel, int bit_depth)
// load an image in a form of text testing vector
// only support 8U and 10 bit data
{
	if (stFilename == NULL || bit_depth < 8 || bit_depth > 16 || width < 1 || height < 1 || channel != 1) {		// TODO: support color image
		showErrMsg("Invalid filename, size or denoted bit depth in CImageUtility::loadImageVector()!\n");
		return NULL;
	}

	IplImage *iplImage = NULL;

	// ----------------------------------
	// 8U image
	// ----------------------------------
	if (bit_depth == 8) {
		// allocate image
		iplImage = createImage(width, height, SR_DEPTH_8U, channel);
		if (iplImage == NULL) {
			showErrMsg("Fail to allocate image buffer in CImageUtility::loadImageVector()!\n");
			return NULL;
		}
		// open file
		FILE *fp = fopen(stFilename, "rt");
		if (fp == NULL) {
			showErrMsg("Fail to open testing vector file %s!\n", stFilename);
			safeReleaseImage(&iplImage);
			return NULL;
		}
		// load data
		int n = 0;
		char stData[16];
		bool bError = false;
		for (int y=0; y<iplImage->height; y++) {
			unsigned char *pDst = (unsigned char *)iplImage->imageData + y * iplImage->widthStep;
			for (int x=0; x<iplImage->width; x++) {
				// load text data
				if (fgets(stData, 15, fp) == NULL) {
					showErrMsg("Fail to load data!\n");
					bError = true;
					break;
				}
				// parse and check 
				int nData;
				if (sscanf(stData, "%X", &nData) != 1) {
					showErrMsg("Fail to load data!\n");
					bError = true;
					break;
				}
				if (nData < 0 || nData > 255) {
					showErrMsg("Invalid 8U data loaded!\n");
					bError = true;
					break;
				}
				pDst[x] = (unsigned char)nData;
				// next item
				n++;
			}
			if (bError) break;
		}
		fclose(fp);
		if (bError) {
			showErrMsg("Error happened in line %d\n", n);
			return NULL;
		}

		return iplImage;
	}

	// ----------------------------------
	// 32S image
	// ----------------------------------
	if (bit_depth > 8 && bit_depth <= 16) {
		// allocate image
		iplImage = createImage(width, height, SR_DEPTH_32S, channel);
		if (iplImage == NULL) {
			showErrMsg("Fail to allocate image buffer in CImageUtility::loadImageVector()!\n");
			return NULL;
		}
		// open file
		FILE *fp = fopen(stFilename, "rt");
		if (fp == NULL) {
			showErrMsg("Fail to open testing vector file %s!\n", stFilename);
			safeReleaseImage(&iplImage);
			return NULL;
		}
		// load data
		int n = 0;
		char stData[16];
		bool bError = false;
		for (int y=0; y<iplImage->height; y++) {
			int *pDst = (int *)((char*)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0; x<iplImage->width; x++) {
				// load text data
				if (fgets(stData, 15, fp) == NULL) {
					showErrMsg("Fail to load data!\n");
					bError = true;
					break;
				}
				// parse and check 
				int nData;
				if (sscanf(stData, "%X", &nData) != 1) {		// read more bits to find possible data error
					showErrMsg("Fail to load data!\n");
					bError = true;
					break;
				}
				if (nData < 0 || nData > 65535) {
					showErrMsg("Invalid 32s (bit depth 8~16) data loaded!\n");
					bError = true;
					break;
				}
				// convert to signed data
				if (nData < 32768) {
					pDst[x] = nData;
				} else {
					pDst[x] = (int)((unsigned int)nData | 0xFFFF0000);
				}
				// next item
				n++;
			}
			if (bError) break;
		}
		fclose(fp);
		if (bError) {
			showErrMsg("Error happened in line %d of the data file.\nFound in function CImageUtility::writeImageVector()", n);
			return NULL;
		}

		return iplImage;
	}

	return NULL;
}

bool CImageUtility::writeImageVector(char stFilename[], IplImage *iplImage, bool signed_int, int bit_depth, int channel)
// write an image into a of text testing vector, where each line is a pixel in hex format of 2 or 4 characters
// only support 8U and 10 bit data

{
	if (stFilename == NULL || bit_depth < 8 || bit_depth > 16 || iplImage->width < 1 || iplImage->height < 1) {		// TODO: support color image
		showErrMsg("Invalid filename, size or denoted bit depth in CImageUtility::writeImageVector()!\n");
		return false;
	}

    if (iplImage->nChannels == 1) {
        channel = 0;
    } else if (channel >= iplImage->nChannels) {
        showErrMsg("Invalid channel number in CImageUtility::writeImageVector()!\n");
        return false;
    }

	// ----------------------------------
	// 8U image
	// ----------------------------------
	if (iplImage->depth == SR_DEPTH_8U) {
		// create file
		FILE *fp = fopen(stFilename, "wt+");
		if (fp == NULL) {
			showErrMsg("Fail to create testing vector file %s!\n", stFilename);
			return NULL;
		}
		// load data
		//bool bError = false;
		for (int y=0; y<iplImage->height; y++) {
			unsigned char *pSrc = (unsigned char *)iplImage->imageData + y * iplImage->widthStep;
			for (int x=0; x<iplImage->width; x++) {
                int idx = x*iplImage->nChannels + channel;
				fprintf(fp, "%02X\n", pSrc[idx]);
			}
		}
		fclose(fp);

		return true;
	}

	// ----------------------------------
	// 32 image (signed)
	// ----------------------------------
	if (iplImage->depth == SR_DEPTH_32S && signed_int) {
		// create file
		FILE *fp = fopen(stFilename, "wt+");
		if (fp == NULL) {
			showErrMsg("Fail to create testing vector file %s!\n", stFilename);
			return NULL;
		}
		// load data
		int bound_unsigned = 1;
		bound_unsigned = bound_unsigned << bit_depth;
		int bound_up = bound_unsigned / 2 - 1;
		int bound_bt = - bound_unsigned / 2;
		bool bError = false;
		for (int y=0; y<iplImage->height; y++) {
			int *pSrc = (int *)((char*)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0; x<iplImage->width; x++) {
				// check data
                int idx = x*iplImage->nChannels + channel;
				int pix_data = pSrc[idx];
				if (pix_data < bound_bt || pix_data > bound_up) {
					showErrMsg("Overflowed data found at <%d, %d> in the input image %s!\n", x, y, stFilename);
					bError = true;
					break;
				}
				// write data
				fprintf(fp, "%04X\n", (unsigned short)pix_data);
			}
			if (bError) break;
		}
		fclose(fp);
		
		if (bError) {
			showErrMsg("Found by function CImageUtility::writeImageVector().\n");
			return false;
		}

		return true;
	}

	// ----------------------------------
	// 32 image (unsigned)
	// ----------------------------------
	if (iplImage->depth == SR_DEPTH_32S && (!signed_int)) {
		// create file
		FILE *fp = fopen(stFilename, "wt+");
		if (fp == NULL) {
			showErrMsg("Fail to create testing vector file %s!\n", stFilename);
			return NULL;
		}
		// load data
		int bound_unsigned = 1;
		int bound_up = (bound_unsigned << bit_depth) - 1;
		bool bError = false;
		for (int y=0; y<iplImage->height; y++) {
			int *pSrc = (int *)((char*)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0; x<iplImage->width; x++) {
				// check data
                int idx = x*iplImage->nChannels + channel;
				int pix_data = pSrc[idx];
				if (pix_data < 0 || pix_data > bound_up) {
					showErrMsg("Overflowed data found at <%d, %d> in the input image %s!\n", x, y, stFilename);
					bError = true;
					break;
				}
				// write data
				fprintf(fp, "%04X\n", (unsigned short)pix_data);
			}
			if (bError) break;
		}
		fclose(fp);
		
		if (bError) {
			showErrMsg("Found by function CImageUtility::writeImageVector().\n");
			return false;
		}

		return true;
	}

	return false;
}

bool CImageUtility::writeImageBlocks_Y12(char stFilename[], IplImage *iplImage, bool signed_int, int bit_depth, int channel)
// write an image into a of text testing vector, where each line is a pixel in hex format of 2 or 4 characters
// only support 8U and 10 bit data

{
	if (stFilename == NULL || bit_depth < 8 || bit_depth > 16 || iplImage->width < 1 || iplImage->height < 1 ||
        signed_int) {		// currenty only support signed_int == false
		showErrMsg("Invalid filename, size or denoted bit depth in CImageUtility::writeImageBlocks_Y12()!\n");
		return false;
	}

    if (iplImage->nChannels == 1) {
        channel = 0;
    } else if (channel >= iplImage->nChannels) {
        showErrMsg("Invalid channel number in CImageUtility::writeImageBlocks_Y12()!\n");
        return false;
    }

	// ----------------------------------
	// 8U image
	// ----------------------------------
	if (iplImage->depth == SR_DEPTH_8U) {
		// create file
		FILE *fp = fopen(stFilename, "wt+");
		if (fp == NULL) {
			showErrMsg("Fail to create testing vector file %s in CImageUtility::writeImageBlocks_Y12()!\n", stFilename);
			return NULL;
		}
		// load data
		//bool bError = false;
		for (int y=0; y<iplImage->height; y+=12) {
			unsigned char *pSrc = (unsigned char *)iplImage->imageData + y * iplImage->widthStep;
			for (int x=0; x<iplImage->width; x++) {
                int idx = x*iplImage->nChannels + channel;

				for (int z=0; z<12; z++){
                    fprintf(fp, "%02X", pSrc[idx+z*(iplImage->widthStep)]);
				}
				fprintf(fp, "\n");
			}
		}
		fclose(fp);

		return true;
	}
	else {
		showErrMsg("Only support 8U input in CImageUtility::writeImageBlocks_Y12()");
		return false;
	}
	
}

bool CImageUtility::writeImageBlocks_X8(char stFilename[], IplImage *iplImage, bool signed_int, int bit_depth, int channel, int offset)
// write an image into a of text testing vector, where each line is a pixel in hex format of 2 or 4 characters
// only support 8U and 10 bit data

{
	if (stFilename == NULL || bit_depth < 8 || bit_depth > 16 || iplImage->width < 1 || iplImage->height < 1 ||
        signed_int) {		// currenty only support signed_int == false
		showErrMsg("Invalid filename, size or denoted bit depth in CImageUtility::writeImageBlocks_X8()!\n");
		return false;
	}

    if (iplImage->nChannels == 1) {
        channel = 0;
    } else if (channel >= iplImage->nChannels) {
        showErrMsg("Invalid channel number in CImageUtility::writeImageBlocks_X8()!\n");
        return false;
    }


	// ----------------------------------
	// 8U image
	// ----------------------------------
	if (iplImage->depth == SR_DEPTH_8U) {
		// create file
		FILE *fp = fopen(stFilename, "wt+");
		if (fp == NULL) {
			showErrMsg("Fail to create testing vector file %s in CImageUtility::writeImageBlocks_X8()!\n", stFilename);
			return NULL;
		}
		// load data
		//bool bError = false;
		//long long sum=0;
		int jump=0;
		for (int y=offset; y<iplImage->height; y++) {
			unsigned char *pSrc = (unsigned char *)iplImage->imageData + y * iplImage->widthStep;
			for (int x=0; x<iplImage->width; x+=8) {
                int idx = x*iplImage->nChannels + channel;

				for (int z=0; z<8; z++){
                    fprintf(fp, "%02X", pSrc[idx+z]);
                    //sum += pSrc[idx+z];
				}
				fprintf(fp, "\n");
			}
			jump++;
			if (jump==12) {jump=0; y= y+12;}
		}
		fclose(fp);

		//sum= sum/((iplImage->height*iplImage->width)/2);

		return true;
	}
	else {
		showErrMsg("Only support 8U input in CImageUtility::writeImageBlocks_X8()");
		return false;
	}
	
}

bool CImageUtility::addFileSuffix(char stSrcFilename[], char stSuffix[], char stDstFilename[])		
// Add suffix to a file name
{
	if (stSrcFilename == NULL || stSuffix == NULL || stDstFilename == NULL) {
		strcpy(stDstFilename, "");
		return false;
	}

	char stExt[256];
	char stPre[256];
	getFileExt(stSrcFilename, stExt);
	getFilePre(stSrcFilename, stPre);

	sprintf(stDstFilename, "%s%s.%s", stPre, stSuffix, stExt);

	return true;
}

bool CImageUtility::addFrameNum(char szSrcFile[], int num, char szDstFile[])		
// Add frame number as suffix of a file name
//   szSrcFile -- [I] original file name. Generally, the file format should be
//                    "xxxx####xxx.xxx", where '#'s represent the position of the frame
//                    number, and 'x' are valid filename characters other than '#'. 
//                    The frame number will replace the '#'s in the resultant filename.
//                    The number of '#' determine the length of the frame number.
//                    For example, the input file name is "Test_####_VEUHD.bmp", if 
//                    the frame number is 16, the resultant file name is "Test_0016_VEUHD.bmp".
//                    If the character '#' does not appear, the frame number will be placed
//                    at the end of the file name with 6 characters. For example, if the input
//                    file name is "Test.bmp", the resultant file will be "Test000016.bmp".
//   n -- [I] frame number. When the nubmer exceeds the limitation of the number of '#'s or 6,
//            the actual number will be added.
//   szDstFile -- [O] resultant file name.
{
	if (szSrcFile == NULL || szDstFile == NULL) {
		strcpy(szDstFile, "");
		return false;
	}
    
    const int dft_num_len = 6;

    char szSuffix[32];
	char szExt[256];
	char szPre[256];
	getFileExt(szSrcFile, szExt);
	getFilePre(szSrcFile, szPre);

    int len_ext = (int)strlen(szExt);

    // search '#'
    int len_pre = (int)strlen(szPre);
    int pond_start, pond_end, i;
    bool bHit = false;
    for (i=len_pre-1; i>=0 && !bHit; i--) {
        if (szPre[i] == '#') bHit = true;
    }

    // identify the position of the '#'s
    int tar_char_num;
    if (bHit) {
        pond_end = i + 1;
        pond_start = pond_end;
        while (szPre[i] == '#' && i>=0) {
            pond_start = i;
            i--;
        }
        tar_char_num = pond_end - pond_start + 1;
    } else {
        pond_start = len_pre;
        pond_end = pond_start;
        tar_char_num = dft_num_len;
    }
	
    // generate frame number suffix
    sprintf(szSuffix, "%d", num);
    int suffix_len = (int)strlen(szSuffix);
    if (suffix_len < tar_char_num) {
        szSuffix[tar_char_num] = 0;
        for (int j=0; j<suffix_len; j++) {
            szSuffix[tar_char_num-1-j] = szSuffix[suffix_len-1-j];
        }
        for (int j=0; j<tar_char_num-suffix_len; j++) {
            szSuffix[j] = '0';
        }
        suffix_len = tar_char_num;
    }
    if (suffix_len + len_pre + len_ext + 1 > 255) {
        showErrMsg("The length of file name exceeds 255!\n");
		strcpy(szDstFile, "");
		return false;
	}

    // replace the '#'s by suffix
    int n=0;
    for (i=0; i<pond_start; i++, n++) { // first part
        szDstFile[n] = szSrcFile[i];
    }
    for (i=0; i<suffix_len; i++, n++) { // frame number (use suffix_len, since it is possibly suffix_len > tar_char_num.
        szDstFile[n] = szSuffix[i];
    }
    for (i=pond_end+1; i<len_pre; i++, n++) {
        szDstFile[n] = szSrcFile[i];
    }
    szDstFile[n] = 0;

    // add extension
    sprintf(szDstFile, "%s.%s", szDstFile, szExt);

	return true;
}


bool CImageUtility::getFileExt(char stFilename[], char stFileExt[])
// get file extension
{
	if (stFilename == NULL) {
		stFileExt[0] = 0;
		return false;
	}

	int len = (int)strlen(stFilename);
	if (len < 1) {
		stFileExt[0] = 0;
		return false;
	}

	int count;
	bool bFindDot = false;
	for (count= len-1; count>0; count--) {
		if (stFilename[count] == '.')  {
			bFindDot = true;
			break;
		}
	}
	if (!bFindDot) {
		stFileExt[0] = 0;
		return false;
	}

	for (int i=0; i<len-count-1; i++) {
		stFileExt[i] = stFilename[count+i+1];
	}
	stFileExt[len-count-1] = 0;
	return true;
}

bool CImageUtility::getFilePre(char stFilename[], char stFilePre[])
// get file prefix (with path)
{
	int len = (int)strlen(stFilename);
	int count = 1;
	while (stFilename[len - count] != '.' && count < len) count++;
	if (count == len) {
		strcpy(stFilePre, stFilename);
		return true;
	}

	for (int i=0; i<(len-count); i++) {
		stFilePre[i] = stFilename[i];
	}
	stFilePre[len-count] = 0;
	return true;
}

char *CImageUtility::getFilename(char stFilePath[], char stFilename[])
{
	if (stFilePath == NULL || stFilename == NULL)
		return NULL;

	char *pFilename = strrchr(stFilePath, '\\');
	if (pFilename == NULL) {
		strncpy(stFilename, stFilePath, 256);
	} else { 
		pFilename++;
		strncpy(stFilename, pFilename, 256);
	}

	return stFilename;
}

char *CImageUtility::getFilePath(char stFilename[], char stFilePath[])
{
	if (stFilename == NULL || stFilePath == NULL)
		return NULL;

	char *pFilename = strrchr(stFilename, '\\');
	if (pFilename == NULL) {
		stFilePath[0] = 0;
	} else {
		int len = (int)(pFilename - stFilename);
		strncpy(stFilePath, stFilename, len);
		stFilePath[len] = 0;
	}

	return stFilePath;
}

bool CImageUtility::isVideoFile(char stFilename[])
{
	static char ppSupportedVideoExt[][16] = { "mpg", "mpeg", "wmv", "rm", "rmvb", "mkv", "avi", "mp4", 
                                                                    "vob", "mov",
											                        "idx", "iml"};		// this is our customized YUV index file
	static int nVideoExtListLen = 12;

	char stFileExt[32];
	if (!CImageUtility::getFileExt(stFilename, stFileExt)) {
		showErrMsg("Invalid file extension!\n");
		return false;
	}
	char *pExt = strlwr(stFileExt);
	for (int i=0; i<nVideoExtListLen; i++) {
		if (strcmp(pExt, ppSupportedVideoExt[i]) == 0) 
			return true;
	}

	return false;
}

bool CImageUtility::isImageFile(char stFilename[])
{
	static char ppSupportedVideoExt[][16] = { "bmp", "dib", "jpg", "jpeg", "jpe", "jp2", "png", "pbm", 
											  "pgm", "ppm", "sr", "ras", "tiff", "tif", "dat"};
	static int nVideoExtListLen = 15;

	char stFileExt[32];
	if (!CImageUtility::getFileExt(stFilename, stFileExt)) {
		showErrMsg("Invalid file extension!\n");
		return false;
	}
	char *pExt = strlwr(stFileExt);
	for (int i=0; i<nVideoExtListLen; i++) {
		if (strcmp(pExt, ppSupportedVideoExt[i]) == 0) 
			return true;
	}

	return false;
}

// process image
bool CImageUtility::meanPyrDown(IplImage *iplSrcImage, IplImage *iplDstImage)
// Create a pyramid image of half size of the original one
// Yp(x,y) = Y(2x, 2y) + Y(2x+1, 2y) + Y(2x, 2y+1) + Y(2x+1, 2y+1)
// This function supports all data types
// by Luhong Liang, IC-ASD, ASTRI, Oct. 20, 2011
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in meanPryDown()!\n");
		return false;
	}

	switch (iplSrcImage->depth) {
		case SR_DEPTH_8U:
			return meanPyrDown_8u(iplSrcImage, iplDstImage);
		case SR_DEPTH_32F:
			return meanPyrDown_32f(iplSrcImage, iplDstImage);
		default:
			showErrMsg("Invalid input image data type in meanPryDown()!\n");
			return false;
	}
}

bool CImageUtility::meanPyrDownHalfPel(IplImage *iplSrcImage, IplImage *iplDstImage)
// Create a pyramid image of half size of the original one
// Yp(x,y) = Y(x, y) + Y(x+1, y) + Y(x, y+1) + Y(x+1, y+1)
// This function supports all data types
// by Luhong Liang, IC-ASD, ASTRI, Oct. 20, 2011
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in meanPyrDownHalfPel()!\n");
		return false;
	}

	switch (iplSrcImage->depth) {
		case SR_DEPTH_8U:
			return meanPyrDownHalfPel_8u(iplSrcImage, iplDstImage);
		case SR_DEPTH_32F:
			return meanPyrDownHalfPel_32f(iplSrcImage, iplDstImage);
		default:
			showErrMsg("Invalid input image data type in meanPyrDownHalfPel()!\n");
			return false;
	}
}

bool CImageUtility::meanPyrDown_8u(IplImage *iplSrcImage, IplImage *iplDstImage)
// Create a pyramid image of half size of the original one
// Yp(x,y) = Y(2x, 2y) + Y(2x+1, 2y) + Y(2x, 2y+1) + Y(2x+1, 2y+1)
// by Luhong Liang, IC-ASD, ASTRI, Oct. 20, 2011
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in meanPryDown()!\n");
		return false;
	}
	if (iplSrcImage->width/2 != iplDstImage->width || 
		iplSrcImage->height/2 != iplDstImage->height || 
		iplSrcImage->nChannels != iplDstImage->nChannels) {
		showErrMsg("Destination image should be half size of the source image!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image data type! Should be unsigned 8-bit.\n");
		return false;
	}

	// calcluate pyramid image
	for (int y=0; y<iplDstImage->height; y++) {
		unsigned char *pSrc1 = (unsigned char*)(iplSrcImage->imageData + 2 * y * iplSrcImage->widthStep);
		unsigned char *pSrc2 = (unsigned char*)(iplSrcImage->imageData + (2*y+1) * iplSrcImage->widthStep);
		unsigned char *pDst = (unsigned char*)(iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, xx=0; x<iplDstImage->width; x++, xx+=2) {
			pDst[x] = (pSrc1[xx] + pSrc1[xx+1] + pSrc2[xx] + pSrc2[xx+1] + 2) >> 2;
		}
	}

	return true;
}

bool CImageUtility::meanPyrDownHalfPel_8u(IplImage *iplSrcImage, IplImage *iplDstImage)
// Create a 1/2-pel image of the pyramid image of half size of the original one
// Yp(x,y) = Y(x, y) + Y(x+1, y) + Y(x, y+1) + Y(x+1, y+1)
// by Luhong Liang, IC-ASD, ASTRI, Oct. 20, 2011
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in meanPryDownHalfPel()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width || 
		iplSrcImage->height != iplDstImage->height || 
		iplSrcImage->nChannels != iplDstImage->nChannels) {
		showErrMsg("Destination image should be the same size as the source image!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image data type! Should be unsigned 8-bit.\n");
		return false;
	}

	// calcluate pyramid image
	int x, y;
	for (y=0; y<iplDstImage->height-1; y++) {
		unsigned char *pSrc1 = (unsigned char*)(iplSrcImage->imageData + y * iplSrcImage->widthStep);
		unsigned char *pSrc2 = (unsigned char*)(iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		unsigned char *pDst = (unsigned char*)(iplDstImage->imageData + y * iplDstImage->widthStep);
		for (x=0; x<iplDstImage->width-1; x++) {
			pDst[x] = (pSrc1[x] + pSrc1[x+1] + pSrc2[x] + pSrc2[x+1] + 2) >> 2;
		}
		pDst[x] = (pSrc1[x] + pSrc2[x] + 1) >> 1;
	}
	unsigned char *pSrc = (unsigned char*)(iplSrcImage->imageData + y * iplSrcImage->widthStep);
	unsigned char *pDst = (unsigned char*)(iplDstImage->imageData + y * iplDstImage->widthStep);
	for (x=0; x<iplDstImage->width-1; x++) {
		pDst[x] = (pSrc[x] + pSrc[x+1] + 1) >> 1;
	}
	pDst[x] = pSrc[x];

	return true;
}

bool CImageUtility::meanPyrDown_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Create a pyramid image of half size of the original one
// Yp(x,y) = Y(2x, 2y) + Y(2x+1, 2y) + Y(2x, 2y+1) + Y(2x+1, 2y+1)
// by Luhong Liang, IC-ASD, ASTRI, Oct. 20, 2011
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in meanPryDown()!\n");
		return false;
	}
	if (iplSrcImage->width/2 != iplDstImage->width || 
		iplSrcImage->height/2 != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point.\n");
		return false;
	}

	// calcluate pyramid image
	for (int y=0; y<iplDstImage->height; y++) {
		float *pSrc1 = (float*)((char *)iplSrcImage->imageData + 2 * y * iplSrcImage->widthStep);	// NOTE: widthStep is counted by BYTE!
		float *pSrc2 = (float*)((char *)iplSrcImage->imageData + (2*y+1) * iplSrcImage->widthStep);
		float *pDst = (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, xx=0; x<iplDstImage->width; x++, xx+=2) {
			pDst[x] = (pSrc1[xx] + pSrc1[xx+1] + pSrc2[xx] + pSrc2[xx+1]) * 0.25f;
		}
	}

	return true;
}

bool CImageUtility::meanPyrDown_32f(IplImage *iplSrcImage, IplImage *iplDstImage, int ds_level)
// Create a pyramid image of 1/2^n size of the original one. In each layer, the sampling method is
// Yp(x,y) = Y(2x, 2y) + Y(2x+1, 2y) + Y(2x, 2y+1) + Y(2x+1, 2y+1)
// by Luhong Liang, IC-ASD, ASTRI, Dec. 5, 2012
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1 || ds_level < 0) {
		showErrMsg("Invalid input image in meanPyrDown_32f()!\n");
		return false;
	}
	int ds_factor = 1;
	if (ds_level > 0) {
		ds_factor = ds_factor << ds_level;
	} 
	int nWidth = iplSrcImage->width >> ds_level;
	int nHeight = iplSrcImage->height >> ds_level;
	if (nWidth != iplDstImage->width || nHeight != iplDstImage->height) {
		showErrMsg("Mismatched input and output image in CImageUtility::meanPyrDown_32f()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point.\n");
		return false;
	}

	// calcluate pyramid image
	float factor = 1.0f / (ds_factor * ds_factor);
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			float mean = 0;
			for (int yy=0; yy<ds_factor; yy++) {
				float *pSrc = (float*)((char *)iplSrcImage->imageData + (y*ds_factor+yy) * iplSrcImage->widthStep) + x*ds_factor;	// NOTE: widthStep is counted by BYTE!
				for (int xx=0; xx<ds_factor; xx++) {
					mean += pSrc[xx];
				}
			}
			pDst[x] = mean * factor;
		}
	}

	return true;
}

bool CImageUtility::intpBicubic_32f(IplImage *iplSrcImage, IplImage *iplDstImage, bool clipping)
// Interpolate image using bicubic function. Filter is [ -1/16 9/16 9/16  -1/16 ]
// by Luhong Liang, IC-ASD, ASTRI, Mar. 3, 2012
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in intpBicubic_32f()!\n");
		return false;
	}
	if (iplSrcImage->width * 2 != iplDstImage->width || 
		iplSrcImage->height * 2 != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in intpBicubic_32f()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in intpBicubic_32f()!\n");
		return false;
	}

	// allocate temp buffer
	IplImage *iplTemp = createImage( iplDstImage->width, iplSrcImage->height, SR_DEPTH_32F, 1 );
	if (iplTemp == NULL) {
		showErrMsg("Fail to allocate buffer in intpBicubic_32f()!\n");
		return false;
	}

	// interpolate in X direction
	for (int y=0; y<iplSrcImage->height; y++) {
		float *pSrc = (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);	// NOTE: widthStep is counted by BYTE!
		float *pDst = (float*)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		// first & second point
		pDst[0] = pSrc[0];
		pDst[1] = pSrc[0] * 0.5f + pSrc[1] * 0.5625f - pSrc[2] * 0.0625f;
		// others
		for (int x=1; x<iplSrcImage->width-2; x++) {
			int xx = x * 2;
			pDst[xx] = pSrc[x];
			pDst[xx+1] = - 0.0625f * ( pSrc[x-1] + pSrc[x+2] ) + 0.5625f * ( pSrc[x] + pSrc[x+1] ); 
		}
		int xx = (iplSrcImage->width-2) * 2;
		pDst[xx] = pSrc[iplSrcImage->width-2];
		pDst[xx+1] = - 0.0625f * pSrc[iplSrcImage->width-3] + 0.5625f * pSrc[iplSrcImage->width-2] + 0.5f * pSrc[iplSrcImage->width-1];
		pDst[xx+2] = pSrc[iplSrcImage->width-1];
		pDst[xx+3] = - 0.0625f * pSrc[iplSrcImage->width-2] + 1.0625f * pSrc[iplSrcImage->width-1];
	}

	// interpolate in Y direction
	memcpy(iplDstImage->imageData, iplTemp->imageData, iplDstImage->widthStep);

	float *pSrc0 = (float*)((char *)iplTemp->imageData);
	float *pSrc1 = (float*)((char *)iplTemp->imageData + iplTemp->widthStep);
	float *pSrc2 = (float*)((char *)iplTemp->imageData + 2 * iplTemp->widthStep);
	float *pDst = (float*)((char *)iplDstImage->imageData + iplDstImage->widthStep);
	for (int x=0; x<iplDstImage->width; x++) {
		pDst[x] = pSrc0[x] * 0.5f + pSrc1[x] * 0.5625f - pSrc2[x] * 0.0625f;
	}

	for (int y=1; y<iplTemp->height-2; y++) {
		float *pSrcN = (float*)((char *)iplTemp->imageData + (y-1) * iplTemp->widthStep);	
		float *pSrc0 = (float*)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		float *pSrc1 = (float*)((char *)iplTemp->imageData + (y+1) * iplTemp->widthStep);
		float *pSrc2 = (float*)((char *)iplTemp->imageData + (y+2) * iplTemp->widthStep);
		memcpy((unsigned char *)iplDstImage->imageData + 2 * y * iplDstImage->widthStep, (unsigned char *)pSrc0, iplDstImage->widthStep);
		float *pDst = (float*)((char *)iplDstImage->imageData + ( 2 * y + 1) * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = - 0.0625f * ( pSrcN[x] + pSrc2[x] ) + 0.5625f * ( pSrc0[x] + pSrc1[x] ); 
		}
	}
		
	int yy = (iplTemp->height-2) * 2;
	memcpy((unsigned char *)iplDstImage->imageData + yy * iplDstImage->widthStep, (unsigned char *)iplTemp->imageData + (iplTemp->height-2) * iplTemp->widthStep, iplDstImage->widthStep);

	float *pSrcN3 = (float*)((char *)iplTemp->imageData + (iplTemp->height-3) * iplTemp->widthStep);
	float *pSrcN2 = (float*)((char *)iplTemp->imageData + (iplTemp->height-2) * iplTemp->widthStep);
	float *pSrcN1 = (float*)((char *)iplTemp->imageData + (iplTemp->height-1) * iplTemp->widthStep);
	pDst = (float*)((char *)iplDstImage->imageData + (iplDstImage->height-3) * iplDstImage->widthStep);
	for (int x=0; x<iplDstImage->width; x++) {
		pDst[x] = - 0.0625f * pSrcN3[x] + 0.5625f * pSrcN2[x] + 0.5f * pSrcN1[x];
	}

	pDst = (float*)((char *)iplDstImage->imageData + (iplDstImage->height-2) * iplDstImage->widthStep);
	memcpy((unsigned char *)pDst, (unsigned char *)pSrcN1, iplDstImage->widthStep);

	pDst = (float*)((char *)iplDstImage->imageData + (iplDstImage->height-1) * iplDstImage->widthStep);
	for (int x=0; x<iplDstImage->width; x++) {
		pDst[x] = - 0.0625f * pSrcN2[x] + 1.0625f * pSrcN1[x];
	}

	releaseImage(&iplTemp);

	if (clipping) {
		for (int y=0; y<iplDstImage->height; y++) {
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				float pix = pDst[x];
				if (pix < 0.0f)
					pDst[x] = 0.0f;
				else if (pix > 255.0f)
					pDst[x] = 255.0f;
			}
		}
	}

	return true;
}

bool CImageUtility::upscaleDyadicBicuLift_32f(IplImage *iplSrcImage, IplImage *iplDstImage, bool clipping)
// Dyadic upscale using bicubic fitting function with filter [-27 225 67 -9]/256 and [-9 67 225 -27]/256 ( from OpenCV)
// This function "lift" the image top left for 1 pixel to match the SR on interpolation grid, i.e.:
//     o       o       o       o       o		<-- pixels in the original image (scan line 0 of original image)
//       *   *   *   *   *   *   *   *   *	 *	<-- interpolated pixels in the upscaled image (scan line 0 of upscaled image)
//     o       o       o       o       o
//       *   *   *   *   *   *   *   *   *   *
// by Luhong Liang, IC-ASD, ASTRI, Oct. 25, 2012
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in upscaleDyadicBicuLift_32f()!\n");
		return false;
	}
	if (iplSrcImage->width * 2 != iplDstImage->width || 
		iplSrcImage->height * 2 != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in upscaleDyadicBicuLift_32f()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in upscaleDyadicBicuLift_32f()!\n");
		return false;
	}

	// allocate temp buffer
	IplImage *iplTemp = createImage( iplDstImage->width, iplSrcImage->height, SR_DEPTH_32F, 1 );
	if (iplTemp == NULL) {
		showErrMsg("Fail to allocate buffer in upscaleDyadicBicuLift_32f()!\n");
		return false;
	}

	const float a00 = -27.0f / 256.0f;
	const float a01 = 225.0f / 256.0f;
	const float a02 = 67.0f / 256.0f;
	const float a03 = -9.0f / 256.0f;
	const float a10 = -9.0f / 256.0f;
	const float a11 = 67.0f / 256.0f;
	const float a12 = 225.0f / 256.0f;
	const float a13 = -27.0f / 256.0f;
	// interpolate in X direction
	for (int y=0; y<iplSrcImage->height; y++) {
		float *pSrc = (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);	// NOTE: widthStep is counted by BYTE!
		float *pDst = (float*)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		// first & second point
		pDst[0] = pSrc[0]*a00 + pSrc[0]*a01 + pSrc[1]*a02 + pSrc[2]*a03;
		pDst[1] = pSrc[0]*a10 + pSrc[0]*a11 + pSrc[1]*a12 + pSrc[2]*a13;
		// others
		for (int x=1; x<iplSrcImage->width-2; x++) {
			int xx = x * 2;
			pDst[xx] = pSrc[x-1]*a00 + pSrc[x]*a01 + pSrc[x+1]*a02 + pSrc[x+2]*a03;
			pDst[xx+1] = pSrc[x-1]*a10 + pSrc[x]*a11 + pSrc[x+1]*a12 + pSrc[x+2]*a13;
		}
		int xx = (iplSrcImage->width-2) * 2;
		pDst[xx] = pSrc[iplSrcImage->width-3]*a00 + pSrc[iplSrcImage->width-2]*a01 + pSrc[iplSrcImage->width-1]*a02 + pSrc[iplSrcImage->width-1]*a03;
		pDst[xx+1] = pSrc[iplSrcImage->width-3]*a10 + pSrc[iplSrcImage->width-2]*a11 + pSrc[iplSrcImage->width-1]*a12 + pSrc[iplSrcImage->width-1]*a13;
		pDst[xx+2] = pSrc[iplSrcImage->width-2]*a00 + pSrc[iplSrcImage->width-1]*a01 + pSrc[iplSrcImage->width-1]*a02 + pSrc[iplSrcImage->width-1]*a03;
		pDst[xx+3] = pSrc[iplSrcImage->width-2]*a10 + pSrc[iplSrcImage->width-1]*a11 + pSrc[iplSrcImage->width-1]*a12 + pSrc[iplSrcImage->width-1]*a13;
	}

	// interpolate in Y direction
	float *pSrc0 = (float*)((char *)iplTemp->imageData);
	float *pSrcN = pSrc0;
	float *pSrc1 = (float*)((char *)iplTemp->imageData + iplTemp->widthStep);
	float *pSrc2 = (float*)((char *)iplTemp->imageData + 2 * iplTemp->widthStep);
	float *pDst0 = (float*)(iplDstImage->imageData);
	float *pDst1 = (float*)((char *)iplDstImage->imageData + iplDstImage->widthStep);
	for (int x=0; x<iplDstImage->width; x++) {
		pDst0[x] = pSrcN[x]*a00 + pSrc0[x]*a01 + pSrc1[x]*a02 + pSrc2[x]*a03;
		pDst1[x] = pSrcN[x]*a10 + pSrc0[x]*a11 + pSrc1[x]*a12 + pSrc2[x]*a13;
	}

	for (int y=1; y<iplTemp->height-2; y++) {
		pSrcN = (float*)((char *)iplTemp->imageData + (y-1) * iplTemp->widthStep);	
		pSrc0 = (float*)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		pSrc1 = (float*)((char *)iplTemp->imageData + (y+1) * iplTemp->widthStep);
		pSrc2 = (float*)((char *)iplTemp->imageData + (y+2) * iplTemp->widthStep);
		pDst0 = (float*)((char *)iplDstImage->imageData + ( 2 * y ) * iplDstImage->widthStep);
		pDst1 = (float*)((char *)iplDstImage->imageData + ( 2 * y + 1) * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst0[x] = pSrcN[x]*a00 + pSrc0[x]*a01 + pSrc1[x]*a02 + pSrc2[x]*a03;
			pDst1[x] = pSrcN[x]*a10 + pSrc0[x]*a11 + pSrc1[x]*a12 + pSrc2[x]*a13;
		}
	}
		
	pSrcN = (float*)((char *)iplTemp->imageData + (iplTemp->height-3) * iplTemp->widthStep);
	pSrc0 = (float*)((char *)iplTemp->imageData + (iplTemp->height-2) * iplTemp->widthStep);
	pSrc1 = (float*)((char *)iplTemp->imageData + (iplTemp->height-1) * iplTemp->widthStep);
	pSrc2 = pSrc1;
	pDst0 = (float*)((char *)iplDstImage->imageData + (iplDstImage->height-4) * iplDstImage->widthStep);
	pDst1 = (float*)((char *)iplDstImage->imageData + (iplDstImage->height-3) * iplDstImage->widthStep);
	for (int x=0; x<iplDstImage->width; x++) {
			pDst0[x] = pSrcN[x]*a00 + pSrc0[x]*a01 + pSrc1[x]*a02 + pSrc2[x]*a03;
			pDst1[x] = pSrcN[x]*a10 + pSrc0[x]*a11 + pSrc1[x]*a12 + pSrc2[x]*a13;
	}

	pDst0 = (float*)((char *)iplDstImage->imageData + (iplDstImage->height-2) * iplDstImage->widthStep);
	pDst1 = (float*)((char *)iplDstImage->imageData + (iplDstImage->height-1) * iplDstImage->widthStep);
	for (int x=0; x<iplDstImage->width; x++) {
			pDst0[x] = pSrc0[x]*a00 + pSrc1[x]*a01 + pSrc2[x]*a02 + pSrc2[x]*a03;
			pDst1[x] = pSrc0[x]*a10 + pSrc1[x]*a11 + pSrc2[x]*a12 + pSrc2[x]*a13;
	}

	releaseImage(&iplTemp);

	if (clipping) {
		for (int y=0; y<iplDstImage->height; y++) {
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				float pix = pDst[x];
				if (pix < 0.0f)
					pDst[x] = 0.0f;
				else if (pix > 255.0f)
					pDst[x] = 255.0f;
			}
		}
	}

	return true;
}

bool CImageUtility::pyrDownEven_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Create a pyramid image of half size of the original one
// Yp(x,y) = Y(2x, 2y) 
// by Luhong Liang, IC-ASD, ASTRI, Oct. 20, 2011
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in pyrDownEven_32f()!\n");
		return false;
	}
	if (iplSrcImage->width/2 != iplDstImage->width || 
		iplSrcImage->height/2 != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in pyrDownEven_32f()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in pyrDownEven_32f()!\n");
		return false;
	}

	// calcluate pyramid image
	for (int y=0; y<iplDstImage->height; y++) {
		float *pSrc1 = (float*)((char *)iplSrcImage->imageData + 2 * y * iplSrcImage->widthStep);	// NOTE: widthStep is counted by BYTE!
		//float *pSrc2 = (float*)((char *)iplSrcImage->imageData + (2*y+1) * iplSrcImage->widthStep);
		float *pDst = (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, xx=0; x<iplDstImage->width; x++, xx+=2) {
			pDst[x] = pSrc1[xx];
		}
	}

	return true;
}

bool CImageUtility::pyrDownEven_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Create a pyramid image of half size of the original one
// Yp(x,y) = Y(2x, 2y) 
// by Luhong Liang, IC-ASD, ASTRI
// April 24, 2013
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in pyrDownEven_8U()!\n");
		return false;
	}
	if (iplSrcImage->width/2 != iplDstImage->width || 
		iplSrcImage->height/2 != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in pyrDownEven_8U()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in pyrDownEven_8U()!\n");
		return false;
	}

	// calcluate pyramid image
	for (int y=0; y<iplDstImage->height; y++) {
		unsigned char *pSrc1 = (unsigned char*)((char *)iplSrcImage->imageData + 2 * y * iplSrcImage->widthStep);
		//unsigned char *pSrc2 = (unsigned char*)((char *)iplSrcImage->imageData + (2*y+1) * iplSrcImage->widthStep);
		unsigned char *pDst = (unsigned char*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, xx=0; x<iplDstImage->width; x++, xx+=2) {
			pDst[x] = pSrc1[xx];
		}
	}

	return true;
}

bool CImageUtility::interlaceX(IplImage *iplSrcImage, IplImage *iplDstImage, bool even)
// Extract the even columns of the input image, when even = true; otherwise, extract odd columns
// by Luhong Liang, IC-ASD, ASTRI
// Aug 22, 2013
{
    if (iplSrcImage->depth == SR_DEPTH_8U && iplDstImage->depth == SR_DEPTH_8U) {
        return interlaceX_8U(iplSrcImage, iplDstImage, even);
    } else if (iplSrcImage->depth == SR_DEPTH_16U && iplDstImage->depth == SR_DEPTH_16U) {
        return interlaceX_16U(iplSrcImage, iplDstImage, even);
    } else if (iplSrcImage->depth == SR_DEPTH_32S && iplDstImage->depth == SR_DEPTH_32S) {
        return interlaceX_Int(iplSrcImage, iplDstImage, even);
    } else if (iplSrcImage->depth == SR_DEPTH_32F && iplDstImage->depth == SR_DEPTH_32F) {
        return interlaceX_32f(iplSrcImage, iplDstImage, even);
    } else {
        showErrMsg("Unsupported or mismatched data type of source and destination images in CImageUtility::interlaceX()!\n");
        return false;
    }
}

bool CImageUtility::interlaceX_8U(IplImage *iplSrcImage, IplImage *iplDstImage, bool even)
// Extract the even columns of the input image, when even = true; otherwise, extract odd columns
// by Luhong Liang, IC-ASD, ASTRI
// April 26, 2013
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in interlaceX_8U()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in interlaceX_8U()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in interlaceX_8U()!\n");
		return false;
	}

	// calcluate pyramid image
	int shift = even ? 0 : 1;
	for (int y=0; y<iplDstImage->height; y++) {
		unsigned char *pSrc = (unsigned char*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		unsigned char *pDst = (unsigned char*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep) + shift;
		for (int x=0, xx=0; x<iplDstImage->width; x++, xx+=2) {
			pDst[x] = pSrc[xx];
		}
	}

	return true;
}

bool CImageUtility::interlaceX_16U(IplImage *iplSrcImage, IplImage *iplDstImage, bool even)
// Extract the even columns of the input image, when even = true; otherwise, extract odd columns
// by Luhong Liang, IC-ASD, ASTRI
// Sept 17, 2013
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in interlaceX_16U()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in interlaceX_16U()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_16U || iplDstImage->depth != SR_DEPTH_16U) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in interlaceX_16U()!\n");
		return false;
	}

	// calcluate pyramid image
	int shift = even ? 0 : 1;
	for (int y=0; y<iplDstImage->height; y++) {
		unsigned short *pSrc = (unsigned short*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		unsigned short *pDst = (unsigned short*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep) + shift;
		for (int x=0, xx=0; x<iplDstImage->width; x++, xx+=2) {
			pDst[x] = pSrc[xx];
		}
	}

	return true;
}

bool CImageUtility::interlaceX_Int(IplImage *iplSrcImage, IplImage *iplDstImage, bool even)
// Extract the even columns of the input image, when even = true; otherwise, extract odd columns
// by Luhong Liang, IC-ASD, ASTRI
// Aug. 22, 2013
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in interlaceX_Int()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in interlaceX_Int()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in interlaceX_Int()!\n");
		return false;
	}

	// calcluate pyramid image
	int shift = even ? 0 : 1;
	for (int y=0; y<iplDstImage->height; y++) {
		int *pSrc = (int*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pDst = (int*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep) + shift;
		for (int x=0, xx=0; x<iplDstImage->width; x++, xx+=2) {
			pDst[x] = pSrc[xx];
		}
	}

	return true;
}

bool CImageUtility::interlaceX_32f(IplImage *iplSrcImage, IplImage *iplDstImage, bool even)
// Extract the even columns of the input image, when even = true; otherwise, extract odd columns
// by Luhong Liang, IC-ASD, ASTRI
// Aug. 22, 2013
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in interlaceX_Int()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in interlaceX_Int()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in interlaceX_Int()!\n");
		return false;
	}

	// calcluate pyramid image
	int shift = even ? 0 : 1;
	for (int y=0; y<iplDstImage->height; y++) {
		float *pSrc = (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		float *pDst = (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep) + shift;
		for (int x=0, xx=0; x<iplDstImage->width; x++, xx+=2) {
			pDst[x] = pSrc[xx];
		}
	}

	return true;
}

bool CImageUtility::interlaceY_8U(IplImage *iplSrcImage, IplImage *iplDstImage, bool even)
// Extract the even rows of the input image, when even = true; otherwise, extract odd rows
// by Luhong Liang, IC-ASD, ASTRI
// April 26, 2013
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in interlaceY_8U()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height*2) {
		showErrMsg("Destination image should be half size of the source image in interlaceY_8U()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in interlaceY_8U()!\n");
		return false;
	}

	// calcluate pyramid image
	int shift = even ? 0 : 1;
	for (int y=0; y<iplDstImage->height; y++) {
		unsigned char *pSrc = (unsigned char*)((char *)iplSrcImage->imageData + (2*y+shift) * iplSrcImage->widthStep);
		unsigned char *pDst = (unsigned char*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = pSrc[x];
		}
	}

	return true;
}

bool CImageUtility::cvt422to444_linear(IplImage *iplSrcImage, IplImage *iplDstImage)
// Convert a 4:2:2 chroma plane to 4:4:4 format using linear interpolation.
// The sampling points in X direction are:
//                o     o     o			<-- 4:2:2
//                *  *  *  *  *  *		<-- 4:4:4
// The filter is (1/2, 1/2)
// by Luhong Liang, IC-ASD, ASTRI
// Aug. 22, 2013
{
    if (iplSrcImage->depth == SR_DEPTH_8U && iplDstImage->depth == SR_DEPTH_8U) {
        return cvt422to444_linear_8U(iplSrcImage, iplDstImage);
    } else if (iplSrcImage->depth == SR_DEPTH_32S && iplDstImage->depth == SR_DEPTH_32S) {
        return cvt422to444_linear_Int(iplSrcImage, iplDstImage);
    } else if (iplSrcImage->depth == SR_DEPTH_32F && iplDstImage->depth == SR_DEPTH_32F) {
        return cvt422to444_linear_32f(iplSrcImage, iplDstImage);
    } else if (iplSrcImage->depth == SR_DEPTH_16U && iplDstImage->depth == SR_DEPTH_16U) {
        return cvt422to444_linear_16U(iplSrcImage, iplDstImage);
    } else {
        showErrMsg("Unsupported or mismatched data type of source and destination images in CImageUtility::cvt422to444_linear()!\n");
        return false;
    }
}

bool CImageUtility::cvt422to444_linear_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Convert a 4:2:2 chroma plane to 4:4:4 format using linear interpolation.
// The sampling points in X direction are:
//                o     o     o			<-- 4:2:2
//                *  *  *  *  *  *		<-- 4:4:4
// The filter is (1/2, 1/2)
// by Luhong Liang, IC-ASD, ASTRI
// April 29, 2013
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in cvt422to444_linear_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in cvt422to444_linear_8U()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in cvt422to444_linear_8U()!\n");
		return false;
	}

	for (int y=0; y<iplDstImage->height; y++) {
		unsigned char *pSrc = (unsigned char*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		unsigned char *pDst = (unsigned char*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, xx=0; x<iplDstImage->width-2; x+=2,xx++) {
			// replicate the even pixel
			pDst[x] = pSrc[xx];
			// interpolate the odd pixel
			int val = (int)pSrc[xx] + (int)pSrc[xx+1];
			pDst[x+1] = rndclp_9Uto8U(val);
		}
        pDst[iplDstImage->width-2] = pSrc[iplSrcImage->width-1];
        pDst[iplDstImage->width-1] = pSrc[iplSrcImage->width-1];
	}

	return true;
}

bool CImageUtility::cvt422to444_linear_16U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Convert a 4:2:2 chroma plane to 4:4:4 format using linear interpolation.
// The sampling points in X direction are:
//                o     o     o			<-- 4:2:2
//                *  *  *  *  *  *		<-- 4:4:4
// The filter is (1/2, 1/2)
// by Luhong Liang, IC-ASD, ASTRI
// Sept. 17, 2013
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in cvt422to444_linear_16U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in cvt422to444_linear_16U()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_16U || iplDstImage->depth != SR_DEPTH_16U) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in cvt422to444_linear_16U()!\n");
		return false;
	}

	for (int y=0; y<iplDstImage->height; y++) {
		unsigned short *pSrc = (unsigned short*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		unsigned short *pDst = (unsigned short*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, xx=0; x<iplDstImage->width-2; x+=2,xx++) {
			// replicate the even pixel
			pDst[x] = pSrc[xx];
			// interpolate the odd pixel
			unsigned int pix = pSrc[xx] + pSrc[xx+1];
            pDst[x+1] = (unsigned short)(((pix&0x00000001)==0) ? (pix>>1) : ((pix>>1)+1));      // will never overflow
		}
        pDst[iplDstImage->width-2] = pSrc[iplSrcImage->width-1];
        pDst[iplDstImage->width-1] = pSrc[iplSrcImage->width-1];
	}

	return true;
}

bool CImageUtility::cvt422to444_linear_Int(IplImage *iplSrcImage, IplImage *iplDstImage)
// Convert a 4:2:2 chroma plane to 4:4:4 format using linear interpolation.
// The sampling points in X direction are:
//                o     o     o			<-- 4:2:2
//                *  *  *  *  *  *		<-- 4:4:4
// The filter is (1/2, 1/2)
// by Luhong Liang, IC-ASD, ASTRI
// Aug. 22, 2013
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in cvt422to444_linear_Int()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in cvt422to444_linear_Int()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in cvt422to444_linear_Int()!\n");
		return false;
	}

	for (int y=0; y<iplDstImage->height; y++) {
		int *pSrc = (int*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pDst = (int*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, xx=0; x<iplDstImage->width-2; x+=2,xx++) {
			// replicate the even pixel
			pDst[x] = pSrc[xx];
			// interpolate the odd pixel
			int val = pSrc[xx] + pSrc[xx+1];
			pDst[x+1] = rndclp_Unsigned(val);
		}
        pDst[iplDstImage->width-2] = pSrc[iplSrcImage->width-1];
        pDst[iplDstImage->width-1] = pSrc[iplSrcImage->width-1];
	}

	return true;
}

bool CImageUtility::cvt422to444_linear_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Convert a 4:2:2 chroma plane to 4:4:4 format using linear interpolation.
// The sampling points in X direction are:
//                o     o     o			<-- 4:2:2
//                *  *  *  *  *  *		<-- 4:4:4
// The filter is (1/2, 1/2)
// by Luhong Liang, IC-ASD, ASTRI
// Aug. 22, 2013
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in cvt422to444_linear_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in cvt422to444_linear_32f()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in cvt422to444_linear_32f()!\n");
		return false;
	}

	for (int y=0; y<iplDstImage->height; y++) {
		float *pSrc = (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		float *pDst = (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, xx=0; x<iplDstImage->width-2; x+=2,xx++) {
			// replicate the even pixel
			pDst[x] = pSrc[xx];
			// interpolate the odd pixel
			pDst[x+1] = (pSrc[xx] + pSrc[xx+1]) * 0.5f;
		}
        pDst[iplDstImage->width-2] = pSrc[iplSrcImage->width-1];
        pDst[iplDstImage->width-1] = pSrc[iplSrcImage->width-1];
	}

	return true;
}

bool CImageUtility::cvt422to444_cubic_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Convert a 4:2:2 chroma plane to 4:4:4 format using cubic interpolation.
// The sampling points in X direction are:
//                o     o     o			<-- 4:2:2
//                *  *  *  *  *  *		<-- 4:4:4
// The filter is (-1/8, 5/8, 5/8, -1/8)
// by Luhong Liang, IC-ASD, ASTRI
// April 29, 2013
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in cvt422to444_cubic_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in cvt422to444_cubic_8U()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in cvt422to444_cubic_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 2, 0, 0);
	if (iplSrcPad == NULL) return false;

	for (int y=0; y<iplDstImage->height; y++) {
		unsigned char *pSrc = (unsigned char*)((char *)iplSrcPad->imageData + y * iplSrcPad->widthStep);
		unsigned char *pDst = (unsigned char*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, xx=1; x<iplDstImage->width; x+=2,xx++) {
			// replicate the even pixel
			pDst[x] = pSrc[xx];
			// interpolate the odd pixel
			int val = (-(int)pSrc[xx-1] + 5*(int)pSrc[xx] + 5*(int)pSrc[xx+1] - (int)pSrc[xx+2]) >> 2;	// perserve 9 bits
			pDst[x+1] = rndclp_9Uto8U(val);
		}
	}

    safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::cvt422to444_lincub_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Convert a 4:2:2 chroma plane to 4:4:4 format using an average of linear and cubic interpolation.
// The sampling points in X direction are:
//                o     o     o			<-- 4:2:2
//                *  *  *  *  *  *		<-- 4:4:4
// The filter is (-1/16, 9/16, 9/16, -1/16)
// by Luhong Liang, IC-ASD, ASTRI
// April 29, 2013
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in cvt422to444_lincub_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in cvt422to444_lincub_8U()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in cvt422to444_lincub_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 2, 0, 0);
	if (iplSrcPad == NULL) return false;

	for (int y=0; y<iplDstImage->height; y++) {
		unsigned char *pSrc = (unsigned char*)((char *)iplSrcPad->imageData + y * iplSrcPad->widthStep);
		unsigned char *pDst = (unsigned char*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, xx=1; x<iplDstImage->width; x+=2,xx++) {
			// replicate the even pixel
			pDst[x] = pSrc[xx];
			// interpolate the odd pixel
			int val = (-(int)pSrc[xx-1] + 9*(int)pSrc[xx] + 9*(int)pSrc[xx+1] - (int)pSrc[xx+2]) >> 3;	// perserve 9 bits
			pDst[x+1] = rndclp_9Uto8U(val);
		}
	}

    safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::pyrDownDiamod5_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Create a pyramid image of half size of the original one
// Yp(x,y) = (2 * Y(2x, 2y) + Y(2x+1, 2y) + Y(2x-1, 2y)  + Y(2x, 2y+1) + Y(2x, 2y-1)) / 6
//   0  1   0
//  1   4  1
//   0  1   0
// by Luhong Liang, IC-ASD, ASTRI, Oct. 20, 2011
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in pyrDownDiamod5_32f()!\n");
		return false;
	}
	if (iplSrcImage->width/2 != iplDstImage->width || 
		iplSrcImage->height/2 != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in pyrDownDiamod5_32f()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in pyrDownDiamod5_32f()!\n");
		return false;
	}

	// calcluate pyramid image
	float *pSrc0 = (float*)((char *)iplSrcImage->imageData), *pSrc1, *pSrcN1;
	float *pDst0 = (float*)((char *)iplDstImage->imageData);
	for (int x=0, xx=0; x<iplDstImage->width; x++, xx+=2) {
		pDst0[x] = pSrc0[xx];
	}
	for (int y=1; y<iplDstImage->height; y++) {
		pSrcN1 = (float*)((char *)iplSrcImage->imageData + (2*y-1) * iplSrcImage->widthStep);
		pSrc0 = (float*)((char *)iplSrcImage->imageData + 2 * y * iplSrcImage->widthStep);	// NOTE: widthStep is counted by BYTE!
		pSrc1 = (float*)((char *)iplSrcImage->imageData + (2*y+1) * iplSrcImage->widthStep);
		pDst0 = (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		pDst0[0] = pSrc0[0];
		for (int x=1, xx=2; x<iplDstImage->width; x++, xx+=2) {
			//pDst0[x] = (pSrc0[xx] * 2 + pSrc0[xx-1] + pSrc0[xx+1] + pSrcN1[xx] + pSrc1[xx]) / 6.0f;
			pDst0[x] = (pSrc0[xx] * 4 + pSrc0[xx-1] + pSrc0[xx+1] + pSrcN1[xx] + pSrc1[xx]) / 8.0f;
		}
	}

	return true;
}

bool CImageUtility::pyrDownSquare9_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Create a pyramid image of half size of the original one
 //Yp(x,y) = ( Y(2x-1, 2y-1) + Y(2x, 2y-1)*2 + Y(2x+1, 2y-1) +
 //			   Y(2x-1, 2y)*2 + Y(2x, 2y)*4   + Y(2x+1, 2y)*2 +
 //			   Y(2x-1, 2y+1) + Y(2x, 2y+1)*2 + Y(2x+1, 2y+1) ) / 16;
// by Luhong Liang, IC-ASD, ASTRI, Oct. 20, 2011
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in pyrDownSquare9_32f()!\n");
		return false;
	}
	if (iplSrcImage->width/2 != iplDstImage->width || 
		iplSrcImage->height/2 != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in pyrDownSquare9_32f()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in pyrDownSquare9_32f()!\n");
		return false;
	}

	// calcluate pyramid image
	float *pSrc0 = (float*)((char *)iplSrcImage->imageData), *pSrc1, *pSrcN1;
	float *pDst0 = (float*)((char *)iplDstImage->imageData);
	for (int x=0, xx=0; x<iplDstImage->width; x++, xx+=2) {
		pDst0[x] = pSrc0[xx];
	}
	for (int y=1; y<iplDstImage->height; y++) {
		pSrcN1 = (float*)((char *)iplSrcImage->imageData + (2*y-1) * iplSrcImage->widthStep);
		pSrc0 = (float*)((char *)iplSrcImage->imageData + 2 * y * iplSrcImage->widthStep);	// NOTE: widthStep is counted by BYTE!
		pSrc1 = (float*)((char *)iplSrcImage->imageData + (2*y+1) * iplSrcImage->widthStep);
		pDst0 = (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		pDst0[0] = pSrc0[0];
		for (int x=1, xx=2; x<iplDstImage->width; x++, xx+=2) {
			pDst0[x] = ( pSrcN1[xx-1]  + pSrcN1[xx]*2 + pSrcN1[xx+1] +
						 pSrc0[xx-1]*2 + pSrc0[xx]*4  + pSrc0[xx+1]*2 +
						 pSrc1[xx-1]   + pSrc1[xx]*2  + pSrc1[xx+1]) / 16.0f;
		}
	}

	return true;
}

bool CImageUtility::meanPyrDownHalfPel_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Create a 1/2-pel image of the pyramid image of half size of the original one
// Yp(x,y) = Y(x, y) + Y(x+1, y) + Y(x, y+1) + Y(x+1, y+1)
// by Luhong Liang, IC-ASD, ASTRI, Oct. 20, 2011
{
	//copy(iplSrcImage, iplDstImage);		// if using the copy, there will be an half-pixel misalignment in the reconstruction image, Nov. 11, 2011
	//return true;
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in meanPyrDownHalfPel_32f()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width || 
		iplSrcImage->height != iplDstImage->height) {
		showErrMsg("Destination image should be the same size as the source image in meanPyrDownHalfPel_32f()!\n");;
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in meanPyrDownHalfPel_32f()!\n");
		return false;
	}

	// calcluate pyramid image
	int x, y;
	for (y=0; y<iplDstImage->height-1; y++) {
		float *pSrc1 = (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);	// NOTE: widthStep is counted by BYTE!
		float *pSrc2 = (float*)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		float *pDst = (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (x=0; x<iplDstImage->width-1; x++) {
			pDst[x] = (pSrc1[x] + pSrc1[x+1] + pSrc2[x] + pSrc2[x+1])/ 4.0f;
		}
		pDst[x] = (pSrc1[x] + pSrc2[x]) / 2.0f;
	}
	float *pSrc = (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);	// NOTE: widthStep is counted by BYTE!
	float *pDst = (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
	for (x=0; x<iplDstImage->width-1; x++) {
		pDst[x] = (pSrc[x] + pSrc[x+1]) / 2.0f;
	}
	pDst[x] = pSrc[x];

	return true;
}

bool CImageUtility::intpPyrDownHalfPel_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Create a pyramid downsampled image of an half-pel shifting image
// Yp(2u,2v) = ( Y(4u, 4v) + Y(4u+2, 4v) + Y(4u, 4v+2) + Y(4u+2, 4v+2) ) / 4
// Yp(2u+1,2v) = ( Y(4u+1, 4v) + Y(4u+3, 4v) + Y(4u+1, 4v+2) + Y(4u+3, 4v+2) ) / 4
// Yp(2u,2v+1) = ( Y(4u, 4v+1) + Y(4u+2, 4v+1) + Y(4u, 4v+3) + Y(4u+2, 4v+3) ) / 4
// Yp(2u+1,2v+1) = ( Y(4u+1, 4v+1) + Y(4u+3, 4v+1) + Y(4u+1, 4v+3) + Y(4u+3, 4v+3) ) / 4
// by Luhong Liang, IC-ASD, ASTRI, March 2, 2012
{
	//copy(iplSrcImage, iplDstImage);		// if using the copy, there will be an half-pixel misalignment in the reconstruction image, Nov. 11, 2011
	//return true;
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in intpPyrDownHalfPel_32f()!\n");
		return false;
	}
	if (iplSrcImage->width != 2 * iplDstImage->width || 
		iplSrcImage->height != 2 * iplDstImage->height) {
		showErrMsg("Destination image should be the same size as the source image in intpPyrDownHalfPel_32f()!\n");;
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in intpPyrDownHalfPel_32f()!\n");
		return false;
	}

	// calcluate pyramid image
	int x, y;
	for (y=0; y<iplDstImage->height; y+=2) {
		int v = 2 * y;
		float *pSrc0 = (float*)((char *)iplSrcImage->imageData + v * iplSrcImage->widthStep);	// NOTE: widthStep is counted by BYTE!
		float *pSrc1 = (float*)((char *)iplSrcImage->imageData + (v+1) * iplSrcImage->widthStep);
		float *pSrc2 = (float*)((char *)iplSrcImage->imageData + (v+2) * iplSrcImage->widthStep);
		float *pSrc3 = (float*)((char *)iplSrcImage->imageData + (v+3) * iplSrcImage->widthStep);
		float *pDst0 = (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		float *pDst1 = (float*)((char *)iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (x=0; x<iplDstImage->width; x+=2) {
			int u0 = 2 * x;
			int u1 = u0 + 1;
			int u2 = u0 + 2;
			int u3 = u0 + 3;
			// Yp(2u,2v) = Y(4u, 4v) + Y(4u+2, 4v) + Y(4u, 4v+2) + Y(4u+2, 4v+2)
			pDst0[x] = (pSrc0[u0] + pSrc0[u2] + pSrc2[u0] + pSrc2[u2])/ 4.0f;
			// Yp(2u+1,2v) = Y(4u+1, 4v) + Y(4u+3, 4v) + Y(4u+1, 4v+2) + Y(4u+3, 4v+2)
			pDst0[x+1] = (pSrc0[u1] + pSrc0[u3] + pSrc2[u1] + pSrc2[u3])/ 4.0f;
			// Yp(2u,2v+1) = Y(4u, 4v+1) + Y(4u+2, 4v+1) + Y(4u, 4v+3) + Y(4u+2, 4v+3)
			pDst1[x] = (pSrc1[u0] + pSrc1[u2] + pSrc3[u0] + pSrc3[u2])/ 4.0f;
			// Yp(2u+1,2v+1) = Y(4u+1, 4v+1) + Y(4u+3, 4v+1) + Y(4u+1, 4v+3) + Y(4u+3, 4v+3)
			pDst1[x+1] = (pSrc1[u1] + pSrc1[u3] + pSrc3[u1] + pSrc3[u3])/ 4.0f;
		}
	}

	return true;
}

bool CImageUtility::relocateToGrid2_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// relocate pixels to a 2x lager grid, fill zero values to "holes"
// by Luhong Liang, IC-ASD, ASTRI, Nov. 2, 2011
{
	// check input arguments
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != iplDstImage->nChannels ||
		iplSrcImage->width * 2 != iplDstImage->width || iplSrcImage->height * 2 != iplDstImage->height ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
			showErrMsg("Invalid input image in relocateToGrid2_32f().!\n");
			return false;
	}

	// copy data
	for (int y=0; y<iplSrcImage->height; y++) {
		float *pSrcLine = (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);	// NOTE: widthStep is counted by BYTE!
		float *pDstLine = (float*)((char *)iplDstImage->imageData + 2 * y * iplDstImage->widthStep);
		float *pDstLine1 = (float*)((char *)iplDstImage->imageData + (2 * y + 1) * iplDstImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			int x2 = x * 2;
			pDstLine[x2] = pSrcLine[x];
			pDstLine[x2+1] = 0.0f;
			pDstLine1[x2] = 0.0f;
			pDstLine1[x2+1] = 0.0f;
		}
	}

	return true;
}

bool CImageUtility::bilinearPyrUp_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Upscale a pyramid image using bilinear interpolation, an inverse process of meanPyrDown()
// More specifically, in even grid, using 
// by Luhong Liang, IC-ASD, ASTRI, Oct. 20, 2011
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in bilinearPyrUp_32f()!\n");
		return false;
	}
	if (iplSrcImage->width * 2 != iplDstImage->width || 
		iplSrcImage->height * 2 != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point.\n");
		return false;
	}

	// calcluate pyramid image
	float a11, a12, a21, a22;
	float *pSrc0, *pSrc1, *pDst1, *pDst2;
	for (int y=0; y<iplSrcImage->height-1; y++) {
		pSrc0= (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		pSrc1= (float*)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		pDst1 = (float*)((char *)iplDstImage->imageData + (2*y+1) * iplDstImage->widthStep);	// NOTE: widthStep is counted by BYTE!
		pDst2 = (float*)((char *)iplDstImage->imageData + (2*y+2) * iplDstImage->widthStep);
		
		for (int x=0, xx=1; x<iplSrcImage->width-1; x++, xx+=2) {
			a11 = 0.75f * pSrc0[x] + 0.25f * pSrc0[x+1];
			a12 = 0.25f * pSrc0[x] + 0.75f * pSrc0[x+1];
			a21 = 0.75f * pSrc1[x] + 0.25f * pSrc1[x+1];
			a22 = 0.25f * pSrc1[x] + 0.75f * pSrc1[x+1];

			pDst1[xx] = 0.75f * a11 + 0.25f * a21;
			pDst1[xx+1] = 0.75f * a12 + 0.25f * a22;
			pDst2[xx] = 0.25f * a11 + 0.75f * a21;
			pDst2[xx+1] = 0.25f * a12 + 0.75f * a22;
		}
	}

	// process up and bottom boundaries
	pSrc0= (float*)((char *)iplSrcImage->imageData);
	pSrc1= (float*)((char *)iplSrcImage->imageData + (iplSrcImage->height-1) * iplSrcImage->widthStep);
	pDst1 = (float*)((char *)iplDstImage->imageData);
	pDst2 = (float*)((char *)iplDstImage->imageData + (iplDstImage->height-1) * iplDstImage->widthStep);
	for (int x=0, xx=0; x<iplSrcImage->width; x++, xx+=2) {
		pDst1[xx] = pSrc0[x];
		pDst1[xx+1] = pSrc0[x];
		pDst2[xx] = pSrc1[x];
		pDst2[xx+1] = pSrc1[x];
	}

	// process left and right boundaries
	pSrc0= (float*)((char *)iplSrcImage->imageData + iplSrcImage->widthStep);
	pSrc1= (float*)((char *)iplSrcImage->imageData +  + iplSrcImage->widthStep);
	
	pDst2 = (float*)((char *)iplDstImage->imageData + (iplDstImage->width-1) * sizeof(float) + iplDstImage->widthStep);
	for (int y=0, yy=0; y<iplSrcImage->height; y++, yy+=2) {		// BUGFIXED: y++ is wrong, should be yy+=2! Nov. 16, 2011, by Luhong
		pSrc0= (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		pDst1 = (float*)((char *)iplDstImage->imageData + yy * iplDstImage->widthStep);
		pDst1[0] = pSrc0[0];
		pDst1 = (float*)((char *)iplDstImage->imageData + (yy+1) * iplDstImage->widthStep);
		pDst1[0] = pSrc0[0];

		pSrc1= (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep + (iplSrcImage->width-1) * sizeof(float));
		pDst2 = (float*)((char *)iplDstImage->imageData + yy * iplDstImage->widthStep + (iplDstImage->width-1) * sizeof(float));
		pDst2[0] = pSrc1[0];
		pDst2 = (float*)((char *)iplDstImage->imageData + (yy+1) * iplDstImage->widthStep + (iplDstImage->width-1) * sizeof(float));
		pDst2[0] = pSrc1[0];	
	}

	return true;
}

IplImage *CImageUtility::bilatFilter_32f(IplImage *iplImage, int nR, float fSigmaSpatial, float fSigmaRange)
// A brute force implementation of bilateral filter
// by Luhong Liang, IC-ASD, ASTRI
// Nov. 17, 2011
{
	if (iplImage == NULL || iplImage->nChannels != 1 || nR < 1 || fSigmaSpatial <= 0.0f || fSigmaRange <= 0.0f) {
		showErrMsg("Invalide input image in bilatFilter_32f()!\n");
		return NULL;
	}

	IplImage *iplDstImage = createImage(iplImage->width, iplImage->height, SR_DEPTH_32F, 1);
	if (iplDstImage == NULL) {
		showErrMsg("Fail to allcoate result image in bilatFilter_32f()!\n");
		return NULL;
	}

	if (bilatFilter_32f(iplImage, iplDstImage, nR, fSigmaSpatial, fSigmaRange)) {
		return iplDstImage;
	} else {
		releaseImage(&iplDstImage);
		return NULL;
	}
}

bool CImageUtility::boxing3x3_32f(IplImage *iplImage, IplImage *iplDstImage, float factor)
// 3x3 boxing filter. This function supports the "in-place" operation (source and destination images are the same one)
// factor -- amplitude factor of the result, i.e. dst = box(src) * factor
// by Luhong Liang, IC-ASD, ASTRI
// April. 1, 2014
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::boxing3x3_32f()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::boxing3x3_32f()!\n");
		return false;
	}

	// line buffer
	float *pLineBuf = new float[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::boxing3x3_32f()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	float div = factor / 9.0f;
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		float *pSrc0 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		float *pSrc2 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			pLineBuf[x] = pSrc0[x] + pSrc1[x] + pSrc2[x];			// [ 1, 1, 1 ]
		}
		// convolution in X direction
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x] + pLineBuf[x+1] + pLineBuf[x+2]) * div;		// [ 1, 1, 1 ]
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::boxing5x5_32f(IplImage *iplImage, IplImage *iplDstImage, float factor)
// 5x5 boxing filter. This function supports the "in-place" operation (source and destination images are the same one)
// factor -- amplitude factor of the result, i.e. dst = box(src) * factor
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::boxing5x5_32f()!\n");
		return false;
	}

	// padding
	const int padded = 2;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::boxing5x5_32f()!\n");
		return false;
	}

    bool rlt = boxing5x5_o1_32f(iplSrcImage, iplDstImage, factor);

    safeReleaseImage(&iplSrcImage);

	return rlt;
}

bool CImageUtility::boxing5x5_o1_32f(IplImage *iplImage, IplImage *iplDstImage, float factor)
// Faster implementation of 5x5 boxing filter. This function DOES NOT supports the "in-place" operation 
// (source and destination images are the same one)!
// Compared with boxing5x5_32f(), this function:
// (1) supposing the input image has been padded 2 pixels
// factor -- amplitude factor of the result, i.e. dst = box(src) * factor
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplImage->width != iplDstImage->width+4 || iplImage->height != iplDstImage->height+4)  {
		showErrMsg("Invalid input argument in CImageUtility::boxing5x5_o1_32f()!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    return boxing5x5_o1_32f_SIMD(iplImage, iplDstImage, factor);
#endif      // #ifdef __SR_USE_SIMD

	// line buffer
	float *pLineBuf = new float[iplImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::boxing5x5_o1_32f()!\n");
		return false;
	}

	// convolution
    float div = factor / 25.0f;
    for (int y=0; y<iplDstImage->height; y++) {
        // convolution in Y direction
        float *pSrc0 = (float *)((char*)iplImage->imageData + y * iplImage->widthStep);
        float *pSrc1 = (float *)((char*)iplImage->imageData + (y+1) * iplImage->widthStep);
        float *pSrc2 = (float *)((char*)iplImage->imageData + (y+2) * iplImage->widthStep);
        float *pSrc3 = (float *)((char*)iplImage->imageData + (y+3) * iplImage->widthStep);
        float *pSrc4 = (float *)((char*)iplImage->imageData + (y+4) * iplImage->widthStep);
        for (int x=0; x<iplImage->width; x++) {
            pLineBuf[x] = pSrc0[x] + pSrc1[x] + pSrc2[x] + pSrc3[x] + pSrc4[x];			// [ 1, 1, 1, 1, 1 ]
        }
        // convolution in X direction
        float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            pDst[x] = (pLineBuf[x] + pLineBuf[x+1] + pLineBuf[x+2] + pLineBuf[x+3] + pLineBuf[x+4]) * div;		// [ 1, 1, 1, 1, 1 ]
        }
    }

	delete [] pLineBuf;

	return true;
}

bool CImageUtility::boxing7x7_32f(IplImage *iplImage, IplImage *iplDstImage, float factor)
// 7x7 boxing filter. This function supports the "in-place" operation (source and destination images are the same one)
// factor -- amplitude factor of the result, i.e. dst = box(src) * factor
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::boxing7x7_32f()!\n");
		return false;
	}

	// padding
	const int padded = 4;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::boxing7x7_32f()!\n");
		return false;
	}

	// line buffer
	float *pLineBuf = new float[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::boxing7x7_32f()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	float div = factor / 49.0f;
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		float *pSrc0 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		float *pSrc2 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		float *pSrc3 = (float *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
		float *pSrc4 = (float *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
        float *pSrc5 = (float *)((char*)iplSrcImage->imageData + (y+5) * iplSrcImage->widthStep);
        float *pSrc6 = (float *)((char*)iplSrcImage->imageData + (y+6) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			pLineBuf[x] = pSrc0[x] + pSrc1[x] + pSrc2[x] + pSrc3[x] + pSrc4[x] + 
                          pSrc5[x] + pSrc6[x];			        // [ 1, 1, 1, 1, 1 ]
		}
		// convolution in X direction
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x] + pLineBuf[x+1] + pLineBuf[x+2] + pLineBuf[x+3] + pLineBuf[x+4] +
                       pLineBuf[x+5] + pLineBuf[x+6]) * div;		// [ 1, 1, 1, 1, 1 ]
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::boxing9x9_32f(IplImage *iplImage, IplImage *iplDstImage, float factor)
// 9x9 boxing filter. This function supports the "in-place" operation (source and destination images are the same one)
// factor -- amplitude factor of the result, i.e. dst = box(src) * factor
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::boxing9x9_32f()!\n");
		return false;
	}

	// padding
	const int padded = 4;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::boxing9x9_32f()!\n");
		return false;
	}

	// line buffer
	float *pLineBuf = new float[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::boxing9x9_32f()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	float div = factor / 81.0f;
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		float *pSrc0 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		float *pSrc2 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		float *pSrc3 = (float *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
		float *pSrc4 = (float *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
        float *pSrc5 = (float *)((char*)iplSrcImage->imageData + (y+5) * iplSrcImage->widthStep);
        float *pSrc6 = (float *)((char*)iplSrcImage->imageData + (y+6) * iplSrcImage->widthStep);
        float *pSrc7 = (float *)((char*)iplSrcImage->imageData + (y+7) * iplSrcImage->widthStep);
        float *pSrc8 = (float *)((char*)iplSrcImage->imageData + (y+8) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			pLineBuf[x] = pSrc0[x] + pSrc1[x] + pSrc2[x] + pSrc3[x] + pSrc4[x] + 
                          pSrc5[x] + pSrc6[x] + pSrc7[x] + pSrc8[x];			        // [ 1, 1, 1, 1, 1 ]
		}
		// convolution in X direction
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x] + pLineBuf[x+1] + pLineBuf[x+2] + pLineBuf[x+3] + pLineBuf[x+4] +
                       pLineBuf[x+5] + pLineBuf[x+6] + pLineBuf[x+7] + pLineBuf[x+8]) * div;		// [ 1, 1, 1, 1, 1 ]
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::neighbormean5x5_32f(IplImage *iplImage, IplImage *iplDstImage)
// 5x5 neighbour mean filter. The filter is 
// [ 1,   1,   1,   1,   1,
//	 1,   2,   2,   2,   1,
// 	 1,   2,   0,   2,   1, 
//	 1,   2,   2,   2,   1,
//	 1,   1,   1,   1,   1 ] / 32;
// This function supports the "in-place" operation (source and destination images are the same one)
//Kayton Modified 5x5 Average Filter
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_10_int()!\n");
		return false;
	}

	// set filter used
	int pFilter5x5_10[] = { 1,   1,   1,   1,   1,
							1,   2,   2,   2,   1,
							1,   2,   0,   2,   1, 
							1,   2,   2,   2,   1,
							1,   1,   1,   1,   1};

	int *pFilter = NULL;
	pFilter = pFilter5x5_10;

	// padding
	const int wnd_size = 5;
	const int padded = 2;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_10_f()!\n");
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			float val = 0;
			for (int yy=0; yy<wnd_size; yy++) {
				int *pF = pFilter + yy * wnd_size;
				float *pSrc = (float *)((char*)iplSrcImage->imageData + (y+yy) * iplSrcImage->widthStep) + x;
				for (int xx=0; xx<wnd_size; xx++) {
					val += pSrc[xx] * pF[xx];		// cannot shift here due to visible quality loss!
				}
			}
			//pDst[x] = val >> filter_bit_depth;	//org code
			pDst[x] = val / 32.0f;
		}
	}

	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::filtLoG_32f(IplImage *iplImage, IplImage *iplDstImage, int wnd_size, float sigma, int lap_option)
// Laplacian of Gaussian (LoG) filter
// This function supports the "in-place" operation (source and destination images are the same one)
// This function uses the decomposition algorithm in Gaussian filter and ignore the boundary effects
//		option -- [I] 1 -- Laplace 4 operator; 2 -- Laplace 8 operator
//                        3 -- absolute Laplace 4 operator; 4 -- absolute Laplace 8 operator 
{
	if (iplImage == NULL || iplDstImage == NULL || wnd_size < 1 || sigma < 0)  {	// TODO: complete check here
		showErrMsg("Invalid input argument in CImageUtility::filtLoG_32f()!\n");
		return false;
	}

	// make filter
	float *pFilter = new float[wnd_size];
	if (pFilter == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::filtLoG_32f()!\n");
		return false;
	}
    int center = wnd_size >> 1;
	float div = 0.0f;
	float div_sigma_sq2 = 0.5f / (sigma * sigma);
	for (int i=0; i<wnd_size; i++) {
		float diff = (float)(i - center);
		float exp_num = - diff * diff * div_sigma_sq2;
		float value = exp(exp_num);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
		pFilter[i] = value;
		div += value;
	}
	for (int i=0; i<wnd_size; i++) {
		pFilter[i] = pFilter[i] / div;
	}

	// padding
	int wnd_radius = wnd_size >> 1;
	IplImage *iplSrcImage = padding(iplImage, wnd_radius+1, wnd_size-wnd_radius, wnd_radius+1, wnd_size-wnd_radius);    // pads one more pixel for the following Laplacian filter
    IplImage *iplInter = createImage(iplImage->width+wnd_size+1, iplImage->height+2, SR_DEPTH_32F, 1);
    IplImage *iplSmooth = createImage(iplDstImage->width+2, iplDstImage->height+2, SR_DEPTH_32F, 1);
	if (iplSrcImage == NULL || iplInter == NULL || iplSmooth == NULL) {
        showErrMsg("Fail to allocate buffer in CImageUtility::filtLoG_32f()!\n");
		delete [] pFilter;
        safeReleaseImage(&iplSrcImage, &iplInter, &iplSmooth);
		return false;
	}

    //saveImage("_Src.bmp", iplSrcImage);
	// convolution in Y direction
	for (int y=0; y<iplInter->height; y++) {
		float *pDst = (float *)((char*)iplInter->imageData + y * iplInter->widthStep);
		for (int x=0; x<iplInter->width; x++) {
			float val = 0.0f;
			for (int yy=0; yy<wnd_size; yy++) {
                float *pSrc = (float *)((char*)iplSrcImage->imageData + (y+yy) * iplSrcImage->widthStep) + x;
                val += pSrc[0] * pFilter[yy];
			}
			pDst[x] = val;
		}
	}

    //saveImage("_gaussianY.bmp", iplInter);

    // convolution in X direction
	for (int y=0; y<iplSmooth->height; y++) {
		float *pDst = (float *)((char*)iplSmooth->imageData + y * iplSmooth->widthStep);
        float *pSrc = (float *)((char*)iplInter->imageData + y * iplInter->widthStep);
		for (int x=0; x<iplSmooth->width; x++) {
			float val = 0.0f;
            float *pSrcCol = pSrc + x;
			for (int xx=0; xx<wnd_size; xx++) {
                val += pSrcCol[xx] * pFilter[xx];
			}
			pDst[x] = val;
		}
	}
    safeReleaseImage(&iplSrcImage, &iplInter);
	delete [] pFilter;

    // Laplacian filter
	if (lap_option == 1) {
		for (int y=0; y<iplDstImage->height; y++) {
			float *pSrcN = (float *)((char *)iplSmooth->imageData + y * iplSmooth->widthStep);
			float *pSrc0 = (float *)((char *)iplSmooth->imageData + (y+1) * iplSmooth->widthStep);
			float *pSrc1 = (float *)((char *)iplSmooth->imageData + (y+2) * iplSmooth->widthStep);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {        // bug fixed, Setp 4, 2014 (width-1)
				//  0 -1  0
				// -1  4 -1
				//  0 -1  0
				pDst[x] = - pSrcN[x] - pSrc0[x-1] + pSrc0[x] * 4 - pSrc0[x+1] - pSrc1[x];
			}
		}
	} else if (lap_option == 2) {
		for (int y=0; y<iplDstImage->height; y++) {
			float *pSrcN = (float *)((char *)iplSmooth->imageData + y * iplSmooth->widthStep);
			float *pSrc0 = (float *)((char *)iplSmooth->imageData + (y+1) * iplSmooth->widthStep);
			float *pSrc1 = (float *)((char *)iplSmooth->imageData + (y+2) * iplSmooth->widthStep);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				// -1 -1 -1
				// -1  8 -1
				// -1 -1 -1
				pDst[x] = - pSrcN[x-1] - pSrcN[x] - pSrcN[x+1]
					           - pSrc0[x-1] + pSrc0[x] * 8 - pSrc0[x+1]  // bug fixed, April 11, 2014
						       - pSrc1[x-1] - pSrc1[x] - pSrc1[x+1];
			}
		}
    } else if (lap_option == 3) {
		for (int y=0; y<iplDstImage->height; y++) {
			float *pSrcN = (float *)((char *)iplSmooth->imageData + y * iplSmooth->widthStep);
			float *pSrc0 = (float *)((char *)iplSmooth->imageData + (y+1) * iplSmooth->widthStep);
			float *pSrc1 = (float *)((char *)iplSmooth->imageData + (y+2) * iplSmooth->widthStep);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				//  0 -1  0
				// -1  4 -1
				//  0 -1  0
				float lap = - pSrcN[x] - pSrc0[x-1] + pSrc0[x] * 4 - pSrc0[x+1] - pSrc1[x];
                pDst[x] = lap < 0.0f ? -lap : lap;
			}
		}
	} else if (lap_option == 4) {
		for (int y=0; y<iplDstImage->height; y++) {
			float *pSrcN = (float *)((char *)iplSmooth->imageData + y * iplSmooth->widthStep);
			float *pSrc0 = (float *)((char *)iplSmooth->imageData + (y+1) * iplSmooth->widthStep);
			float *pSrc1 = (float *)((char *)iplSmooth->imageData + (y+2) * iplSmooth->widthStep);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				// -1 -1 -1
				// -1  8 -1
				// -1 -1 -1
				float lap = - pSrcN[x-1] - pSrcN[x] - pSrcN[x+1]
					             - pSrc0[x-1] + pSrc0[x] * 8 - pSrc0[x+1]  // bug fixed, April 11, 2014
						         - pSrc1[x-1] - pSrc1[x] - pSrc1[x+1];
                pDst[x] = lap < 0.0f ? -lap : lap;
			}
		}
	} else {
		showErrMsg("Invalid operator type in CImageUtility::filtLoG_32f()!\n");
        safeReleaseImage(&iplSmooth);
		return false;
	} 

	safeReleaseImage(&iplSmooth);

	return true;
}

bool CImageUtility::sobel_32f(IplImage *iplSrcImage, IplImage *iplDstImage, int direction)
// Sobel operator. We do not use OpenCV build-in function because it uses a Gaussian filter before gradient calculation
// This function supports "in-place" operation
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image; should be the same size as iplSrcImage
//		direction -- [I] direction: 0 -- horizontal;  1 -- vertical;  2 -- modulation (2-norm);    3 -- ABS (1-norm)
{
	if (iplSrcImage == NULL || iplDstImage == NULL) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::sobel_32f()!\n");
		return false;
	}

	const int padded = 1;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::sobel_32f()!\n");
		return false;
	}

    bool rlt = sobel_o1_32f(iplPadded, iplDstImage, direction);

    safeReleaseImage(&iplPadded);

    return rlt;
}

bool CImageUtility::sobel_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage, int direction)
// Sobel operator. We do not use OpenCV build-in function because it uses a Gaussian filter before gradient calculation
// This function supports "in-place" operation
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image, has been padded 1 pixels in each direction
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image
//		direction -- [I] direction: 0 -- horizontal;  1 -- vertical;  2 -- modulation (2-norm);    3 -- ABS (1-norm)
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width+2 || iplSrcImage->height != iplDstImage->height+2)  {
		showErrMsg("Invalid input/output image in CImageUtility::sobel_o1_32f()!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    return sobel_o1_32f_SIMD(iplSrcImage, iplDstImage, direction);
#endif      // #ifdef __SR_USE_SIMD

	if (direction == 0) {
		for (int y=0; y<iplDstImage->height; y++) {
			float *pSrcN = (float *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			float *pSrc0 = (float *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			float *pSrc1 = (float *)((char *)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				// -1 0 1
				// -2 0 2
				// -1 0 1
				pDst[x] = (- pSrcN[x]     + pSrcN[x+2]
						   - pSrc0[x] * 2 + pSrc0[x+2] * 2
						   - pSrc1[x]     + pSrc1[x+2]) * 0.25f;
			}
		}
	} else if (direction == 1) {
        for (int y=0; y<iplDstImage->height; y++) {
			float *pSrcN = (float *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			//float *pSrc0 = (float *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			float *pSrc1 = (float *)((char *)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				// -1  -2  -1
				//  0   0   0
				//  1   2   1
				pDst[x] = (- pSrcN[x] - pSrcN[x+1] * 2 - pSrcN[x+2]
					       + pSrc1[x] + pSrc1[x+1] * 2 + pSrc1[x+2]) * 0.25f;
			}
		}
	} else if (direction == 2) {
        for (int y=0; y<iplDstImage->height; y++) {
			float *pSrcN = (float *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			float *pSrc0 = (float *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			float *pSrc1 = (float *)((char *)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				float grad_h = - pSrcN[x]     + pSrcN[x+2]
							   - pSrc0[x] * 2 + pSrc0[x+2] * 2
						       - pSrc1[x]     + pSrc1[x+2];
				float grad_v = - pSrcN[x] - pSrcN[x+1] * 2 - pSrcN[x+2]
					           + pSrc1[x] + pSrc1[x+1] * 2 + pSrc1[x+2];			
				pDst[x] = (float)sqrt( grad_h * grad_h + grad_v * grad_v) * 0.125f;
			}
		}
	} else if (direction == 3) {
        for (int y=0; y<iplDstImage->height; y++) {
			float *pSrcN = (float *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			float *pSrc0 = (float *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			float *pSrc1 = (float *)((char *)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				float grad_h = - pSrcN[x]     + pSrcN[x+2]
							   - pSrc0[x] * 2 + pSrc0[x+2] * 2
						       - pSrc1[x]     + pSrc1[x+2];
				grad_h = grad_h < 0 ? - grad_h : grad_h;
				float grad_v = - pSrcN[x] - pSrcN[x+1] * 2 - pSrcN[x+2]
					           + pSrc1[x] + pSrc1[x+1] * 2 + pSrc1[x+2];			
				grad_v = grad_v < 0 ? - grad_v : grad_v;
				pDst[x] = (grad_h + grad_v) * 0.125f;
			}
		}
	} else {
		showErrMsg("Invalid filter type in CImageUtility::sobel_o1_32f()!\n");
		return false;
	} 
	
	return true;
}

bool CImageUtility::sobel_int(IplImage *iplSrcImage, IplImage *iplDstImage, int direction, int clip_low, int clip_high)
// Sobel operator. We do not use OpenCV build-in function because it uses a Gaussian filter before gradient calculation
// Arguments:
//		iplSrcImage -- [I] input image; must be 32S, 1-channel image
//		iplDstImage -- [O] input image; must be 32S, 1-channel image; should be the same size as iplSrcImage
//		direction -- [I] direction: 0 -- horizontal;  1 -- vertical;  3 -- ABS (1-norm)
//		clip_low, clip_high -- [I] will limit the output to [clip_low, clip_high]
// NOTE: The result is right-shifted 1 MORE BIT to match the bit-depth!
//	Luhong Liang, IC-ASD, ASTRI
//	Jan. 15, 2012
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::sobel_int()!\n");
		return false;
	}

	setZero(iplDstImage);		// ignore the boundary region

	if (direction == 0) {
		for (int y=1; y<iplDstImage->height-1; y++) {
			int *pSrcN = (int *)((char *)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
			int *pSrc0 = (int *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			int *pSrc1 = (int *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			int *pDst = (int *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=1; x<iplDstImage->width-1; x++) {
				// -1 0 1
				// -2 0 2
				// -1 0 1
				int grad = (- pSrcN[x-1]     + pSrcN[x+1]
						   - (pSrc0[x-1]<<1) + (pSrc0[x+1]<<1)
						   - pSrc1[x-1]     + pSrc1[x+1]) >> 3;		// shifted ONE MORE BIT here!
				// clipping
				if (grad < clip_low) {
					pDst[x] = clip_low;
				} else if (grad > clip_high) {
					pDst[x] = clip_high;
				} else {
					pDst[x] = grad;
				}
			}
		}
	} else if (direction == 1) {
		for (int y=1; y<iplDstImage->height-1; y++) {
			int *pSrcN = (int *)((char *)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
			int *pSrc1 = (int *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			int *pDst = (int *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=1; x<iplDstImage->width-1; x++) {
				// -1  -2  -1
				//  0   0   0
				//  1   2   1
				int grad = (- pSrcN[x-1] - (pSrcN[x]<<1) - pSrcN[x+1]
					       + pSrc1[x-1] + (pSrc1[x]<<1) + pSrc1[x+1]) >> 3;		// shifted ONE MORE BIT here!
				// clipping
				if (grad < clip_low) {
					pDst[x] = clip_low;
				} else if (grad > clip_high) {
					pDst[x] = clip_high;
				} else {
					pDst[x] = grad;
				}
			}
		}
	} else if (direction == 3) {
		for (int y=1; y<iplDstImage->height-1; y++) {
			int *pSrcN = (int *)((char *)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
			int *pSrc0 = (int *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			int *pSrc1 = (int *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			int *pDst = (int *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=1; x<iplDstImage->width-1; x++) {
				int grad_h = - pSrcN[x-1]     + pSrcN[x+1]
							 - (pSrc0[x-1]<<1) + (pSrc0[x+1]<<1)
						       - pSrc1[x-1]     + pSrc1[x+1];
				grad_h = grad_h < 0 ? - grad_h : grad_h;
				int grad_v = - pSrcN[x-1] - (pSrcN[x]<<1) - pSrcN[x+1]
					         + pSrc1[x-1] + (pSrc1[x]<<1) + pSrc1[x+1];			
				grad_v = grad_v < 0 ? - grad_v : grad_v;
				int grad = (grad_h + grad_v) >> 4;		// shifted ONE MORE BIT here!
				// clipping
				if (grad < clip_low) {
					pDst[x] = clip_low;
				} else if (grad > clip_high) {
					pDst[x] = clip_high;
				} else {
					pDst[x] = grad;
				}
			}
		}
	} else {
		showErrMsg("Invalid filter type in CImageUtility::sobel_32f()!\n");
		return false;
	} 
		
	return true;
}

bool CImageUtility::sobel_8U_int(IplImage *iplSrcImage, IplImage *iplDstImage, int direction)
// Sobel operator. We do not use OpenCV build-in function because it uses a Gaussian filter before gradient calculation
// Arguments:
//		iplSrcImage -- [I] input image; must be 8U, 1-channel image
//		iplDstImage -- [O] input image; must be 32S, 1-channel image; should be the same size as iplSrcImage
//		direction -- [I] direction: 0 -- horizontal;  1 -- vertical;  3 -- ABS (1-norm)
// NOTE: The result is right-shifted 1 MORE BIT to match the bit-depth (i.e. keep the results between [-127, 127])!
//	Luhong Liang, IC-ASD, ASTRI
//	Feb. 21, 2012
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::sobel_8U_int()!\n");
		return false;
	}

	setZero(iplDstImage);		// ignore the boundary region

	if (direction == 0) {
		for (int y=1; y<iplDstImage->height-1; y++) {
			unsigned char *pSrcN = (unsigned char *)((char *)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
			unsigned char *pSrc0 = (unsigned char *)((unsigned char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			unsigned char *pSrc1 = (unsigned char *)((unsigned char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			int *pDst = (int *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=1; x<iplDstImage->width-1; x++) {
				// -1 0 1
				// -2 0 2
				// -1 0 1
				int grad = (- pSrcN[x-1]     + pSrcN[x+1]
						   - (pSrc0[x-1]<<1) + (pSrc0[x+1]<<1)
						   - pSrc1[x-1]     + pSrc1[x+1]) >> 3;		// shifted ONE MORE BIT here!
				// clipping
				if (grad < -127) {
					pDst[x] = -127;
				} else if (grad > 127) {
					pDst[x] = 127;
				} else {
					pDst[x] = grad;
				}
			}
		}
	} else if (direction == 1) {
		for (int y=1; y<iplDstImage->height-1; y++) {
			unsigned char *pSrcN = (unsigned char *)((char *)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
			unsigned char *pSrc1 = (unsigned char *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			int *pDst = (int *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=1; x<iplDstImage->width-1; x++) {
				// -1  -2  -1
				//  0   0   0
				//  1   2   1
				int grad = (- pSrcN[x-1] - (pSrcN[x]<<1) - pSrcN[x+1]
					       + pSrc1[x-1] + (pSrc1[x]<<1) + pSrc1[x+1]) >> 3;		// shifted ONE MORE BIT here!
				// clipping
				if (grad < -127) {
					pDst[x] = -127;
				} else if (grad > 127) {
					pDst[x] = 127;
				} else {
					pDst[x] = grad;
				}
			}
		}
	} else if (direction == 3) {
		for (int y=1; y<iplDstImage->height-1; y++) {
			unsigned char *pSrcN = (unsigned char *)((char *)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
			unsigned char *pSrc0 = (unsigned char *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			unsigned char *pSrc1 = (unsigned char *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			int *pDst = (int *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=1; x<iplDstImage->width-1; x++) {
				int grad_h = - pSrcN[x-1]     + pSrcN[x+1]
							 - (pSrc0[x-1]<<1) + (pSrc0[x+1]<<1)
						       - pSrc1[x-1]     + pSrc1[x+1];
				grad_h = grad_h < 0 ? - grad_h : grad_h;
				int grad_v = - pSrcN[x-1] - (pSrcN[x]<<1) - pSrcN[x+1]
					         + pSrc1[x-1] + (pSrc1[x]<<1) + pSrc1[x+1];			
				grad_v = grad_v < 0 ? - grad_v : grad_v;
				int grad = (grad_h + grad_v) >> 4;		// shifted ONE MORE BIT here!
				// clipping
				if (grad < -127) {
					pDst[x] = -127;
				} else if (grad > 127) {
					pDst[x] = 127;
				} else {
					pDst[x] = grad;
				}
			}
		}
	} else {
		showErrMsg("Invalid filter type in CImageUtility::sobel_8U_int()!\n");
		return false;
	} 
		
	return true;
}

bool CImageUtility::sobel_8U(IplImage *iplSrcImage, IplImage *iplDstImage, int direction)
// Sobel operator. We do not use OpenCV build-in function because it uses a Gaussian filter before gradient calculation
// Arguments:
//		iplSrcImage -- [I] input image; must be 8U, 1-channel image
//		iplDstImage -- [O] input image; must be 8U, 1-channel image; should be the same size as iplSrcImage
//		direction -- [I] direction: 0 -- horizontal (absolute value);  1 -- vertical (absolute value);  3 -- ABS (1-norm)
//	Luhong Liang, IC-ASD, ASTRI
//	Sept. 25, 2014
{
	if (iplSrcImage == NULL || iplDstImage == NULL || 
        iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U ||
        iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::sobel_8U()!\n");
		return false;
	}

    IplImage *iplPadded = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::sobel_8U()!\n");
		return false;
	}

    bool rlt = sobel_o1_8U(iplPadded, iplDstImage, direction);      // let it check the padding result
    safeReleaseImage(&iplPadded);

    return rlt;
}

bool CImageUtility::sobel_o1_8U(IplImage *iplSrcImage, IplImage *iplDstImage, int direction)
// Sobel operator. We do not use OpenCV build-in function because it uses a Gaussian filter before gradient calculation
// Arguments:
//		iplSrcImage -- [I] input image; must be 8U, 1-channel image, has been padded 1 pixel in each direction
//		iplDstImage -- [O] input image; must be 8U, 1-channel image 
//		direction -- [I] direction: 0 -- horizontal (absolute value);  1 -- vertical (absolute value);  3 -- ABS (1-norm)
//	Luhong Liang, IC-ASD, ASTRI
//	Sept. 25, 2014
{
	if (iplSrcImage == NULL || iplDstImage == NULL || 
        iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U ||
        iplSrcImage->width != iplDstImage->width+2 || iplSrcImage->height != iplDstImage->height+2) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::sobel_o1_8U()!\n");
		return false;
	}

	if (direction == 0) {
		for (int y=0; y<iplDstImage->height; y++) {
			unsigned char *pSrcN = (unsigned char *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			unsigned char *pSrc0 = (unsigned char *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			unsigned char *pSrc1 = (unsigned char *)((char *)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
			unsigned char *pDst = (unsigned char *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				// -1 0 1
				// -2 0 2
				// -1 0 1
				int grad = (- pSrcN[x]          + pSrcN[x+2]
						         - (pSrc0[x]<<1)  + (pSrc0[x+2]<<1)
						         - pSrc1[x]           + pSrc1[x+2]) >> 3;		// shifted ONE MORE BIT here!
				// clipping
                grad = grad < 0 ? -grad : grad;
                grad = grad > 255 ? 255 : grad;
                pDst[x] = (unsigned char)grad;
			}
		}
	} else if (direction == 1) {
		for (int y=0; y<iplDstImage->height; y++) {
			unsigned char *pSrcN = (unsigned char *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			unsigned char *pSrc1 = (unsigned char *)((char *)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
			unsigned char *pDst = (unsigned char *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				// -1  -2  -1
				//  0   0   0
				//  1   2   1
				int grad = (- pSrcN[x] - (pSrcN[x+1]<<1) - pSrcN[x+2]
					             + pSrc1[x] + (pSrc1[x+1]<<1) + pSrc1[x+2]) >> 3;		// shifted ONE MORE BIT here!
				// clipping
                grad = grad < 0 ? -grad : grad;
                grad = grad > 255 ? 255 : grad;
                pDst[x] = (unsigned char)grad;
			}
		}
	} else if (direction == 3) {
		for (int y=0; y<iplDstImage->height; y++) {
			unsigned char *pSrcN = (unsigned char *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			unsigned char *pSrc0 = (unsigned char *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			unsigned char *pSrc1 = (unsigned char *)((char *)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
			unsigned char *pDst = (unsigned char *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				int grad_h = - pSrcN[x]         + pSrcN[x+2]
							       - (pSrc0[x]<<1) + (pSrc0[x+2]<<1)
						            - pSrc1[x]         + pSrc1[x+2];
				grad_h = grad_h < 0 ? - grad_h : grad_h;
				int grad_v = - pSrcN[x] - (pSrcN[x+1]<<1) - pSrcN[x+2]
					               + pSrc1[x] + (pSrc1[x+1]<<1) + pSrc1[x+2];			
				grad_v = grad_v < 0 ? - grad_v : grad_v;
				int grad = (grad_h + grad_v) >> 3;
				// clipping
                grad = grad > 255 ? 255 : grad;
                pDst[x] = (unsigned char)grad;
			}
		}
	} else {
		showErrMsg("Invalid filter type in CImageUtility::sobel_8U()!\n");
		return false;
	} 
		
	return true;
}

bool CImageUtility::sobel_8U_int_s5(IplImage *iplSrcImage, IplImage *iplDstImage, int direction)
// Sobel operator. We do not use OpenCV build-in function because it uses a Gaussian filter before gradient calculation
// Different from sobel_8U_int, this function supposes the input image has been padded by 1 pixel in each direction.
// Arguments:
//		iplSrcImage -- [I] input image; must be 8U, 1-channel image
//		iplDstImage -- [O] input image; must be 32S (result range is -127~127), 1-channel image; should be the same size as iplSrcImage,
//		direction -- [I] direction: 0 -- horizontal;  1 -- vertical;  3 -- ABS (1-norm)
// NOTE: The result is right-shifted 1 MORE BIT to match the bit-depth (i.e. keep the results between [-127, 127])!
//	Luhong Liang, IC-ASD, ASTRI
//	May. 27, 2012
// June 20, 2014: fixed bug in option direction == 3
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::sobel_8U_int_s5()!\n");
		return false;
	}

	if (direction == 0) {
		for (int y=0; y<iplDstImage->height; y++) {
			unsigned char *pSrcN = (unsigned char *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			unsigned char *pSrc0 = (unsigned char *)((unsigned char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			unsigned char *pSrc1 = (unsigned char *)((unsigned char *)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
			int *pDst = (int *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				// -1 0 1
				// -2 0 2
				// -1 0 1
				int grad = (- pSrcN[x]     + pSrcN[x+2]
						   - (pSrc0[x]<<1) + (pSrc0[x+2]<<1)
						   - pSrc1[x]     + pSrc1[x+2]) >> 3;		// shifted ONE MORE BIT here!
				// clipping
				if (grad < -127) {
					pDst[x] = -127;
				} else if (grad > 127) {
					pDst[x] = 127;
				} else {
					pDst[x] = grad;
				}
			}
		}
	} else if (direction == 1) {
		for (int y=0; y<iplDstImage->height; y++) {
			unsigned char *pSrcN = (unsigned char *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			unsigned char *pSrc1 = (unsigned char *)((char *)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
			int *pDst = (int *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				// -1  -2  -1
				//  0   0   0
				//  1   2   1
				int grad = (- pSrcN[x] - (pSrcN[x+1]<<1) - pSrcN[x+2]
					        + pSrc1[x] + (pSrc1[x+1]<<1) + pSrc1[x+2]) >> 3;		// shifted ONE MORE BIT here!
				// clipping
				if (grad < -127) {
					pDst[x] = -127;
				} else if (grad > 127) {
					pDst[x] = 127;
				} else {
					pDst[x] = grad;
				}
			}
		}
	} else if (direction == 3) {
		for (int y=0; y<iplDstImage->height; y++) {
			unsigned char *pSrcN = (unsigned char *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			unsigned char *pSrc0 = (unsigned char *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			unsigned char *pSrc1 = (unsigned char *)((char *)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
			int *pDst = (int *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				int grad_h = - pSrcN[x]     + pSrcN[x+2]
							 - (pSrc0[x]<<1) + (pSrc0[x+2]<<1)
						     - pSrc1[x]     + pSrc1[x+2];
				grad_h = grad_h < 0 ? - grad_h : grad_h;
				int grad_v = - pSrcN[x] - (pSrcN[x+1]<<1) - pSrcN[x+2]
					         + pSrc1[x] + (pSrc1[x+1]<<1) + pSrc1[x+2];			
				grad_v = grad_v < 0 ? - grad_v : grad_v;
				int grad = (grad_h + grad_v) >> 3;
				// clipping
                grad = grad > 255 ? 255 : grad;     // June 20, 2014: fixed bug
                pDst[x] = grad;
			}
		}
	} else {
		showErrMsg("Invalid filter type in CImageUtility::sobel_8U_int_s5()!\n");
		return false;
	} 
		
	return true;
}

bool CImageUtility::sobel_laplace_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Sobel + Laplace operator: Sobel : SAD of gradients in x and y directions
// Sobel operator. We do not use OpenCV build-in function because it uses a Gaussian filter before gradient calculation
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image; should be the same size as iplSrcImage
{
	if (iplSrcImage == NULL || iplDstImage == NULL) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::sobel_laplace_32f()!\n");
		return false;
	}

	const int padded = 1;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::sobel_laplace_32f()!\n");
		return false;
	}

    bool rlt = sobel_laplace_o1_32f(iplPadded, iplDstImage);

    safeReleaseImage(&iplPadded);

    return rlt;
}

bool CImageUtility::sobel_laplace_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Sobel + Laplace operator: Sobel : SAD of gradients in x and y directions
// Sobel operator. This function suppose the input image has been padded 1 pixel in each direction
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image, has been padded 1 pixel in each direction
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width+2 || iplSrcImage->height != iplDstImage->height+2)  {
		showErrMsg("Invalid input/output image in CImageUtility::sobel_laplace_o1_32f()!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    return sobel_laplace_o1_32f_SIMD(iplSrcImage, iplDstImage);
#endif      // #ifdef __SR_USE_SIMD

	for (int y=0; y<iplDstImage->height; y++) {
		float *pSrcN = (float *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		float *pSrc0 = (float *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		float *pSrc1 = (float *)((char *)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			// sobel
			float grad_h = - pSrcN[x]     + pSrcN[x+2]          // x index bug fixed by Luhong (March 4, 2015)
						   - pSrc0[x] * 2 + pSrc0[x+2] * 2
					       - pSrc1[x]     + pSrc1[x+2];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			float grad_v = - pSrcN[x] - pSrcN[x+1] * 2 - pSrcN[x+2]
				           + pSrc1[x] + pSrc1[x+1] * 2 + pSrc1[x+2];			
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			// laplace
			float lap = - pSrcN[x+1] - pSrc0[x] + pSrc0[x+1] * 4 - pSrc0[x+2] - pSrc1[x+1];
			lap = lap < 0.0f ? -lap : lap;
			pDst[x] = (grad_h + grad_v) * 0.125f + lap;
		}
	}
		
	return true;
}

bool CImageUtility::sobel_laplace_abs_2_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// sobel and laplace operator followed by a 3x3 max filter
// This is an optimized version where the Sobel operation is fixed to absolute sum of X and Y gradient
// and the magnification factor is fixed to 2!
// This function is identical to the Sobel-Laplace part of function sobel_laplace_max3x3_abs_2_32f().
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::sobel_laplace_abs_2_32f()!\n");
		return false;
	}

    // alloacate buffer
	IplImage *iplPadded = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::sobel_laplace_abs_2_32f()!\n");
        safeReleaseImage(&iplPadded);
		return false;
	}
    
    // sobel & laplace
    for (int y=0; y<iplDstImage->height; y++) {
        float *pSrcN = (float *)((char *)iplPadded->imageData + y * iplPadded->widthStep);
        float *pSrc0 = (float *)((char *)iplPadded->imageData + (y+1) * iplPadded->widthStep);
        float *pSrc1 = (float *)((char *)iplPadded->imageData + (y+2) * iplPadded->widthStep);
        float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            // Sobel
            float grad_h = - pSrcN[x]     + pSrcN[x+2]
                           - pSrc0[x] * 2 + pSrc0[x+2] * 2
						   - pSrc1[x]     + pSrc1[x+2];
            grad_h = grad_h < 0 ? - grad_h : grad_h;
            float grad_v = - pSrcN[x] - pSrcN[x+1] * 2 - pSrcN[x+2]
                           + pSrc1[x] + pSrc1[x+1] * 2 + pSrc1[x+2];			
                           grad_v = grad_v < 0 ? - grad_v : grad_v;
            float sob = (grad_h + grad_v) * 0.25f;

			// laplace
			float lap = (- pSrcN[x+1] - pSrc0[x] + pSrc0[x+1] * 4 - pSrc0[x+2] - pSrc1[x+1]) * 0.5f;
			lap = lap < 0.0f ? -lap : lap;

            // fusion (to make the gradient magnitude equivalent to sobel only)
            pDst[x] = lap > sob ? lap : sob;
        }
    }
    //saveImage("_Sobel.bmp", iplInter);
    //saveImage("_Sobel_Laplace.bmp", iplInter);
    
    safeReleaseImage(&iplPadded);

    return true;
}

bool CImageUtility::sobel_laplace_int(IplImage *iplSrcImage, int src_depth, IplImage *iplDstImage, int dst_depth)
// Sobel + Laplace operator: Sobel : SAD of gradients in x and y directions
// Sobel operator. We do not use OpenCV build-in function because it uses a Gaussian filter before gradient calculation
// Arguments:
//		iplSrcImage -- [I] input image; must be 32S, 1-channel image
//		src_depth -- [I] bit depth of iplSrcImage, must between 8 and 16
//		iplDstImage -- [O] output image; must be 8U, 1-channel image; should be the same size as iplSrcImage
//		dst_depth -- [I] bit depth of iplDstImage, must between 2 and 8
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width ||		// TODO: complete check needed
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_8U ||
		src_depth < 8 || src_depth > 16 || dst_depth < 2 || dst_depth > 8) {
		showErrMsg("Invalid input/output image in CImageUtility::sobel_laplace_int()!\n");
		return false;
	}

	setZero(iplDstImage);		// to ignore the boundary

	int clip_th = (1 << dst_depth) - 1;

	for (int y=1; y<iplDstImage->height-1; y++) {
		int *pSrcN = (int *)((char *)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
		int *pSrc0 = (int *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		unsigned char *pDst = (unsigned char *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=1; x<iplDstImage->width-1; x++) {
			// sobel
			int grad_h = - pSrcN[x-1]     + pSrcN[x+1]
						 - (pSrc0[x-1] << 1) + (pSrc0[x+1] << 1)
					     - pSrc1[x-1]     + pSrc1[x+1];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			int grad_v = - pSrcN[x-1] - (pSrcN[x] << 1) - pSrcN[x+1]
				           + pSrc1[x-1] + (pSrc1[x] << 1) + pSrc1[x+1];			
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			// laplace
			int lap = - pSrcN[x] - pSrc0[x-1] + (pSrc0[x] << 2) - pSrc0[x+1] - pSrc1[x];
			lap = lap < 0.0f ? -lap : lap;
			// fusion
			int val = ((grad_h + grad_v) >> 3) + lap;
			val = val >> (src_depth - dst_depth);		// normalize to dst_depth
			// clipping
			pDst[x] = (unsigned char)(val > clip_th ? clip_th : val);
		}
	}
		
	return true;
}

bool CImageUtility::sobel_laplace_int_s5(IplImage *iplSrcImage, int src_depth, IplImage *iplDstImage, int dst_depth)
// Sobel + Laplace operator: Sobel : SAD of gradients in x and y directions
// Sobel operator. We do not use OpenCV build-in function because it uses a Gaussian filter before gradient calculation
// Different from sobel_laplace_int(), this function supposes the input image has been padded.
// Arguments:
//		iplSrcImage -- [I] input image; must be 32S, 1-channel image
//		src_depth -- [I] bit depth of iplSrcImage, must between 8 and 16
//		iplDstImage -- [O] output image; must be 8U, 1-channel image; should be the same size as iplSrcImage
//		dst_depth -- [I] bit depth of iplDstImage, must between 2 and 8
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_8U ||
		src_depth < 8 || src_depth > 16 || dst_depth < 2 || dst_depth > 8) {
		showErrMsg("Invalid input/output image in CImageUtility::sobel_laplace_int_s5()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width+2 || iplSrcImage->height != iplDstImage->height+2) {
		showErrMsg("Sizes of the input and output image do not match in CImageUtility::sobel_laplace_int_s5()!\n");
		return false;
	}

	int clip_th = (1 << dst_depth) - 1;

	for (int y=0; y<iplDstImage->height; y++) {
		int *pSrcN = (int *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc0 = (int *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char *)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		unsigned char *pDst = (unsigned char *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			// sobel
			int grad_h = - pSrcN[x]     + pSrcN[x+2]
						 - (pSrc0[x] << 1) + (pSrc0[x+2] << 1)
					     - pSrc1[x]     + pSrc1[x+2];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			int grad_v = - pSrcN[x] - (pSrcN[x+1] << 1) - pSrcN[x+2]
				           + pSrc1[x] + (pSrc1[x+1] << 1) + pSrc1[x+2];			
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			// laplace
			int lap = - pSrcN[x+1] - pSrc0[x] + (pSrc0[x+1] << 2) - pSrc0[x+2] - pSrc1[x+1];
			lap = lap < 0.0f ? -lap : lap;
			// fusion
			int val = ((grad_h + grad_v) >> 3) + lap;
			val = val >> (src_depth - dst_depth);		// normalize to dst_depth
			// clipping
			pDst[x] = (unsigned char)(val > clip_th ? clip_th : val);
		}
	}
		
	return true;
}

bool CImageUtility::sobel_laplace_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Sobel + Laplace operator: Sobel : SAD of gradients in x and y directions
// Sobel operator. We do not use OpenCV build-in function because it uses a Gaussian filter before gradient calculation
// Arguments:
//		iplSrcImage -- [I] input image; must be 8U, 1-channel image
//		iplDstImage -- [O] input image; must be 8U, 1-channel image; should be the same size as iplSrcImage
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width ||		// TODO: complete check needed
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input/output image in CImageUtility::sobel_laplace_8U()!\n");
		return false;
	}

	setZero(iplDstImage);		// to ignore the boundary

	for (int y=1; y<iplDstImage->height-1; y++) {
		unsigned char *pSrcN = (unsigned char *)((char *)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
		unsigned char *pSrc0 = (unsigned char *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		unsigned char *pSrc1 = (unsigned char *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		unsigned char *pDst = (unsigned char *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=1; x<iplDstImage->width-1; x++) {
			// sobel
			int grad_h = - pSrcN[x-1]     + pSrcN[x+1]
						 - (pSrc0[x-1] << 1) + (pSrc0[x+1] << 1)
					     - pSrc1[x-1]     + pSrc1[x+1];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			int grad_v = - pSrcN[x-1] - (pSrcN[x] << 1) - pSrcN[x+1]
				           + pSrc1[x-1] + (pSrc1[x] << 1) + pSrc1[x+1];			
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			// laplace
			int lap = - pSrcN[x] - pSrc0[x-1] + (pSrc0[x] << 2) - pSrc0[x+1] - pSrc1[x];
			lap = lap < 0.0f ? -lap : lap;
			// fusion
			int val = (grad_h + grad_v) + (lap << 3);
			val = val >> 2;		// normalize to dst_depth
			// clipping and rounding
			if (val > 511) {
				pDst[x] = 255;
			} else {
				pDst[x] = (unsigned char)(((val & 0x0001) == 0) ? (val>>1) : ((val>>1)+1));
			}
		}
	}
		
	return true;
}

bool CImageUtility::sobel_max3x3_32f(IplImage *iplSrcImage, IplImage *iplDstImage, int direction, float factor)
// sobel operator followed by a 3x3 max filter
{
    // Sobel filter
    if (!sobel_32f(iplSrcImage, iplDstImage, direction)) return false;
    // saveImage("_Sobel.bmp", iplDstImage);

    // MAX filter
    if (!max3x3_32f(iplDstImage, iplDstImage)) return false;

    // magnification factor
    for (int y=0; y<iplDstImage->height; y++) {
        float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            pDst[x] *= factor;
        }
    }

    return true;
}

bool CImageUtility::sobel_max3x3_abs_2_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// sobel operator followed by a 3x3 max filter
// This is an optimized version where the Sobel operation is fixed to absolute sum of X and Y gradient
// and the magnification factor is fixed to 2!
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::sobel_max3x3_o1_32f()!\n");
		return false;
	}

    // alloacate buffer
	IplImage *iplPadded = padding(iplSrcImage, 2, 2, 2, 2);
    IplImage *iplInter = createImage(iplDstImage->width+2, iplDstImage->height+2, SR_DEPTH_32F, 1);
    float *pLineBuf = new float[iplPadded->width];
	if (iplPadded == NULL || iplInter == NULL || pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::sobel_max3x3_o1_32f()!\n");
        safeReleaseImage(&iplPadded, &iplInter);
        if (pLineBuf != NULL) delete [] pLineBuf;
		return false;
	}
    
    // sobel
    for (int y=0; y<iplInter->height; y++) {
        float *pSrcN = (float *)((char *)iplPadded->imageData + y * iplPadded->widthStep);
        float *pSrc0 = (float *)((char *)iplPadded->imageData + (y+1) * iplPadded->widthStep);
        float *pSrc1 = (float *)((char *)iplPadded->imageData + (y+2) * iplPadded->widthStep);
        float *pDst = (float *)((char *)iplInter->imageData + y * iplInter->widthStep);
        for (int x=0; x<iplInter->width; x++) {
            float grad_h = - pSrcN[x]     + pSrcN[x+2]
                           - pSrc0[x] * 2 + pSrc0[x+2] * 2
						   - pSrc1[x]     + pSrc1[x+2];
            grad_h = grad_h < 0 ? - grad_h : grad_h;
            float grad_v = - pSrcN[x] - pSrcN[x+1] * 2 - pSrcN[x+2]
                           + pSrc1[x] + pSrc1[x+1] * 2 + pSrc1[x+2];			
                           grad_v = grad_v < 0 ? - grad_v : grad_v;
            pDst[x] = (grad_h + grad_v) * 0.25f;
        }
    }

    // MAX filter
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		float *pSrc0 = (float *)((char*)iplInter->imageData + y * iplInter->widthStep);
		float *pSrc1 = (float *)((char*)iplInter->imageData + (y+1) * iplInter->widthStep);
		float *pSrc2 = (float *)((char*)iplInter->imageData + (y+2) * iplInter->widthStep);
		for (int x=0; x<iplInter->width; x++) {
            float maxv = pSrc0[x] > pSrc1[x] ? pSrc0[x] : pSrc1[x];
            maxv = maxv > pSrc2[x] ? maxv : pSrc2[x];
			pLineBuf[x] = maxv;
		}
		// convolution in X direction
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            float maxv = pLineBuf[x] > pLineBuf[x+1] ? pLineBuf[x] : pLineBuf[x+1];
            maxv = maxv > pLineBuf[x+2] ? maxv : pLineBuf[x+2];
			pDst[x] = maxv;

		}
	}

	delete [] pLineBuf;
    safeReleaseImage(&iplPadded, &iplInter);

    return true;
}

bool CImageUtility::sobel_max5x5_32f(IplImage *iplSrcImage, IplImage *iplDstImage, int direction, float factor)
// sobel operator followed by a 5x5 max filter
{
    // Sobel filter
    if (!sobel_32f(iplSrcImage, iplDstImage, direction)) return false;

    // MAX filter
    if (!max5x5_32f(iplDstImage, iplDstImage)) return false;

    // magnification factor
    for (int y=0; y<iplDstImage->height; y++) {
        float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            pDst[x] *= factor;
        }
    }

    return true;
}

bool CImageUtility::sobel_laplace_max3x3_abs_2_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// sobel and laplace operator followed by a 3x3 max filter
// This is an optimized version where the Sobel operation is fixed to absolute sum of X and Y gradient
// and the magnification factor is fixed to 2!
// The Sobel-Laplace part of this function is identical to the function sobel_laplace_abs_2_32f().
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::sobel_laplace_max3x3_abs_2_32f()!\n");
		return false;
	}

    // alloacate buffer
	IplImage *iplPadded = padding(iplSrcImage, 2, 2, 2, 2);
    IplImage *iplInter = createImage(iplDstImage->width+2, iplDstImage->height+2, SR_DEPTH_32F, 1);
    float *pLineBuf = new float[iplPadded->width];
	if (iplPadded == NULL || iplInter == NULL || pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::sobel_laplace_max3x3_abs_2_32f()!\n");
        safeReleaseImage(&iplPadded, &iplInter);
        if (pLineBuf != NULL) delete [] pLineBuf;
		return false;
	}
    
    // sobel & laplace
    for (int y=0; y<iplInter->height; y++) {
        float *pSrcN = (float *)((char *)iplPadded->imageData + y * iplPadded->widthStep);
        float *pSrc0 = (float *)((char *)iplPadded->imageData + (y+1) * iplPadded->widthStep);
        float *pSrc1 = (float *)((char *)iplPadded->imageData + (y+2) * iplPadded->widthStep);
        float *pDst = (float *)((char *)iplInter->imageData + y * iplInter->widthStep);
        for (int x=0; x<iplInter->width; x++) {
            // Sobel
            float grad_h = - pSrcN[x]     + pSrcN[x+2]
                           - pSrc0[x] * 2 + pSrc0[x+2] * 2
						   - pSrc1[x]     + pSrc1[x+2];
            grad_h = grad_h < 0 ? - grad_h : grad_h;
            float grad_v = - pSrcN[x] - pSrcN[x+1] * 2 - pSrcN[x+2]
                           + pSrc1[x] + pSrc1[x+1] * 2 + pSrc1[x+2];			
                           grad_v = grad_v < 0 ? - grad_v : grad_v;
            float sob = (grad_h + grad_v) * 0.25f;

			// laplace
			float lap = (- pSrcN[x+1] - pSrc0[x] + pSrc0[x+1] * 4 - pSrc0[x+2] - pSrc1[x+1]) * 0.5f;
			lap = lap < 0.0f ? -lap : lap;

            // fusion (to make the gradient magnitude equivalent to sobel only)
            pDst[x] = lap > sob ? lap : sob;
        }
    }
    //saveImage("_Sobel.bmp", iplInter);
    //saveImage("_Sobel_Laplace.bmp", iplInter);

    // MAX filter
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		float *pSrc0 = (float *)((char*)iplInter->imageData + y * iplInter->widthStep);
		float *pSrc1 = (float *)((char*)iplInter->imageData + (y+1) * iplInter->widthStep);
		float *pSrc2 = (float *)((char*)iplInter->imageData + (y+2) * iplInter->widthStep);
		for (int x=0; x<iplInter->width; x++) {
            float maxv = pSrc0[x] > pSrc1[x] ? pSrc0[x] : pSrc1[x];
            maxv = maxv > pSrc2[x] ? maxv : pSrc2[x];
			pLineBuf[x] = maxv;
		}
		// convolution in X direction
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            float maxv = pLineBuf[x] > pLineBuf[x+1] ? pLineBuf[x] : pLineBuf[x+1];
            maxv = maxv > pLineBuf[x+2] ? maxv : pLineBuf[x+2];
			pDst[x] = maxv;

		}
	}

	delete [] pLineBuf;
    safeReleaseImage(&iplPadded, &iplInter);

    return true;
}

bool CImageUtility::sobel5x5_32f(IplImage *iplImage, IplImage *iplDstImage, int direction)
// A fixed-point implementation of the Gaussian filter with 7x7 window and sigma = 1.0
// This function supports the "in-place" operation (source and destination images are the same one)
// This function does not use the decomposition algorithm and ignore the boundary effects
// Kayton Modified 5x5 Sobel Filter
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_10_int()!\n");
		return false;
	}

	int pFilter5x5_G1_10[] = {  0,   0,   0,   0,   0,
								1,   3,   8,   3,   1,
								0,   0,   0,   0,   0, 
							   -1,  -3,  -8,  -3,  -1,
								0,   0,   0,   0,   0};

	int pFilter5x5_G2_10[] = {  0,   0,   1,   0,   0,
								0,   8,   3,   0,   0,
								1,   3,   0,  -3,  -1, 
								0,   0,  -3,  -8,   0,
								0,   0,  -1,   0,   0};

	int pFilter5x5_G3_10[] = {  0,   0,   1,   0,   0,
								0,   0,   3,   8,   0,
							   -1,  -3,   0,   3,   1, 
								0,  -8,  -3,   0,   0,
								0,   0,  -1,   0,   0};

	int pFilter5x5_G4_10[] = {  0,   1,   0,  -1,   0,
								0,   3,   0,  -3,   0,
							    0,   8,   0,  -8,   0, 
								0,   3,   0,  -3,   0,
								0,   0,   0,  -1,   0};

	int *pFilter = NULL;
	// set filter used
	if (direction == 1)  {
		pFilter = pFilter5x5_G1_10;
	}else 	if (direction == 2)  {
		pFilter = pFilter5x5_G2_10;
	}else 	if (direction == 3)  {
		pFilter = pFilter5x5_G3_10;
	}else 	if (direction == 4) {
		pFilter = pFilter5x5_G4_10;
	}else {
		showErrMsg("Unsupported direction in CImageUtility::sobel5x5_32f()!\n");
		return false;
	}

	// padding
	const int wnd_size = 5;
	const int padded = 2;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_10_f()!\n");
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			float val = 0;
			for (int yy=0; yy<wnd_size; yy++) {
				int *pF = pFilter + yy * wnd_size;
				float *pSrc = (float *)((char*)iplSrcImage->imageData + (y+yy) * iplSrcImage->widthStep) + x;
				for (int xx=0; xx<wnd_size; xx++) {
					val += pSrc[xx] * pF[xx];		// cannot shift here due to visible quality loss!
				}
			}
			//pDst[x] = val >> filter_bit_depth;	//org code
			pDst[x] = val / 16.0f;
		}
	}

	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::sobel5x5ds_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// 5x5 Sobel operator (not used)
// Filter (x direction as example)
//     -1   -1    0    1     1
//     -3   -3    0    3     3
//     -4   -4    0    4     4
//     -3   -3    0    3     3
//     -1   -1    0    1     1
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image; should be the same size as iplSrcImage
{
	if (iplSrcImage == NULL || iplDstImage == NULL) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::sobel5x5ds_32f()!\n");
		return false;
	}

	const int padded = 2;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::sobel5x5ds_32f()!\n");
		return false;
	}

    for (int y=0; y<iplDstImage->height; y++) {
        float *pSrc0 = (float *)((char *)iplPadded->imageData + y * iplPadded->widthStep);
        float *pSrc1 = (float *)((char *)iplPadded->imageData + (y+1) * iplPadded->widthStep);
        float *pSrc2 = (float *)((char *)iplPadded->imageData + (y+2) * iplPadded->widthStep);
        float *pSrc3 = (float *)((char *)iplPadded->imageData + (y+3) * iplPadded->widthStep);
        float *pSrc4 = (float *)((char *)iplPadded->imageData + (y+4) * iplPadded->widthStep);
        float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            // x direction
            //float grad_h =    -pSrc0[x]  -    pSrc0[x+1] +    pSrc0[x+3] +    pSrc0[x+4]
            //                      -3*pSrc1[x]  - 3*pSrc1[x+1] + 3*pSrc1[x+3] + 3*pSrc1[x+4]
            //                      -4*pSrc2[x]  - 4*pSrc2[x+1] + 4*pSrc2[x+3] + 4*pSrc2[x+4]
            //                      -3*pSrc3[x]  - 3*pSrc3[x+1] + 3*pSrc3[x+3] + 3*pSrc3[x+4]
            //                         -pSrc4[x]  -    pSrc4[x+1] +    pSrc4[x+3] +    pSrc4[x+4];
            float grad_h =   -pSrc0[x]  - pSrc0[x+1] + pSrc0[x+3] + pSrc0[x+4]
                             -pSrc1[x]  - pSrc1[x+1] + pSrc1[x+3] + pSrc1[x+4]
                             -pSrc2[x]  - pSrc2[x+1] + pSrc2[x+3] + pSrc2[x+4]
                             -pSrc3[x]  - pSrc3[x+1] + pSrc3[x+3] + pSrc3[x+4]
                             -pSrc4[x]  - pSrc4[x+1] + pSrc4[x+3] + pSrc4[x+4];
		    grad_h = grad_h < 0 ? - grad_h : grad_h;
            //float grad_v =  -pSrc0[x]  -  3*pSrc0[x+1] - 4*pSrc0[x+2] - 3*pSrc0[x+3] - pSrc0[x+4]
            //                       -pSrc1[x]  -  3*pSrc1[x+1] - 4*pSrc1[x+2] - 3*pSrc1[x+3] - pSrc1[x+4] 
            //                      +pSrc3[x]  + 3*pSrc3[x+1] + 4*pSrc3[x+2] + 3*pSrc3[x+3] + pSrc3[x+4]
            //                      +pSrc4[x]  + 3*pSrc4[x+1] + 4*pSrc4[x+2] + 3*pSrc4[x+3] + pSrc4[x+4];
            float grad_v =  -pSrc0[x]  -  pSrc0[x+1] - pSrc0[x+2] - pSrc0[x+3] - pSrc0[x+4]
                            -pSrc1[x]  -  pSrc1[x+1] - pSrc1[x+2] - pSrc1[x+3] - pSrc1[x+4] 
                            +pSrc3[x]  + pSrc3[x+1] + pSrc3[x+2] + pSrc3[x+3] + pSrc3[x+4]
                            +pSrc4[x]  + pSrc4[x+1] + pSrc4[x+2] + pSrc4[x+3] + pSrc4[x+4];
			grad_v = grad_v < 0.0f ? - grad_v : grad_v;
			pDst[x] = (grad_h + grad_v) * 0.125f * 0.5f;
		}
	}
    safeReleaseImage(&iplPadded);
	
	return true;
}

bool CImageUtility::prewitt3x3max_int(IplImage *iplSrcImage, int src_depth, IplImage *iplDstImage, int dst_depth)
// Extended 5x5 prewitt edge detection
// The filter is 3x3 prewitt filters
//   1  1  1			-1  0  1
//   0  0  0			-1  0  1
//  -1 -1 -1			-1  0  1
// followed by a hit operation in the 5x5 window.
// NOTE: only the internal (w-4)x(h-4) region is valid in the result image!
// Arguments:
//		iplSrcImage -- [I] input image; must be 32S, 1-channel image
//		src_depth -- [I] bit depth of iplSrcImage, must between 8 and 16
//		iplDstImage -- [O] input image; must be 8U, 1-channel image; should be the same size as iplSrcImage
//		dst_depth -- [I] bit depth of iplDstImage, must between 2 and 8
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width ||		// TODO: complete check needed
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_8U ||
		src_depth < 8 || src_depth > 16 || dst_depth < 2 || dst_depth > 8) {
		showErrMsg("Invalid input/output image in CImageUtility::prewitt3x3max_int()!\n");
		return false;
	}

	setZero(iplDstImage);		// to ignore the boundary

	int clip_th = (1 << dst_depth) - 1;

	for (int y=2; y<iplDstImage->height-2; y++) {
		int *pSrc0 = (int *)((char*)iplSrcImage->imageData + (y-2) * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char*)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
		int *pSrc2 = (int *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc3 = (int *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		int *pSrc4 = (int *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		unsigned char *pDst = (unsigned char *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=2; x<iplDstImage->width-2; x++) {
			int grad_h, grad_v, grad, temp;
			// 9 prewitt 3x3 operations in a 5x5 window
			// (0,0)
			grad_h = -pSrc0[x-2] + pSrc0[x] - pSrc1[x-2] + pSrc1[x] - pSrc2[x-2] + pSrc2[x];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc0[x-2] + pSrc0[x-1] + pSrc0[x] - pSrc2[x-2] - pSrc2[x-1] - pSrc2[x];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			grad = grad_h + grad_v;
			// (0,1)
			grad_h = -pSrc0[x-1] + pSrc0[x+1] - pSrc1[x-1] + pSrc1[x+1] - pSrc2[x-1] + pSrc2[x+1];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc0[x-1] + pSrc0[x] + pSrc0[x+1] - pSrc2[x-1] - pSrc2[x] - pSrc2[x+1];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (0,2)
			grad_h = -pSrc0[x] + pSrc0[x+2] - pSrc1[x] + pSrc1[x+2] - pSrc2[x] + pSrc2[x+2];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc0[x] + pSrc0[x+1] + pSrc0[x+2] - pSrc2[x] - pSrc2[x+1] - pSrc2[x+2];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (1,0)
			grad_h = -pSrc1[x-2] + pSrc1[x] - pSrc2[x-2] + pSrc2[x] - pSrc3[x-2] + pSrc3[x];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc1[x-2] + pSrc1[x-1] + pSrc1[x] - pSrc3[x-2] - pSrc3[x-1] - pSrc3[x];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (1,1)
			grad_h = -pSrc1[x-1] + pSrc1[x+1] - pSrc2[x-1] + pSrc2[x+1] - pSrc3[x-1] + pSrc3[x+1];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc1[x-1] + pSrc1[x] + pSrc1[x+1] - pSrc3[x-1] - pSrc3[x] - pSrc3[x+1];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (1,2)
			grad_h = -pSrc1[x] + pSrc1[x+2] - pSrc2[x] + pSrc2[x+2] - pSrc3[x] + pSrc3[x+2];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc1[x] + pSrc1[x+1] + pSrc1[x+2] - pSrc3[x] - pSrc3[x+1] - pSrc3[x+2];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;			
			// (2,0)
			grad_h = -pSrc2[x-2] + pSrc2[x] - pSrc3[x-2] + pSrc3[x] - pSrc4[x-2] + pSrc4[x];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc2[x-2] + pSrc2[x-1] + pSrc2[x] - pSrc4[x-2] - pSrc4[x-1] - pSrc4[x];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (2,1)
			grad_h = -pSrc2[x-1] + pSrc2[x+1] - pSrc3[x-1] + pSrc3[x+1] - pSrc4[x-1] + pSrc4[x+1];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc2[x-1] + pSrc2[x] + pSrc2[x+1] - pSrc4[x-1] - pSrc4[x] - pSrc4[x+1];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (2,2)
			grad_h = -pSrc2[x] + pSrc2[x+2] - pSrc3[x] + pSrc3[x+2] - pSrc4[x] + pSrc4[x+2];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc2[x] + pSrc2[x+1] + pSrc2[x+2] - pSrc4[x] - pSrc4[x+1] - pSrc4[x+2];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;			
			// fusion
			int val = (grad >> 1) + (grad >> 2);
			val = val >> (src_depth - dst_depth);		// normalize to dst_depth
			// clipping
			pDst[x] = (unsigned char)(val > clip_th ? clip_th : val);
		}
	}
		
	return true;
}

bool CImageUtility::prewitt3x3max_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Extended 5x5 prewitt edge detection
// The filter is 3x3 prewitt filters
//   1  1  1			-1  0  1
//   0  0  0			-1  0  1
//  -1 -1 -1			-1  0  1
// followed by a hit operation in the 5x5 window.
// Arguments:
//		iplSrcImage -- [I] input image; must be 8U, 1-channel image
//		iplDstImage -- [O] input image; must be 8U, 1-channel image; should be the same size as iplSrcImage
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width ||		// TODO: complete check needed
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input/output image in CImageUtility::prewitt3x3max_8U()!\n");
		return false;
	}

	setZero(iplDstImage);		// to ignore the boundary

	for (int y=2; y<iplDstImage->height-2; y++) {
		unsigned char *pSrc0 = (unsigned char *)((char*)iplSrcImage->imageData + (y-2) * iplSrcImage->widthStep);
		unsigned char *pSrc1 = (unsigned char *)((char*)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
		unsigned char *pSrc2 = (unsigned char *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		unsigned char *pSrc3 = (unsigned char *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		unsigned char *pSrc4 = (unsigned char *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		unsigned char *pDst = (unsigned char *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=2; x<iplDstImage->width-2; x++) {
			int grad_h, grad_v, grad, temp;
			// 9 prewitt 3x3 operations in a 5x5 window
			// (0,0)
			grad_h = -pSrc0[x-2] + pSrc0[x] - pSrc1[x-2] + pSrc1[x] - pSrc2[x-2] + pSrc2[x];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc0[x-2] + pSrc0[x-1] + pSrc0[x] - pSrc2[x-2] - pSrc2[x-1] - pSrc2[x];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			grad = grad_h + grad_v;
			// (0,1)
			grad_h = -pSrc0[x-1] + pSrc0[x+1] - pSrc1[x-1] + pSrc1[x+1] - pSrc2[x-1] + pSrc2[x+1];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc0[x-1] + pSrc0[x] + pSrc0[x+1] - pSrc2[x-1] - pSrc2[x] - pSrc2[x+1];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (0,2)
			grad_h = -pSrc0[x] + pSrc0[x+2] - pSrc1[x] + pSrc1[x+2] - pSrc2[x] + pSrc2[x+2];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc0[x] + pSrc0[x+1] + pSrc0[x+2] - pSrc2[x] - pSrc2[x+1] - pSrc2[x+2];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (1,0)
			grad_h = -pSrc1[x-2] + pSrc1[x] - pSrc2[x-2] + pSrc2[x] - pSrc3[x-2] + pSrc3[x];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc1[x-2] + pSrc1[x-1] + pSrc1[x] - pSrc3[x-2] - pSrc3[x-1] - pSrc3[x];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (1,1)
			grad_h = -pSrc1[x-1] + pSrc1[x+1] - pSrc2[x-1] + pSrc2[x+1] - pSrc3[x-1] + pSrc3[x+1];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc1[x-1] + pSrc1[x] + pSrc1[x+1] - pSrc3[x-1] - pSrc3[x] - pSrc3[x+1];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (1,2)
			grad_h = -pSrc1[x] + pSrc1[x+2] - pSrc2[x] + pSrc2[x+2] - pSrc3[x] + pSrc3[x+2];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc1[x] + pSrc1[x+1] + pSrc1[x+2] - pSrc3[x] - pSrc3[x+1] - pSrc3[x+2];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;			
			// (2,0)
			grad_h = -pSrc2[x-2] + pSrc2[x] - pSrc3[x-2] + pSrc3[x] - pSrc4[x-2] + pSrc4[x];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc2[x-2] + pSrc2[x-1] + pSrc2[x] - pSrc4[x-2] - pSrc4[x-1] - pSrc4[x];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (2,1)
			grad_h = -pSrc2[x-1] + pSrc2[x+1] - pSrc3[x-1] + pSrc3[x+1] - pSrc4[x-1] + pSrc4[x+1];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc2[x-1] + pSrc2[x] + pSrc2[x+1] - pSrc4[x-1] - pSrc4[x] - pSrc4[x+1];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (2,2)
			grad_h = -pSrc2[x] + pSrc2[x+2] - pSrc3[x] + pSrc3[x+2] - pSrc4[x] + pSrc4[x+2];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc2[x] + pSrc2[x+1] + pSrc2[x+2] - pSrc4[x] - pSrc4[x+1] - pSrc4[x+2];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;			
			// normalize
			//int val = (grad >> 1) + (grad >> 2);
            int val = (grad >> 1);      // March 7, 2014
			// clipping
			pDst[x] = (unsigned char)(val > 255 ? 255 : val);
		}
	}
		
	return true;
}

bool CImageUtility::prewitt3x3max_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Extended 5x5 prewitt edge detection
// The filter is 3x3 prewitt filters
//   1  1  1			-1  0  1
//   0  0  0			-1  0  1
//  -1 -1 -1			-1  0  1
// followed by a hit operation in the 5x5 window.
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F, 1-channel image
//		iplDstImage -- [O] input image; must be 32F, 1-channel image; should be the same size as iplSrcImage
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width ||		// TODO: complete check needed
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input/output image in CImageUtility::prewitt3x3max_32f()!\n");
		return false;
	}

	setZero(iplDstImage);		// to ignore the boundary

	for (int y=2; y<iplDstImage->height-2; y++) {
		float *pSrc0 = (float *)((char*)iplSrcImage->imageData + (y-2) * iplSrcImage->widthStep);
		float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
		float *pSrc2 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		float *pSrc3 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		float *pSrc4 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=2; x<iplDstImage->width-2; x++) {
			float grad_h, grad_v, grad, temp;
			// 9 prewitt 3x3 operations in a 5x5 window
			// (0,0)
			grad_h = -pSrc0[x-2] + pSrc0[x] - pSrc1[x-2] + pSrc1[x] - pSrc2[x-2] + pSrc2[x];
			grad_h = grad_h < 0.0f ? - grad_h : grad_h;
			grad_v = pSrc0[x-2] + pSrc0[x-1] + pSrc0[x] - pSrc2[x-2] - pSrc2[x-1] - pSrc2[x];
			grad_v = grad_v < 0.0f ? - grad_v : grad_v;
			grad = grad_h + grad_v;
			// (0,1)
			grad_h = -pSrc0[x-1] + pSrc0[x+1] - pSrc1[x-1] + pSrc1[x+1] - pSrc2[x-1] + pSrc2[x+1];
			grad_h = grad_h < 0.0f ? - grad_h : grad_h;
			grad_v = pSrc0[x-1] + pSrc0[x] + pSrc0[x+1] - pSrc2[x-1] - pSrc2[x] - pSrc2[x+1];
			grad_v = grad_v < 0.0f ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (0,2)
			grad_h = -pSrc0[x] + pSrc0[x+2] - pSrc1[x] + pSrc1[x+2] - pSrc2[x] + pSrc2[x+2];
			grad_h = grad_h < 0.0f ? - grad_h : grad_h;
			grad_v = pSrc0[x] + pSrc0[x+1] + pSrc0[x+2] - pSrc2[x] - pSrc2[x+1] - pSrc2[x+2];
			grad_v = grad_v < 0.0f ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (1,0)
			grad_h = -pSrc1[x-2] + pSrc1[x] - pSrc2[x-2] + pSrc2[x] - pSrc3[x-2] + pSrc3[x];
			grad_h = grad_h < 0.0f ? - grad_h : grad_h;
			grad_v = pSrc1[x-2] + pSrc1[x-1] + pSrc1[x] - pSrc3[x-2] - pSrc3[x-1] - pSrc3[x];
			grad_v = grad_v < 0.0f ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (1,1)
			grad_h = -pSrc1[x-1] + pSrc1[x+1] - pSrc2[x-1] + pSrc2[x+1] - pSrc3[x-1] + pSrc3[x+1];
			grad_h = grad_h < 0.0f ? - grad_h : grad_h;
			grad_v = pSrc1[x-1] + pSrc1[x] + pSrc1[x+1] - pSrc3[x-1] - pSrc3[x] - pSrc3[x+1];
			grad_v = grad_v < 0.0f ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (1,2)
			grad_h = -pSrc1[x] + pSrc1[x+2] - pSrc2[x] + pSrc2[x+2] - pSrc3[x] + pSrc3[x+2];
			grad_h = grad_h < 0.0f ? - grad_h : grad_h;
			grad_v = pSrc1[x] + pSrc1[x+1] + pSrc1[x+2] - pSrc3[x] - pSrc3[x+1] - pSrc3[x+2];
			grad_v = grad_v < 0.0f ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;			
			// (2,0)
			grad_h = -pSrc2[x-2] + pSrc2[x] - pSrc3[x-2] + pSrc3[x] - pSrc4[x-2] + pSrc4[x];
			grad_h = grad_h < 0.0f ? - grad_h : grad_h;
			grad_v = pSrc2[x-2] + pSrc2[x-1] + pSrc2[x] - pSrc4[x-2] - pSrc4[x-1] - pSrc4[x];
			grad_v = grad_v < 0.0f ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (2,1)
			grad_h = -pSrc2[x-1] + pSrc2[x+1] - pSrc3[x-1] + pSrc3[x+1] - pSrc4[x-1] + pSrc4[x+1];
			grad_h = grad_h < 0.0f ? - grad_h : grad_h;
			grad_v = pSrc2[x-1] + pSrc2[x] + pSrc2[x+1] - pSrc4[x-1] - pSrc4[x] - pSrc4[x+1];
			grad_v = grad_v < 0.0f ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (2,2)
			grad_h = -pSrc2[x] + pSrc2[x+2] - pSrc3[x] + pSrc3[x+2] - pSrc4[x] + pSrc4[x+2];
			grad_h = grad_h < 0.0f ? - grad_h : grad_h;
			grad_v = pSrc2[x] + pSrc2[x+1] + pSrc2[x+2] - pSrc4[x] - pSrc4[x+1] - pSrc4[x+2];
			grad_v = grad_v < 0.0f ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;			
			// normalize
			float val = grad * 0.5f;
			pDst[x] = val;
		}
	}

	return true;
}

bool CImageUtility::prewitt3x3max_8U_s5(IplImage *iplSrcImage, IplImage *iplDstImage)
// Extended 5x5 prewitt edge detection
// The filter is 3x3 prewitt filters
//   1  1  1			-1  0  1
//   0  0  0			-1  0  1
//  -1 -1 -1			-1  0  1
// followed by a hit operation in the 5x5 window.
// Different from prewitt3x3max_8U(), this function supposes the input image has been padded by 2 pixels in each direction.
// Arguments:
//		iplSrcImage -- [I] input image; must be 8U, 1-channel image
//		iplDstImage -- [O] input image; must be 8U, 1-channel image; should be the same size as iplSrcImage
// Luhong Liang, IC-ASD, ASTRI
// May 28, 2013
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width+4 || iplSrcImage->height != iplDstImage->height+4 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {			// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::prewitt3x3max_8U_s5()!\n");
		return false;
	}

	for (int y=0; y<iplDstImage->height; y++) {
		unsigned char *pSrc0 = (unsigned char *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep) + 2;
		unsigned char *pSrc1 = (unsigned char *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep) + 2;
		unsigned char *pSrc2 = (unsigned char *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep) + 2;
		unsigned char *pSrc3 = (unsigned char *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep) + 2;
		unsigned char *pSrc4 = (unsigned char *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep) + 2;
		unsigned char *pDst = (unsigned char *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			int grad_h, grad_v, grad, temp;
			// 9 prewitt 3x3 operations in a 5x5 window
			// (0,0)
			grad_h = -pSrc0[x-2] + pSrc0[x] - pSrc1[x-2] + pSrc1[x] - pSrc2[x-2] + pSrc2[x];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc0[x-2] + pSrc0[x-1] + pSrc0[x] - pSrc2[x-2] - pSrc2[x-1] - pSrc2[x];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			grad = grad_h + grad_v;
			// (0,1)
			grad_h = -pSrc0[x-1] + pSrc0[x+1] - pSrc1[x-1] + pSrc1[x+1] - pSrc2[x-1] + pSrc2[x+1];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc0[x-1] + pSrc0[x] + pSrc0[x+1] - pSrc2[x-1] - pSrc2[x] - pSrc2[x+1];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (0,2)
			grad_h = -pSrc0[x] + pSrc0[x+2] - pSrc1[x] + pSrc1[x+2] - pSrc2[x] + pSrc2[x+2];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc0[x] + pSrc0[x+1] + pSrc0[x+2] - pSrc2[x] - pSrc2[x+1] - pSrc2[x+2];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (1,0)
			grad_h = -pSrc1[x-2] + pSrc1[x] - pSrc2[x-2] + pSrc2[x] - pSrc3[x-2] + pSrc3[x];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc1[x-2] + pSrc1[x-1] + pSrc1[x] - pSrc3[x-2] - pSrc3[x-1] - pSrc3[x];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (1,1)
			grad_h = -pSrc1[x-1] + pSrc1[x+1] - pSrc2[x-1] + pSrc2[x+1] - pSrc3[x-1] + pSrc3[x+1];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc1[x-1] + pSrc1[x] + pSrc1[x+1] - pSrc3[x-1] - pSrc3[x] - pSrc3[x+1];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (1,2)
			grad_h = -pSrc1[x] + pSrc1[x+2] - pSrc2[x] + pSrc2[x+2] - pSrc3[x] + pSrc3[x+2];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc1[x] + pSrc1[x+1] + pSrc1[x+2] - pSrc3[x] - pSrc3[x+1] - pSrc3[x+2];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;			
			// (2,0)
			grad_h = -pSrc2[x-2] + pSrc2[x] - pSrc3[x-2] + pSrc3[x] - pSrc4[x-2] + pSrc4[x];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc2[x-2] + pSrc2[x-1] + pSrc2[x] - pSrc4[x-2] - pSrc4[x-1] - pSrc4[x];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (2,1)
			grad_h = -pSrc2[x-1] + pSrc2[x+1] - pSrc3[x-1] + pSrc3[x+1] - pSrc4[x-1] + pSrc4[x+1];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc2[x-1] + pSrc2[x] + pSrc2[x+1] - pSrc4[x-1] - pSrc4[x] - pSrc4[x+1];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;
			// (2,2)
			grad_h = -pSrc2[x] + pSrc2[x+2] - pSrc3[x] + pSrc3[x+2] - pSrc4[x] + pSrc4[x+2];
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			grad_v = pSrc2[x] + pSrc2[x+1] + pSrc2[x+2] - pSrc4[x] - pSrc4[x+1] - pSrc4[x+2];
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			temp = grad_h + grad_v;
			grad = temp > grad ? temp : grad;			
			// normalize
			int val = (grad >> 1) + (grad >> 2);
			// clipping
			pDst[x] = (unsigned char)(val > 255 ? 255 : val);
		}
	}
		
	return true;
}

bool CImageUtility::prewitt5x5_int(IplImage *iplSrcImage, int src_depth, IplImage *iplDstImage, int dst_depth)
// Extended 5x5 prewitt edge detection
// The filter is
//		2  2  2  2  2				-2 -1  0  1  2
//      1  1  1  1  1				-2 -1  0  1  2
//      0  0  0  0  0	and			-2 -1  0  1  2
//     -1 -1 -1 -1 -1				-2 -1  0  1  2
//     -2 -2 -2 -2 -2				-2 -1  0  1  2
// Arguments:
//		iplSrcImage -- [I] input image; must be 32S, 1-channel image
//		src_depth -- [I] bit depth of iplSrcImage, must between 8 and 16
//		iplDstImage -- [O] input image; must be 8U, 1-channel image; should be the same size as iplSrcImage
//		dst_depth -- [I] bit depth of iplDstImage, must between 2 and 8
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width ||		// TODO: complete check needed
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_8U ||
		src_depth < 8 || src_depth > 16 || dst_depth < 2 || dst_depth > 8) {
		showErrMsg("Invalid input/output image in CImageUtility::sobel_laplace_int()!\n");
		return false;
	}

	setZero(iplDstImage);		// to ignore the boundary

	int clip_th = (1 << dst_depth) - 1;

	for (int y=2; y<iplDstImage->height-2; y++) {
		int *pSrc0 = (int *)((char*)iplSrcImage->imageData + (y-2) * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char*)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
		int *pSrc2 = (int *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc3 = (int *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		int *pSrc4 = (int *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		unsigned char *pDst = (unsigned char *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=2; x<iplDstImage->width-2; x++) {
			// prewitt 5x5
			int grad_h = - (pSrc0[x-2]<<1) - pSrc0[x-1] + pSrc0[x+1] + (pSrc0[x+2]<<1) 
						 - (pSrc1[x-2]<<1) - pSrc1[x-1] + pSrc1[x+1] + (pSrc1[x+2]<<1)
						 - (pSrc2[x-2]<<1) - pSrc2[x-1] + pSrc2[x+1] + (pSrc2[x+2]<<1)
						 - (pSrc3[x-2]<<1) - pSrc3[x-1] + pSrc3[x+1] + (pSrc3[x+2]<<1)
						 - (pSrc4[x-2]<<1) - pSrc4[x-1] + pSrc4[x+1] + (pSrc4[x+2]<<1);
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			int grad_v =   (pSrc0[x-2]<<1) + (pSrc0[x-1]<<1) + (pSrc0[x]<<1) + (pSrc0[x+1]<<1) + (pSrc0[x+2]<<1)
			             + pSrc1[x-2] + pSrc1[x-1] + pSrc1[x] + pSrc1[x+1] + pSrc1[x+2]
						 - pSrc3[x-2] - pSrc3[x-1] - pSrc3[x] - pSrc3[x+1] - pSrc3[x+2]
						 - (pSrc4[x-2]<<1) - (pSrc4[x-1]<<1) - (pSrc4[x]<<1) - (pSrc4[x+1]<<1) - (pSrc4[x+2]<<1);
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			// fusion
			int val = (grad_h + grad_v) >> 3;
			val = val >> (src_depth - dst_depth);		// normalize to dst_depth
			// clipping
			pDst[x] = (unsigned char)(val > clip_th ? clip_th : val);
		}
	}
		
	return true;
}

bool CImageUtility::prewitt5x5_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Extended 5x5 prewitt edge detection
// The filter is
//		2  2  2  2  2				-2 -1  0  1  2
//      1  1  1  1  1				-2 -1  0  1  2
//      0  0  0  0  0	and			-2 -1  0  1  2
//     -1 -1 -1 -1 -1				-2 -1  0  1  2
//     -2 -2 -2 -2 -2				-2 -1  0  1  2
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F, 1-channel image
//		iplDstImage -- [O] input image; must be 32F, 1-channel image; should be the same size as iplSrcImage
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width ||		// TODO: complete check needed
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input/output image in CImageUtility::prewitt5x5_32f()!\n");
		return false;
	}

    setZero(iplDstImage);		// to ignore the boundary

	for (int y=2; y<iplDstImage->height-2; y++) {
		float *pSrc0 = (float *)((char*)iplSrcImage->imageData + (y-2) * iplSrcImage->widthStep);
		float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
		float *pSrc2 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		float *pSrc3 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		float *pSrc4 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=2; x<iplDstImage->width-2; x++) {
			// prewitt 5x5
			float grad_h = - (pSrc0[x-2]*2.0f) - pSrc0[x-1] + pSrc0[x+1] + (pSrc0[x+2]*2.0f) 
                                  - (pSrc1[x-2]*2.0f) - pSrc1[x-1] + pSrc1[x+1] + (pSrc1[x+2]*2.0f)
                                  - (pSrc2[x-2]*2.0f) - pSrc2[x-1] + pSrc2[x+1] + (pSrc2[x+2]*2.0f)
                                  - (pSrc3[x-2]*2.0f) - pSrc3[x-1] + pSrc3[x+1] + (pSrc3[x+2]*2.0f)
                                  - (pSrc4[x-2]*2.0f) - pSrc4[x-1] + pSrc4[x+1] + (pSrc4[x+2]*2.0f);
			grad_h = grad_h < 0 ? - grad_h : grad_h;
			float grad_v =   (pSrc0[x-2]*2.0f) + (pSrc0[x-1]*2.0f) + (pSrc0[x]*2.0f) + (pSrc0[x+1]*2.0f) + (pSrc0[x+2]*2.0f)
                                 + pSrc1[x-2] + pSrc1[x-1] + pSrc1[x] + pSrc1[x+1] + pSrc1[x+2]
                                  - pSrc3[x-2] - pSrc3[x-1] - pSrc3[x] - pSrc3[x+1] - pSrc3[x+2]
                                 - (pSrc4[x-2]*2.0f) - (pSrc4[x-1]*2.0f) - (pSrc4[x]*2.0f) - (pSrc4[x+1]*2.0f) - (pSrc4[x+2]*2.0f);
			grad_v = grad_v < 0 ? - grad_v : grad_v;
			// fusion
			float val = (grad_h + grad_v) * 0.125f;
			pDst[x] = val;
		}
	}

    return true;
}

bool CImageUtility::filtLoG_RGB5x5_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float sigma)
// detect edge in an RGB image using LoG operator.
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 3-channel image
//		iplDstImage -- [O] input image; must be 32F floating point, 3-channel image; should be the same size as iplSrcImage
//		sigma -- [I] sigma of the Gaussian filter
// by Luhong Liang
// May 21, 2014
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width ||		// TODO: complete check needed
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->nChannels != 3 || iplDstImage->nChannels != 1) {
		showErrMsg("Invalid input/output image in CImageUtility::filtLoG_RGB5x5_32f()!\n");
		return false;
	}

    IplImage *iplPadded = padding(iplSrcImage, 2, 2, 2, 2, 0);
    if (iplPadded == NULL) {
		return false;
	}

    // pre-calculate the 5x5 LoG filter
    float sigma2 = sigma * sigma;
    float sigma4 = sigma2 * sigma2;
    float pLoG[25];
    int i = 0;
    float filter_mean= 0.0f;
    for (int y=-2; y<=2; y++) {
        for (int x=-2; x<=2; x++) {
            float factor = (x * x + y * y) / (2.0f * sigma2);
            float filter = - (1.0f - factor) * exp(- factor) / (PI * sigma4);
            pLoG[i] = filter;
            filter_mean += filter;
            i++;
        }
    }
    filter_mean = filter_mean / 25.0f;
    for (int i=0; i<25; i++) {
        pLoG[i] = pLoG[i] - filter_mean;
    }
    float pL3[25*3];
    for (int i=0; i<25; i++) {
        pL3[i*3] = pLoG[i];
        pL3[i*3+1] = pLoG[i];
        pL3[i*3+2] = pLoG[i];
    }

    // filtering 3D: Sh = (S1 + S2 + S3) / 3;
    for (int y=0; y<iplDstImage->height; y++) {
        float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            int off_x = x * 3;
            float *pS0 = (float *)((char*)iplPadded->imageData + y * iplPadded->widthStep) + off_x;
		    float *pS1 = (float *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep) + off_x;
		    float *pS2 = (float *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep) + off_x;
		    float *pS3 = (float *)((char*)iplPadded->imageData + (y+3) * iplPadded->widthStep) + off_x;
		    float *pS4 = (float *)((char*)iplPadded->imageData + (y+4) * iplPadded->widthStep) + off_x;
            float res_sum = 0.0f;
            float *pF = pL3;      for (int i=0; i<15; i++) res_sum += pF[i] * pS0[i];
            pF += 15;               for (int i=0; i<15; i++) res_sum += pF[i] * pS1[i];  
            pF += 15;               for (int i=0; i<15; i++) res_sum += pF[i] * pS2[i];  
            pF += 15;               for (int i=0; i<15; i++) res_sum += pF[i] * pS3[i];  
            pF += 15;               for (int i=0; i<15; i++) res_sum += pF[i] * pS4[i];  
            pDst[x] = res_sum / 3.0f;
        }
    }

    safeReleaseImage(&iplPadded);

    return true;
}

bool CImageUtility::laplace_32f(IplImage *iplSrcImage, IplImage *iplDstImage, int option)
// Laplace operator. 
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image; should be the same size as iplSrcImage
//		option -- [I] 1 -- Laplace 4 operator; 2 -- Laplace 8 operator
//                        3 -- absolute Laplace 4 operator; 4 -- absolute Laplace 8 operator 
{
	if (iplSrcImage == NULL || iplDstImage == NULL) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::laplace_32f()!\n");
		return false;
	}

	setZero(iplDstImage);

	if (option == 1) {
		for (int y=1; y<iplDstImage->height-1; y++) {
			float *pSrcN = (float *)((char *)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
			float *pSrc0 = (float *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			float *pSrc1 = (float *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=1; x<iplDstImage->width-1; x++) {        // bug fixed, Setp 4, 2014 (width-1)
				//  0 -1  0
				// -1  4 -1
				//  0 -1  0
				pDst[x] = - pSrcN[x] - pSrc0[x-1] + pSrc0[x] * 4 - pSrc0[x+1] - pSrc1[x];
			}
		}
	} else if (option == 2) {
		for (int y=1; y<iplDstImage->height-1; y++) {
			float *pSrcN = (float *)((char *)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
			float *pSrc0 = (float *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			float *pSrc1 = (float *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=1; x<iplDstImage->width-1; x++) {
				// -1 -1 -1
				// -1  8 -1
				// -1 -1 -1
				pDst[x] = - pSrcN[x-1] - pSrcN[x] - pSrcN[x+1]
					           - pSrc0[x-1] + pSrc0[x] * 8 - pSrc0[x+1]  // bug fixed, April 11, 2014
						       - pSrc1[x-1] - pSrc1[x] - pSrc1[x+1];
			}
		}
    } else if (option == 3) {
		for (int y=1; y<iplDstImage->height-1; y++) {
			float *pSrcN = (float *)((char *)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
			float *pSrc0 = (float *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			float *pSrc1 = (float *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=1; x<iplDstImage->width-1; x++) {
				//  0 -1  0
				// -1  4 -1
				//  0 -1  0
				float lap = - pSrcN[x] - pSrc0[x-1] + pSrc0[x] * 4 - pSrc0[x+1] - pSrc1[x];
                pDst[x] = lap < 0.0f ? -lap : lap;
			}
		}
	} else if (option == 4) {
		for (int y=1; y<iplDstImage->height-1; y++) {
			float *pSrcN = (float *)((char *)iplSrcImage->imageData + (y-1) * iplSrcImage->widthStep);
			float *pSrc0 = (float *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			float *pSrc1 = (float *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=1; x<iplDstImage->width-1; x++) {
				// -1 -1 -1
				// -1  8 -1
				// -1 -1 -1
				float lap = - pSrcN[x-1] - pSrcN[x] - pSrcN[x+1]
					             - pSrc0[x-1] + pSrc0[x] * 8 - pSrc0[x+1]  // bug fixed, April 11, 2014
						         - pSrc1[x-1] - pSrc1[x] - pSrc1[x+1];
                pDst[x] = lap < 0.0f ? -lap : lap;
			}
		}
	} else {
		showErrMsg("Invalid operator type in CImageUtility::laplace_32f()!\n");
		return false;
	} 
		
	return false;
}

bool CImageUtility::bilatFilter_32f(IplImage *iplSrcImage, IplImage *iplDstImage, int nR, float fSigmaSpatial, float fSigmaRange)
// A brute force implementation of bilateral filter, 32-bit floating point internal engine.
// Support in-place operation. Support 8U-->8U, 8U-->32F and 32F->32F input/output data (data range should be in 0~255!).
// by Luhong Liang, IC-ASD, ASTRI
// Nov. 15, 2011; April 16, 2012
// Nov. 14, 2014: added calling to one function with fixed window and sigma
// May 7, 2015: support on zero sigma (direct copy)
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
		iplSrcImage->nChannels != iplDstImage->nChannels || iplSrcImage->nChannels != 1 || nR < 1 || fSigmaSpatial < 0.0f || fSigmaRange < 0.0f) {
		showErrMsg("Invalide input image or parameter(s) in bilatFilter_32f()!\n");
		return false;
	}

	if (fSigmaSpatial == 0.0f || fSigmaRange == 0.0f) {		// May 7, 2015
		return copy(iplSrcImage, iplDstImage);
	} else if (nR == 2 && abs(fSigmaSpatial - 1.0f) < 0.01f && abs(fSigmaRange - 25.0f) < 0.01f) { // Nov. 14, 2014
        return bilatFilter5x5_1_25_32f(iplSrcImage, iplDstImage);
    }

	// prepare spatial fitler, TODO: can reduce the table to almost 1/4!
	int nSize = 2 * nR + 1;
	float *pGs = new float[nSize * nSize];
	if (pGs == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
		return false;
	}
	float fDiv = 1.0f /( 2.0f * fSigmaSpatial * fSigmaSpatial);
	int nGsIdx = 0;
	for (int y=-nR; y<=nR; y++) {
		for (int x=-nR; x<=nR; x++) {
			float value = (float)exp(-(x*x + y*y) * fDiv);
            value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
            pGs[nGsIdx] = value;
			nGsIdx ++;
            //showErrMsg("%f\t", value);
		}
        //showErrMsg("\n");
	}
		
	// prepare LUT for range filter, TODO: can reduce the table size according to range sigma!
	float *pRangeLUT = new float[512];
	if (pRangeLUT == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
		delete [] pGs;
		return false;
	}
	fDiv = 1.0f / (2.0f * fSigmaRange * fSigmaRange);
	for (int i=0; i<256; i++) {
		float value = (float)exp(- i * i * fDiv);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
        pRangeLUT[256+i] = value;
		pRangeLUT[256-i] = pRangeLUT[256+i];
	}

	// prepare LUT, TODO: can reduce the LUT to (1/4 * 1/2)!
	float *pLUT = new float[512 * nSize * nSize];
	if (pLUT == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
		delete [] pGs;
		delete [] pRangeLUT;
		return false;
	}
	for (int n=0; n<nSize*nSize; n++) {
		float fGs = pGs[n];
		float *pLUTPos = pLUT + n * 512;
		for (int i=0; i<512; i++) {
			pLUTPos[i] = pRangeLUT[i] * fGs;
		}
	}
	delete [] pGs;
	delete [] pRangeLUT;

	// padding and process (8U-->32F)
	if (iplSrcImage->depth == SR_DEPTH_8U && iplDstImage->depth == SR_DEPTH_32F) {
		int nPadWidth = iplSrcImage->width + 2 * nR;
		int nPadHeight = iplSrcImage->height + 2 * nR;
		unsigned char *pPadImage = new unsigned char[nPadWidth * nPadHeight];
		if (pPadImage == NULL) {
			showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
			delete [] pLUT;
			return false;
		}
		// TODO: try cvCopyMakeBorder()
		// padding top boundary lines
		for (int y=0; y<nR; y++) {
			unsigned char *pSrc= (unsigned char *)iplSrcImage->imageData;		// padding first line
			unsigned char *pDst = pPadImage + y * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
			}
		}
		// padding
		for (int y=0; y<iplSrcImage->height; y++) {
			unsigned char *pSrc= (unsigned char *)iplSrcImage->imageData + y * iplSrcImage->widthStep;		// padding lines
			unsigned char *pDst = pPadImage + (y + nR) * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
			}
		}
		// padding bottom boundary lines
		for (int y=0; y<nR; y++) {
			unsigned char *pSrc= (unsigned char *)iplSrcImage->imageData + (iplSrcImage->height - 1) * iplSrcImage->widthStep;		// padding first line
			unsigned char *pDst = pPadImage + (y + iplSrcImage->height + nR) * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
			}
		}
		// process
		float *pChkLUT = pLUT + 256;
		for (int y=0; y<iplDstImage->height; y++) {
			float *pDst= (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				float fWeight = 0.0f;
				float fValue = 0.0f;
				int nCenter = pPadImage[(y+nR) * nPadWidth + x + nR];
				unsigned char *pPadImageLine = pPadImage + y*nPadWidth + x;
				for (int v=0; v<nSize; v++) {
					unsigned char *pPadImageLine1 = pPadImageLine + v * nPadWidth;
					float *pChkLUT1 = pChkLUT + v * nSize * 512;
					for (int u=0; u<nSize; u++) {
						int nPixel = pPadImageLine1[u];	//int nPixel = pPadImage[(y+nR+v) * nPadWidth + x + nR + u];
						int nDiff = nPixel - nCenter;
						float fLUT = pChkLUT1[(u<<9)+nDiff];	//float fLUT = pLUT[(v*nSize+u)*512+nDiff+256];
						fWeight += fLUT;
						fValue += fLUT * nPixel;
					}
				}
				pDst[x] = fValue / fWeight;
			}
		}

		delete [] pPadImage;
		delete [] pLUT;

		return true;
	}

	// padding and process (32F-->32F)
	if (iplSrcImage->depth == SR_DEPTH_32F && iplDstImage->depth == SR_DEPTH_32F) {
		int nPadWidth = iplSrcImage->width + 2 * nR;
		int nPadHeight = iplSrcImage->height + 2 * nR;
		float *pPadImage = new float[nPadWidth * nPadHeight];
		if (pPadImage == NULL) {
			showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
			delete [] pLUT;
			return false;
		}
		// TODO: try cvCopyMakeBorder()
		// padding top boundary lines
		for (int y=0; y<nR; y++) {
			float *pSrc= (float*)((char *)iplSrcImage->imageData);		// padding first line
			float *pDst = pPadImage + y * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
			}
		}
		// padding
		for (int y=0; y<iplSrcImage->height; y++) {
			float *pSrc= (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);		// padding lines
			float *pDst = pPadImage + (y + nR) * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
			}
		}
		// padding bottom boundary lines
		for (int y=0; y<nR; y++) {
			float *pSrc= (float*)((char *)iplSrcImage->imageData + (iplSrcImage->height - 1) * iplSrcImage->widthStep);		// padding last line
			float *pDst = pPadImage + (y + iplSrcImage->height + nR) * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
			}
		}
		//saveImagePatch_32f("_TestPadding.bmp", pPadImage, nPadWidth, nPadHeight, 1);	// for debug only
        // pre-process (clipping)
        for (int i=0; i<nPadWidth*nPadHeight; i++) {
            float value = pPadImage[i];
            value = value < 0.0f ? 0.0f : value;
            value = value > 255.0f ? 255.0f : value;
            pPadImage[i] = value;
        }
		// process
		float *pChkLUT = pLUT + 256;
		for (int y=0; y<iplDstImage->height; y++) {
			float *pDst= (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				// for each point
				float fWeight = 0.0f;
				float fValue = 0.0f;
				float fCenter = pPadImage[(y+nR) * nPadWidth + x + nR];
				float *pPadImageLine = pPadImage + y*nPadWidth + x;
                //float *pChkGs = pGs;
				for (int v=0; v<nSize; v++) {
					float *pPadImageLine1 = pPadImageLine + v * nPadWidth;
					float *pChkLUT1 = pChkLUT + v * nSize * 512;
					for (int u=0; u<nSize; u++) {
						float fPixel = pPadImageLine1[u];	//int nPixel = pPadImage[(y+nR+v) * nPadWidth + x + nR + u];
						float fDiff = fPixel - fCenter;
						int nDiff = (int)fDiff;		
						//nDiff = nDiff < -255 ? -255 : nDiff;      // move to pre-process
						//nDiff = nDiff > 255 ? 255 : nDiff;
						float fLUT = pChkLUT1[(u<<9)+nDiff];		//float fLUT = pLUT[(v*nSize+u)*512+nDiff+256];
                        //float fGs = pGs[u];
                        //float w = fLUT * fGs;
						fWeight += fLUT;
						fValue += fLUT * fPixel;
					}
                    //pChkGs += nSize;
				}
				pDst[x] = fValue / fWeight;
			}
		}

		delete [] pPadImage;
		delete [] pLUT;

		return true;
	}

	// padding and process (8U-->8U)
	if (iplSrcImage->depth == SR_DEPTH_8U && iplDstImage->depth == SR_DEPTH_8U) {
		int nPadWidth = iplSrcImage->width + 2 * nR;
		int nPadHeight = iplSrcImage->height + 2 * nR;
		unsigned char *pPadImage = new unsigned char[nPadWidth * nPadHeight];
		if (pPadImage == NULL) {
			showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
			delete [] pLUT;
			return false;
		}
		// TODO: try cvCopyMakeBorder()
		// padding top boundary lines
		for (int y=0; y<nR; y++) {
			unsigned char *pSrc= (unsigned char *)iplSrcImage->imageData;		// padding first line
			unsigned char *pDst = pPadImage + y * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
			}
		}
		// padding
		for (int y=0; y<iplSrcImage->height; y++) {
			unsigned char *pSrc= (unsigned char *)iplSrcImage->imageData + y * iplSrcImage->widthStep;		// padding lines
			unsigned char *pDst = pPadImage + (y + nR) * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
			}
		}
		// padding bottom boundary lines
		for (int y=0; y<nR; y++) {
			unsigned char *pSrc= (unsigned char *)iplSrcImage->imageData + (iplSrcImage->height - 1) * iplSrcImage->widthStep;		// padding first line
			unsigned char *pDst = pPadImage + (y + iplSrcImage->height + nR) * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
			}
		}
		// process
		float *pChkLUT = pLUT + 256;
		for (int y=0; y<iplDstImage->height; y++) {
			unsigned char *pDst= (unsigned char*)(iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				float fWeight = 0.0f;
				float fValue = 0.0f;
				int nCenter = pPadImage[(y+nR) * nPadWidth + x + nR];
				unsigned char *pPadImageLine = pPadImage + y*nPadWidth + x;
				for (int v=0; v<nSize; v++) {
					unsigned char *pPadImageLine1 = pPadImageLine + v * nPadWidth;
					float *pChkLUT1 = pChkLUT + v * nSize * 512;
					for (int u=0; u<nSize; u++) {
						int nPixel = pPadImageLine1[u];	//int nPixel = pPadImage[(y+nR+v) * nPadWidth + x + nR + u];
						int nDiff = nPixel - nCenter;
						float fLUT = pChkLUT1[(u<<9)+nDiff];	//float fLUT = pLUT[(v*nSize+u)*512+nDiff+256];
						fWeight += fLUT;
						fValue += fLUT * nPixel;
					}
				}
				fValue = fValue / fWeight;
				if (fValue < 0)
					pDst[x] = 0;
				else if (fValue > 255)
					pDst[x] = 255;
				else 
					pDst[x] = (unsigned char)(fValue + 0.5f);
			}
		}

		delete [] pPadImage;
		delete [] pLUT;

		return true;
	}

	showErrMsg("Invalide data type of input image in bilatFilter_32f()!\n");

	return false;
}

bool CImageUtility::bilatFilter5x5_1_25_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// A brute force implementation of bilateral filter, fixed-point implementation with 5x5 window, spatial sigma = 1.0 and range sigma = 25
// Argument:
//			iplSrcImage -- [I] input image, 32F data type
//			iplDstImage -- [I] result image, 32F data type
// by Luhong Liang, IC-ASD, ASTRI
// Aug 23, 2013
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
		iplSrcImage->nChannels != iplDstImage->nChannels || iplSrcImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplSrcImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalide input image in bilatFilter5x5_1_25_32f()!\n");
		return false;
	}
		
	// prepare LUT for range filter, TODO: can reduce the table size according to range sigma!
	float pRangeLUT[512];
	float fDiv = 1.0f / (2.0f * 25.0f * 25.0f);
	for (int i=0; i<256; i++) {
		float value = (float)exp(- i * i * fDiv);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
        pRangeLUT[256+i] = value;
		pRangeLUT[256-i] = pRangeLUT[256+i];
	}

    int nPadWidth = iplSrcImage->width + 2 * 2;
    int nPadHeight = iplSrcImage->height + 2 * 2;
    float *pPadImage = new float[nPadWidth * nPadHeight];
    if (pPadImage == NULL) {
        showErrMsg("Fail to allocate buffer in bilatFilter5x5_1_25_32f()!\n");
        return false;
    }
	
    // padding top boundary lines
    for (int y=0; y<2; y++) {
        float *pSrc= (float*)((char *)iplSrcImage->imageData);		// padding first line
        float *pDst = pPadImage + y * nPadWidth;
        for (int x=0; x<2; x++) {
            pDst[x] = pSrc[0];
        }
        for (int x=0; x<iplSrcImage->width; x++) {
            pDst[x+2] = pSrc[x];
        }
        for (int x=1; x<=2; x++) {
            pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
        }
    }
    // padding
    for (int y=0; y<iplSrcImage->height; y++) {
        float *pSrc= (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);		// padding lines
        float *pDst = pPadImage + (y + 2) * nPadWidth;
        for (int x=0; x<2; x++) {
            pDst[x] = pSrc[0];
        }
        for (int x=0; x<iplSrcImage->width; x++) {
            pDst[x+2] = pSrc[x];
        }
        for (int x=1; x<=2; x++) {
            pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
        }
    }
    // padding bottom boundary lines
    for (int y=0; y<2; y++) {
        float *pSrc= (float*)((char *)iplSrcImage->imageData + (iplSrcImage->height - 1) * iplSrcImage->widthStep);		// padding last line
        float *pDst = pPadImage + (y + iplSrcImage->height + 2) * nPadWidth;
        for (int x=0; x<2; x++) {
            pDst[x] = pSrc[0];
        }
        for (int x=0; x<iplSrcImage->width; x++) {
            pDst[x+2] = pSrc[x];
        }
        for (int x=1; x<=2; x++) {
            pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
        }
    }
    // pre-process (clipping)
    for (int i=0; i<nPadWidth*nPadHeight; i++) {
        float value = pPadImage[i];
        value = value < 0.0f ? 0.0f : value;
        value = value > 255.0f ? 255.0f : value;
        pPadImage[i] = value;
    }

    // process
    float *pChkLUT = pRangeLUT + 256;
    for (int y=0; y<iplDstImage->height; y++) {
        float *pDst= (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            // for each point
            float weight = 0.0f;
            float value = 0.0f;
            int diff;
            float val;
            float *pPadImageLine0 = pPadImage + y*nPadWidth + x;
            float *pPadImageLine1 = pPadImageLine0 + nPadWidth;
            float *pPadImageLine2 = pPadImageLine1 + nPadWidth;
            float *pPadImageLine3 = pPadImageLine2 + nPadWidth;
            float *pPadImageLine4 = pPadImageLine3 + nPadWidth;
            float center = pPadImageLine2[2];
            // 0.018316	0.082085	0.135335	0.082085	0.018316	
            diff = (int)(pPadImageLine0[0] - center); val = pChkLUT[diff] * 0.018316f; weight += val; value += val * pPadImageLine0[0];
            diff = (int)(pPadImageLine0[1] - center); val = pChkLUT[diff] * 0.082085f; weight += val; value += val * pPadImageLine0[1];
            diff = (int)(pPadImageLine0[2] - center); val = pChkLUT[diff] * 0.135335f; weight += val; value += val * pPadImageLine0[2];
            diff = (int)(pPadImageLine0[3] - center); val = pChkLUT[diff] * 0.082085f; weight += val; value += val * pPadImageLine0[3];
            diff = (int)(pPadImageLine0[4] - center); val = pChkLUT[diff] * 0.018316f; weight += val; value += val * pPadImageLine0[4];
            // 0.082085	0.367879	0.606531	0.367879	0.082085	
            diff = (int)(pPadImageLine1[0] - center); val = pChkLUT[diff] * 0.082085f; weight += val; value += val * pPadImageLine1[0];
            diff = (int)(pPadImageLine1[1] - center); val = pChkLUT[diff] * 0.367879f; weight += val; value += val * pPadImageLine1[1];
            diff = (int)(pPadImageLine1[2] - center); val = pChkLUT[diff] * 0.606531f; weight += val; value += val * pPadImageLine1[2];
            diff = (int)(pPadImageLine1[3] - center); val = pChkLUT[diff] * 0.367879f; weight += val; value += val * pPadImageLine1[3];
            diff = (int)(pPadImageLine1[4] - center); val = pChkLUT[diff] * 0.082085f; weight += val; value += val * pPadImageLine1[4];
            // 0.135335	0.606531	1.000000	0.606531	0.135335	
            diff = (int)(pPadImageLine2[0] - center); val = pChkLUT[diff] * 0.135335f; weight += val; value += val * pPadImageLine2[0];
            diff = (int)(pPadImageLine2[1] - center); val = pChkLUT[diff] * 0.606531f; weight += val; value += val * pPadImageLine2[1];
            diff = (int)(pPadImageLine2[2] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine2[2];
            diff = (int)(pPadImageLine2[3] - center); val = pChkLUT[diff] * 0.606531f; weight += val; value += val * pPadImageLine2[3];
            diff = (int)(pPadImageLine2[4] - center); val = pChkLUT[diff] * 0.135335f; weight += val; value += val * pPadImageLine2[4];
            // 0.082085	0.367879	0.606531	0.367879	0.082085	
            diff = (int)(pPadImageLine3[0] - center); val = pChkLUT[diff] * 0.082085f; weight += val; value += val * pPadImageLine3[0];
            diff = (int)(pPadImageLine3[1] - center); val = pChkLUT[diff] * 0.367879f; weight += val; value += val * pPadImageLine3[1];
            diff = (int)(pPadImageLine3[2] - center); val = pChkLUT[diff] * 0.606531f; weight += val; value += val * pPadImageLine3[2];
            diff = (int)(pPadImageLine3[3] - center); val = pChkLUT[diff] * 0.367879f; weight += val; value += val * pPadImageLine3[3];
            diff = (int)(pPadImageLine3[4] - center); val = pChkLUT[diff] * 0.082085f; weight += val; value += val * pPadImageLine3[4];
            // 0.018316	0.082085	0.135335	0.082085	0.018316
            diff = (int)(pPadImageLine4[0] - center); val = pChkLUT[diff] * 0.018316f; weight += val; value += val * pPadImageLine4[0];
            diff = (int)(pPadImageLine4[1] - center); val = pChkLUT[diff] * 0.082085f; weight += val; value += val * pPadImageLine4[1];
            diff = (int)(pPadImageLine4[2] - center); val = pChkLUT[diff] * 0.135335f; weight += val; value += val * pPadImageLine4[2];
            diff = (int)(pPadImageLine4[3] - center); val = pChkLUT[diff] * 0.082085f; weight += val; value += val * pPadImageLine4[3];
            diff = (int)(pPadImageLine4[4] - center); val = pChkLUT[diff] * 0.018316f; weight += val; value += val * pPadImageLine4[4];

            pDst[x] = value / weight;
        }
    }

    delete [] pPadImage;
    
	return true;
}

bool CImageUtility::bilatFilter5x5_box_25_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// A approximate implementation of bilateral filter, fixed-point implementation with 5x5 window, spatial sigma = 1.0 and range sigma = 25
// more importantly, using boxing filter instead of gaussian filter
// Argument:
//			iplSrcImage -- [I] input image, 32F data type
//			iplDstImage -- [I] result image, 32F data type
// by Luhong Liang, IC-ASD, ASTRI
// Aug 26, 2013
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
		iplSrcImage->nChannels != iplDstImage->nChannels || iplSrcImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplSrcImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalide input image in bilatFilter5x5_box_25_32f()!\n");
		return false;
	}
		
	// prepare LUT for range filter, TODO: can reduce the table size according to range sigma!
	float pRangeLUT[512];
	float fDiv = 1.0f / (2.0f * 25.0f * 25.0f);
	for (int i=0; i<256; i++) {
		float value = (float)exp(- i * i * fDiv);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
        pRangeLUT[256+i] = value;
		pRangeLUT[256-i] = pRangeLUT[256+i];
	}

    int nPadWidth = iplSrcImage->width + 2 * 2;
    int nPadHeight = iplSrcImage->height + 2 * 2;
    float *pPadImage = new float[nPadWidth * nPadHeight];
    if (pPadImage == NULL) {
        showErrMsg("Fail to allocate buffer in bilatFilter5x5_box_25_32f()!\n");
        return false;
    }
	
    // padding top boundary lines
    for (int y=0; y<2; y++) {
        float *pSrc= (float*)((char *)iplSrcImage->imageData);		// padding first line
        float *pDst = pPadImage + y * nPadWidth;
        for (int x=0; x<2; x++) {
            pDst[x] = pSrc[0];
        }
        for (int x=0; x<iplSrcImage->width; x++) {
            pDst[x+2] = pSrc[x];
        }
        for (int x=1; x<=2; x++) {
            pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
        }
    }
    // padding
    for (int y=0; y<iplSrcImage->height; y++) {
        float *pSrc= (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);		// padding lines
        float *pDst = pPadImage + (y + 2) * nPadWidth;
        for (int x=0; x<2; x++) {
            pDst[x] = pSrc[0];
        }
        for (int x=0; x<iplSrcImage->width; x++) {
            pDst[x+2] = pSrc[x];
        }
        for (int x=1; x<=2; x++) {
            pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
        }
    }
    // padding bottom boundary lines
    for (int y=0; y<2; y++) {
        float *pSrc= (float*)((char *)iplSrcImage->imageData + (iplSrcImage->height - 1) * iplSrcImage->widthStep);		// padding last line
        float *pDst = pPadImage + (y + iplSrcImage->height + 2) * nPadWidth;
        for (int x=0; x<2; x++) {
            pDst[x] = pSrc[0];
        }
        for (int x=0; x<iplSrcImage->width; x++) {
            pDst[x+2] = pSrc[x];
        }
        for (int x=1; x<=2; x++) {
            pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
        }
    }
    // pre-process (clipping)
    for (int i=0; i<nPadWidth*nPadHeight; i++) {
        float value = pPadImage[i];
        value = value < 0.0f ? 0.0f : value;
        value = value > 255.0f ? 255.0f : value;
        pPadImage[i] = value;
    }

    // process
    float *pChkLUT = pRangeLUT + 256;
    for (int y=0; y<iplDstImage->height; y++) {
        float *pDst= (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            // for each point
            float weight = 0.0f;
            float value = 0.0f;
            int diff;
            float val;
            float *pPadImageLine0 = pPadImage + y*nPadWidth + x;
            float *pPadImageLine1 = pPadImageLine0 + nPadWidth;
            float *pPadImageLine2 = pPadImageLine1 + nPadWidth;
            float *pPadImageLine3 = pPadImageLine2 + nPadWidth;
            float *pPadImageLine4 = pPadImageLine3 + nPadWidth;
            float center = pPadImageLine2[2];

            diff = (int)(pPadImageLine0[0] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine0[0];
            diff = (int)(pPadImageLine0[1] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine0[1];
            diff = (int)(pPadImageLine0[2] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine0[2];
            diff = (int)(pPadImageLine0[3] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine0[3];
            diff = (int)(pPadImageLine0[4] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine0[4];
            // 0.082085	0.367879	0.606531	0.367879	0.082085	
            diff = (int)(pPadImageLine1[0] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine1[0];
            diff = (int)(pPadImageLine1[1] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine1[1];
            diff = (int)(pPadImageLine1[2] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine1[2];
            diff = (int)(pPadImageLine1[3] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine1[3];
            diff = (int)(pPadImageLine1[4] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine1[4];
            // 0.135335	0.606531	1.000000	0.606531	0.135335	
            diff = (int)(pPadImageLine2[0] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine2[0];
            diff = (int)(pPadImageLine2[1] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine2[1];
            diff = (int)(pPadImageLine2[2] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine2[2];
            diff = (int)(pPadImageLine2[3] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine2[3];
            diff = (int)(pPadImageLine2[4] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine2[4];
            // 0.082085	0.367879	0.606531	0.367879	0.082085	
            diff = (int)(pPadImageLine3[0] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine3[0];
            diff = (int)(pPadImageLine3[1] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine3[1];
            diff = (int)(pPadImageLine3[2] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine3[2];
            diff = (int)(pPadImageLine3[3] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine3[3];
            diff = (int)(pPadImageLine3[4] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine3[4];
            // 0.018316	0.082085	0.135335	0.082085	0.018316
            diff = (int)(pPadImageLine4[0] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine4[0];
            diff = (int)(pPadImageLine4[1] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine4[1];
            diff = (int)(pPadImageLine4[2] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine4[2];
            diff = (int)(pPadImageLine4[3] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine4[3];
            diff = (int)(pPadImageLine4[4] - center); val = pChkLUT[diff]; weight += val; value += val * pPadImageLine4[4];

            pDst[x] = value / weight;
        }
    }

    delete [] pPadImage;
    
	return true;
}

bool CImageUtility::bilatFilter5x5_1_25_int(IplImage *iplSrcImage, int bit_depth, IplImage *iplDstImage, int sp_depth, int ra_depth)
// A brute force implementation of bilateral filter, fixed-point implementation with 5x5 window, spatial sigma = 1.0 and range sigma = 25
// Argument:
//			iplSrcImage -- [I] input image, 32S data type, bit depth should be 8~16
//			bit_depth -- [I] bit depth of iplSrcImage, 8~16
//			iplDstImage -- [I] result image, 32S data type, bit depth should be 8~16
//			sp_depth -- [I] bit depth of the spatial parameter LUT, support 9 bit
//			ra_depth -- [I] bit depth of the range parameter LUT, support 12 bit
// by Luhong Liang, IC-ASD, ASTRI
// Jan 17, 2013
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
		iplSrcImage->nChannels != iplDstImage->nChannels || iplSrcImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplSrcImage->depth != SR_DEPTH_32S || bit_depth < 8 || bit_depth > 16) {
		showErrMsg("Invalide input image in bilatFilter5x5_1_25_int()!\n");
		return false;
	}

	// prepare spatial fitler, TODO: can reduce the table to almost 1/4!
	int pFilter5x5_10_9bit[] = { 2,	7,	11,	7,	2,
								 7,	30,	50,	30,	7,
								 11, 50, 84, 50, 11,
								 7,	30,	50,	30,	7,
								 2,	7,	11,	7,	2 };
	int *pSpatialLUT = NULL;
	if (sp_depth == 9) {
		pSpatialLUT = pFilter5x5_10_9bit;
	} else {
		showErrMsg("Unsupported bit_depth of spatial filter in bilatFilter5x5_1_25_int()!\n");
		return false;
	}

	// prepare LUT for range filter
	int lut_entry_num;
	int ra_factor;
	if (ra_depth == 12) {
		lut_entry_num = 108;	// 108 is enough for 12-bit
		ra_factor = 4096;
	} else {
		showErrMsg("Unsupported bit_depth of range filter in bilatFilter5x5_1_25_int()!\n");
		return false;
	}

	int pRangeLUT[256];		// 12-bit
	float fDiv = 1.0f / (2.0f * 25 * 25);
	for (int i=0; i<lut_entry_num; i++) {
        float value = (float)exp(- i * i * fDiv);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
		pRangeLUT[i] = (int)floor(value * ra_factor + 0.5f);
	}

	// padding
	IplImage *iplPadImage = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplPadImage == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilter5x5_1_25_int()!\n");
		return false;
	}

	// process
	int pBlock[25];
	for (int y=0; y<iplDstImage->height; y++) {
		int *pDst= (int*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			// load a 5x5 block in source image
			int i = 0;
			for (int yy=y; yy<y+5; yy++) {
				int *pBuf = (int *)(iplPadImage->imageData + yy * iplPadImage->widthStep);
				for (int xx=x; xx<x+5; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// filtering
			int center = pBlock[12];
			unsigned int weight = 0;
			unsigned int value = 0;
			for (int ii=0; ii<25; ii++) {
				int pix_val = pBlock[ii];
				// range filter
				int diff = pix_val - center;
				diff = diff < 0 ? -diff : diff;
				diff = diff >> (bit_depth - 8);	// normalize to 0~255
				int ra;
				if (diff >= lut_entry_num) {
					ra = 0;
				} else {
					ra = pRangeLUT[diff];
				}
				// spatial filter & weight
				unsigned int w = (pSpatialLUT[ii] * ra) >> 3;		// keep w within 14-bit
				w = w > 16383 ? 16383 : w;							// keep w within 14-bit
				weight += w;
				// filter value
				value += pix_val * w;			// 10/12-bit input + 14-bit weight + 5-bit (25 points)
			}
			// division / 16-bit
			if (weight > 262143L) {
				value = value >> 3;
				weight = weight >> 3;
			} else if (weight > 131071L) {
				value = value >> 2;
				weight = weight >> 2;
			} else if (weight > 65535L) {
				value = value >> 1;
				weight = weight >> 1;
			}
			pDst[x] = value / weight;
		}
	}

	safeReleaseImage(&iplPadImage);

	return false;
}

bool CImageUtility::bilatFilter5x5_1_25_8U_10bit(IplImage *iplSrc8U, IplImage *iplDstInt)
// A brute force implementation of bilateral filter, fixed-point implementation with 5x5 window, spatial sigma = 1.0 and range sigma = 25
// This function is a simplified version of function bilatFilter5x5_1_25_int().
// Argument:
//			iplSrc8U -- [I] input image, 8U
//			iplDstInt -- [I] result image, 32S data type, bit depth should be 10
// by Luhong Liang, IC-ASD, ASTRI
// Jan 29, 2013
{
	if (iplSrc8U == NULL || iplDstInt == NULL || iplSrc8U->width != iplDstInt->width || iplSrc8U->height != iplDstInt->height ||
		iplSrc8U->nChannels != iplDstInt->nChannels || iplSrc8U->nChannels != 1 || iplSrc8U->depth != SR_DEPTH_8U || iplDstInt->depth != SR_DEPTH_32S) {
		showErrMsg("Invalide input image in bilatFilter5x5_1_25_8U_10bit()!\n");
		return false;
	}

	// prepare spatial fitler, TODO: can reduce the table to almost 1/4!
	int pFilter5x5_10_9bit[] = { 2,	7,	11,	7,	2,
								 7,	30,	50,	30,	7,
								 11, 50, 84, 50, 11,
								 7,	30,	50,	30,	7,
								 2,	7,	11,	7,	2 };
	int *pSpatialLUT = pFilter5x5_10_9bit;

	// prepare LUT for range filter
	int ra_factor = 4095;
	int lut_entry_num = 108;	// 108 is enough for 12-bit

	int pRangeLUT[256];		// 12-bit
	float fDiv = 1.0f / (2.0f * 25 * 25);
	for (int i=0; i<lut_entry_num; i++) {
        float value = (float)exp(- i * i * fDiv);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
		pRangeLUT[i] = (int)floor(value * ra_factor + 0.5f);
	}

	// padding
	IplImage *iplPadImage = padding(iplSrc8U, 2, 2, 2, 2);
	if (iplPadImage == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilter5x5_1_25_8U_10bit()!\n");
		return false;
	}

	// process
	int pBlock[25];
	for (int y=0; y<iplDstInt->height; y++) {
		int *pDst= (int*)((char *)iplDstInt->imageData + y * iplDstInt->widthStep);
		for (int x=0; x<iplDstInt->width; x++) {
			// load a 5x5 block in source image
			int i = 0;
			for (int yy=y; yy<y+5; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplPadImage->imageData + yy * iplPadImage->widthStep);
				for (int xx=x; xx<x+5; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// filtering
			int center = pBlock[12];
			unsigned int weight = 0;
			unsigned int value = 0;
			for (int ii=0; ii<25; ii++) {
				int pix_val = pBlock[ii];
				// range filter
				int diff = pix_val - center;
				diff = diff < 0 ? -diff : diff;	// 0 ~ 255
				int ra;
				if (diff >= lut_entry_num) {
					ra = 0;
				} else {
					ra = pRangeLUT[diff];
				}
				// spatial filter & weight
				unsigned int w = (pSpatialLUT[ii] * ra) >> 3;		// keep w within 14-bit
				w = w > 16383 ? 16383 : w;							// keep w within 14-bit
				weight += w;
				// filter value
				value += pix_val * w;			// 8-bit input + 14-bit weight + 5-bit (25 points)
			}
			// division / 16-bit, convert 8-bit to 10-bit
			if (weight > 256*256*4) {		// 19-bit ~ 18-bit (weight is limited to 19-bit)
				value = value >> 1;
				weight = weight >> 3;
			} else if (weight > 256*256*2) {
				//value = value;
				weight = weight >> 2;
			} else if (weight > 65535L) {
				value = value << 1;
				weight = weight >> 1;
			} else {
				value = value << 2;
				//weight = weight;
			}
			pDst[x] = value / weight;
		}
	}

	safeReleaseImage(&iplPadImage);

	return false;
}

bool CImageUtility::bilatFilter5x5_1_25_8U_10bit_s1(IplImage *iplSrc8U, IplImage *iplDstInt)
// A brute force implementation of bilateral filter, fixed-point implementation with 5x5 window, spatial sigma = 1.0 and range sigma = 25
// This function is a simplified version of function bilatFilter5x5_1_25_8U_10bit(). 
// The range LUT and spatial LUT are optimized to 8-bit and 6-bit respectively.
// Argument:
//			iplSrc8U -- [I] input image, 8U
//			iplDstInt -- [I] result image, 32S data type, bit depth should be 10
// by Luhong Liang, IC-ASD, ASTRI
// Feb 19, 2013
{
	if (iplSrc8U == NULL || iplDstInt == NULL || iplSrc8U->width != iplDstInt->width || iplSrc8U->height != iplDstInt->height ||
		iplSrc8U->nChannels != iplDstInt->nChannels || iplSrc8U->nChannels != 1 || iplSrc8U->depth != SR_DEPTH_8U || iplDstInt->depth != SR_DEPTH_32S) {
		showErrMsg("Invalide input image in bilatFilter5x5_1_25_8U_10bit_s1()!\n");
		return false;
	}

	// prepare spatial fitler, TODO: can reduce the table to almost 1/4!
	int pSpatialLUT[] = { 1,	5,	9,	5,	1,
						  5,	23,	38,	23,	5,
						  9,	38,	63,	38,	9,
						  5,	23,	38,	23,	5,
						  1,	5,	9,	5,	1 };		// optimized, divied by 398, sum is 387

	// prepare LUT for range filter
	int lut_entry_num = 89;	// 89 is enough for 8-bit
	int pRangeLUT[89] = { 255, 255, 254, 253, 252, 250, 248, 245, 242, 239, 235, 231, 227, 223, 218, 213, 208, 202, 197, 191, 185, 179, 
						  173, 167, 161, 155, 148, 142, 136, 130, 124, 118, 112, 107, 101, 96, 90, 85, 80, 76, 71, 66, 62, 58, 54, 50, 
						  47, 44, 40, 37, 35, 32, 29, 27, 25, 23, 21, 19, 17, 16, 14, 13, 12, 11, 10, 9, 8, 7, 6, 6, 5, 5, 4, 4, 3, 3, 3, 
						  2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1 };		// 89-entry, 8-bit

	// padding
	IplImage *iplPadImage = padding(iplSrc8U, 2, 2, 2, 2);
	if (iplPadImage == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilter5x5_1_25_8U_10bit_s1()!\n");
		return false;
	}

	// process
	int pBlock[25];
	for (int y=0; y<iplDstInt->height; y++) {
		int *pDst= (int*)((char *)iplDstInt->imageData + y * iplDstInt->widthStep);
		for (int x=0; x<iplDstInt->width; x++) {
			// load a 5x5 block in source image
			int i = 0;
			for (int yy=y; yy<y+5; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplPadImage->imageData + yy * iplPadImage->widthStep);
				for (int xx=x; xx<x+5; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// filtering
			int center = pBlock[12];
			unsigned int weight = 0;
			unsigned int value = 0;
			for (int ii=0; ii<25; ii++) {
				int pix_val = pBlock[ii];
				// range filter
				int diff = pix_val - center;
				diff = diff < 0 ? -diff : diff;	// 0 ~ 255
				int ra;
				if (diff >= lut_entry_num) {
					ra = 0;
				} else {
					ra = pRangeLUT[diff];
				}
				// spatial filter & weight
				unsigned int w = pSpatialLUT[ii] * ra;		// w: 8-bit range filter + 6-bit spatial filter = 14 bits
				weight += w;								// weight: 8-bit range filter + 9-bit sum of spatial filter = 17 bit
				// filter value
				value += pix_val * w;						// pixel valut: 17-bit weight + 8-bit pixel = 25-bit
			}
			// division: 27-bit by 17-bit = 10 bits
			pDst[x] = (value << 2) / weight;
		}
	}

	safeReleaseImage(&iplPadImage);

	return false;
}

bool CImageUtility::bilatFilter5x5_1_25_8U_10bit_s5(IplImage *iplSrc8U, IplImage *iplDstInt)
// A brute force implementation of bilateral filter, fixed-point implementation with 5x5 window, spatial sigma = 1.0 and range sigma = 25
// This function is a simplified version of function bilatFilter5x5_1_25_8U_10bit(). 
// The range LUT and spatial LUT are optimized to 8-bit and 6-bit respectively.
// Different from bilatFilter5x5_1_25_8U_10bit_s1(), this function supposes the input image has been padded by 2 pixels in each direction!
// Argument:
//			iplSrc8U -- [I] input image, 8U
//			iplDstInt -- [I] result image, 32S data type, bit depth should be 10
// by Luhong Liang, IC-ASD, ASTRI
// May 29, 2013
{
	if (iplSrc8U == NULL || iplDstInt == NULL || iplSrc8U->width != iplDstInt->width+4 || iplSrc8U->height != iplDstInt->height+4 ||
		iplSrc8U->nChannels != iplDstInt->nChannels || iplSrc8U->nChannels != 1 || iplSrc8U->depth != SR_DEPTH_8U || iplDstInt->depth != SR_DEPTH_32S) {
		showErrMsg("Invalide input image in bilatFilter5x5_1_25_8U_10bit_s5()!\n");
		return false;
	}

	// prepare spatial fitler, TODO: can reduce the table to almost 1/4!
	int pSpatialLUT[] = { 1,	5,	9,	5,	1,
						  5,	23,	38,	23,	5,
						  9,	38,	63,	38,	9,
						  5,	23,	38,	23,	5,
						  1,	5,	9,	5,	1 };		// optimized, divied by 398, sum is 387

	// prepare LUT for range filter
	int lut_entry_num = 89;	// 89 is enough for 8-bit
	int pRangeLUT[89] = { 255, 255, 254, 253, 252, 250, 248, 245, 242, 239, 235, 231, 227, 223, 218, 213, 208, 202, 197, 191, 185, 179, 
						  173, 167, 161, 155, 148, 142, 136, 130, 124, 118, 112, 107, 101, 96, 90, 85, 80, 76, 71, 66, 62, 58, 54, 50, 
						  47, 44, 40, 37, 35, 32, 29, 27, 25, 23, 21, 19, 17, 16, 14, 13, 12, 11, 10, 9, 8, 7, 6, 6, 5, 5, 4, 4, 3, 3, 3, 
						  2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1 };		// 89-entry, 8-bit

	// process
	int pBlock[25];
	for (int y=0; y<iplDstInt->height; y++) {
		int *pDst= (int*)((char *)iplDstInt->imageData + y * iplDstInt->widthStep);
		for (int x=0; x<iplDstInt->width; x++) {
			// load a 5x5 block in source image
			int i = 0;
			for (int yy=y; yy<y+5; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrc8U->imageData + yy * iplSrc8U->widthStep);
				for (int xx=x; xx<x+5; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// filtering
			int center = pBlock[12];
			unsigned int weight = 0;
			unsigned int value = 0;
			for (int ii=0; ii<25; ii++) {
				int pix_val = pBlock[ii];
				// range filter
				int diff = pix_val - center;
				diff = diff < 0 ? -diff : diff;	// 0 ~ 255
				int ra;
				if (diff >= lut_entry_num) {
					ra = 0;
				} else {
					ra = pRangeLUT[diff];
				}
				// spatial filter & weight
				unsigned int w = pSpatialLUT[ii] * ra;		// w: 8-bit range filter + 6-bit spatial filter = 14 bits
				weight += w;								// weight: 8-bit range filter + 9-bit sum of spatial filter = 17 bit
				// filter value
				value += pix_val * w;						// pixel valut: 17-bit weight + 8-bit pixel = 25-bit
			}
			// division: 27-bit by 17-bit = 10 bits
			pDst[x] = (value << 2) / weight;
		}
	}

	return false;
}

bool CImageUtility::bilatFilter5x5_D5_12D5_8U_10bit(IplImage *iplSrc8U, IplImage *iplDstInt)
// A brute force implementation of bilateral filter, fixed-point implementation with 5x5 window, spatial sigma = 0.5 and range sigma = 12.5
// This function is a copy of function bilatFilter5x5_1_25_8U_10bit_s1() with different LUT's. 
// The range LUT and spatial LUT are optimized to 8-bit and 6-bit respectively.
// Argument:
//			iplSrc8U -- [I] input image, 8U
//			iplDstInt -- [I] result image, 32S data type, bit depth should be 10
// by Luhong Liang, LIU XUEJIAO, ICDD-VIDEO
// Aug 26, 2015
{
	if (iplSrc8U == NULL || iplDstInt == NULL || iplSrc8U->width != iplDstInt->width || iplSrc8U->height != iplDstInt->height ||
		iplSrc8U->nChannels != iplDstInt->nChannels || iplSrc8U->nChannels != 1 || iplSrc8U->depth != SR_DEPTH_8U || iplDstInt->depth != SR_DEPTH_32S) {
		showErrMsg("Invalide input image in bilatFilter5x5_D5_12D5_8U_10bit()!\n");
		return false;
	}

	// prepare spatial fitler, TODO: can reduce the table to almost 1/4!
	int pSpatialLUT[] = { 0,	0,	0,	0,	0,
						  0,	1,	9,	1,	0,
						  0,	9,	63,	9,	0,
						  0,	1,	9,	1,	0,
						  0,	0,	0,	0,	0 };		// optimized, divied by 398, sum is 387

	// prepare LUT for range filter
	int lut_entry_num = 45;	// 45 is enough for 8-bit
	int pRangeLUT[45] = { 255, 254, 252, 248, 242, 235, 227, 218, 208, 197, 185, 173, 
						  161, 148, 136, 124, 112, 101, 90,  80,  71,  62,  54,  47, 
						  40,  35,  29,  25,  21,  17,  14,  12,  10,  8,   6,   5, 
						  4,   3,   3,   2,   2,   1,   1,   1,   1 };		// 45-entry, 8-bit

	// padding
	IplImage *iplPadImage = padding(iplSrc8U, 2, 2, 2, 2);
	if (iplPadImage == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilter5x5_D5_12D5_8U_10bit()!\n");
		return false;
	}

	// process
	int pBlock[25];
	for (int y=0; y<iplDstInt->height; y++) {
		int *pDst= (int*)((char *)iplDstInt->imageData + y * iplDstInt->widthStep);
		for (int x=0; x<iplDstInt->width; x++) {
			// load a 5x5 block in source image
			int i = 0;
			for (int yy=y; yy<y+5; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplPadImage->imageData + yy * iplPadImage->widthStep);
				for (int xx=x; xx<x+5; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// filtering
			int center = pBlock[12];
			unsigned int weight = 0;
			unsigned int value = 0;
			for (int ii=0; ii<25; ii++) {
				int pix_val = pBlock[ii];
				// range filter
				int diff = pix_val - center;
				diff = diff < 0 ? -diff : diff;	// 0 ~ 255
				int ra;
				if (diff >= lut_entry_num) {
					ra = 0;
				} else {
					ra = pRangeLUT[diff];
				}
				// spatial filter & weight
				unsigned int w = pSpatialLUT[ii] * ra;		// w: 8-bit range filter + 6-bit spatial filter = 14 bits
				weight += w;								// weight: 8-bit range filter + 9-bit sum of spatial filter = 17 bit
				// filter value
				value += pix_val * w;						// pixel valut: 17-bit weight + 8-bit pixel = 25-bit
			}
			// division: 27-bit by 17-bit = 10 bits
			pDst[x] = (value << 2) / weight;
		}
	}

	safeReleaseImage(&iplPadImage);

	return false;
}

bool CImageUtility::bilatFilter5x5_D7_17D5_8U_10bit(IplImage *iplSrc8U, IplImage *iplDstInt)
// A brute force implementation of bilateral filter, fixed-point implementation with 5x5 window, spatial sigma = 0.7 and range sigma = 17.5
// This function is a copy of function bilatFilter5x5_1_25_8U_10bit_s1() with different LUT's. 
// The range LUT and spatial LUT are optimized to 8-bit and 6-bit respectively.
// Argument:
//			iplSrc8U -- [I] input image, 8U
//			iplDstInt -- [I] result image, 32S data type, bit depth should be 10
// by Luhong Liang, LIU XUEJIAO, ICDD-VIDEO
// Aug 26, 2015
{
	if (iplSrc8U == NULL || iplDstInt == NULL || iplSrc8U->width != iplDstInt->width || iplSrc8U->height != iplDstInt->height ||
		iplSrc8U->nChannels != iplDstInt->nChannels || iplSrc8U->nChannels != 1 || iplSrc8U->depth != SR_DEPTH_8U || iplDstInt->depth != SR_DEPTH_32S) {
		showErrMsg("Invalide input image in bilatFilter5x5_D7_17D5_8U_10bit()!\n");
		return false;
	}

	// prepare spatial fitler, TODO: can reduce the table to almost 1/4!
	int pSpatialLUT[] = { 0,	0,	1,	0,	0,
						  0,	8,	23,	8,	0,
						  1,	23,	63,	23,	1,
						  0,	8,	23,	8,	0,
						  0,	0,	1,	0,	0 };		// optimized, divied by 398, sum is 387

	// prepare LUT for range filter
	int lut_entry_num = 62;	// 62 is enough for 8-bit
	int pRangeLUT[62] = { 255, 255, 253, 251, 248, 245, 240, 235, 230, 223, 217, 209, 202, 194, 185, 177, 168, 
						  159, 150, 141, 133, 124, 116, 108, 100, 92,  85,  78,  71,  65,  59,  53,  48,  43,
						  39,  35,  31,  27,  24,  21,  19,  16,  14,  12,  11,  9,   8,   7,   6,   5,   4,
						  4,   3,   3,   2,   2,   2,   1,   1,   1,   1,   1 };		// 62-entry, 8-bit

	// padding
	IplImage *iplPadImage = padding(iplSrc8U, 2, 2, 2, 2);
	if (iplPadImage == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilter5x5_D7_17D5_8U_10bit()!\n");
		return false;
	}

	// process
	int pBlock[25];
	for (int y=0; y<iplDstInt->height; y++) {
		int *pDst= (int*)((char *)iplDstInt->imageData + y * iplDstInt->widthStep);
		for (int x=0; x<iplDstInt->width; x++) {
			// load a 5x5 block in source image
			int i = 0;
			for (int yy=y; yy<y+5; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplPadImage->imageData + yy * iplPadImage->widthStep);
				for (int xx=x; xx<x+5; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// filtering
			int center = pBlock[12];
			unsigned int weight = 0;
			unsigned int value = 0;
			for (int ii=0; ii<25; ii++) {
				int pix_val = pBlock[ii];
				// range filter
				int diff = pix_val - center;
				diff = diff < 0 ? -diff : diff;	// 0 ~ 255
				int ra;
				if (diff >= lut_entry_num) {
					ra = 0;
				} else {
					ra = pRangeLUT[diff];
				}
				// spatial filter & weight
				unsigned int w = pSpatialLUT[ii] * ra;		// w: 8-bit range filter + 6-bit spatial filter = 14 bits
				weight += w;								// weight: 8-bit range filter + 9-bit sum of spatial filter = 17 bit
				// filter value
				value += pix_val * w;						// pixel valut: 17-bit weight + 8-bit pixel = 25-bit
			}
			// division: 27-bit by 17-bit = 10 bits
			pDst[x] = (value << 2) / weight;
		}
	}

	safeReleaseImage(&iplPadImage);

	return false;
}

bool CImageUtility::bilatFilterW_32f(IplImage *iplSrcImage, IplImage *iplFilterRegion, IplImage *iplDstImage, int nR, float fSigmaSpatial, float fSigmaRange)
// A brute force implementation of bilateral filter, 32-bit floating point internal engine.
// Support in-place operation. Support 32F->32F input/output data.
// by Luhong Liang, IC-ASD, ASTRI
// Nov. 5, 2012
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
		iplSrcImage->nChannels != iplDstImage->nChannels || iplSrcImage->nChannels != 1 || nR < 1 || fSigmaSpatial <= 0.0f || fSigmaRange <= 0.0f) {
		showErrMsg("Invalide input image in bilatFilterW_32f()!\n");
		return false;
	}

	// prepare spatial fitler, TODO: can reduce the table to almost 1/4!
	int nSize = 2 * nR + 1;
	float *pGs = new float[nSize * nSize];
	if (pGs == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilterW_32f()!\n");
		return false;
	}
	float fDiv = 1.0f /( 2.0f * fSigmaSpatial * fSigmaSpatial);
	int nGsIdx = 0;
	for (int y=-nR; y<=nR; y++) {
		for (int x=-nR; x<=nR; x++) {
			float value = (float)exp(-(x*x + y*y) * fDiv);
            value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
            pGs[nGsIdx] = value;
			nGsIdx ++;
		}
	}
		
	// prepare LUT for range filter, TODO: can reduce the table size according to range sigma!
	float *pRangeLUT = new float[512];
	if (pRangeLUT == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilterW_32f()!\n");
		delete [] pGs;
		return false;
	}
	fDiv = 1.0f / (2.0f * fSigmaRange * fSigmaRange);
	for (int i=0; i<256; i++) {
		float value = (float)exp(- i * i * fDiv);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
        pRangeLUT[256+i] = value;
		pRangeLUT[256-i] = pRangeLUT[256+i];
	}

	// prepare LUT, TODO: can reduce the LUT to (1/4 * 1/2)!
	float *pLUT = new float[512 * nSize * nSize];
	if (pLUT == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilterW_32f()!\n");
		delete [] pGs;
		delete [] pRangeLUT;
		return false;
	}
	for (int n=0; n<nSize*nSize; n++) {
		float fGs = pGs[n];
		float *pLUTPos = pLUT + n * 512;
		for (int i=0; i<512; i++) {
			pLUTPos[i] = pRangeLUT[i] * fGs;
		}
	}
	delete [] pGs;
	delete [] pRangeLUT;

	// padding and process (32F-->32F)
	if (iplSrcImage->depth == SR_DEPTH_32F && iplDstImage->depth == SR_DEPTH_32F) {
		int nPadWidth = iplSrcImage->width + 2 * nR;
		int nPadHeight = iplSrcImage->height + 2 * nR;
		float *pPadImage = new float[nPadWidth * nPadHeight];
		if (pPadImage == NULL) {
			showErrMsg("Fail to allocate buffer in bilatFilterW_32f()!\n");
			delete [] pLUT;
			return false;
		}
		// TODO: try cvCopyMakeBorder()
		// padding top boundary lines
		for (int y=0; y<nR; y++) {
			float *pSrc= (float*)((char *)iplSrcImage->imageData);		// padding first line
			float *pDst = pPadImage + y * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
			}
		}
		// padding
		for (int y=0; y<iplSrcImage->height; y++) {
			float *pSrc= (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);		// padding lines
			float *pDst = pPadImage + (y + nR) * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
			}
		}
		// padding bottom boundary lines
		for (int y=0; y<nR; y++) {
			float *pSrc= (float*)((char *)iplSrcImage->imageData + (iplSrcImage->height - 1) * iplSrcImage->widthStep);		// padding last line
			float *pDst = pPadImage + (y + iplSrcImage->height + nR) * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
			}
		}
		//saveImagePatch_32f("_TestPadding.bmp", pPadImage, nPadWidth, nPadHeight, 1);	// for debug only
		// process
		float *pChkLUT = pLUT + 256;
		for (int y=0; y<iplDstImage->height; y++) {
			float *pDst= (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			float *pWei= (float*)((char *)iplFilterRegion->imageData + y * iplFilterRegion->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				// for each point
				float fWeight = 0.0f;
				float fValue = 0.0f;
				float fCenter = pPadImage[(y+nR) * nPadWidth + x + nR];
				float *pPadImageLine = pPadImage + y*nPadWidth + x;
				for (int v=0; v<nSize; v++) {
					float *pPadImageLine1 = pPadImageLine + v * nPadWidth;
					float *pChkLUT1 = pChkLUT + v * nSize * 512;
					for (int u=0; u<nSize; u++) {
						float fPixel = pPadImageLine1[u];	//int nPixel = pPadImage[(y+nR+v) * nPadWidth + x + nR + u];
						float fDiff = fPixel - fCenter;
						int nDiff = (int)fDiff;			// cutting
						float fLUT = pChkLUT1[(u<<9)+nDiff];		//float fLUT = pLUT[(v*nSize+u)*512+nDiff+256];
						fWeight += fLUT;
						fValue += fLUT * fPixel;
					}
				}
				pDst[x] = (fValue / fWeight) * pWei[x] + fCenter * (1 - pWei[x]);
			}
		}

		delete [] pPadImage;
		delete [] pLUT;

		return true;
	}

	return false;
}

bool CImageUtility::bilatFilter_32f(IplImage *iplSrcImage, IplImage *iplInitUpscale, IplImage *iplDstImage, int nR, float fSigmaSpatial, float fSigmaRange)
// A brute force implementation of bilateral filter, 32-bit floating point internal engine.
// Different to classic algorithm, this algorithm get range variables from an initial upscaled image 
// by Luhong Liang, IC-ASD, ASTRI
// Oct. 16, 2012
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
		iplSrcImage->nChannels != iplDstImage->nChannels || iplSrcImage->nChannels != 1 || nR < 1 || fSigmaSpatial <= 0.0f || fSigmaRange <= 0.0f) {
		showErrMsg("Invalide input image in bilatFilter_32f()!\n");
		return false;
	}

	// prepare spatial fitler, TODO: can reduce the table to almost 1/4!
	int nSize = 2 * nR + 1;
	float *pGs = new float[nSize * nSize];
	if (pGs == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
		return false;
	}
	float fDiv = 1.0f /( 2.0f * fSigmaSpatial * fSigmaSpatial);
	int nGsIdx = 0;
	for (int y=-nR; y<=nR; y++) {
		for (int x=-nR; x<=nR; x++) {
			float value = (float)exp(-(x*x + y*y) * fDiv);
            value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
            pGs[nGsIdx] = value;
			nGsIdx ++;
		}
	}
		
	// prepare LUT for range filter, TODO: can reduce the table size according to range sigma!
	float *pRangeLUT = new float[512];
	if (pRangeLUT == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
		delete [] pGs;
		return false;
	}
	fDiv = 1.0f / (2.0f * fSigmaRange * fSigmaRange);
	for (int i=0; i<256; i++) {
		float value = (float)exp(- i * i * fDiv);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
        pRangeLUT[256+i] = value;
		pRangeLUT[256-i] = pRangeLUT[256+i];
	}

	// prepare LUT, TODO: can reduce the LUT to (1/4 * 1/2)!
	float *pLUT = new float[512 * nSize * nSize];
	if (pLUT == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
		delete [] pGs;
		delete [] pRangeLUT;
		return false;
	}
	for (int n=0; n<nSize*nSize; n++) {
		float fGs = pGs[n];
		float *pLUTPos = pLUT + n * 512;
		for (int i=0; i<512; i++) {
			pLUTPos[i] = pRangeLUT[i] * fGs;
		}
	}
	delete [] pGs;
	delete [] pRangeLUT;

	// padding and process (32F-->32F)
	if (iplSrcImage->depth == SR_DEPTH_32F && iplDstImage->depth == SR_DEPTH_32F) {
		int nPadWidth = iplSrcImage->width + 2 * nR;
		int nPadHeight = iplSrcImage->height + 2 * nR;
		float *pPadImage = new float[nPadWidth * nPadHeight];
		if (pPadImage == NULL) {
			showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
			delete [] pLUT;
			return false;
		}
		float *pPadInit = new float[nPadWidth * nPadHeight];
		if (pPadInit == NULL) {
			showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
			delete [] pLUT;
			return false;
		}
		// TODO: try cvCopyMakeBorder()
		// padding top boundary lines
		for (int y=0; y<nR; y++) {
			float *pSrc= (float*)((char *)iplSrcImage->imageData);		// padding first line
			float *pSrc1= (float*)((char *)iplInitUpscale->imageData);
			float *pDst = pPadImage + y * nPadWidth;
			float *pDst1 = pPadInit + y * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
				pDst1[x] = pSrc1[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
				pDst1[x+nR] = pSrc1[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
				pDst1[nPadWidth-x] = pSrc1[iplSrcImage->width-1];
			}
		}
		// padding
		for (int y=0; y<iplSrcImage->height; y++) {
			float *pSrc= (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);		// padding lines
			float *pSrc1= (float*)((char *)iplInitUpscale->imageData + y * iplInitUpscale->widthStep);
			float *pDst = pPadImage + (y + nR) * nPadWidth;
			float *pDst1 = pPadInit + (y + nR) * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
				pDst1[x] = pSrc1[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
				pDst1[x+nR] = pSrc1[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
				pDst1[nPadWidth-x] = pSrc1[iplSrcImage->width-1];
			}
		}
		// padding bottom boundary lines
		for (int y=0; y<nR; y++) {
			float *pSrc= (float*)((char *)iplSrcImage->imageData + (iplSrcImage->height - 1) * iplSrcImage->widthStep);		// padding last line
			float *pSrc1= (float*)((char *)iplInitUpscale->imageData + (iplInitUpscale->height - 1) * iplInitUpscale->widthStep);
			float *pDst = pPadImage + (y + iplSrcImage->height + nR) * nPadWidth;
			float *pDst1 = pPadInit + (y + iplInitUpscale->height + nR) * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
				pDst1[x] = pSrc1[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
				pDst1[x+nR] = pSrc1[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
				pDst1[nPadWidth-x] = pSrc1[iplSrcImage->width-1];
			}
		}
		//saveImagePatch_32f("_TestPadding.bmp", pPadImage, nPadWidth, nPadHeight, 1);	// for debug only
		// process
		float *pChkLUT = pLUT + 256;
		for (int y=0; y<iplDstImage->height; y++) {
			float *pDst= (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				// for each point
				float fWeight = 0.0f;
				float fValue = 0.0f;
				float fCenter = pPadInit[(y+nR) * nPadWidth + x + nR];
				float *pPadInitLine = pPadInit + y*nPadWidth + x;
				float *pPadImageLine = pPadImage + y*nPadWidth + x;
				for (int v=0; v<nSize; v++) {
					float *pPadImageLine1 = pPadImageLine + v * nPadWidth;
					float *pPadInitLine1 = pPadInitLine + v * nPadWidth;
					float *pChkLUT1 = pChkLUT + v * nSize * 512;
					for (int u=0; u<nSize; u++) {
						float fPixel1 = pPadInitLine1[u];	//int nPixel = pPadImage[(y+nR+v) * nPadWidth + x + nR + u];
						float fDiff = fPixel1 - fCenter;
						int nDiff = (int)fDiff;			// cutting
						float fLUT = pChkLUT1[(u<<9)+nDiff];		//float fLUT = pLUT[(v*nSize+u)*512+nDiff+256];
						float fPixel = pPadImageLine1[u];	//int nPixel = pPadImage[(y+nR+v) * nPadWidth + x + nR + u];
						fValue += fLUT * fPixel;
						fWeight += fLUT;
					}
				}
				pDst[x] = fValue / fWeight;
			}
		}

		delete [] pPadInit;
		delete [] pPadImage;
		delete [] pLUT;

		return true;
	}

	showErrMsg("Invalide data type of input image in bilatFilter_32f()!\n");

	return false;
}

bool CImageUtility::bilatFilter_32f(IplImage *iplSrcImage, IplImage *iplInitUpscale, IplImage *iplEdge, IplImage *iplDstImage, int nR, float fSigmaSpatial, float fSigmaRange)
// A brute force implementation of bilateral filter, 32-bit floating point internal engine.
// Different to classic algorithm, (1) this algorithm get range variables from an initial upscaled image 
// (2) it use an edge map (binarized) is conduct bilateral filter along edges.
// by Luhong Liang, IC-ASD, ASTRI
// Oct. 16, 2012
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplEdge == NULL || iplInitUpscale == NULL ||
		iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
		iplSrcImage->nChannels != iplDstImage->nChannels || iplSrcImage->nChannels != 1 || 
		nR < 1 || fSigmaSpatial <= 0.0f || fSigmaRange <= 0.0f) {
		showErrMsg("Invalide input image in bilatFilter_32f()!\n");
		return false;
	}

	// prepare spatial fitler, TODO: can reduce the table to almost 1/4!
	int nSize = 2 * nR + 1;
	float *pGs = new float[nSize * nSize];
	if (pGs == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
		return false;
	}
	float fDiv = 1.0f /( 2.0f * fSigmaSpatial * fSigmaSpatial);
	int nGsIdx = 0;
	for (int y=-nR; y<=nR; y++) {
		for (int x=-nR; x<=nR; x++) {
			float value = (float)exp(-(x*x + y*y) * fDiv);
            value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
            pGs[nGsIdx] = value;
			nGsIdx ++;
		}
	}
		
	// prepare LUT for range filter, TODO: can reduce the table size according to range sigma!
	float *pRangeLUT = new float[512];
	if (pRangeLUT == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
		delete [] pGs;
		return false;
	}
	fDiv = 1.0f / (2.0f * fSigmaRange * fSigmaRange);
	for (int i=0; i<256; i++) {
		float value = (float)exp(- i * i * fDiv);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
        pRangeLUT[256+i] = value;
		pRangeLUT[256-i] = pRangeLUT[256+i];
	}

	// prepare LUT, TODO: can reduce the LUT to (1/4 * 1/2)!
	float *pLUT = new float[512 * nSize * nSize];
	if (pLUT == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
		delete [] pGs;
		delete [] pRangeLUT;
		return false;
	}
	for (int n=0; n<nSize*nSize; n++) {
		float fGs = pGs[n];
		float *pLUTPos = pLUT + n * 512;
		for (int i=0; i<512; i++) {
			pLUTPos[i] = pRangeLUT[i] * fGs;
		}
	}
	delete [] pGs;
	delete [] pRangeLUT;

	// padding and process (32F-->32F)
	if (iplSrcImage->depth == SR_DEPTH_32F && iplDstImage->depth == SR_DEPTH_32F) {
		int nPadWidth = iplSrcImage->width + 2 * nR;
		int nPadHeight = iplSrcImage->height + 2 * nR;
		float *pPadImage = new float[nPadWidth * nPadHeight];
		if (pPadImage == NULL) {
			showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
			delete [] pLUT;
			return false;
		}
		float *pPadInit = new float[nPadWidth * nPadHeight];
		if (pPadInit == NULL) {
			showErrMsg("Fail to allocate buffer in bilatFilter_32f()!\n");
			delete [] pPadImage;
			delete [] pLUT;
			return false;
		}
		// TODO: try cvCopyMakeBorder()
		// padding top boundary lines
		for (int y=0; y<nR; y++) {
			float *pSrc= (float*)((char *)iplSrcImage->imageData);		// padding first line
			float *pSrc1= (float*)((char *)iplInitUpscale->imageData);
			float *pDst = pPadImage + y * nPadWidth;
			float *pDst1 = pPadInit + y * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
				pDst1[x] = pSrc1[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
				pDst1[x+nR] = pSrc1[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
				pDst1[nPadWidth-x] = pSrc1[iplSrcImage->width-1];
			}
		}
		// padding
		for (int y=0; y<iplSrcImage->height; y++) {
			float *pSrc= (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);		// padding lines
			float *pSrc1= (float*)((char *)iplInitUpscale->imageData + y * iplInitUpscale->widthStep);
			float *pDst = pPadImage + (y + nR) * nPadWidth;
			float *pDst1 = pPadInit + (y + nR) * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
				pDst1[x] = pSrc1[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
				pDst1[x+nR] = pSrc1[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
				pDst1[nPadWidth-x] = pSrc1[iplSrcImage->width-1];
			}
		}
		// padding bottom boundary lines
		for (int y=0; y<nR; y++) {
			float *pSrc= (float*)((char *)iplSrcImage->imageData + (iplSrcImage->height - 1) * iplSrcImage->widthStep);		// padding last line
			float *pSrc1= (float*)((char *)iplInitUpscale->imageData + (iplInitUpscale->height - 1) * iplInitUpscale->widthStep);
			float *pDst = pPadImage + (y + iplSrcImage->height + nR) * nPadWidth;
			float *pDst1 = pPadInit + (y + iplInitUpscale->height + nR) * nPadWidth;
			for (int x=0; x<nR; x++) {
				pDst[x] = pSrc[0];
				pDst1[x] = pSrc1[0];
			}
			for (int x=0; x<iplSrcImage->width; x++) {
				pDst[x+nR] = pSrc[x];
				pDst1[x+nR] = pSrc1[x];
			}
			for (int x=1; x<=nR; x++) {
				pDst[nPadWidth-x] = pSrc[iplSrcImage->width-1];
				pDst1[nPadWidth-x] = pSrc1[iplSrcImage->width-1];
			}
		}
		//saveImagePatch_32f("_TestPadding.bmp", pPadImage, nPadWidth, nPadHeight, 1);	// for debug only
		// process
		float *pChkLUT = pLUT + 256;
		for (int y=0; y<iplDstImage->height; y++) {
			float *pDst= (float*)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			float *pEdge = (float*)((char *)iplEdge->imageData + y * iplEdge->widthStep);
			float *pSrc = (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				// for each point
				float fWeight = 0.0f;
				float fValue = 0.0f;
				float fCenter = pPadInit[(y+nR) * nPadWidth + x + nR];
				float fEdge = pEdge[x];
				if (fEdge < 128.0f) {
					pDst[x] = pSrc[x];
					continue;
				}
				float *pPadInitLine = pPadInit + y*nPadWidth + x;
				float *pPadImageLine = pPadImage + y*nPadWidth + x;
				for (int v=0; v<nSize; v++) {
					float *pPadImageLine1 = pPadImageLine + v * nPadWidth;
					float *pPadInitLine1 = pPadInitLine + v * nPadWidth;
					float *pChkLUT1 = pChkLUT + v * nSize * 512;
					for (int u=0; u<nSize; u++) {
						float fPixel1 = pPadInitLine1[u];	//int nPixel = pPadImage[(y+nR+v) * nPadWidth + x + nR + u];
						float fDiff = fPixel1 - fCenter;
						int nDiff = (int)fDiff;			// cutting
						float fLUT = pChkLUT1[(u<<9)+nDiff];		//float fLUT = pLUT[(v*nSize+u)*512+nDiff+256];
						float fPixel = pPadImageLine1[u];	//int nPixel = pPadImage[(y+nR+v) * nPadWidth + x + nR + u];
						fValue += fLUT * fPixel;
						fWeight += fLUT;
					}
				}
				pDst[x] = fValue / fWeight;
			}
		}

		delete [] pPadInit;
		delete [] pPadImage;
		delete [] pLUT;

		return true;
	}

	showErrMsg("Invalide data type of input image in bilatFilter_32f()!\n");

	return false;
}

//bool CImageUtility::bilatFilterAdapt_32f(IplImage *iplSrcImage, IplImage *iplDstImage, int nR, float fSigmaSpatial)
// A brute force implementation of adaptive bilateral filter (ABF) presented in
// [Zhang, 2007] B. Zhang and Jan P. Allebach, Adpative bilateral filter for sharpness
// enhancement and noise removal, ICIP, 2007
// by Luhong Liang, IC-ASD, ASTRI
// Nov. 14, 2011
//{
//	return true;
//}

//bool CImageUtility::bilatFilterEnc_32f(IplImage *iplSrcImage, IplImage *iplDstImage, int nR, float fSigmaSpatial, float fSigmaRange)
// A brute force implementation of enhanced bilateral filter (EBF) proposed by Luhong Liang
// by Luhong Liang, IC-ASD, ASTRI
// Nov. 14, 2011
//{
//	return true;
//}

bool CImageUtility::subImage_32f(IplImage *iplSrc1, IplImage *iplSrc2, IplImage *iplDst)
// Image substraction, i.e. Dst = Src1 - Src2, supporting hybrid 32F, 32S and 8U operations
// Supported data type:	Src1 (8U, 32S, 32F), Src2 (8U, 32S, 32F), Dst(32F)
// NOTE: Different to function cvtImageXtoX(), this function directly converts the 8U/32S
//       data to floating-point.
// by Luhong Liang, IC-ASD, ASTRI
// Nov. 14, 2011; June 3, 2013; March 6, 2015
{
	if (iplSrc1 == NULL || iplSrc2 == NULL || iplDst == NULL || 
		iplSrc1->nChannels != 1 || iplSrc2->nChannels != 1 || iplDst->nChannels != 1 ||
		iplSrc1->width != iplSrc2->width || iplSrc1->width != iplDst->width ||
		iplSrc1->height != iplSrc2->height || iplSrc1->height != iplDst->height ||
		iplDst->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image found in CImageUtility::subImage_32f()!\n");
		return false;
	}

    if (iplSrc1->depth == SR_DEPTH_32F && iplSrc2->depth == SR_DEPTH_8U) {   // bug fix, March, 2015
		// 32F - 8U
		for (int y=0; y<iplDst->height; y++) {
			float *pSrc1 = (float *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			unsigned char *pSrc2 = (unsigned char *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp2 = pSrc2[x];
				pDst[x] = pSrc1[x] - temp2;
			}
		}
	} else if (iplSrc1->depth == SR_DEPTH_32F && iplSrc2->depth == SR_DEPTH_32S) {
		// 32F - 32S
		for (int y=0; y<iplDst->height; y++) {
			float *pSrc1 = (float *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			int *pSrc2 = (int *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp2 = (float)pSrc2[x];
				pDst[x] = pSrc1[x] - temp2;
			}
		}
    } else if (iplSrc1->depth == SR_DEPTH_32F && iplSrc2->depth == SR_DEPTH_32F) {
		// 32F - 32F
		//cvSub(iplSrc1, iplSrc2, iplDst);
		for (int y=0; y<iplDst->height; y++) {
			float *pSrc1 = (float *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			float *pSrc2 = (float *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp1 = pSrc1[x];
				float temp2 = pSrc2[x];
				pDst[x] = temp1 - temp2;
			}
		}
	} else if (iplSrc1->depth == SR_DEPTH_8U && iplSrc2->depth == SR_DEPTH_8U) {
		// 8U - 8U
		for (int y=0; y<iplDst->height; y++) {
			unsigned char *pSrc1 = (unsigned char *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			unsigned char *pSrc2 = (unsigned char *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp1 = pSrc1[x];
				float temp2 = pSrc2[x];
				pDst[x] = temp1 - temp2;
			}
		}
	} else if (iplSrc1->depth == SR_DEPTH_8U && iplSrc2->depth == SR_DEPTH_32S) {
		// 8U - 32S
		for (int y=0; y<iplDst->height; y++) {
			unsigned char *pSrc1 = (unsigned char *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			int *pSrc2 = (int *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp1 = (float)pSrc1[x];
				pDst[x] = temp1 - pSrc2[x];
			}
		}
    } else if (iplSrc1->depth == SR_DEPTH_8U && iplSrc2->depth == SR_DEPTH_32F) {
		// 8U - 32F
		for (int y=0; y<iplDst->height; y++) {
			unsigned char *pSrc1 = (unsigned char *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			float *pSrc2 = (float *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp1 = pSrc1[x];
				pDst[x] = temp1 - pSrc2[x];
			}
		}
    } else if (iplSrc1->depth == SR_DEPTH_32S && iplSrc2->depth == SR_DEPTH_8U) { 
		// 32S - 8U
		for (int y=0; y<iplDst->height; y++) {
			int *pSrc1 = (int *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			unsigned char *pSrc2 = (unsigned char *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp2 = pSrc2[x];
				pDst[x] = (float)pSrc1[x] - temp2;
			}
		}
	} else if (iplSrc1->depth == SR_DEPTH_32S && iplSrc2->depth == SR_DEPTH_32S) {
		// 32S - 32S
		for (int y=0; y<iplDst->height; y++) {
			int *pSrc1 = (int *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			int *pSrc2 = (int *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp2 = (float)pSrc2[x];
				pDst[x] = (float)pSrc1[x] - temp2;
			}
		}
    } else if (iplSrc1->depth == SR_DEPTH_32S && iplSrc2->depth == SR_DEPTH_32F) {
		// 32S - 32F
		//cvSub(iplSrc1, iplSrc2, iplDst);
		for (int y=0; y<iplDst->height; y++) {
			int *pSrc1 = (int *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			float *pSrc2 = (float *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp1 = (float)pSrc1[x];
				float temp2 = pSrc2[x];
				pDst[x] = temp1 - temp2;
			}
		}
	} else {
		showErrMsg("Unsupported input image data type found in CImageUtility::subImage_32f()!\n");
		return false;
	}

	return true;
}

bool CImageUtility::addImage_32f(IplImage *iplSrc1, IplImage *iplSrc2, IplImage *iplDst)
// Image addition, i.e. Dst = Src1 + Src2, supporting hybrid 32F, 32S and 8U operations
// Supported data type:	Src1 (8U, 32S, 32F), Src2 (8U, 32S, 32F), Dst(32F)
// NOTE: Different to function cvtImageXtoX(), this function directly converts the 8U/32S
//       data to floating-point.
// by Luhong Liang, IC-ASD, ASTRI
// Nov. 14, 2011; June 3, 2013; March 6, 2015
{
	if (iplSrc1 == NULL || iplSrc2 == NULL || iplDst == NULL || 
		iplSrc1->nChannels != 1 || iplSrc2->nChannels != 1 || iplDst->nChannels != 1 ||
		iplSrc1->width != iplSrc2->width || iplSrc1->width != iplDst->width ||
		iplSrc1->height != iplSrc2->height || iplSrc1->height != iplDst->height ||
		iplDst->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image found in CImageUtility::addImage_32f()!\n");
		return false;
	}

    if (iplSrc1->depth == SR_DEPTH_32F && iplSrc2->depth == SR_DEPTH_8U) {   // bug fix, March, 2015
		// 32F + 8U
		for (int y=0; y<iplDst->height; y++) {
			float *pSrc1 = (float *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			unsigned char *pSrc2 = (unsigned char *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp2 = pSrc2[x];
				pDst[x] = pSrc1[x] + temp2;
			}
		}
	} else if (iplSrc1->depth == SR_DEPTH_32F && iplSrc2->depth == SR_DEPTH_32S) {
		// 32F + 32S
		for (int y=0; y<iplDst->height; y++) {
			float *pSrc1 = (float *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			int *pSrc2 = (int *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp2 = (float)pSrc2[x];
				pDst[x] = pSrc1[x] + temp2;
			}
		}
    } else if (iplSrc1->depth == SR_DEPTH_32F && iplSrc2->depth == SR_DEPTH_32F) {
		// 32F + 32F
		//cvSub(iplSrc1, iplSrc2, iplDst);
		for (int y=0; y<iplDst->height; y++) {
			float *pSrc1 = (float *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			float *pSrc2 = (float *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp1 = pSrc1[x];
				float temp2 = pSrc2[x];
				pDst[x] = temp1 + temp2;
			}
		}
	} else if (iplSrc1->depth == SR_DEPTH_8U && iplSrc2->depth == SR_DEPTH_8U) {
		// 8U + 8U
		for (int y=0; y<iplDst->height; y++) {
			unsigned char *pSrc1 = (unsigned char *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			unsigned char *pSrc2 = (unsigned char *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp1 = pSrc1[x];
				float temp2 = pSrc2[x];
				pDst[x] = temp1 + temp2;
			}
		}
	} else if (iplSrc1->depth == SR_DEPTH_8U && iplSrc2->depth == SR_DEPTH_32S) {
		// 8U + 32S
		for (int y=0; y<iplDst->height; y++) {
			unsigned char *pSrc1 = (unsigned char *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			int *pSrc2 = (int *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp1 = (float)pSrc1[x];
				pDst[x] = temp1 + pSrc2[x];
			}
		}
    } else if (iplSrc1->depth == SR_DEPTH_8U && iplSrc2->depth == SR_DEPTH_32F) {
		// 8U + 32F
		for (int y=0; y<iplDst->height; y++) {
			unsigned char *pSrc1 = (unsigned char *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			float *pSrc2 = (float *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp1 = pSrc1[x];
				pDst[x] = temp1 + pSrc2[x];
			}
		}
    } else if (iplSrc1->depth == SR_DEPTH_32S && iplSrc2->depth == SR_DEPTH_8U) { 
		// 32S + 8U
		for (int y=0; y<iplDst->height; y++) {
			int *pSrc1 = (int *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			unsigned char *pSrc2 = (unsigned char *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp2 = pSrc2[x];
				pDst[x] = (float)pSrc1[x] + temp2;
			}
		}
	} else if (iplSrc1->depth == SR_DEPTH_32S && iplSrc2->depth == SR_DEPTH_32S) {
		// 32S + 32S
		for (int y=0; y<iplDst->height; y++) {
			int *pSrc1 = (int *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			int *pSrc2 = (int *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp2 = (float)pSrc2[x];
				pDst[x] = (float)pSrc1[x] + temp2;
			}
		}
    } else if (iplSrc1->depth == SR_DEPTH_32S && iplSrc2->depth == SR_DEPTH_32F) {
		// 32S + 32F
		//cvSub(iplSrc1, iplSrc2, iplDst);
		for (int y=0; y<iplDst->height; y++) {
			int *pSrc1 = (int *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
			float *pSrc2 = (float *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp1 = (float)pSrc1[x];
				float temp2 = pSrc2[x];
				pDst[x] = temp1 + temp2;
			}
		}
	} else {
		showErrMsg("Unsupported input image data type found in CImageUtility::addImage_32f()!\n");
		return false;
	}

	return true;
}

bool CImageUtility::addImage_32f(IplImage *iplSrc, IplImage *iplDst, float bright_shift)
{
	if (iplSrc == NULL || iplDst == NULL || iplSrc->nChannels != 1 || iplDst->nChannels != 1 ||
		iplSrc->width != iplDst->width || iplSrc->height != iplDst->height ||
		iplDst->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image found in CImageUtility::addImage_32f()!\n");
		return false;
	}

	if (iplSrc->depth == SR_DEPTH_32F) {
		// 32F - 32F
		for (int y=0; y<iplDst->height; y++) {
			float *pSrc = (float *)((char *)iplSrc->imageData + y * iplSrc->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				pDst[x] = pSrc[x] + bright_shift;
			}
		}
	} else {
		showErrMsg("Unsupported input image data type found in CImageUtility::addImage_32f()!\n");
		return false;
	}

    return true;
}

bool CImageUtility::addImagePos_32f(IplImage *iplSrc, IplImage *iplDst, float bright_shift)
// add a bias to the image and clip the resultant image positive value
{
	if (iplSrc == NULL || iplDst == NULL || iplSrc->nChannels != 1 || iplDst->nChannels != 1 ||
		iplSrc->width != iplDst->width || iplSrc->height != iplDst->height ||
		iplDst->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image found in CImageUtility::addImagePos_32f()!\n");
		return false;
	}

	if (iplSrc->depth == SR_DEPTH_32F) {
		// 32F - 32F
		for (int y=0; y<iplDst->height; y++) {
			float *pSrc = (float *)((char *)iplSrc->imageData + y * iplSrc->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float val = pSrc[x] + bright_shift;
                pDst[x] = val < 0.0f ? 0.0f : val;
			}
		}
	} else {
		showErrMsg("Unsupported input image data type found in CImageUtility::addImagePos_32f()!\n");
		return false;
	}

    return true;
}

bool CImageUtility::absImage_32f(IplImage *iplSrc, IplImage *iplDst)
// Absolute image
{
	if (iplSrc == NULL || iplDst == NULL || iplSrc->nChannels != 1 || iplDst->nChannels != 1 ||
		iplSrc->width != iplDst->width || iplSrc->height != iplDst->height ||
		iplDst->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image found in CImageUtility::absImage_32f()!\n");
		return false;
	}

	if (iplSrc->depth == SR_DEPTH_32F) {
		// 32F - 32F
		for (int y=0; y<iplDst->height; y++) {
			float *pSrc = (float *)((char *)iplSrc->imageData + y * iplSrc->widthStep);
			float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
			for (int x=0; x<iplDst->width; x++) {
				float temp = pSrc[x];
				pDst[x] = temp < 0.0f ? -temp : temp;
			}
		}
	} else {
		showErrMsg("Unsupported input image data type found in CImageUtility::addImage_32f()!\n");
		return false;
	}

    return true;
}

bool CImageUtility::mulImage_32f(IplImage *iplSrc, float fFactor)
// Multiply pixels of an image and a scaler
// by Luhong Liang, IC-ASD, ASTRI
// Jan. 23, 2011
{
	if (iplSrc == NULL || iplSrc->nChannels != 1 || iplSrc->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image found in CImageUtility::mulImage_32f()!\n");
		return false;
	}

	for (int y=0; y<iplSrc->height; y++) {
		float *pSrc = (float *)((char *)iplSrc->imageData + y * iplSrc->widthStep);
		for (int x=0; x<iplSrc->width; x++) {
			pSrc[x] = pSrc[x] * fFactor;
		}
	}

	return true;
}

bool CImageUtility::mulImage_8U(IplImage *iplSrc, float fFactor)
// Multiply pixels of an image and a scaler
// by Luhong Liang, IC-ASD, ASTRI
// July 7, 2014
{
	if (iplSrc == NULL || iplSrc->nChannels != 1 || iplSrc->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image found in CImageUtility::mulImage_8U()!\n");
		return false;
	}

	for (int y=0; y<iplSrc->height; y++) {
		unsigned char *pSrc = (unsigned char *)((char *)iplSrc->imageData + y * iplSrc->widthStep);
		for (int x=0; x<iplSrc->width; x++) {
            int val = pSrc[x];
            val = (int)(val * fFactor + 0.5f);
            val = val < 0 ? 0 : val;
            val = val > 255 ? 255 : val;
			pSrc[x] = (unsigned char)val;
		}
	}

	return true;
}

bool CImageUtility::mulImage_32f(IplImage *iplSrc1, IplImage *iplSrc2, IplImage *iplDst)
// Pixel-to-pixel multiplication of two images
// by Luhong Liang, IC-ASD, ASTRI
// Jan. 23, 2011
{
	if (iplSrc1 == NULL || iplSrc1->nChannels != 1 || iplSrc1->depth != SR_DEPTH_32F ||
		iplSrc2 == NULL || iplSrc2->nChannels != 1 || iplSrc2->depth != SR_DEPTH_32F ||
		iplDst == NULL || iplDst->nChannels != 1 || iplDst->depth != SR_DEPTH_32F ||
		iplSrc1->width != iplDst->width || iplSrc1->height != iplDst->height || 
		iplSrc2->width != iplDst->width || iplSrc2->height != iplDst->height) {
		showErrMsg("Invalid input image found in CImageUtility::mulImage_32f()!\n");
		return false;
	}

	for (int y=0; y<iplDst->height; y++) {
		float *pSrc1 = (float *)((char *)iplSrc1->imageData + y * iplSrc1->widthStep);
		float *pSrc2 = (float *)((char *)iplSrc2->imageData + y * iplSrc2->widthStep);
		float *pDst = (float *)((char *)iplDst->imageData + y * iplDst->widthStep);
		for (int x=0; x<iplDst->width; x++) {
			pDst[x] = pSrc1[x] * pSrc2[x];
		}
	}

	return true;
}

float CImageUtility::maxInImage_32f(IplImage *iplSrc)
// get the maximum value in the image
// by Luhong Liang, IC-ASD, ASTRI
// Jan. 23, 2011
{
	if (iplSrc == NULL || iplSrc->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image found in CImageUtility::mulImage_32f()!\n");
		return false;
	}

	float fMax = -FLT_MAX;
    if (iplSrc->nChannels == 1) {
	    for (int y=0; y<iplSrc->height; y++) {
		    float *pSrc = (float *)((char *)iplSrc->imageData + y * iplSrc->widthStep);
		    for (int x=0; x<iplSrc->width; x++) {
			    if (pSrc[x] > fMax) {
				    fMax = pSrc[x];
                }
		    }
	    }
    } else if (iplSrc->nChannels == 3) {
	    for (int y=0; y<iplSrc->height; y++) {
		    float *pSrc = (float *)((char *)iplSrc->imageData + y * iplSrc->widthStep);
		    for (int x=0; x<iplSrc->width; x++) {
                int xx = x * 3;
			    if (pSrc[xx] > fMax) {
				    fMax = pSrc[xx];
                }
			    if (pSrc[xx+1] > fMax) {
				    fMax = pSrc[xx+1];
                }
			    if (pSrc[xx+2] > fMax) {
				    fMax = pSrc[xx+2];
                }
		    }
	    }
    } else {
		showErrMsg("Only supports 1- or 3-channel images in CImageUtility::mulImage_32f()!\n");
		return false;
    }

    return fMax;
}

int CImageUtility::maxInImage_32s(IplImage *iplSrc)
// get the maximum value in the image
// by Luhong Liang, IC-ASD, ASTRI
// July 15, 2011
{
	if (iplSrc == NULL || iplSrc->nChannels != 1 || iplSrc->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image found in CImageUtility::mulImage_32s()!\n");
		return 0;
	}

	int nMax = 0x80000000;
	for (int y=0; y<iplSrc->height; y++) {
		int *pSrc = (int *)((char *)iplSrc->imageData + y * iplSrc->widthStep);
		for (int x=0; x<iplSrc->width; x++) {
			if (pSrc[x] > nMax)
				nMax = pSrc[x];
		}
	}

	return nMax;
}

float CImageUtility::minInImage_32f(IplImage *iplSrc)
// get the mimimal value in the image
// by Luhong Liang, IC-ASD, ASTRI
// Jan. 23, 2011
{
	if (iplSrc == NULL || iplSrc->nChannels != 1 || iplSrc->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image found in CImageUtility::mulImage_32f()!\n");
		return false;
	}

	float fMin = FLT_MAX;
	for (int y=0; y<iplSrc->height; y++) {
		float *pSrc = (float *)((char *)iplSrc->imageData + y * iplSrc->widthStep);
		for (int x=0; x<iplSrc->width; x++) {
			if (pSrc[x] < fMin)
				fMin = pSrc[x];
		}
	}

	return fMin;
}

int CImageUtility::minInImage_32s(IplImage *iplSrc)
// get the mimimal value in the image
// by Luhong Liang, IC-ASD, ASTRI
// July 15, 2011
{
	if (iplSrc == NULL || iplSrc->nChannels != 1 || iplSrc->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image found in CImageUtility::mulImage_32s()!\n");
		return 0;
	}

	int nMin = 0x7FFFFFFF;
	for (int y=0; y<iplSrc->height; y++) {
		int *pSrc = (int *)((char *)iplSrc->imageData + y * iplSrc->widthStep);
		for (int x=0; x<iplSrc->width; x++) {
			if (pSrc[x] < nMin)
				nMin = pSrc[x];
		}
	}

	return nMin;
}

bool CImageUtility::getMaxMinVal(IplImage *iplImage, unsigned char &maxval, unsigned char &minval)
// get the maximum mimimum of the image
// by Luhong Liang, IC-ASD, ASTRI
// July 18, 2014
{
	if (iplImage == NULL || iplImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image found in CImageUtility::getMaxMinVal()!\n");
		return false;
	}

    maxval = 0;
    minval = 255;
	for (int y=0; y<iplImage->height; y++) {
		unsigned char *pTen = (unsigned char*)((char *)iplImage->imageData + y * iplImage->widthStep);
        for (int x=0; x<iplImage->width*iplImage->nChannels; x++) {
            unsigned char val = pTen[x];
            maxval = val > maxval ? val : maxval;
            minval = val < minval ? val : minval;
        }
    }

    return true;
}

bool CImageUtility::getMaxMinVal(IplImage *iplImage, unsigned short &maxval, unsigned short &minval)
// get the maximum mimimum of the image
// by Luhong Liang, IC-ASD, ASTRI
// July 18, 2014
{
	if (iplImage == NULL || iplImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image found in CImageUtility::getMaxMinVal()!\n");
		return false;
	}

    unsigned short *pTen = (unsigned short*)((char *)iplImage->imageData + iplImage->widthStep);
    maxval = pTen[0];
    minval = pTen[0];
	for (int y=0; y<iplImage->height; y++) {
		unsigned short *pTen = (unsigned short*)((char *)iplImage->imageData + y * iplImage->widthStep);
        for (int x=0; x<iplImage->width*iplImage->nChannels; x++) {
            unsigned short val = pTen[x];
            maxval = val > maxval ? val : maxval;
            minval = val < minval ? val : minval;
        }
    }

    return true;
}

bool CImageUtility::getMaxMinVal(IplImage *iplImage, int &maxval, int &minval)
// get the maximum mimimum of the image
// by Luhong Liang, IC-ASD, ASTRI
// July 18, 2014
{
	if (iplImage == NULL || iplImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image found in CImageUtility::getMaxMinVal()!\n");
		return false;
	}

    int *pTen = (int*)((char *)iplImage->imageData + iplImage->widthStep);
    maxval = pTen[0];
    minval = pTen[0];
	for (int y=0; y<iplImage->height; y++) {
		int *pTen = (int*)((char *)iplImage->imageData + y * iplImage->widthStep);
        for (int x=0; x<iplImage->width*iplImage->nChannels; x++) {
            int val = pTen[x];
            maxval = val > maxval ? val : maxval;
            minval = val < minval ? val : minval;
        }
    }

    return true;
}

bool CImageUtility::getMaxMinVal(IplImage *iplImage, float &maxval, float &minval)
// get the maximum mimimum of the image
// by Luhong Liang, IC-ASD, ASTRI
// July 18, 2014
{
	if (iplImage == NULL || iplImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image found in CImageUtility::getMaxMinVal()!\n");
		return false;
	}

    maxval = -FLT_MAX;
    minval = FLT_MAX;
	for (int y=0; y<iplImage->height; y++) {
		float *pTen = (float*)((char *)iplImage->imageData + y * iplImage->widthStep);
        for (int x=0; x<iplImage->width*iplImage->nChannels; x++) {
            float val = pTen[x];
            maxval = val > maxval ? val : maxval;
            minval = val < minval ? val : minval;
        }
    }

    return true;
}

float CImageUtility::meanImage(IplImage *iplSrc)
// Multiply pixels of an image and a scaler
// by Luhong Liang, IC-ASD, ASTRI
// Jan. 23, 2011
// July 7, 2014: added support on 32S and 8U data
{
	if (iplSrc == NULL || iplSrc->nChannels != 1) {
		showErrMsg("Invalid input image in CImageUtility::meanImage()!\n");
		return false;
	}

	float fMean = 0;
    if  (iplSrc->depth == SR_DEPTH_32F) {
	    for (int y=0; y<iplSrc->height; y++) {
		    float *pSrc = (float *)((char *)iplSrc->imageData + y * iplSrc->widthStep);
		    for (int x=0; x<iplSrc->width; x++) {
			    fMean += pSrc[x];
		    }
	    }
    } else if  (iplSrc->depth == SR_DEPTH_32S) {
	    for (int y=0; y<iplSrc->height; y++) {
		    int *pSrc = (int *)((char *)iplSrc->imageData + y * iplSrc->widthStep);
		    for (int x=0; x<iplSrc->width; x++) {
			    fMean += (float)(pSrc[x]);
		    }
	    }
    } else if  (iplSrc->depth == SR_DEPTH_8U) {
	    for (int y=0; y<iplSrc->height; y++) {
		    unsigned char *pSrc = (unsigned char *)((char *)iplSrc->imageData + y * iplSrc->widthStep);
		    for (int x=0; x<iplSrc->width; x++) {
			    fMean += (float)(pSrc[x]);
		    }
	    }
    } else {
        showErrMsg("Unsupported image data type in CImageUtility::meanImage()!\n");
        return -1.0f;
    }


	return fMean / (iplSrc->width * iplSrc->height);
}

bool CImageUtility::cvtToLogDomain_32f(IplImage *iplImage)
// covert image to log domain
// by Luhong Liang, IC-ASD, ASTRI
// Nov. 23, 2011
{
	if (iplImage == NULL || iplImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image found in CImageUtility::cvtToLogDomain_32f()!\n");
		return false;
	}

	// prepare LUT
	float *pLUT = new float[1024];
	if (pLUT == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::cvtToLogDomain_32f()!\n");
		return false;
	}
	float fMax = (float)log(256.0f);
	for (int i=0; i<1024; i++) {
		float val = (float)i / 4.0f + 1;
		pLUT[i] = (float)log(val) * 255.0f / fMax;
	}

	// covert data
	for (int y=0; y<iplImage->height; y++) {
		float *pImg = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
		for (int x=0; x<iplImage->width * iplImage->nChannels; x++) {
			float val = pImg[x];
			if (val >= 255.0f) {
				pImg[x] = 255.0f;
			} else if (val < 0.0f) {
				pImg[x] = 0.0f;
			} else {
				int index = (int)(val * 4.0f + 0.5f);
				pImg[x] = pLUT[index];
			}
		}
	}

	return true;
}

bool CImageUtility::cvtFromLogDomain_32f(IplImage *iplImage)
// covert image from log domain
// by Luhong Liang, IC-ASD, ASTRI
// Nov. 23, 2011
{
	if (iplImage == NULL || iplImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image found in CImageUtility::cvtFromLogDomain_32f()!\n");
		return false;
	}

	// prepare LUT
	float *pLUT = new float[1024];
	if (pLUT == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::cvtFromLogDomain_32f()!\n");
		return false;
	}
	float fMax = (float)log(256.0f);
	//for (int i=0; i<1024; i++) {
	//	float val = (float)i / 4.0f;
	//	pLUT[i] = (float)exp((val * fMax / 255.0f)) - 1.0f; 
	//}

	// covert data
	for (int y=0; y<iplImage->height; y++) {
		float *pImg = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
		for (int x=0; x<iplImage->width * iplImage->nChannels; x++) {
			float val = pImg[x];
			if (val >= 255.0f) {
				pImg[x] = 255.0f;
			} else if (val < 0.0f) {
				pImg[x] = 0.0f;
			} else {
				//int index = (int)(val * 4.0f + 0.5f);
				//pImg[x] = pLUT[index];
                float value = (float)exp((val * fMax / 255.0f));
                value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
				pImg[x] = value - 1.0f; 
			}
		}
	}

	return true;
}

bool CImageUtility::clip_32f(IplImage *iplImage, float min_v, float max_v)
// clip the pixel value of the given image into [min, max]
// Luhong Liang, IC-ASD, ASTRI
{
	if (iplImage== NULL || iplImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image format in CImageUtility::clip_32f()!\n");
		return false;
	}

	for (int y=0; y<iplImage->height; y++) {
		float *pLine = (float *)((char*)iplImage->imageData + y * iplImage->widthStep);
		for (int x=0; x<iplImage->width*iplImage->nChannels; x++) {
			float val = pLine[x];
			if (val < min_v)
				pLine[x] = min_v;
			else if (val > max_v)
				pLine[x] = max_v;
		}
	}

	return true;
}

bool CImageUtility::binarize_32f(IplImage *iplImage, float threshold, float val0, float val1)
// Binarize the image. When the pixel value is less than threshold, set the value to val0;
// otherwise, set the value to val1.
// Luhong Liang, IC-ASD, ASTRI
{
	if (iplImage== NULL || iplImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image format in CImageUtility::binarize_32f()!\n");
		return false;
	}

	for (int y=0; y<iplImage->height; y++) {
		float *pLine = (float *)((char*)iplImage->imageData + y * iplImage->widthStep);
		for (int x=0; x<iplImage->width*iplImage->nChannels; x++) {
			float val = pLine[x];
            pLine[x] = val < threshold ? val0 : val1;
		}
	}

	return true;
}

bool CImageUtility::setValue(IplImage *iplImage, unsigned char val)
// set unique value to a 8U image
{
	if (iplImage == NULL || iplImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image format in CImageUtility::setValue()!\n");
		return false;
	}

	unsigned char *pBuf = (unsigned char*)(iplImage->imageData);
	memset(pBuf, val, iplImage->widthStep * iplImage->height);

	return true;
}

bool CImageUtility::setValue(IplImage *iplImage, int val)
// set unique value to a 32S image
{
	if (iplImage == NULL || iplImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image format in CImageUtility::setValue()!\n");
		return false;
	}

    for (int y=0; y<iplImage->height; y++) {
        int *pBuf = (int *)(iplImage->imageData + y * iplImage->widthStep);
        for (int x=0; x<iplImage->width * iplImage->nChannels; x++) {
            pBuf[x] = val;
        }
    }

    return true;
}

bool CImageUtility::setValue(IplImage *iplImage, float val)
// set unique value to a 32F image
{
	if (iplImage == NULL || iplImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image format in CImageUtility::setValue()!\n");
		return false;
	}

    for (int y=0; y<iplImage->height; y++) {
        float *pBuf = (float *)(iplImage->imageData + y * iplImage->widthStep);
        for (int x=0; x<iplImage->width * iplImage->nChannels; x++) {
            pBuf[x] = val;
        }
    }

    return true;
}

//bool CImageUtility::setZero(IplImage *iplImage)
//{
//	if (iplImage == NULL) {
//		showErrMsg("Invalid input image format in CImageUtility::setZero()!\n");
//		return false;
//	}

//    if (iplImage->depth == SR_DEPTH_8U) {
//        unsigned char *pBuf = (unsigned char*)(iplImage->imageData);
//        memset(pBuf, 0, iplImage->widthStep * iplImage->height);
//    } else if (iplImage->depth == SR_DEPTH_32S) {
//        for (int y=0; y<iplImage->height; y++) {
//            int *pBuf = (int *)(iplImage->imageData + y * iplImage->widthStep);
//            for (int x=0; x<iplImage->width * iplImage->nChannels; x++) {
//                pBuf[x] = 0;
//            }
//        }
//    } else if (iplImage->depth == SR_DEPTH_32F) {
//        for (int y=0; y<iplImage->height; y++) {
//            float *pBuf = (float *)(iplImage->imageData + y * iplImage->widthStep);
//            for (int x=0; x<iplImage->width * iplImage->nChannels; x++) {
//                pBuf[x] = 0.0f;
//            }
//        }
//    } else {
//		showErrMsg("Unsupported image data type in CImageUtility::setZero()!\n");
//		return false;
//    }

//    return true;
//}

bool CImageUtility::shift_bilinear_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float sx, float sy, bool clipping)
// shift an image over sx in horizontal direction and sy in vertical using bilinear interpolation
// Luhong Liang, IC-ASD, ASTRI
{
	if (!IPL_SAME_FORMAT(iplSrcImage, iplDstImage)) {
		showErrMsg("Invalid or mismatched source and destination image in CImageUtility::shift()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F || iplSrcImage->nChannels !=1 ) {
		showErrMsg("Invalid image data type or channel number in CImageUtility::shift()!\n");
		return false;
	}

	if (fabs(sx) > iplSrcImage->width || fabs(sy) > iplSrcImage->height) {	// for moving out
		setZero(iplDstImage);
		return true;
	}

	IplImage *iplTemp = createImage(iplSrcImage->width, iplSrcImage->height, SR_DEPTH_32F, 1);
	if (iplTemp == NULL) {
		showErrMsg("Fail to allocate temp image in CImageUtility::shift()!\n");
		return false;
	}

	// reverse sx and sy for backprojection
	sx = -sx;
	sy = -sy;

	// interpolate in horizontal direction
	int shift_x_dec = (int)floor(sx);
	float shift_x_frac = sx - shift_x_dec;		// fraction of shifting, always positive sub-pixel from left neighbor
	float shift_x_frac1 = 1.0f - shift_x_frac;
	for (int y=0; y<iplTemp->height; y++) {
		float *pSrc = (float *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		float *pDst = (float *)((char *)iplTemp->imageData + y * iplTemp->widthStep);

		if (shift_x_dec < 0) {
			// process left part that exceeds boundary
			for (int x=0, xx=shift_x_dec; xx<0; x++, xx++) {
				pDst[x] = pSrc[0];
			}
			// process central part
			for (int x=-shift_x_dec, xx=0; x<iplTemp->width; x++, xx++) {
				pDst[x] = pSrc[xx] * shift_x_frac1 + pSrc[xx+1] * shift_x_frac;
			}
		} else {
			// process central part
			for (int x=0, xx=shift_x_dec; xx<iplSrcImage->width-1; x++, xx++) {
				pDst[x] = pSrc[xx] * shift_x_frac1 + pSrc[xx+1] * shift_x_frac;
			}
			// process right part that exceeds boundary
			for (int x=iplTemp->width-shift_x_dec-1; x<iplTemp->width; x++) {
				pDst[x] = pSrc[iplSrcImage->width-1];
			}
		}
	}
	//saveImage("_XSftEGIImage.bmp", iplTemp);

	// interpolate in vertical direction
	int shift_y_dec = (int)floor(sy);
	float shift_y_frac = sy - shift_y_dec;		// fraction of shifting, always positive sub-pixel from upper neighbor
	float shift_y_frac1 = 1.0f - shift_y_frac;
	if (shift_y_dec < 0) {
		// process top part that exceeds boundary
		for (int y=0, yy=shift_y_dec; yy<0; y++, yy++) {
			float *pSrc = (float *)((char *)iplTemp->imageData);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				pDst[x] = pSrc[x];
			}
		}
		// process central part
		for (int y=-shift_y_dec, yy=0; y<iplTemp->height; y++, yy++) {
			float *pSrc = (float *)((char *)iplTemp->imageData + yy * iplTemp->widthStep);
			float *pSrc1 = (float *)((char *)iplTemp->imageData + (yy+1) * iplTemp->widthStep);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				pDst[x] = pSrc[x] * shift_y_frac1 + pSrc1[x] * shift_y_frac;
			}
		}
	} else {
		// process central part
		for (int y=0, yy=shift_y_dec; yy<iplTemp->height-1; y++, yy++) {
			float *pSrc = (float *)((char *)iplTemp->imageData + yy * iplTemp->widthStep);
			float *pSrc1 = (float *)((char *)iplTemp->imageData + (yy+1) * iplTemp->widthStep);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				pDst[x] = pSrc[x] * shift_y_frac1 + pSrc1[x] * shift_y_frac;
			}
		}
		// process right part that exceeds boundary
		for (int y=iplTemp->height-shift_y_dec-1; y<iplDstImage->height; y++) {
			float *pSrc = (float *)((char *)iplTemp->imageData + (iplTemp->height-1)*iplTemp->widthStep);
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				pDst[x] = pSrc[x];
			}
		}
	}

	if (clipping) {
		for (int y=0; y<iplDstImage->height; y++) {
			float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				float pix = pDst[x];
				if (pix < 0.0f)
					pDst[x] = 0.0f;
				else if (pix > 255.0f)
					pDst[x] = 255.0f;
			}
		}
	}

	releaseImage(&iplTemp);

	return true;
}

bool CImageUtility::shift_bilinear_32f(IplImage *iplImage, float sx, float sy)
// shift an image over sx in horizontal direction and sy in vertical using bilinear interpolation
// Luhong Liang, IC-ASD, ASTRI
{
	if (iplImage == NULL || iplImage->depth != SR_DEPTH_32F || iplImage->nChannels !=1 ) {
		showErrMsg("Invalid input image in CImageUtility::shift()!\n");
		return false;
	}

	if (fabs(sx) > iplImage->width || fabs(sy) > iplImage->height) {	// for moving out
		setZero(iplImage);
		return true;
	}

	IplImage *iplTemp = createImage(iplImage->width, iplImage->height, SR_DEPTH_32F, 1);
	if (iplTemp == NULL) {
		showErrMsg("Fail to allocate temp image in CImageUtility::shift()!\n");
		return false;
	}

	// reverse sx and sy for backprojection
	sx = -sx;
	sy = -sy;

	// interpolate in horizontal direction
	int shift_x_dec = (int)floor(sx);
	float shift_x_frac = sx - shift_x_dec;		// fraction of shifting, always positive sub-pixel from left neighbor
	float shift_x_frac1 = 1.0f - shift_x_frac;
	for (int y=0; y<iplTemp->height; y++) {
		float *pSrc = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
		float *pDst = (float *)((char *)iplTemp->imageData + y * iplTemp->widthStep);

		if (shift_x_dec < 0) {
			// process left part that exceeds boundary
			for (int x=0, xx=shift_x_dec; xx<0; x++, xx++) {
				pDst[x] = pSrc[0];
			}
			// process central part
			for (int x=-shift_x_dec, xx=0; x<iplTemp->width; x++, xx++) {
				pDst[x] = pSrc[xx] * shift_x_frac1 + pSrc[xx+1] * shift_x_frac;
			}
		} else {
			// process central part
			for (int x=0, xx=shift_x_dec; xx<iplImage->width-1; x++, xx++) {
				pDst[x] = pSrc[xx] * shift_x_frac1 + pSrc[xx+1] * shift_x_frac;
			}
			// process right part that exceeds boundary
			for (int x=iplTemp->width-shift_x_dec-1; x<iplTemp->width; x++) {
				pDst[x] = pSrc[iplImage->width-1];
			}
		}
	}
	//saveImage("_XSftEGIImage.bmp", iplTemp);

	// interpolate in vertical direction
	int shift_y_dec = (int)floor(sy);
	float shift_y_frac = sy - shift_y_dec;		// fraction of shifting, always positive sub-pixel from upper neighbor
	float shift_y_frac1 = 1.0f - shift_y_frac;
	if (shift_y_dec < 0) {
		// process top part that exceeds boundary
		for (int y=0, yy=shift_y_dec; yy<0; y++, yy++) {
			float *pSrc = (float *)((char *)iplTemp->imageData);
			float *pDst = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0; x<iplImage->width; x++) {
				pDst[x] = pSrc[x];
			}
		}
		// process central part
		for (int y=-shift_y_dec, yy=0; y<iplTemp->height; y++, yy++) {
			float *pSrc = (float *)((char *)iplTemp->imageData + yy * iplTemp->widthStep);
			float *pSrc1 = (float *)((char *)iplTemp->imageData + (yy+1) * iplTemp->widthStep);
			float *pDst = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0; x<iplImage->width; x++) {
				pDst[x] = pSrc[x] * shift_y_frac1 + pSrc1[x] * shift_y_frac;
			}
		}
	} else {
		// process central part
		for (int y=0, yy=shift_y_dec; yy<iplTemp->height-1; y++, yy++) {
			float *pSrc = (float *)((char *)iplTemp->imageData + yy * iplTemp->widthStep);
			float *pSrc1 = (float *)((char *)iplTemp->imageData + (yy+1) * iplTemp->widthStep);
			float *pDst = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0; x<iplImage->width; x++) {
				pDst[x] = pSrc[x] * shift_y_frac1 + pSrc1[x] * shift_y_frac;
			}
		}
		// process right part that exceeds boundary
		for (int y=iplTemp->height-shift_y_dec-1; y<iplImage->height; y++) {
			float *pSrc = (float *)((char *)iplTemp->imageData + (iplTemp->height-1)*iplTemp->widthStep);
			float *pDst = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0; x<iplImage->width; x++) {
				pDst[x] = pSrc[x];
			}
		}
	}

	releaseImage(&iplTemp);

	return true;
}

bool CImageUtility::shiftHalfPel_bicubic_32f(IplImage *iplImage, int horizontal, int vertical, bool clip)
// shift an image over sx in horizontal direction and sy in vertical using bicubic interpolation
// Luhong Liang, IC-ASD, ASTRI
// Memory leak check, June 27, 2013
{
	if (iplImage == NULL || iplImage->depth != SR_DEPTH_32F || iplImage->nChannels !=1 ) {
		showErrMsg("Invalid input image in CImageUtility::shiftHalfPel_bicubic_32f()!\n");
		return false;
	}

	IplImage *iplTemp = createImage(iplImage->width, iplImage->height, SR_DEPTH_32F, 1);
	if (iplTemp == NULL) {
		showErrMsg("Fail to allocate temp image in CImageUtility::shiftHalfPel_bicubic_32f()!\n");
		return false;
	}

	// interpolate in horizontal direction
	if (horizontal > 0) {
		// move to left
		for (int y=0; y<iplTemp->height; y++) {
			float *pSrc = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
			float *pDst = (float *)((char *)iplTemp->imageData + y * iplTemp->widthStep);
			// left most point
			pDst[0] = 0.5f * pSrc[0] + 0.5625f * pSrc[1] - 0.0625f * pSrc[2];
			int x;
			for (x=1 ; x<iplTemp->width-2; x++) {
				pDst[x] = 0.5625f * (pSrc[x] + pSrc[x+1]) - 0.0625f * (pSrc[x-1] + pSrc[x+2]);
			}
			pDst[x] = -0.0625f * pSrc[x-1] + 0.5625f * pSrc[x] + 0.5f * pSrc[x+1];
			x++;
			pDst[x] = -0.0625f * pSrc[x-1] + 1.0625f * pSrc[x];
		}		
	} else if (horizontal < 0) {
		// move to right
		for (int y=0; y<iplTemp->height; y++) {
			float *pSrc = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
			float *pDst = (float *)((char *)iplTemp->imageData + y * iplTemp->widthStep);
			// left most point
			pDst[0] = 1.0625f * pSrc[0] - 0.0625f * pSrc[1];
			pDst[1] = 0.5f * pSrc[0] + 0.5625f * pSrc[1] - 0.0625f * pSrc[2];
			int x;
			for (x=2 ; x<iplTemp->width-1; x++) {
				pDst[x] = 0.5625f * (pSrc[x-1] + pSrc[x]) - 0.0625f * (pSrc[x-2] + pSrc[x+1]);
			}
			pDst[x] = -0.0625f * pSrc[x-2] + 0.5625f * pSrc[x-1] + 0.5f * pSrc[x];
		}		
	}

	// interpolate in vertical direction
	if (vertical > 0) {
		// move to top
		float *pSrc0 = (float *)((char *)iplTemp->imageData);
		float *pSrc1 = (float *)((char *)iplTemp->imageData + iplTemp->widthStep);
		float *pSrc2 = (float *)((char *)iplTemp->imageData + 2 * iplTemp->widthStep);
		float *pSrc3;
		float *pDst = (float *)((char *)iplImage->imageData);
		for (int x=0 ; x<iplImage->width; x++) {
			pDst[x] = 0.5f * pSrc0[x] + 0.5625f * pSrc1[x] - 0.0625f * pSrc2[x];
		}
		int y;
		for (y=1; y<iplTemp->height-2; y++) {
			pSrc0 = (float *)((char *)iplTemp->imageData + (y-1) * iplTemp->widthStep);
			pSrc1 = (float *)((char *)iplTemp->imageData + y * iplTemp->widthStep);
			pSrc2 = (float *)((char *)iplTemp->imageData + (y+1) * iplTemp->widthStep);
			pSrc3 = (float *)((char *)iplTemp->imageData + (y+2) * iplTemp->widthStep);
			pDst = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0 ; x<iplImage->width; x++) {
				pDst[x] = 0.5625f * (pSrc1[x] + pSrc2[x]) - 0.0625f * (pSrc0[x] + pSrc3[x]);
			}
		}
		pSrc0 = (float *)((char *)iplTemp->imageData + (y-1) * iplTemp->widthStep);
		pSrc1 = (float *)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		pSrc2 = (float *)((char *)iplTemp->imageData + (y+1) * iplTemp->widthStep);
		pDst = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
		for (int x=0 ; x<iplImage->width; x++) {
			pDst[x] = 0.5f * pSrc2[x] + 0.5625f * pSrc1[x] - 0.0625f * pSrc0[x];
		}
		y++;
		pDst = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
		for (int x=0 ; x<iplImage->width; x++) {
			pDst[x] = -0.0625f * pSrc1[x] + 1.0625f * pSrc2[x];
		}		
	} else if (vertical < 0) {
		// move to bottom
		float *pSrc0 = (float *)((char *)iplTemp->imageData);
		float *pSrc1 = (float *)((char *)iplTemp->imageData + iplTemp->widthStep);
		float *pSrc2 = (float *)((char *)iplTemp->imageData + 2 * iplTemp->widthStep);
		float *pSrc3;
		float *pDst = (float *)((char *)iplImage->imageData);
		for (int x=0 ; x<iplImage->width; x++) {
			pDst[x] = 1.0625f * pSrc0[x] - 0.0625f * pSrc1[x];
		}
		pDst = (float *)((char *)iplImage->imageData + iplImage->widthStep);
		for (int x=0 ; x<iplImage->width; x++) {
			pDst[x] = 0.5f * pSrc0[x] + 0.5625f * pSrc1[x] - 0.0625f * pSrc2[x];
		}
		int y;
		for (y=2; y<iplTemp->height-1; y++) {
			pSrc0 = (float *)((char *)iplTemp->imageData + (y-2) * iplTemp->widthStep);
			pSrc1 = (float *)((char *)iplTemp->imageData + (y-1) * iplTemp->widthStep);
			pSrc2 = (float *)((char *)iplTemp->imageData + y * iplTemp->widthStep);
			pSrc3 = (float *)((char *)iplTemp->imageData + (y+1) * iplTemp->widthStep);
			pDst = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0 ; x<iplImage->width; x++) {
				pDst[x] = 0.5625f * (pSrc1[x] + pSrc2[x]) - 0.0625f * (pSrc0[x] + pSrc3[x]);
			}
		}
		pSrc0 = (float *)((char *)iplTemp->imageData + (y-2) * iplTemp->widthStep);
		pSrc1 = (float *)((char *)iplTemp->imageData + (y-1) * iplTemp->widthStep);
		pSrc2 = (float *)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		pDst = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
		for (int x=0 ; x<iplImage->width; x++) {
			pDst[x] = 0.5f * pSrc2[x] + 0.5625f * pSrc1[x] - 0.0625f * pSrc0[x];
		}
	}

	if (clip) {
		float *pDst = (float *)((char *)iplImage->imageData);
		for (int i=0; i<iplImage->width*iplImage->height; i++) {
			pDst[i] = CLIP_PIX(pDst[i], 255.0f, 0.0f);
		}
	}
	releaseImage(&iplTemp);

	return true;
}

bool CImageUtility::shiftHalfPel_bicubic_int(IplImage *iplImage, int horizontal, int vertical, int clip_low, int clip_high)
// Shift an image over sx in horizontal direction and sy in vertical using bicubic interpolation
// This function is a fixed-point version of function shiftHalfPel_bicubic_32f()
// Luhong Liang, IC-ASD, ASTRI
{
	if (iplImage == NULL || iplImage->depth != SR_DEPTH_32S || iplImage->nChannels !=1 ) {
		showErrMsg("Invalid input image in CImageUtility::shiftHalfPel_bicubic_int()!\n");
		return false;
	}

	IplImage *iplTemp = createImage(iplImage->width, iplImage->height, SR_DEPTH_32S, 1);
	if (iplTemp == NULL) {
		showErrMsg("Fail to allocate temp image in CImageUtility::shiftHalfPel_bicubic_int()!\n");
		return false;
	}

	// interpolate in horizontal direction
	if (horizontal > 0) {
		// move to left
		for (int y=0; y<iplTemp->height; y++) {
			int *pSrc = (int *)((char *)iplImage->imageData + y * iplImage->widthStep);
			int *pDst = (int *)((char *)iplTemp->imageData + y * iplTemp->widthStep);
			// left most point
			pDst[0] = (pSrc[0] >> 1) + ((9 * pSrc[1] - pSrc[2]) >> 4);		// (8, 9, -1) / 16
			int x;
			for (x=1 ; x<iplTemp->width-2; x++) {
				pDst[x] = (9 * (pSrc[x] + pSrc[x+1]) - (pSrc[x-1] + pSrc[x+2])) >> 4; // 9/16, 1/16
			}
			pDst[x] = ((-pSrc[x-1] + 9 * pSrc[x]) >> 4) + (pSrc[x+1] >> 1);
			x++;
			pDst[x] = (-pSrc[x-1] + 17 * pSrc[x]) >> 4;
		}		
	} else if (horizontal < 0) {
		// move to right
		for (int y=0; y<iplTemp->height; y++) {
			int *pSrc = (int *)((char *)iplImage->imageData + y * iplImage->widthStep);
			int *pDst = (int *)((char *)iplTemp->imageData + y * iplTemp->widthStep);
			// left most point
			pDst[0] = (17 * pSrc[0] - pSrc[1]) >> 4;
			pDst[1] = (pSrc[0] >> 1) + ((9 * pSrc[1] - pSrc[2]) >> 4);
			int x;
			for (x=2 ; x<iplTemp->width-1; x++) {
				pDst[x] = (9 * (pSrc[x-1] + pSrc[x]) - (pSrc[x-2] + pSrc[x+1])) >> 4;
			}
			pDst[x] = ((-pSrc[x-2] + 9 * pSrc[x-1]) >> 4) + (pSrc[x] >> 1);
		}		
	}
	//saveImage("_shift_interm.bmp", iplTemp, 0, 1.0f, 12);

	// interpolate in vertical direction
	if (vertical > 0) {
		// move to top
		int *pSrc0 = (int *)((char *)iplTemp->imageData);
		int *pSrc1 = (int *)((char *)iplTemp->imageData + iplTemp->widthStep);
		int *pSrc2 = (int *)((char *)iplTemp->imageData + 2 * iplTemp->widthStep);
		int *pSrc3;
		int *pDst = (int *)((char *)iplImage->imageData);
		for (int x=0 ; x<iplImage->width; x++) {
			pDst[x] = (pSrc0[x] >> 1) + ((9 * pSrc1[x] - pSrc2[x]) >> 4);
		}
		int y;
		for (y=1; y<iplTemp->height-2; y++) {
			pSrc0 = (int *)((char *)iplTemp->imageData + (y-1) * iplTemp->widthStep);
			pSrc1 = (int *)((char *)iplTemp->imageData + y * iplTemp->widthStep);
			pSrc2 = (int *)((char *)iplTemp->imageData + (y+1) * iplTemp->widthStep);
			pSrc3 = (int *)((char *)iplTemp->imageData + (y+2) * iplTemp->widthStep);
			pDst = (int *)((char *)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0 ; x<iplImage->width; x++) {
				pDst[x] = (9 * (pSrc1[x] + pSrc2[x]) - (pSrc0[x] + pSrc3[x])) >> 4;
			}
		}
		pSrc0 = (int *)((char *)iplTemp->imageData + (y-1) * iplTemp->widthStep);
		pSrc1 = (int *)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		pSrc2 = (int *)((char *)iplTemp->imageData + (y+1) * iplTemp->widthStep);
		pDst = (int *)((char *)iplImage->imageData + y * iplImage->widthStep);
		for (int x=0 ; x<iplImage->width; x++) {
			pDst[x] = (pSrc2[x] >> 1) + ((9 * pSrc1[x] - pSrc0[x]) >> 4);
		}
		y++;
		pDst = (int *)((char *)iplImage->imageData + y * iplImage->widthStep);
		for (int x=0 ; x<iplImage->width; x++) {
			pDst[x] = (-pSrc1[x] + 17 * pSrc2[x]) >> 4;
		}		
	} else if (vertical < 0) {
		// move to bottom
		int *pSrc0 = (int *)((char *)iplTemp->imageData);
		int *pSrc1 = (int *)((char *)iplTemp->imageData + iplTemp->widthStep);
		int *pSrc2 = (int *)((char *)iplTemp->imageData + 2 * iplTemp->widthStep);
		int *pSrc3;
		int *pDst = (int *)((char *)iplImage->imageData);
		for (int x=0 ; x<iplImage->width; x++) {
			pDst[x] = (17 * pSrc0[x] - pSrc1[x]) >> 4;
		}
		pDst = (int *)((char *)iplImage->imageData + iplImage->widthStep);
		for (int x=0 ; x<iplImage->width; x++) {
			pDst[x] = (pSrc0[x] >> 1) + ((9 * pSrc1[x] - pSrc2[x]) >> 4);
		}
		int y;
		for (y=2; y<iplTemp->height-1; y++) {
			pSrc0 = (int *)((char *)iplTemp->imageData + (y-2) * iplTemp->widthStep);
			pSrc1 = (int *)((char *)iplTemp->imageData + (y-1) * iplTemp->widthStep);
			pSrc2 = (int *)((char *)iplTemp->imageData + y * iplTemp->widthStep);
			pSrc3 = (int *)((char *)iplTemp->imageData + (y+1) * iplTemp->widthStep);
			pDst = (int *)((char *)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0 ; x<iplImage->width; x++) {
				pDst[x] = (9 * (pSrc1[x] + pSrc2[x]) - (pSrc0[x] + pSrc3[x])) >> 4;
			}
		}
		pSrc0 = (int *)((char *)iplTemp->imageData + (y-2) * iplTemp->widthStep);
		pSrc1 = (int *)((char *)iplTemp->imageData + (y-1) * iplTemp->widthStep);
		pSrc2 = (int *)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		pDst = (int *)((char *)iplImage->imageData + y * iplImage->widthStep);
		for (int x=0 ; x<iplImage->width; x++) {
			pDst[x] = (pSrc2[x] >> 1) + ((9 * pSrc1[x] - pSrc0[x]) >> 4);
		}
	}

	releaseImage(&iplTemp);

	// clipping (can merge to the loop above)
	for (int y=0; y<iplImage->height; y++) {
		int *pDst = (int *)((char *)iplImage->imageData + y * iplImage->widthStep);
		for (int x=0; x<iplImage->width; x++) {
			int pix = pDst[x];
			if (pix < clip_low)
				pDst[x] = clip_low;
			else if (pix > clip_high)
				pDst[x] = clip_high;
			else 
				pDst[x] = pix;
		}
	}

	return true;
}

bool CImageUtility::shiftHalfPel_bicubic_int_s1(IplImage *iplImage, int clip_low, int clip_high)
// Shift an image over sx in horizontal direction and sy in vertical using bicubic interpolation
// This function is a improved fixed-point version of function shiftHalfPel_bicubic_int()
// The filter is (-3, 19, 19, -3) / 32
// Luhong Liang, IC-ASD, ASTRI
// Feb. 5, 2013
{
	if (iplImage == NULL || iplImage->depth != SR_DEPTH_32S || iplImage->nChannels !=1 ) {
		showErrMsg("Invalid input image in CImageUtility::shiftHalfPel_bicubic_int_s1()!\n");
		return false;
	}

	IplImage *iplTemp = createImage(iplImage->width, iplImage->height, SR_DEPTH_32S, 1);
	if (iplTemp == NULL) {
		showErrMsg("Fail to allocate temp image in CImageUtility::shiftHalfPel_bicubic_int_s1()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcImage = padding(iplImage, 1, 2, 1, 2);
	if (iplSrcImage == NULL) return false;
	
	// line buffer
	int *pLineBuf = new int[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::shiftHalfPel_bicubic_int_s1()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	for (int y=0; y<iplImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		int *pSrc2 = (int *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		int *pSrc3 = (int *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			pLineBuf[x] = -3 * pSrc0[x] + 19 * pSrc1[x] + 19 * pSrc2[x] - 3 * pSrc3[x];		// 6-bit + bit depth
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplImage->imageData + y * iplImage->widthStep);
		for (int x=0; x<iplImage->width; x++) {
			int pix = ( -3 * pLineBuf[x] + 19 * pLineBuf[x+1] + 19 * pLineBuf[x+2] -3 * pLineBuf[x+3]) >> 10;		// 12-bit + bit depth
			// clipping (to avoid overflow in in SiSS module)
			if (pix < clip_low)
				pDst[x] = clip_low;
			else if (pix > clip_high)
				pDst[x] = clip_high;
			else 
				pDst[x] = pix;
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::shiftHalfPel_bicubic_8U_10bit_s5(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Shift an image over sx in horizontal direction and sy in vertical using bicubic interpolation
// This function is a improved fixed-point version of function shiftHalfPel_bicubic_int()
// The filter is (-3, 19, 19, -3) / 32
// Different from shiftHalfPel_bicubic_int_s1(), this function suppose the input image has been padded
// Luhong Liang, IC-ASD, ASTRI
// May 15, 2013
{
	if (iplSrcImage == NULL || iplSrcImage->depth != SR_DEPTH_8U || iplSrcImage->nChannels !=1 ||
		iplDstImage == NULL || iplDstImage->depth != SR_DEPTH_32S || iplDstImage->nChannels !=1 ) {
		showErrMsg("Invalid input or output image in CImageUtility::shiftHalfPel_bicubic_8U_10bit_s5()!\n");
		return false;
	}

	if (iplSrcImage->width != iplDstImage->width+3 || iplSrcImage->height != iplDstImage->height+3) {
		showErrMsg("Sizes of the input and output image do not match in CImageUtility::shiftHalfPel_bicubic_8U_10bit_s5()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::shiftHalfPel_bicubic_8U_10bit_s5()!\n");
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		unsigned char *pSrc0 = (unsigned char *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		unsigned char *pSrc1 = (unsigned char *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		unsigned char *pSrc2 = (unsigned char *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		unsigned char *pSrc3 = (unsigned char *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			pLineBuf[x] = -3 * pSrc0[x] + 19 * pSrc1[x] + 19 * pSrc2[x] - 3 * pSrc3[x];		// 6-bit + bit depth
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			int pix = ( -3 * pLineBuf[x] + 19 * pLineBuf[x+1] + 19 * pLineBuf[x+2] -3 * pLineBuf[x+3]) >> 8;		// preserve 10-bit
			// clipping (to avoid overflow in in SiSS module)
			if (pix < clip_low)
				pDst[x] = clip_low;
			else if (pix > clip_high)
				pDst[x] = clip_high;
			else 
				pDst[x] = pix;
		}
	}

	delete [] pLineBuf;

	return true;
}

bool CImageUtility::resize(IplImage *iplSrcImage, IplImage *iplDstImage, int inter_type)
// resize an image using OpenCV or in-house functions
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||  iplSrcImage->depth != iplDstImage->depth) {
		showErrMsg("Invalid input/output image or mismatched image data depth in CImageUtility::resize()!\n");
		return false;
	}

	// -------------------------------------------------
	// Try in-house functions first
	// -------------------------------------------------

	if (iplSrcImage->nChannels !=1 || iplDstImage->nChannels != 1) {
		showErrMsg("Only support 1-channel image in CImageUtility::resize()!\n");
		return false;
	}

	// x1
	if (iplSrcImage->width == iplDstImage->width && iplSrcImage->height == iplDstImage->height) {
		return copy(iplSrcImage, iplDstImage);
	}

	// 32F
	if (iplSrcImage->depth == SR_DEPTH_32F) {
        // Lanczos-2
		if (inter_type == SR_INTER_LANCZOS2) {
            return resizeLanczos_32f(iplSrcImage, iplDstImage, 2);
        }

        // Lanczos-3
		if (inter_type == SR_INTER_LANCZOS3) {
            return resizeLanczos_32f(iplSrcImage, iplDstImage, 3);
        }

		// bicubic
		if (inter_type == SR_INTER_CUBIC) {
			// 2
			if (iplSrcImage->width*2 == iplDstImage->width && iplSrcImage->height*2 == iplDstImage->height) 
				return resize_1to2_bicubic_32f(iplSrcImage, iplDstImage);
		
			// 1.5
			if (iplSrcImage->width*3 == iplDstImage->width*2 && iplSrcImage->height*3 == iplDstImage->height*2) 
				return resize_2to3_bicubic_32f(iplSrcImage, iplDstImage);

			// 4/3
			if (iplSrcImage->width*4 == iplDstImage->width*3 && iplSrcImage->height*4 == iplDstImage->height*3) 
				return resize_3to4_bicubic_32f(iplSrcImage, iplDstImage);
        }

        // nearest neighbour
		if (inter_type == SR_INTER_NN) {
            return resize_nn_32f(iplSrcImage, iplDstImage);	
        }

		// bilinear
		if (inter_type == SR_INTER_LINEAR) {
			// 0.5
			if (iplSrcImage->width == iplDstImage->width*2 && iplSrcImage->height == iplDstImage->height*2) 
				return resize_2to1_bilinear_32f(iplSrcImage, iplDstImage);

			// 2/3
			if (iplSrcImage->width*2 == iplDstImage->width*3 && iplSrcImage->height*2 == iplDstImage->height*3) 
				return resize_3to2_bilinear_32f(iplSrcImage, iplDstImage);		
			
			// 3/4
			if (iplSrcImage->width*3 == iplDstImage->width*4 && iplSrcImage->height*3 == iplDstImage->height*4) 
				return resize_4to3_bilinear_32f(iplSrcImage, iplDstImage);		

			// 1.5
			if (iplSrcImage->width*3 == iplDstImage->width*2 && iplSrcImage->height*3 == iplDstImage->height*2) 
				return resize_2to3_bilinear_32f(iplSrcImage, iplDstImage);

			// 2
			if (iplSrcImage->width*2 == iplDstImage->width && iplSrcImage->height*2 == iplDstImage->height) 
				return resize_1to2_bilinear_32f(iplSrcImage, iplDstImage);		
		}
    }

	// 16U
	if (iplSrcImage->depth == SR_DEPTH_16U) {
		// bilinear
		if (inter_type == SR_INTER_LINEAR) {
			// x2
			if (iplSrcImage->width*2 == iplDstImage->width && iplSrcImage->height*2 == iplDstImage->height) 
				return resize_1to2_bilinear_16U(iplSrcImage, iplDstImage);
            
            // x0.5
            if (iplSrcImage->width == iplDstImage->width*2 && iplSrcImage->height == iplDstImage->height*2)
                return resize_2to1_bilinear_16U(iplSrcImage, iplDstImage);
        }

        // nearest neighbour
		if (inter_type == SR_INTER_NN) {
            return resize_nn_16U(iplSrcImage, iplDstImage);	
        }

	} 

	// 8U
	if (iplSrcImage->depth == SR_DEPTH_8U) {
		// bicubic
		if (inter_type == SR_INTER_CUBIC) {
			// x2
			if (iplSrcImage->width*2 == iplDstImage->width && iplSrcImage->height*2 == iplDstImage->height) 
				return resize_1to2_bicubic_8U(iplSrcImage, iplDstImage);
		
			// x0.5
			if (iplSrcImage->width == iplDstImage->width*2 && iplSrcImage->height == iplDstImage->height*2) 
				return resize_2to1_bicubic_8U(iplSrcImage, iplDstImage);
		}

		// bilinear
		if (inter_type == SR_INTER_LINEAR) {
			// x2
			if (iplSrcImage->width*2 == iplDstImage->width && iplSrcImage->height*2 == iplDstImage->height) 
				return resize_1to2_bilinear_8U(iplSrcImage, iplDstImage);

			// x0.5
			if (iplSrcImage->width == iplDstImage->width*2 && iplSrcImage->height == iplDstImage->height*2) 
				return resize_2to1_bilinear_8U(iplSrcImage, iplDstImage);
		}

        // nearest neighbour
		if (inter_type == SR_INTER_NN) {
            return resize_nn_8U(iplSrcImage, iplDstImage);	
        }

	} 

	// -------------------------------------------------
	// Then, try OpenCV functions
	// -------------------------------------------------
#ifdef __OPENCV_OLD_CV_H__
#ifdef __SR_USE_SIMD
    if (isOpenCVAligned64Bytes(iplSrcImage) && isOpenCVAligned64Bytes(iplDstImage) &&
        (inter_type == SR_INTER_LINEAR || inter_type == SR_INTER_NN || inter_type == SR_INTER_CUBIC ||
        inter_type == SR_INTER_AREA || inter_type == SR_INTER_LANCZOS4)) {
        cvResize(iplSrcImage, iplDstImage, inter_type);
        saveImage("_OpenCVResize.bmp", iplDstImage);
        return true;
    }
#else   // __SR_USE_SIMD
    if (inter_type == SR_INTER_LINEAR || inter_type == SR_INTER_NN || inter_type == SR_INTER_CUBIC ||
        inter_type == SR_INTER_AREA || inter_type == SR_INTER_LANCZOS4) {
        cvResize(iplSrcImage, iplDstImage, inter_type);
        return true;
    }
#endif  // __SR_USE_SIMD
#endif		// #ifdef __OPENCV_OLD_CV_H__

    showErrMsg("Warning: Unsupported interpolation method or maginifcation factor in CImageUtility::resize()!\nUse Lanczos-2 interpolation instead.\n");
    resizeLanczos_32f(iplSrcImage, iplDstImage, 2);

    return false;
}

bool CImageUtility::smooth(IplImage *iplSrcImage, IplImage *iplDstImage, int smoothtype, 
                           int size1, int size2, double sigma1, double sigma2)
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||  iplSrcImage->depth != iplDstImage->depth) {
		showErrMsg("Invalid input/output image or mismatched image data depth in CImageUtility::resize()!\n");
		return false;
	}
    if (smoothtype < 0 || size1 < 1 || size2 < 1 || sigma1 < 0.0 || sigma2 < 0.0) {
        showErrMsg("Invalid input parameter(s) in CImageUtility::resize()!\n");
		return false;
	}

	// -------------------------------------------------
	// OpenCV implementations
	// -------------------------------------------------
#ifdef __OPENCV_OLD_CV_H__
	cvSmooth(iplSrcImage, iplDstImage, smoothtype, size1, size2, sigma1, sigma2);
	return true;
#else		// #ifdef __OPENCV_OLD_CV_H__

	// -------------------------------------------------
	// in-house functions
	// -------------------------------------------------
	showErrMsg("OpenCV is necessary in CImageUtility::smooth()!\n");
	return false;
#endif		// #ifdef __OPENCV_OLD_CV_H__
}

bool CImageUtility::resize_4to3_bilinear_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 3/4 using bilinear interpolation
// The sample location follows the resize() in OpenCV
// This is a fixed-point implementation
//     0             1             2               3             4         <---- source image grid
//       1/6               3/2                17/6			               <---- destination image grid mapped to source image
//    (5/6,1/6)         (1/2,1/2)           (1/6,5/6)                      <---- filters
//
// Luhong Liang, IC-ASD, ASTRI
// May. 31, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::resize_4to3_bilinear_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*3 != iplDstImage->width*4 || iplSrcImage->height*3 != iplDstImage->height*4) {
		showErrMsg("Only support 4:3 downsampling in CImageUtility::resize_4to3_bilinear_32f()!\n");
		return false;
	}
	
	// downsample bilinearly (3x3 block, step = 3, all in destination image)
	float pBlock[4*4];
	float pBlock1[3*4];
	float pBlock2[3*3];
	for (int y=0, top=0; y<iplDstImage->height; y+=3, top+=4) {
		for (int x=0, left=0; x<iplDstImage->width; x+=3, left+=4) {
			// load a 4x4 block in source image
			int i = 0;
			for (int yy=top; yy<top+4; yy++) {
				float *pBuf = (float *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);
				for (int xx=left; xx<left+4; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<4; v++) {
				float *pLineSrc = pBlock + v * 4;
				float *pLineDst = pBlock1 + v * 3;
				pLineDst[0] = (pLineSrc[0]*5.0f + pLineSrc[1]) * 0.166666667f;		// ( 5/6, 1/6 )
				pLineDst[1] = (pLineSrc[1] + pLineSrc[2]) * 0.5f;					// ( 1/2, 1/2 )
				pLineDst[2] = (pLineSrc[2] + pLineSrc[3]*5.0f) * 0.166666667f;		// ( 1/6, 5/6 )
			}
			// interpolation in Y direction
			for (int u=0; u<3; u++) {
				float *pLineSrc = pBlock1 + u;
				float *pLineDst = pBlock2 + u;
				pLineDst[0] = (pLineSrc[0]*5.0f + pLineSrc[3]) * 0.166666667f;		// ( 5/6, 1/6 )
				pLineDst[3] = (pLineSrc[3] + pLineSrc[6]) * 0.5f;					// ( 1/2, 1/2 )
				pLineDst[6] = (pLineSrc[6] + pLineSrc[9]*5.0f) * 0.166666667f;		// ( 1/6, 5/6 )
			}
			// write a 3x3 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+3; yy++) {
				float *pBuf = (float *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+3; xx++) {
					pBuf[xx] = pBlock2[i];
					i++;
				}
			}
		}
	}
	
	return true;
}

bool CImageUtility::resize_4to3_bilinear_odd_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 3/4 using bilinear interpolation. Specially designed for EGI followed by a bilinear interpolation for 
// 2:3 resize with the OVERALL sample location follows the resize() in OpenCV)!
//     0             1             2               3         4   <---- source image grid
//             2/3                2                  10/3      <---- destination image grid mapped to source image
//        (1/3, 2/3)           (1)              (2/3, 1/3)
//
// Luhong Liang, IC-ASD, ASTRI
// March 24, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::resize_4to3_bilinear_odd_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*3 != iplDstImage->width*4 || iplSrcImage->height*3 != iplDstImage->height*4) {
		showErrMsg("Only support 4:3 downsampling in CImageUtility::resize_4to3_bilinear_odd_32f()!\n");
		return false;
	}
	
	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 0, 1, 0, 1);
	if (iplSrcPad == NULL) return false;

	// downsample bilinearly (3x3 block, step = 3, all in destination image)
	float pBlock[5*5];
	float pBlock1[3*5];
	float pBlock2[3*3];
	for (int y=0, top=0; y<iplDstImage->height; y+=3, top+=4) {
		for (int x=0, left=0; x<iplDstImage->width; x+=3, left+=4) {
			// load a 5x5 block in source image
			int i = 0;
			for (int yy=top; yy<top+5; yy++) {
				float *pBuf = (float *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+5; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<5; v++) {
				float *pLineSrc = pBlock + v * 5;
				float *pLineDst = pBlock1 + v * 3;
				pLineDst[0] = pLineSrc[0]*0.333333f + pLineSrc[1]*0.666667f;
				pLineDst[1] = pLineSrc[2];
				pLineDst[2] = pLineSrc[3]*0.666667f + pLineSrc[4]*0.333333f;
			}
			// interpolation in Y direction
			for (int u=0; u<3; u++) {
				float *pLineSrc = pBlock1 + u;
				float *pLineDst = pBlock2 + u;
				pLineDst[0] = pLineSrc[0]*0.333333f + pLineSrc[3]*0.666667f;
				pLineDst[3] = pLineSrc[6];
				pLineDst[6] = pLineSrc[9]*0.666667f + pLineSrc[12]*0.333333f;
			}
			// write a 3x3 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+3; yy++) {
				float *pBuf = (float *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+3; xx++) {
					pBuf[xx] = pBlock2[i];
					i++;
				}
			}
		}
	}

    safeReleaseImage(&iplSrcPad);
	
	return true;
}

bool CImageUtility::resize_4to3_bilinear_int(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Resize the image to 3/4 using bilinear interpolation
// The sample location follows the resize() in OpenCV
// This is a fixed-point implementation
//     0             1             2               3             4         <---- source image grid
//       1/6               3/2                17/6			               <---- destination image grid mapped to source image
//    (5/6,1/6)         (1/2,1/2)           (1/6,5/6)                      <---- filters
//
// Luhong Liang, IC-ASD, ASTRI
// Jan. 18, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_4to3_bilinear_int()!\n");
		return false;
	}
	if (iplSrcImage->width*3 != iplDstImage->width*4 || iplSrcImage->height*3 != iplDstImage->height*4) {
		showErrMsg("Only support 4:3 downsampling in CImageUtility::resize_4to3_bilinear_int()!\n");
		return false;
	}
	
	// downsample bilinearly (3x3 block, step = 3, all in destination image)
	int pBlock[4*4];
	int pBlock1[3*4];
	int pBlock2[3*3];
	for (int y=0, top=0; y<iplDstImage->height; y+=3, top+=4) {
		for (int x=0, left=0; x<iplDstImage->width; x+=3, left+=4) {
			// load a 4x4 block in source image
			int i = 0;
			for (int yy=top; yy<top+4; yy++) {
				int *pBuf = (int *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);
				for (int xx=left; xx<left+4; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<4; v++) {
				int *pLineSrc = pBlock + v * 4;
				int *pLineDst = pBlock1 + v * 3;
				pLineDst[0] = (pLineSrc[0]*5 + pLineSrc[1]) / 6;		// ( 5/6, 1/6 )
				pLineDst[1] = (pLineSrc[1] + pLineSrc[2]) / 2;		    // ( 1/2, 1/2 )
				pLineDst[2] = (pLineSrc[2] + pLineSrc[3]*5) / 6;		// ( 1/6, 5/6 )
			}
			// interpolation in Y direction
			for (int u=0; u<3; u++) {
				int *pLineSrc = pBlock1 + u;
				int *pLineDst = pBlock2 + u;
				pLineDst[0] = (pLineSrc[0]*5 + pLineSrc[3]) / 6;		// ( 5/6, 1/6 )
				pLineDst[3] = (pLineSrc[3] + pLineSrc[6]) / 2;		    // ( 1/2, 1/2 )
				pLineDst[6] = (pLineSrc[6] + pLineSrc[9]*5) / 6;		// ( 1/6, 5/6 )
			}
			// write a 3x3 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+3; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+3; xx++) {
					int val = pBlock2[i];
					if (val < clip_low) {
						pBuf[xx] = clip_low;
					} else if (val > clip_high) {
						pBuf[xx] = clip_high;
					} else {
						pBuf[xx] = val;
					}
					i++;
				}
			}
		}
	}
	
	return true;
}

bool CImageUtility::resize_4to3_bilinear_int_s1(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Resize the image to 3/4 using bilinear interpolation (simified verion 1.0)
// Different from resize_4to3_bilinear_int(), the sample location is adjusted to get a more simple interpolation parameters
// This is a fixed-point implementation
//     0             1             2               3             4         <---- source image grid
//       3/16              3/2               15/8			               <---- destination image grid mapped to source image
//  (13/16,3/16)        (1/2,1/2)          (1/8,7/8)	                   <---- filters
//
// Luhong Liang, IC-ASD, ASTRI
// Jan. 21, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_4to3_bilinear_int_s1()!\n");
		return false;
	}
	if (iplSrcImage->width*3 != iplDstImage->width*4 || iplSrcImage->height*3 != iplDstImage->height*4) {
		showErrMsg("Only support 4:3 downsampling in CImageUtility::resize_4to3_bilinear_int_s1()!\n");
		return false;
	}
	
	// downsample bilinearly (3x3 block, step = 3, all in destination image)
	int pBlock[4*4];
	int pBlock1[3*4];
	int pBlock2[3*3];
	for (int y=0, top=0; y<iplDstImage->height; y+=3, top+=4) {
		for (int x=0, left=0; x<iplDstImage->width; x+=3, left+=4) {
			// load a 4x4 block in source image
			int i = 0;
			for (int yy=top; yy<top+4; yy++) {
				int *pBuf = (int *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);
				for (int xx=left; xx<left+4; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<4; v++) {
				int *pLineSrc = pBlock + v * 4;
				int *pLineDst = pBlock1 + v * 3;
				pLineDst[0] = (pLineSrc[0]*13 + pLineSrc[1]*3) >> 4;	// ( 13/16, 3/16 )
				pLineDst[1] = (pLineSrc[1] + pLineSrc[2]) >> 1;		    // ( 1/2, 1/2 )
				pLineDst[2] = (pLineSrc[2] + pLineSrc[3]*7) >> 3;		// ( 1/8, 7/8 )
			}
			// interpolation in Y direction
			for (int u=0; u<3; u++) {
				int *pLineSrc = pBlock1 + u;
				int *pLineDst = pBlock2 + u;
				pLineDst[0] = (pLineSrc[0]*13 + pLineSrc[3]*3) >> 4;	// ( 13/16, 3/16 )
				pLineDst[3] = (pLineSrc[3] + pLineSrc[6]) >> 1;		    // ( 1/2, 1/2 )
				pLineDst[6] = (pLineSrc[6] + pLineSrc[9]*7) >> 3;		// ( 1/8, 7/8 )
			}
			// write a 3x3 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+3; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+3; xx++) {
					int val = pBlock2[i];
					if (val < clip_low) {
						pBuf[xx] = clip_low;
					} else if (val > clip_high) {
						pBuf[xx] = clip_high;
					} else {
						pBuf[xx] = val;
					}
					i++;
				}
			}
		}
	}
	
	return true;
}

bool CImageUtility::resize_3to4_bilinear_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 4/3 using bicubic interpolation
// The sample location follows the resize() in OpenCV
//                 Filter                           Index  
//     0.1250000    0.8750000           0       1
//     0.3750000    0.6250000           1       2
//     0.6250000    0.3750000           2       3
//     0.8750000    0.1250000           3       4
// Luhong Liang, IC-ASD, ASTRI
// Aug, 2014
{
    return false;       // not verified code!

	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::resize_3to4_bicubic_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*4 != iplDstImage->width*3 || iplSrcImage->height*4 != iplDstImage->height*3) {
		showErrMsg("Only support 3:4 upsampling in CImageUtility::resize_3to4_bicubic_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 1, 1, 1);
    float *pLine0 = new float[iplSrcPad->width]; 
    float *pLine1 = new float[iplSrcPad->width];
    float *pLine2 = new float[iplSrcPad->width];
    float *pLine3 = new float[iplSrcPad->width];
	if (iplSrcPad == NULL || pLine0 == NULL || pLine1 == NULL || pLine2 == NULL || pLine3 == NULL)  {
        safeReleaseImage(&iplSrcPad);
        if (pLine0 != NULL) delete [] pLine0;
        if (pLine1 != NULL) delete [] pLine1;
        if (pLine2 != NULL) delete [] pLine2;
        if (pLine3 != NULL) delete [] pLine3;
        return false;
    }
	
	// upscaling by bicubic (4x4 block, step = 4, all in destination image)
	for (int y=0, top=0; y<iplDstImage->height; y+=4, top+=3) {
        float *pSrc0 = (float *)(iplSrcPad->imageData + y * iplSrcPad->widthStep);
        float *pSrc1 = (float *)(iplSrcPad->imageData + (y+1) * iplSrcPad->widthStep);
        float *pSrc2 = (float *)(iplSrcPad->imageData + (y+2) * iplSrcPad->widthStep);
        float *pSrc3 = (float *)(iplSrcPad->imageData + (y+3) * iplSrcPad->widthStep);
        float *pSrc4 = (float *)(iplSrcPad->imageData + (y+4) * iplSrcPad->widthStep);
        float *pDst0 = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pDst1 = (float *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
        float *pDst2 = (float *)(iplDstImage->imageData + (y+2) * iplDstImage->widthStep);
        float *pDst3 = (float *)(iplDstImage->imageData + (y+3) * iplDstImage->widthStep);
        // interpolation in Y
		for (int x=0; x<iplDstImage->width; x++) {
            pLine0[x] = 0.125f * pSrc0[x] + 0.875f * pSrc1[x];      //     0.1250000    0.8750000           0       1
            pLine1[x] = 0.375f * pSrc1[x] + 0.625f * pSrc2[x];      //     0.3750000    0.6250000           1       2
            pLine2[x] = 0.625f * pSrc2[x] + 0.375f * pSrc3[x];      //     0.6250000    0.3750000           2       3
            pLine3[x] = 0.875f * pSrc3[x] + 0.125f * pSrc4[x];      //     0.8750000    0.1250000           3       4
        }
        // interpolation in X
        for (int x=0; x<iplDstImage->width; x+=4) {
            pDst0[x] = 0.125f * pLine0[x] + 0.875f * pLine0[x+1];
            pDst0[x+1] = 0.375f * pLine0[x+1] + 0.625f * pLine0[x+2];
            pDst0[x+2] = 0.625f * pLine0[x+2] + 0.375f * pLine0[x+3];
            pDst0[x+3] = 0.875f * pLine0[x+3] + 0.125f * pLine0[x+4];
            pDst1[x] = 0.125f * pLine1[x] + 0.875f * pLine1[x+1];
            pDst1[x+1] = 0.375f * pLine1[x+1] + 0.625f * pLine1[x+2];
            pDst1[x+2] = 0.625f * pLine1[x+2] + 0.375f * pLine1[x+3];
            pDst1[x+3] = 0.875f * pLine1[x+3] + 0.125f * pLine1[x+4];
            pDst2[x] = 0.125f * pLine2[x] + 0.875f * pLine2[x+1];
            pDst2[x+1] = 0.375f * pLine2[x+1] + 0.625f * pLine2[x+2];
            pDst2[x+2] = 0.625f * pLine2[x+2] + 0.375f * pLine2[x+3];
            pDst2[x+3] = 0.875f * pLine2[x+3] + 0.125f * pLine2[x+4];
            pDst3[x] = 0.125f * pLine3[x] + 0.875f * pLine3[x+1];
            pDst3[x+1] = 0.375f * pLine3[x+1] + 0.625f * pLine3[x+2];
            pDst3[x+2] = 0.625f * pLine3[x+2] + 0.375f * pLine3[x+3];
            pDst3[x+3] = 0.875f * pLine3[x+3] + 0.125f * pLine3[x+4];
		}
	}

	safeReleaseImage(&iplSrcPad);
    if (pLine0 != NULL) delete [] pLine0;
    if (pLine1 != NULL) delete [] pLine1;
    if (pLine2 != NULL) delete [] pLine2;
    if (pLine3 != NULL) delete [] pLine3;

	return true;
}

bool CImageUtility::resize_3to4_bicubic_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 4/3 using bicubic interpolation
// The sample location follows the resize() in OpenCV
//                 Filter                                   Index  
// -0.0102539	0.1147461	0.9672852	-0.0717773		-2	-1	0	1
// -0.0659180	0.4262695	0.7495117	-0.1098633		-1	0	1	2
// -0.1098633	0.7495117	0.4262695	-0.0659180		0	1	2	3
// -0.0717773	0.9672852	0.1147461	-0.0102539		1	2	3	4
//
// Luhong Liang, IC-ASD, ASTRI
// May. 30, 2013
// Memory leak check, June 27, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::resize_3to4_bicubic_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*4 != iplDstImage->width*3 || iplSrcImage->height*4 != iplDstImage->height*3) {
		showErrMsg("Only support 3:4 upsampling in CImageUtility::resize_3to4_bicubic_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (4x4 block, step = 4, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	float pBlock[7*7];		// 7x7 block in source image
	float pBlock1[4*7];		// after interpolation in X direction
	float pBlock2[4*4];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=4, top+=3) {
		for (int x=0, left=0; x<iplDstImage->width; x+=4, left+=3) {
			// load a 7x7 block in source image (3x3 + padding)
			int i = 0;
			for (int yy=top; yy<top+7; yy++) {
				float *pBuf = (float *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+7; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<7; v++) {
				float *pSrc = pBlock + v * 7;
				float *pDst = pBlock1 + v * 4;
				pDst[0] = -0.0102539f*pSrc[0] + 0.1147461f*pSrc[1] + 0.9672852f*pSrc[2] - 0.0717773f*pSrc[3];	// -0.0102539	0.1147461	0.9672852	-0.0717773		-2	-1	0	1
				pDst[1] = -0.0659180f*pSrc[1] + 0.4262695f*pSrc[2] + 0.7495117f*pSrc[3] - 0.1098633f*pSrc[4];	// -0.0659180	0.4262695	0.7495117	-0.1098633		-1	0	1	2
				pDst[2] = -0.1098633f*pSrc[2] + 0.7495117f*pSrc[3] + 0.4262695f*pSrc[4] - 0.0659180f*pSrc[5];	// -0.1098633	0.7495117	0.4262695	-0.0659180		0	1	2	3
				pDst[3] = -0.0717773f*pSrc[3] + 0.9672852f*pSrc[4] + 0.1147461f*pSrc[5] - 0.0102539f*pSrc[6];	// -0.0717773	0.9672852	0.1147461	-0.0102539		1	2	3	4
			}
			// interpolation in Y direction
			for (int u=0; u<4; u++) {
				float *pSrc = pBlock1 + u;
				float *pDst = pBlock2 + u;
				pDst[0] = -0.0102539f*pSrc[0] + 0.1147461f*pSrc[4] + 0.9672852f*pSrc[8] - 0.0717773f*pSrc[12];		// -0.0102539	0.1147461	0.9672852	-0.0717773		-2	-1	0	1
				pDst[4] = -0.0659180f*pSrc[4] + 0.4262695f*pSrc[8] + 0.7495117f*pSrc[12] - 0.1098633f*pSrc[16];		// -0.0659180	0.4262695	0.7495117	-0.1098633		-1	0	1	2
				pDst[8] = -0.1098633f*pSrc[8] + 0.7495117f*pSrc[12] + 0.4262695f*pSrc[16] - 0.0659180f*pSrc[20];	// -0.1098633	0.7495117	0.4262695	-0.0659180		0	1	2	3
				pDst[12] = -0.0717773f*pSrc[12] + 0.9672852f*pSrc[16] + 0.1147461f*pSrc[20] - 0.0102539f*pSrc[24];	// -0.0717773	0.9672852	0.1147461	-0.0102539		1	2	3	4
			}
			// write a 4x4 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+4; yy++) {
				float *pBuf = (float *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+4; xx++) {
					pBuf[xx] = pBlock2[i];
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_3to4_bicubic_int(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Resize the image to 4/3 using bicubic interpolation
// The sample location follows the resize() in OpenCV
// This is a fixed-point implementation
//  -2              -1            0             1                  2             3      4  <---- source image grid
//                             1/8        5/8        11/8           17/8                   <---- destination image grid mapped to source image
//                    (-21,235,1981,-147)    (-225,1535,873,-135)                          <---- filters * 2048
//                                (-135,873,1535,-225)      (-147,1981,235,-21)
//
// Luhong Liang, IC-ASD, ASTRI
// Jan. 12, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_3to4_bicubic_int()!\n");
		return false;
	}
	if (iplSrcImage->width*4 != iplDstImage->width*3 || iplSrcImage->height*4 != iplDstImage->height*3) {
		showErrMsg("Only support 3:4 upsampling in CImageUtility::resize_3to4_bicubic_int()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (4x4 block, step = 4, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[7*7];		// 7x7 block in source image
	int pBlock1[4*7];		// after interpolation in X direction
	int pBlock2[4*4];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=4, top+=3) {
		for (int x=0, left=0; x<iplDstImage->width; x+=4, left+=3) {
			// load a 7x7 block in source image (3x3 + padding)
			int i = 0;
			for (int yy=top; yy<top+7; yy++) {
				int *pBuf = (int *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+7; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<7; v++) {
				int *pSrc = pBlock + v * 7;
				int *pDst = pBlock1 + v * 4;
				pDst[0] = (-21*pSrc[0] + 235*pSrc[1] + 1981*pSrc[2] - 147*pSrc[3]) >> 11;	// (-21,235,1981,-147) / 2048,   (12-bit + bit-depth)
				pDst[1] = (-135*pSrc[1] + 873*pSrc[2] + 1535*pSrc[3] - 225*pSrc[4]) >> 11;	// (-135,873,1535,-225) / 2048,   (12-bit + bit-depth)
				pDst[2] = (-225*pSrc[2] + 1535*pSrc[3] + 873*pSrc[4] - 135*pSrc[5]) >> 11;	// (-225,1535,873,-135) / 2048,   (12-bit + bit-depth)
				pDst[3] = (-147*pSrc[3] + 1981*pSrc[4] + 235*pSrc[5] - 21*pSrc[6]) >> 11;	// (-147,1981,235,-21) / 2048,   (12-bit + bit-depth)
			}
			// interpolation in Y direction
			for (int u=0; u<4; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				pDst[0] = (-21*pSrc[0] + 235*pSrc[4] + 1981*pSrc[8] - 147*pSrc[12]) >> 11;		// (-21,235,1981,-147) / 2048,   (12-bit + bit-depth)
				pDst[4] = (-135*pSrc[4] + 873*pSrc[8] + 1535*pSrc[12] - 225*pSrc[16]) >> 11;	// (-135,873,1535,-225) / 2048,   (12-bit + bit-depth)
				pDst[8] = (-225*pSrc[8] + 1535*pSrc[12] + 873*pSrc[16] - 135*pSrc[20]) >> 11;	// (-225,1535,873,-135) / 2048,   (12-bit + bit-depth)
				pDst[12] = (-147*pSrc[12] + 1981*pSrc[16] + 235*pSrc[20] - 21*pSrc[24]) >> 11;	// (-147,1981,235,-21) / 2048,   (12-bit + bit-depth)
			}
			// write a 4x4 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+4; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+4; xx++) {
					int val = pBlock2[i];
					if (val < clip_low) {
						pBuf[xx] = clip_low;
					} else if (val > clip_high) {
						pBuf[xx] = clip_high;
					} else {
						pBuf[xx] = val;
					}
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_3to4_bicubic_int_s1(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Resize the image to 4/3 using bicubic interpolation(simified verion 1.0)
// Different from resize_3to4_bicubic_int(), the sample location is adjusted to get a more simple interpolation parameters
// This is a fixed-point implementation
//  -2              -1               0                1                     2             3      4  <---- source image grid
//                              -5/48          31/48           67/48             103/48             <---- destination image grid mapped to source image
//                        (-1,12,125,-8)/128            (-14,93,58,-9)/128                          <---- filters
//                                         (-8,51,99,-14)/128             (-20,245,35,-3)/256
//
// Luhong Liang, IC-ASD, ASTRI
// Jan. 21, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_3to4_bicubic_int_s1()!\n");
		return false;
	}
	if (iplSrcImage->width*4 != iplDstImage->width*3 || iplSrcImage->height*4 != iplDstImage->height*3) {
		showErrMsg("Only support 3:4 upsampling in CImageUtility::resize_3to4_bicubic_int_s1()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (4x4 block, step = 4, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[7*7];		// 7x7 block in source image
	int pBlock1[4*7];		// after interpolation in X direction
	int pBlock2[4*4];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=4, top+=3) {
		for (int x=0, left=0; x<iplDstImage->width; x+=4, left+=3) {
			// load a 7x7 block in source image (3x3 + padding)
			int i = 0;
			for (int yy=top; yy<top+7; yy++) {
				int *pBuf = (int *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+7; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<7; v++) {
				int *pSrc = pBlock + v * 7;
				int *pDst = pBlock1 + v * 4;
				pDst[0] = (-pSrc[0] + 12*pSrc[1] + 125*pSrc[2] - 8*pSrc[3]) >> 7;		//-1	12	125	-8	/128
				pDst[1] = (-8*pSrc[1] + 51*pSrc[2] + 99*pSrc[3] - 14*pSrc[4]) >> 7;		//-8	51	99	-14	/128
				pDst[2] = (-14*pSrc[2] + 93*pSrc[3] + 58*pSrc[4] - 9*pSrc[5]) >> 7;		//-14	93	58	-9	/128
				pDst[3] = (-20*pSrc[3] + 245*pSrc[4] + 35*pSrc[5] - 3*pSrc[6]) >> 8;	//-20	245	35	-3	/256
			}
			// interpolation in Y direction
			for (int u=0; u<4; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				pDst[0] = (-pSrc[0] + 12*pSrc[4] + 125*pSrc[8] - 8*pSrc[12]) >> 7;			//-1	12	125	-8	/128
				pDst[4] = (-8*pSrc[4] + 51*pSrc[8] + 99*pSrc[12] - 14*pSrc[16]) >> 7;		//-8	51	99	-14	/128
				pDst[8] = (-14*pSrc[8] + 93*pSrc[12] + 58*pSrc[16] - 9*pSrc[20]) >> 7;		//-14	93	58	-9	/128
				pDst[12] = (-20*pSrc[12] + 245*pSrc[16] + 35*pSrc[20] - 3*pSrc[24]) >> 8;	//-20	245	35	-3	/256
			}
			// write a 4x4 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+4; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+4; xx++) {
					int val = pBlock2[i];
					if (val < clip_low) {
						pBuf[xx] = clip_low;
					} else if (val > clip_high) {
						pBuf[xx] = clip_high;
					} else {
						pBuf[xx] = val;
					}
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_2to3_bilinear_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 3/2 using bicubic interpolation
// The sample location follows the resize() in OpenCV
//
// Luhong Liang, IC-ASD, ASTRI
// March. 24, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::resize_2to3_bilinear_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*3 != iplDstImage->width*2 || iplSrcImage->height*3 != iplDstImage->height*2) {
		showErrMsg("Only support 2:3 upsampling in CImageUtility::resize_2to3_bilinear_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	float pBlock[4*4];		// 4x4 block in source image
	float pBlock1[3*4];		// after interpolation in X direction
	float pBlock2[3*3];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=3, top+=2) {
		for (int x=0, left=0; x<iplDstImage->width; x+=3, left+=2) {
			// load a 4x4 block in source image (2x2 + padding)
			int i = 0;
			for (int yy=top; yy<top+4; yy++) {
				float *pBuf = (float *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+4; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<4; v++) {
				float *pSrc = pBlock + v * 4;
				float *pDst = pBlock1 + v * 3;
				pDst[0] = 0.166667f*pSrc[0] + 0.833333f*pSrc[1];
				pDst[1] = 0.5f*pSrc[1] + 0.5f*pSrc[2];
				pDst[2] = 0.833333f*pSrc[2] + 0.166667f*pSrc[3];
			}
			// interpolation in Y direction
			for (int u=0; u<3; u++) {
				float *pSrc = pBlock1 + u;
				float *pDst = pBlock2 + u;
				pDst[0] = 0.166667f*pSrc[0] + 0.833333f*pSrc[3];
				pDst[3] = 0.5f*pSrc[3] + 0.5f*pSrc[6];
				pDst[6] = 0.833333f*pSrc[6] + 0.166667f*pSrc[9];
			}
			// write a 3x3 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+3; yy++) {
				float *pBuf = (float *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+3; xx++) {
					pBuf[xx] = pBlock2[i];
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_2to3_bicubic_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 3/2 using bicubic interpolation
// The sample location follows the resize() in OpenCV
//                 Filter                                   Index  
// -0.0173611	0.1608796	0.9432870	-0.0868056		-2	-1	0	1
// -0.0937500	0.5937500	0.5937500	-0.0937500		-1	0	1	2
// -0.0868056	0.9432870	0.1608796	-0.0173611		0	1	2	3
//
// Luhong Liang, IC-ASD, ASTRI
// May. 30, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::resize_2to3_bicubic_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*3 != iplDstImage->width*2 || iplSrcImage->height*3 != iplDstImage->height*2) {
		showErrMsg("Only support 2:3 upsampling in CImageUtility::resize_2to3_bicubic_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	float pBlock[6*6];		// 7x7 block in source image
	float pBlock1[3*7];		// after interpolation in X direction
	float pBlock2[3*3];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=3, top+=2) {
		for (int x=0, left=0; x<iplDstImage->width; x+=3, left+=2) {
			// load a 7x7 block in source image (3x3 + padding)
			int i = 0;
			for (int yy=top; yy<top+6; yy++) {
				float *pBuf = (float *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+6; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<6; v++) {
				float *pSrc = pBlock + v * 6;
				float *pDst = pBlock1 + v * 3;
				pDst[0] = -0.0173611f*pSrc[0] + 0.1608796f*pSrc[1] + 0.9432870f*pSrc[2] - 0.0868056f*pSrc[3];	// -0.0173611	0.1608796	0.9432870	-0.0868056		-2	-1	0	1
				pDst[1] = -0.0937500f*pSrc[1] + 0.5937500f*pSrc[2] + 0.5937500f*pSrc[3] - 0.0937500f*pSrc[4];	// -0.0937500	0.5937500	0.5937500	-0.0937500		-1	0	1	2
				pDst[2] = -0.0868056f*pSrc[2] + 0.9432870f*pSrc[3] + 0.1608796f*pSrc[4] - 0.0173611f*pSrc[5];	// -0.0868056	0.9432870	0.1608796	-0.0173611		0	1	2	3
			}
			// interpolation in Y direction
			for (int u=0; u<3; u++) {
				float *pSrc = pBlock1 + u;
				float *pDst = pBlock2 + u;
				pDst[0] = -0.0173611f*pSrc[0] + 0.1608796f*pSrc[3] + 0.9432870f*pSrc[6] - 0.0868056f*pSrc[9];	// -0.0173611	0.1608796	0.9432870	-0.0868056		-2	-1	0	1
				pDst[3] = -0.0937500f*pSrc[3] + 0.5937500f*pSrc[6] + 0.5937500f*pSrc[9] - 0.0937500f*pSrc[12];	// -0.0937500	0.5937500	0.5937500	-0.0937500		-1	0	1	2
				pDst[6] = -0.0868056f*pSrc[6] + 0.9432870f*pSrc[9] + 0.1608796f*pSrc[12] - 0.0173611f*pSrc[15];	// -0.0868056	0.9432870	0.1608796	-0.0173611		0	1	2	3
			}
			// write a 3x3 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+3; yy++) {
				float *pBuf = (float *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+3; xx++) {
					pBuf[xx] = pBlock2[i];
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_3to2_bilinear_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 2/3 using bilinear interpolation
// The sample location follows the resize() in OpenCV
// This is a fixed-point implementation
//     0                 1                 2          <---- source image grid
//        1/4                       7/4               <---- destination image grid mapped to source image
//     (3/4,1/4)                 (1/4,3/4)            <---- filters
//
// Luhong Liang, IC-ASD, ASTRI
// May. 31, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::resize_3to2_bilinear_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width*3 || iplSrcImage->height*2 != iplDstImage->height*3) {
		showErrMsg("Only support 3:2 downsampling in CImageUtility::resize_3to2_bilinear_32f()!\n");
		return false;
	}
	
	// downsample bilinearly (3x3 block, step = 3, all in destination image)
	float pBlock[3*3];
	float pBlock1[2*3];
	float pBlock2[2*2];
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top+=3) {
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left+=3) {
			// load a 4x4 block in source image
			int i = 0;
			for (int yy=top; yy<top+3; yy++) {
				float *pBuf = (float *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);
				for (int xx=left; xx<left+3; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<3; v++) {
				float *pLineSrc = pBlock + v * 3;
				float *pLineDst = pBlock1 + v * 2;
				pLineDst[0] = (pLineSrc[0]*3.0f + pLineSrc[1]) * 0.25f;		// (3/4, 1/4 )
				pLineDst[1] = (pLineSrc[1] + pLineSrc[2]*3.0f) * 0.25f;		// (1/4, 3/4 )
			}
			// interpolation in Y direction
			for (int u=0; u<2; u++) {
				float *pLineSrc = pBlock1 + u;
				float *pLineDst = pBlock2 + u;
				pLineDst[0] = (pLineSrc[0]*3.0f + pLineSrc[2]) * 0.25f;		// (3/4, 1/4 )
				pLineDst[2] = (pLineSrc[2] + pLineSrc[4]*3.0f) * 0.25f;		// (1/4, 3/4 )
			}
			// write a 3x3 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+2; yy++) {
				float *pBuf = (float *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+2; xx++) {
					pBuf[xx] = pBlock2[i];
					i++;
				}
			}
		}
	}
	
	return true;
}

bool CImageUtility::resize_16to9_bilinear_int(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Resize the image to 9/16 using bilinear interpolation
// The sample location follows the resize() in OpenCV
// This is a fixed-point implementation
//     0      1      2      3      4      5      6      7      8      9     10     11     12     13     14     15     16          <---- source image grid
//       *		       *          *            *            *           *            *          *            *           *        <---- destination image grid mapped to source image
//   (11,7)/18      (5,1)/6    (1,17)/18    (5,13)/18    (1,1)/2    (13,5)/18   (17,1)/18   (1,5)/6    (7,11)/18     (11,7)/18   <---- filters
//
// Luhong Liang, IC-ASD, ASTRI
// Jan. 12, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_16to9_bilinear_int()!\n");
		return false;
	}
	if (iplSrcImage->width*9 != iplDstImage->width*16 || iplSrcImage->height*9 != iplDstImage->height*16) {
		showErrMsg("Only support 16:9 downsampling in CImageUtility::resize_16to9_bilinear_int()!\n");
		return false;
	}
	
	// downsample bilinearly (16x16 block, step = 9, all in destination image)
	int pBlock[16*16];
	int pBlock1[9*16];
	int pBlock2[9*9];
	for (int y=0, top=0; y<iplDstImage->height; y+=9, top+=16) {
		for (int x=0, left=0; x<iplDstImage->width; x+=9, left+=16) {
			// load a 16x16 block in source image
			int i = 0;
			for (int yy=top; yy<top+16; yy++) {
				int *pBuf = (int *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);
				for (int xx=left; xx<left+16; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<16; v++) {
				int *pLineSrc = pBlock + v * 16;
				int *pLineDst = pBlock1 + v * 9;
				pLineDst[0] = (pLineSrc[0]*11 + pLineSrc[1]*7) / 18;		// ( 11, 7 ) / 18
				pLineDst[1] = (pLineSrc[2]*5 + pLineSrc[3]) / 6;			// ( 5, 1 ) / 6
				pLineDst[2] = (pLineSrc[3] + pLineSrc[4]*17) / 18;			// ( 1, 17 ) / 18
				pLineDst[3] = (pLineSrc[5]*5 + pLineSrc[6]*13) / 18;		// ( 5, 13 ) / 18
				pLineDst[4] = (pLineSrc[7] + pLineSrc[8]) / 2;				// ( 1, 1 ) / 2
				pLineDst[5] = (pLineSrc[9]*13 + pLineSrc[10]*5) / 18;		// ( 13, 5 ) / 18
				pLineDst[6] = (pLineSrc[11]*17 + pLineSrc[12]) / 18;		// ( 17, 1 ) / 18
				pLineDst[7] = (pLineSrc[12] + pLineSrc[13]*5) / 6;			// ( 1, 5 ) / 6
				pLineDst[8] = (pLineSrc[14]*7 + pLineSrc[15]*11) / 18;		// ( 7, 11 ) / 18
			}
			// interpolation in Y direction
			for (int u=0; u<9; u++) {
				int *pLineSrc = pBlock1 + u;
				int *pLineDst = pBlock2 + u;
				pLineDst[0] = (pLineSrc[0]*11 + pLineSrc[9]*7) / 18;			// ( 11, 7 ) / 18
				pLineDst[9] = (pLineSrc[2*9]*5 + pLineSrc[3*9]) / 6;			// ( 5, 1 ) / 6
				pLineDst[2*9] = (pLineSrc[3*9] + pLineSrc[4*9]*17) / 18;		// ( 1, 17 ) / 18
				pLineDst[3*9] = (pLineSrc[5*9]*5 + pLineSrc[6*9]*13) / 18;		// ( 5, 13 ) / 18
				pLineDst[4*9] = (pLineSrc[7*9] + pLineSrc[8*9]) / 2;			// ( 1, 1 ) / 2
				pLineDst[5*9] = (pLineSrc[9*9]*13 + pLineSrc[10*9]*5) / 18;		// ( 13, 5 ) / 18
				pLineDst[6*9] = (pLineSrc[11*9]*17 + pLineSrc[12*9]) / 18;		// ( 17, 1 ) / 18
				pLineDst[7*9] = (pLineSrc[12*9] + pLineSrc[13*9]*5) / 6;		// ( 1, 5 ) / 6
				pLineDst[8*9] = (pLineSrc[14*9]*7 + pLineSrc[15*9]*11) / 18;	// ( 7, 11 ) / 18
			}
			// write a 9x9 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+9; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+9; xx++) {
					int val = pBlock2[i];
					if (val < clip_low) {
						pBuf[xx] = clip_low;
					} else if (val > clip_high) {
						pBuf[xx] = clip_high;
					} else {
						pBuf[xx] = val;
					}
					i++;
				}
			}
		}
	}
	
	return true;
}

bool CImageUtility::resize_16to9_bilinear_int_s1(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Resize the image to 9/16 using bilinear interpolation(simified verion 1.0)
// Different from resize_16to9_bilinear_int(), the sample location is adjusted to get a more simple interpolation parameters
// This is a fixed-point implementation
//     0      1      2      3      4      5      6      7      8      9     10     11     12     13     14     15     <---- source image grid
//       *		       *           *           *            *           *            *          *            *        <---- destination image grid mapped to source image
//   (9,7)/16      (13,3)/16      (1)      (1,3)/4      (7,9)/16   (11,5)/16     (7,1)/8    (1,7)/8    (5,11)/16      <---- filters
//
// Luhong Liang, IC-ASD, ASTRI
// Jan. 21, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_16to9_bilinear_int_s1()!\n");
		return false;
	}
	if (iplSrcImage->width*9 != iplDstImage->width*16 || iplSrcImage->height*9 != iplDstImage->height*16) {
		showErrMsg("Only support 16:9 downsampling in CImageUtility::resize_16to9_bilinear_int_s1()!\n");
		return false;
	}
	
	// downsample bilinearly (16x16 block, step = 9, all in destination image)
	int pBlock[16*16];
	int pBlock1[9*16];
	int pBlock2[9*9];
	for (int y=0, top=0; y<iplDstImage->height; y+=9, top+=16) {
		for (int x=0, left=0; x<iplDstImage->width; x+=9, left+=16) {
			// load a 16x16 block in source image
			int i = 0;
			for (int yy=top; yy<top+16; yy++) {
				int *pBuf = (int *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);
				for (int xx=left; xx<left+16; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<16; v++) {
				int *pLineSrc = pBlock + v * 16;
				int *pLineDst = pBlock1 + v * 9;
				pLineDst[0] = (pLineSrc[0]*9 + pLineSrc[1]*7) >> 4;		//9	7	/16
				pLineDst[1] = (pLineSrc[2]*13 + pLineSrc[3]*3) >> 4;	//13	3	/16
				pLineDst[2] = pLineSrc[4];								//1
				pLineDst[3] = (pLineSrc[5] + pLineSrc[6]*3) >> 2;		//1	3	/4
				pLineDst[4] = (pLineSrc[7]*7 + pLineSrc[8]*9) >> 4;		//7	9	/16
				pLineDst[5] = (pLineSrc[9]*11 + pLineSrc[10]*5) >> 4;	//11	5	/16
				pLineDst[6] = (pLineSrc[11]*7 + pLineSrc[12]) >> 3;		//7	1	/8
				pLineDst[7] = (pLineSrc[12] + pLineSrc[13]*7) >> 3;		//1	7	/8
				pLineDst[8] = (pLineSrc[14]*5 + pLineSrc[15]*11) >> 4;	//5	11	/16
			}
			// interpolation in Y direction
			for (int u=0; u<9; u++) {
				int *pLineSrc = pBlock1 + u;
				int *pLineDst = pBlock2 + u;
				pLineDst[0] = (pLineSrc[0]*9 + pLineSrc[9]*7) >> 4;			//9	7	/16
				pLineDst[9] = (pLineSrc[2*9]*13 + pLineSrc[3*9]*3) >> 4;	//13	3	/16
				pLineDst[2*9] = pLineSrc[4*9];								//1
				pLineDst[3*9] = (pLineSrc[5*9] + pLineSrc[6*9]*3) >> 2;		//1	3	/4
				pLineDst[4*9] = (pLineSrc[7*9]*7 + pLineSrc[8*9]*9)  >> 4;	//7	9	/16
				pLineDst[5*9] = (pLineSrc[9*9]*11 + pLineSrc[10*9]*5) >> 4;	//11	5	/16
				pLineDst[6*9] = (pLineSrc[11*9]*7 + pLineSrc[12*9]) >> 3;	//7	1	/8
				pLineDst[7*9] = (pLineSrc[12*9] + pLineSrc[13*9]*7) >> 3;	//1	7	/8
				pLineDst[8*9] = (pLineSrc[14*9]*5 + pLineSrc[15*9]*11) >> 4;//5	11	/16
			}
			// write a 9x9 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+9; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+9; xx++) {
					int val = pBlock2[i];
					if (val < clip_low) {
						pBuf[xx] = clip_low;
					} else if (val > clip_high) {
						pBuf[xx] = clip_high;
					} else {
						pBuf[xx] = val;
					}
					i++;
				}
			}
		}
	}
	
	return true;
}

bool CImageUtility::resize_16to9_bilinear_8U_s1(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 9/16 using bilinear interpolation(simified verion 1.0)
// Different from resize_16to9_bilinear_int(), the sample location is adjusted to get a more simple interpolation parameters
// This is a fixed-point implementation
//     0      1      2      3      4      5      6      7      8      9     10     11     12     13     14     15     <---- source image grid
//       *		       *           *           *            *           *            *          *            *        <---- destination image grid mapped to source image
//   (9,7)/16      (13,3)/16      (1)      (1,3)/4      (7,9)/16   (11,5)/16     (7,1)/8    (1,7)/8    (5,11)/16      <---- filters
//
// Luhong Liang, IC-ASD, ASTRI
// Jan. 30, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_16to9_bilinear_8U_s1()!\n");
		return false;
	}
	if (iplSrcImage->width*9 != iplDstImage->width*16 || iplSrcImage->height*9 != iplDstImage->height*16) {
		showErrMsg("Only support 16:9 downsampling in CImageUtility::resize_16to9_bilinear_8U_s1()!\n");
		return false;
	}
	
	// downsample bilinearly (16x16 block, step = 9, all in destination image)
	int pBlock[16*16];
	int pBlock1[9*16];
	int pBlock2[9*9];
	for (int y=0, top=0; y<iplDstImage->height; y+=9, top+=16) {
		for (int x=0, left=0; x<iplDstImage->width; x+=9, left+=16) {
			// load a 16x16 block in source image
			int i = 0;
			for (int yy=top; yy<top+16; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);
				for (int xx=left; xx<left+16; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction (keep 9 bits)
			for (int v=0; v<16; v++) {
				int *pLineSrc = pBlock + v * 16;
				int *pLineDst = pBlock1 + v * 9;
				pLineDst[0] = (pLineSrc[0]*9 + pLineSrc[1]*7) >> 3;		//9	7	/16
				pLineDst[1] = (pLineSrc[2]*13 + pLineSrc[3]*3) >> 3;	//13	3	/16
				pLineDst[2] = pLineSrc[4]<<1;							//1
				pLineDst[3] = (pLineSrc[5] + pLineSrc[6]*3) >> 1;		//1	3	/4
				pLineDst[4] = (pLineSrc[7]*7 + pLineSrc[8]*9) >> 3;		//7	9	/16
				pLineDst[5] = (pLineSrc[9]*11 + pLineSrc[10]*5) >> 3;	//11	5	/16
				pLineDst[6] = (pLineSrc[11]*7 + pLineSrc[12]) >> 2;		//7	1	/8
				pLineDst[7] = (pLineSrc[12] + pLineSrc[13]*7) >> 2;		//1	7	/8
				pLineDst[8] = (pLineSrc[14]*5 + pLineSrc[15]*11) >> 3;	//5	11	/16
			}
			// interpolation in Y direction
			for (int u=0; u<9; u++) {
				int *pLineSrc = pBlock1 + u;
				int *pLineDst = pBlock2 + u;
				pLineDst[0] = (pLineSrc[0]*9 + pLineSrc[9]*7) >> 4;			//9	7	/16
				pLineDst[9] = (pLineSrc[2*9]*13 + pLineSrc[3*9]*3) >> 4;	//13	3	/16
				pLineDst[2*9] = pLineSrc[4*9];								//1
				pLineDst[3*9] = (pLineSrc[5*9] + pLineSrc[6*9]*3) >> 2;		//1	3	/4
				pLineDst[4*9] = (pLineSrc[7*9]*7 + pLineSrc[8*9]*9)  >> 4;	//7	9	/16
				pLineDst[5*9] = (pLineSrc[9*9]*11 + pLineSrc[10*9]*5) >> 4;	//11	5	/16
				pLineDst[6*9] = (pLineSrc[11*9]*7 + pLineSrc[12*9]) >> 3;	//7	1	/8
				pLineDst[7*9] = (pLineSrc[12*9] + pLineSrc[13*9]*7) >> 3;	//1	7	/8
				pLineDst[8*9] = (pLineSrc[14*9]*5 + pLineSrc[15*9]*11) >> 4;//5	11	/16
			}
			// write a 9x9 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+9; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+9; xx++) {
					int val = pBlock2[i];
					// rounding
					val = ((val&0x0001)==0) ? (val>>1) : ((val>>1)+1);
					// clipping
					val = (val > 255) ? 255 : val;
					pBuf[xx] = (unsigned char)val;
					i++;
				}
			}
		}
	}
	
	return true;
}

bool CImageUtility::resize_9to16_nn_int_s1(IplImage *iplSrcImage, IplImage *iplDstImage)
// resize the image to 16/9 using nearest neighbour
// The sample location is that same as the function resize_9to16_bicubic_int_s1();
// This is a fixed-point implementation
//
// Luhong Liang, IC-ASD, ASTRI
// Jan. 21, 2013
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_9to16_bicubic_int()!\n");
		return false;
	}
	if (iplSrcImage->width*16 != iplDstImage->width*9 || iplSrcImage->height*16 != iplDstImage->height*9) {
		showErrMsg("Only support 9:16 upsampling in CImageUtility::resize_9to16_bicubic_int()!\n");
		return false;
	}

	int pLocLUT[] = { 0, 0, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 7, 8, 8};		// 3-bit, 16 entry

	for (int y=0, top=0; y<iplDstImage->height; y+=16, top+=9) {
		for (int yy=0; yy<16; yy++) {
			int *pDst = (int *)(iplDstImage->imageData + (y+yy) * iplDstImage->widthStep);
			int loc_y = top + pLocLUT[yy];
			int *pSrc = (int *)(iplSrcImage->imageData + loc_y * iplSrcImage->widthStep);
			for (int x=0, left=0; x<iplDstImage->width; x+=16, left+=9) {
				for (int xx=0; xx<16; xx++) {
					int loc_x = left + pLocLUT[xx];
					pDst[x+xx] = pSrc[loc_x];
				}
			}

		}
	}
	
	return true;
}

bool CImageUtility::resize_9to16_bicubic_int(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Resize the image to 16/9 using bicubic interpolation
// The sample location and filter follow the resize() in OpenCV, but the filter is an approximation!
// This is a fixed-point implementation
//   Ref Point			Filter * 2048
// -2	-1	0	1	-57	456	1854	-205
// -1	0	1	2	-227	1607	787	-119
// -1	0	1	2	-12	169	2010	-119
// 0	1	2	3	-203	1299	1131	-179
// 1	2	3	4	-45	2044	51	-2
// 1	2	3	4	-150	959	1459	-220
// 2	3	4	5	-170	1945	305	-32
// 2	3	4	5	-87	618	1740	-223
// 3	4	5	6	-223	1740	618	-87
// 3	4	5	6	-32	305	1945	-170
// 4	5	6	7	-220	1459	959	-150
// 4	5	6	7	-2	51	2044	-45
// 5	6	7	8	-179	1131	1299	-203
// 6	7	8	9	-119	2010	169	-12
// 6	7	8	9	-119	787	1607	-227
// 7	8	9	10	-205	1854	456	-57
//
// Luhong Liang, IC-ASD, ASTRI
// Jan. 15, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_9to16_bicubic_int()!\n");
		return false;
	}
	if (iplSrcImage->width*16 != iplDstImage->width*9 || iplSrcImage->height*16 != iplDstImage->height*9) {
		showErrMsg("Only support 9:16 upsampling in CImageUtility::resize_9to16_bicubic_int()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (16x16 block, step = 16, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[13*13];		// 13x13 block in source image (9 points + padding)
	int pBlock1[16*13];		// after interpolation in X direction
	int pBlock2[16*16];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=16, top+=9) {
		for (int x=0, left=0; x<iplDstImage->width; x+=16, left+=9) {
			// load a 13x13 block in source image (9x9 + padding)
			int i = 0;
			for (int yy=top; yy<top+13; yy++) {
				int *pBuf = (int *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+13; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<13; v++) {
				int *pSrc = pBlock + v * 13;
				int *pDst = pBlock1 + v * 16;
				// calculation		   											                      ref point             filter
				pDst[0] = (-57*pSrc[0] + 456*pSrc[1] + 1854*pSrc[2] - 205*pSrc[3]) >> 11;		// 0	1	2	3	-57	456	1854	-205
				pDst[1] = (-227*pSrc[1] + 1607*pSrc[2] + 787*pSrc[3] - 119*pSrc[4]) >> 11;		// 1	2	3	4	-227	1607	787	-119
				pDst[2] = (-12*pSrc[1] + 169*pSrc[2] + 2010*pSrc[3] - 119*pSrc[4]) >> 11;		// 1	2	3	4	-12	169	2010	-119
				pDst[3] = (-203*pSrc[2] + 1299*pSrc[3] + 1131*pSrc[4] - 179*pSrc[5]) >> 11;		// 2	3	4	5	-203	1299	1131	-179
				pDst[4] = (-45*pSrc[3] + 2044*pSrc[4] + 51*pSrc[5] - 2*pSrc[6]) >> 11;			// 3	4	5	6	-45	2044	51	-2
				pDst[5] = (-150*pSrc[3] + 959*pSrc[4] + 1459*pSrc[5] - 220*pSrc[6]) >> 11;		// 3	4	5	6	-150	959	1459	-220
				pDst[6] = (-170*pSrc[4] + 1945*pSrc[5] + 305*pSrc[6] - 32*pSrc[7]) >> 11;		// 4	5	6	7	-170	1945	305	-32
				pDst[7] = (-87*pSrc[4] + 618*pSrc[5] + 1740*pSrc[6] - 223*pSrc[7]) >> 11;		// 4	5	6	7	-87	618	1740	-223
				pDst[8] = (-223*pSrc[5] + 1740*pSrc[6] + 618*pSrc[7] - 87*pSrc[8]) >> 11;		// 5	6	7	8	-223	1740	618	-87
				pDst[9] = (-32*pSrc[5] + 305*pSrc[6] + 1945*pSrc[7] - 170*pSrc[8]) >> 11;		// 5	6	7	8	-32	305	1945	-170
				pDst[10] = (-220*pSrc[6] + 1459*pSrc[7] + 959*pSrc[8] - 150*pSrc[9]) >> 11;		// 6	7	8	9	-220	1459	959	-150
				pDst[11] = (-2*pSrc[6] + 51*pSrc[7] + 2044*pSrc[8] - 45*pSrc[9]) >> 11;			// 6	7	8	9	-2	51	2044	-45
				pDst[12] = (-179*pSrc[7] + 1131*pSrc[8] + 1299*pSrc[9] - 203*pSrc[10]) >> 11;		// 7	8	9	10	-179	1131	1299	-203
				pDst[13] = (-119*pSrc[8] + 2010*pSrc[9] + 169*pSrc[10] - 12*pSrc[11]) >> 11;		// 8	9	10	11	-119	2010	169	-12
				pDst[14] = (-119*pSrc[8] + 787*pSrc[9] + 1607*pSrc[10] - 227*pSrc[11]) >> 11;		// 8	9	10	11	-119	787	1607	-227
				pDst[15] = (-205*pSrc[9] + 1854*pSrc[10] + 456*pSrc[11] - 57*pSrc[12]) >> 11;		// 9	10	11	12	-205	1854	456	-57
			}
			// interpolation in Y direction
			for (int u=0; u<16; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		   																		 ref point             filter
				pDst[0] = (-57*pSrc[0] + 456*pSrc[16] + 1854*pSrc[2*16] - 205*pSrc[3*16]) >> 11;			// 0	1	2	3	-57	456	1854	-205
				pDst[16] = (-227*pSrc[16] + 1607*pSrc[2*16] + 787*pSrc[3*16] - 119*pSrc[4*16]) >> 11;		// 1	2	3	4	-227	1607	787	-119
				pDst[2*16] = (-12*pSrc[16] + 169*pSrc[2*16] + 2010*pSrc[3*16] - 119*pSrc[4*16]) >> 11;		// 1	2	3	4	-12	169	2010	-119
				pDst[3*16] = (-203*pSrc[2*16] + 1299*pSrc[3*16] + 1131*pSrc[4*16] - 179*pSrc[5*16]) >> 11;	// 2	3	4	5	-203	1299	1131	-179
				pDst[4*16] = (-45*pSrc[3*16] + 2044*pSrc[4*16] + 51*pSrc[5*16] - 2*pSrc[6*16]) >> 11;		// 3	4	5	6	-45	2044	51	-2
				pDst[5*16] = (-150*pSrc[3*16] + 959*pSrc[4*16] + 1459*pSrc[5*16] - 220*pSrc[6*16]) >> 11;	// 3	4	5	6	-150	959	1459	-220
				pDst[6*16] = (-170*pSrc[4*16] + 1945*pSrc[5*16] + 305*pSrc[6*16] - 32*pSrc[7*16]) >> 11;	// 4	5	6	7	-170	1945	305	-32
				pDst[7*16] = (-87*pSrc[4*16] + 618*pSrc[5*16] + 1740*pSrc[6*16] - 223*pSrc[7*16]) >> 11;	// 4	5	6	7	-87	618	1740	-223
				pDst[8*16] = (-223*pSrc[5*16] + 1740*pSrc[6*16] + 618*pSrc[7*16] - 87*pSrc[8*16]) >> 11;	// 5	6	7	8	-223	1740	618	-87
				pDst[9*16] = (-32*pSrc[5*16] + 305*pSrc[6*16] + 1945*pSrc[7*16] - 170*pSrc[8*16]) >> 11;	// 5	6	7	8	-32	305	1945	-170
				pDst[10*16] = (-220*pSrc[6*16] + 1459*pSrc[7*16] + 959*pSrc[8*16] - 150*pSrc[9*16]) >> 11;	// 6	7	8	9	-220	1459	959	-150
				pDst[11*16] = (-2*pSrc[6*16] + 51*pSrc[7*16] + 2044*pSrc[8*16] - 45*pSrc[9*16]) >> 11;		// 6	7	8	9	-2	51	2044	-45
				pDst[12*16] = (-179*pSrc[7*16] + 1131*pSrc[8*16] + 1299*pSrc[9*16] - 203*pSrc[10*16]) >> 11;// 7	8	9	10	-179	1131	1299	-203
				pDst[13*16] = (-119*pSrc[8*16] + 2010*pSrc[9*16] + 169*pSrc[10*16] - 12*pSrc[11*16]) >> 11;	// 8	9	10	11	-119	2010	169	-12
				pDst[14*16] = (-119*pSrc[8*16] + 787*pSrc[9*16] + 1607*pSrc[10*16] - 227*pSrc[11*16]) >> 11;// 8	9	10	11	-119	787	1607	-227
				pDst[15*16] = (-205*pSrc[9*16] + 1854*pSrc[10*16] + 456*pSrc[11*16] - 57*pSrc[12*16]) >> 11;// 9	10	11	12	-205	1854	456	-57
			}
			// write a 16x16 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+16; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+16; xx++) {
					int val = pBlock2[i];
					if (val < clip_low) {
						pBuf[xx] = clip_low;
					} else if (val > clip_high) {
						pBuf[xx] = clip_high;
					} else {
						pBuf[xx] = val;
					}
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_9to16_bicubic_int_s1(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Resize the image to 16/9 using bicubic interpolation(simified verion 1.0)
// Different from resize_9to16_bicubic_int(), the sample location is adjusted to get a more simple interpolation parameters
// This is a fixed-point implementation
//   Ref Point			Filter * 256
// -2	-1	0	1	-5	42	241	-22
// -1	0	1	2	-28	187	115	-18
// -1	0	1	2	0	9	255	-8
// 0	1	2	3	-23	146	158	-25
// 1	2	3	4	-13	252	18	-1
// 1	2	3	4	-16	103	197	-28
// 2	3	4	5	-25	235	53	-6
// 2	3	4	5	-8	61	229	-26
// 3	4	5	6	-28	205	94	-14
// 3	4	5	6	-2	25	250	-16
// 4	5	6	7	-26	167	137	-22
// 5	6	7	8	-3	256	3	0
// 5	6	7	8	-20	125	178	-27
// 6	7	8	9	-20	245	34	-3
// 6	7	8	9	-12	82	214	-28
// 7	8	9	10	-28	221	73	-10
//
// Luhong Liang, IC-ASD, ASTRI
// Jan. 21, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_9to16_bicubic_int_s1()!\n");
		return false;
	}
	if (iplSrcImage->width*16 != iplDstImage->width*9 || iplSrcImage->height*16 != iplDstImage->height*9) {
		showErrMsg("Only support 9:16 upsampling in CImageUtility::resize_9to16_bicubic_int_s1()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (16x16 block, step = 16, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[13*13];		// 13x13 block in source image (9 points + padding)
	int pBlock1[16*13];		// after interpolation in X direction
	int pBlock2[16*16];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=16, top+=9) {
		for (int x=0, left=0; x<iplDstImage->width; x+=16, left+=9) {
			// load a 13x13 block in source image (9x9 + padding)
			int i = 0;
			for (int yy=top; yy<top+13; yy++) {
				int *pBuf = (int *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+13; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<13; v++) {
				int *pSrc = pBlock + v * 13;
				int *pDst = pBlock1 + v * 16;
				// calculation		   											                      ref point             filter
				pDst[0] = (-5*pSrc[0] + 42*pSrc[1] + 241*pSrc[2] - 22*pSrc[3]) >> 8;			// -2	-1	0	1	-5	42	241	-22
				pDst[1] = (-28*pSrc[1] + 187*pSrc[2] + 115*pSrc[3] - 18*pSrc[4]) >> 8;			// -1	0	1	2	-28	187	115	-18
				pDst[2] = (9*pSrc[2] + 255*pSrc[3] - 8*pSrc[4]) >> 8;							// -1	0	1	2	0	9	255	-8
				pDst[3] = (-23*pSrc[2] + 146*pSrc[3] + 158*pSrc[4] - 25*pSrc[5]) >> 8;			// 0	1	2	3	-23	146	158	-25
				pDst[4] = (-13*pSrc[3] + 252*pSrc[4] + 18*pSrc[5] - pSrc[6]) >> 8;				// 1	2	3	4	-13	252	18	-1
				pDst[5] = (-16*pSrc[3] + 103*pSrc[4] + 197*pSrc[5] - 28*pSrc[6]) >> 8;			// 1	2	3	4	-16	103	197	-28
				pDst[6] = (-25*pSrc[4] + 235*pSrc[5] + 53*pSrc[6] - 6*pSrc[7]) >> 8;			// 2	3	4	5	-25	235	53	-6
				pDst[7] = (-8*pSrc[4] + 61*pSrc[5] + 229*pSrc[6] - 26*pSrc[7]) >> 8;			// 2	3	4	5	-8	61	229	-26
				pDst[8] = (-28*pSrc[5] + 205*pSrc[6] + 94*pSrc[7] - 14*pSrc[8]) >> 8;			// 3	4	5	6	-28	205	94	-14
				pDst[9] = (-2*pSrc[5] + 25*pSrc[6] + 250*pSrc[7] - 16*pSrc[8]) >> 8;			// 3	4	5	6	-2	25	250	-16
				pDst[10] = (-26*pSrc[6] + 167*pSrc[7] + 137*pSrc[8] - 22*pSrc[9]) >> 8;			// 4	5	6	7	-26	167	137	-22
				pDst[11] = ((3 * (-pSrc[7] + pSrc[9])) >> 8) + pSrc[8];							// 5	6	7	8	-3	256	3	0
				pDst[12] = (-20*pSrc[7] + 125*pSrc[8] + 178*pSrc[9] - 27*pSrc[10]) >> 8;		// 5	6	7	8	-20	125	178	-27
				pDst[13] = (-20*pSrc[8] + 245*pSrc[9] + 34*pSrc[10] - 3*pSrc[11]) >> 8;			// 6	7	8	9	-20	245	34	-3
				pDst[14] = (-12*pSrc[8] + 82*pSrc[9] + 214*pSrc[10] - 28*pSrc[11]) >> 8;		// 6	7	8	9	-12	82	214	-28
				pDst[15] = (-28*pSrc[9] + 221*pSrc[10] + 73*pSrc[11] - 10*pSrc[12]) >> 8;		// 7	8	9	10	-28	221	73	-10
			}
			// interpolation in Y direction
			for (int u=0; u<16; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		   																			 ref point             filter
				pDst[0] = (-5*pSrc[0] + 42*pSrc[16] + 241*pSrc[2*16] - 22*pSrc[3*16]) >> 8;					// -2	-1	0	1	-5	42	241	-22
				pDst[16] = (-28*pSrc[16] + 187*pSrc[2*16] + 115*pSrc[3*16] - 18*pSrc[4*16]) >> 8;			// -1	0	1	2	-28	187	115	-18
				pDst[2*16] = (9*pSrc[2*16] + 255*pSrc[3*16] - 8*pSrc[4*16]) >> 8;							// -1	0	1	2	0	9	255	-8
				pDst[3*16] = (-23*pSrc[2*16] + 146*pSrc[3*16] + 158*pSrc[4*16] - 25*pSrc[5*16]) >> 8;		// 0	1	2	3	-23	146	158	-25
				pDst[4*16] = (-13*pSrc[3*16] + 252*pSrc[4*16] + 18*pSrc[5*16] - pSrc[6*16]) >> 8;			// 1	2	3	4	-13	252	18	-1
				pDst[5*16] = (-16*pSrc[3*16] + 103*pSrc[4*16] + 197*pSrc[5*16] - 28*pSrc[6*16]) >> 8;		// 1	2	3	4	-16	103	197	-28
				pDst[6*16] = (-25*pSrc[4*16] + 235*pSrc[5*16] + 53*pSrc[6*16] - 6*pSrc[7*16]) >> 8;			// 2	3	4	5	-25	235	53	-6
				pDst[7*16] = (-8*pSrc[4*16] + 61*pSrc[5*16] + 229*pSrc[6*16] - 26*pSrc[7*16]) >> 8;			// 2	3	4	5	-8	61	229	-26
				pDst[8*16] = (-28*pSrc[5*16] + 205*pSrc[6*16] + 94*pSrc[7*16] - 14*pSrc[8*16]) >> 8;		// 3	4	5	6	-28	205	94	-14
				pDst[9*16] = (-2*pSrc[5*16] + 25*pSrc[6*16] + 250*pSrc[7*16] - 16*pSrc[8*16]) >> 8;			// 3	4	5	6	-2	25	250	-16
				pDst[10*16] = (-26*pSrc[6*16] + 167*pSrc[7*16] + 137*pSrc[8*16] - 22*pSrc[9*16]) >> 8;		// 4	5	6	7	-26	167	137	-22
				pDst[11*16] = ((3 * (-pSrc[7*16] + pSrc[9*16])) >> 8) + pSrc[8*16];							// 5	6	7	8	-3	256	3	0
				pDst[12*16] = (-20*pSrc[7*16] + 125*pSrc[8*16] + 178*pSrc[9*16] - 27*pSrc[10*16]) >> 8;		// 5	6	7	8	-20	125	178	-27
				pDst[13*16] = (-20*pSrc[8*16] + 245*pSrc[9*16] + 34*pSrc[10*16] - 3*pSrc[11*16]) >> 8;		// 6	7	8	9	-20	245	34	-3
				pDst[14*16] = (-12*pSrc[8*16] + 82*pSrc[9*16] + 214*pSrc[10*16] - 28*pSrc[11*16]) >> 8;		// 6	7	8	9	-12	82	214	-28
				pDst[15*16] = (-28*pSrc[9*16] + 221*pSrc[10*16] + 73*pSrc[11*16] - 10*pSrc[12*16]) >> 8;	// 7	8	9	10	-28	221	73	-10
			}
			// write a 16x16 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+16; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+16; xx++) {
					int val = pBlock2[i];
					if (val < clip_low) {
						pBuf[xx] = clip_low;
					} else if (val > clip_high) {
						pBuf[xx] = clip_high;
					} else {
						pBuf[xx] = val;
					}
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_9to16_bicubic_8U_10bit_s1(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 16/9 using bicubic interpolation(simified verion 1.0)
// Different from resize_9to16_bicubic_int(), the sample location is adjusted to get a more simple interpolation parameters
// This is a simplied fixed-point implementation of function resize_9to16_bicubic_int_s1(), where the input is 8U the output
// is UNSIGNED integer of 10-bit
//   Ref Point			Filter * 256
// -2	-1	0	1	-5	42	241	-22
// -1	0	1	2	-28	187	115	-18
// -1	0	1	2	0	9	255	-8
// 0	1	2	3	-23	146	158	-25
// 1	2	3	4	-13	252	18	-1
// 1	2	3	4	-16	103	197	-28
// 2	3	4	5	-25	235	53	-6
// 2	3	4	5	-8	61	229	-26
// 3	4	5	6	-28	205	94	-14
// 3	4	5	6	-2	25	250	-16
// 4	5	6	7	-26	167	137	-22
// 5	6	7	8	-3	256	3	0
// 5	6	7	8	-20	125	178	-27
// 6	7	8	9	-20	245	34	-3
// 6	7	8	9	-12	82	214	-28
// 7	8	9	10	-28	221	73	-10
//
// Luhong Liang, IC-ASD, ASTRI
// Jan. 29, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_9to16_bicubic_8U_10bit_s1()!\n");
		return false;
	}
	if (iplSrcImage->width*16 != iplDstImage->width*9 || iplSrcImage->height*16 != iplDstImage->height*9) {
		showErrMsg("Only support 3:4 upsampling in CImageUtility::resize_9to16_bicubic_8U_10bit_s1()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (16x16 block, step = 16, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[13*13];		// 13x13 block in source image (9 points + padding)
	int pBlock1[16*13];		// after interpolation in X direction
	int pBlock2[16*16];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=16, top+=9) {
		for (int x=0, left=0; x<iplDstImage->width; x+=16, left+=9) {
			// load a 13x13 block in source image (9x9 + padding)
			int i = 0;
			for (int yy=top; yy<top+13; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+13; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<13; v++) {
				int *pSrc = pBlock + v * 13;
				int *pDst = pBlock1 + v * 16;
				// calculation		   											                      ref point             filter
				pDst[0] = (-5*pSrc[0] + 42*pSrc[1] + 241*pSrc[2] - 22*pSrc[3]) >> 6;			// -2	-1	0	1	-5	42	241	-22
				pDst[1] = (-28*pSrc[1] + 187*pSrc[2] + 115*pSrc[3] - 18*pSrc[4]) >> 6;			// -1	0	1	2	-28	187	115	-18
				pDst[2] = (9*pSrc[2] + 255*pSrc[3] - 8*pSrc[4]) >> 6;							// -1	0	1	2	0	9	255	-8
				pDst[3] = (-23*pSrc[2] + 146*pSrc[3] + 158*pSrc[4] - 25*pSrc[5]) >> 6;			// 0	1	2	3	-23	146	158	-25
				pDst[4] = (-13*pSrc[3] + 252*pSrc[4] + 18*pSrc[5] - pSrc[6]) >> 6;				// 1	2	3	4	-13	252	18	-1
				pDst[5] = (-16*pSrc[3] + 103*pSrc[4] + 197*pSrc[5] - 28*pSrc[6]) >> 6;			// 1	2	3	4	-16	103	197	-28
				pDst[6] = (-25*pSrc[4] + 235*pSrc[5] + 53*pSrc[6] - 6*pSrc[7]) >> 6;			// 2	3	4	5	-25	235	53	-6
				pDst[7] = (-8*pSrc[4] + 61*pSrc[5] + 229*pSrc[6] - 26*pSrc[7]) >> 6;			// 2	3	4	5	-8	61	229	-26
				pDst[8] = (-28*pSrc[5] + 205*pSrc[6] + 94*pSrc[7] - 14*pSrc[8]) >> 6;			// 3	4	5	6	-28	205	94	-14
				pDst[9] = (-2*pSrc[5] + 25*pSrc[6] + 250*pSrc[7] - 16*pSrc[8]) >> 6;			// 3	4	5	6	-2	25	250	-16
				pDst[10] = (-26*pSrc[6] + 167*pSrc[7] + 137*pSrc[8] - 22*pSrc[9]) >> 6;			// 4	5	6	7	-26	167	137	-22
				pDst[11] = (3 * (-pSrc[7] + pSrc[9]) + (pSrc[8]<<8)) >> 6;						// 5	6	7	8	-3	256	3	0
				pDst[12] = (-20*pSrc[7] + 125*pSrc[8] + 178*pSrc[9] - 27*pSrc[10]) >> 6;		// 5	6	7	8	-20	125	178	-27
				pDst[13] = (-20*pSrc[8] + 245*pSrc[9] + 34*pSrc[10] - 3*pSrc[11]) >> 6;			// 6	7	8	9	-20	245	34	-3
				pDst[14] = (-12*pSrc[8] + 82*pSrc[9] + 214*pSrc[10] - 28*pSrc[11]) >> 6;		// 6	7	8	9	-12	82	214	-28
				pDst[15] = (-28*pSrc[9] + 221*pSrc[10] + 73*pSrc[11] - 10*pSrc[12]) >> 6;		// 7	8	9	10	-28	221	73	-10
			}
			// interpolation in Y direction
			for (int u=0; u<16; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		   																			 ref point             filter
				pDst[0] = (-5*pSrc[0] + 42*pSrc[16] + 241*pSrc[2*16] - 22*pSrc[3*16]) >> 8;					// -2	-1	0	1	-5	42	241	-22
				pDst[16] = (-28*pSrc[16] + 187*pSrc[2*16] + 115*pSrc[3*16] - 18*pSrc[4*16]) >> 8;			// -1	0	1	2	-28	187	115	-18
				pDst[2*16] = (9*pSrc[2*16] + 255*pSrc[3*16] - 8*pSrc[4*16]) >> 8;							// -1	0	1	2	0	9	255	-8
				pDst[3*16] = (-23*pSrc[2*16] + 146*pSrc[3*16] + 158*pSrc[4*16] - 25*pSrc[5*16]) >> 8;		// 0	1	2	3	-23	146	158	-25
				pDst[4*16] = (-13*pSrc[3*16] + 252*pSrc[4*16] + 18*pSrc[5*16] - pSrc[6*16]) >> 8;			// 1	2	3	4	-13	252	18	-1
				pDst[5*16] = (-16*pSrc[3*16] + 103*pSrc[4*16] + 197*pSrc[5*16] - 28*pSrc[6*16]) >> 8;		// 1	2	3	4	-16	103	197	-28
				pDst[6*16] = (-25*pSrc[4*16] + 235*pSrc[5*16] + 53*pSrc[6*16] - 6*pSrc[7*16]) >> 8;			// 2	3	4	5	-25	235	53	-6
				pDst[7*16] = (-8*pSrc[4*16] + 61*pSrc[5*16] + 229*pSrc[6*16] - 26*pSrc[7*16]) >> 8;			// 2	3	4	5	-8	61	229	-26
				pDst[8*16] = (-28*pSrc[5*16] + 205*pSrc[6*16] + 94*pSrc[7*16] - 14*pSrc[8*16]) >> 8;		// 3	4	5	6	-28	205	94	-14
				pDst[9*16] = (-2*pSrc[5*16] + 25*pSrc[6*16] + 250*pSrc[7*16] - 16*pSrc[8*16]) >> 8;			// 3	4	5	6	-2	25	250	-16
				pDst[10*16] = (-26*pSrc[6*16] + 167*pSrc[7*16] + 137*pSrc[8*16] - 22*pSrc[9*16]) >> 8;		// 4	5	6	7	-26	167	137	-22
				pDst[11*16] = (3 * (-pSrc[7*16] + pSrc[9*16]) + (pSrc[8*16] << 8)) >> 8;					// 5	6	7	8	-3	256	3	0
				pDst[12*16] = (-20*pSrc[7*16] + 125*pSrc[8*16] + 178*pSrc[9*16] - 27*pSrc[10*16]) >> 8;		// 5	6	7	8	-20	125	178	-27
				pDst[13*16] = (-20*pSrc[8*16] + 245*pSrc[9*16] + 34*pSrc[10*16] - 3*pSrc[11*16]) >> 8;		// 6	7	8	9	-20	245	34	-3
				pDst[14*16] = (-12*pSrc[8*16] + 82*pSrc[9*16] + 214*pSrc[10*16] - 28*pSrc[11*16]) >> 8;		// 6	7	8	9	-12	82	214	-28
				pDst[15*16] = (-28*pSrc[9*16] + 221*pSrc[10*16] + 73*pSrc[11*16] - 10*pSrc[12*16]) >> 8;	// 7	8	9	10	-28	221	73	-10
			}
			// write a 16x16 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+16; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+16; xx++) {
					// clip to 10-bit unsigned integer
					int val = pBlock2[i];
					if (val > 1023) {
						pBuf[xx] = 1023;
					} else if (val < 0) {
						pBuf[xx] = 0;
					} else {
						pBuf[xx] = val;
					}
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_15to8_bilinear_int(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Resize the image to 8/15 using bilinear interpolation
// The sample location follows the resize() in OpenCV
// This is a fixed-point implementation
//     0      1      2      3      4      5      6      7      8      9     10     11     12     13     14        <---- source image grid
//       *		       *             *            *           *           *            *             *            <---- destination image grid mapped to source image
//   (9,7)/16      (11,5)/16    (13,3)/16    (15,1)/16    (1,15)/16    (3,13)/16   (5,11)/16      (7,9)/16        <---- filters
//
// Luhong Liang, IC-ASD, ASTRI
// Feb. 4, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_15to8_bilinear_int()!\n");
		return false;
	}
	if (iplSrcImage->width*8 != iplDstImage->width*15 || iplSrcImage->height*8 != iplDstImage->height*15) {
		showErrMsg("Only support 15:8 downsampling in CImageUtility::resize_15to8_bilinear_int()!\n");
		return false;
	}
	
	// downsample bilinearly (8x8 block, step = 8, all in destination image)
	int pBlock[15*15];
	int pBlock1[8*15];
	int pBlock2[8*8];
	for (int y=0, top=0; y<iplDstImage->height; y+=8, top+=15) {
		for (int x=0, left=0; x<iplDstImage->width; x+=8, left+=15) {
			// load a 15x15 block in source image
			int i = 0;
			for (int yy=top; yy<top+15; yy++) {
				int *pBuf = (int *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);
				for (int xx=left; xx<left+15; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<15; v++) {
				int *pLineSrc = pBlock + v * 15;
				int *pLineDst = pBlock1 + v * 8;
				pLineDst[0] = (pLineSrc[0]*9 + pLineSrc[1]*7) >> 4;		// 9,7
				pLineDst[1] = (pLineSrc[2]*11 + pLineSrc[3]*5) >> 4;	// 11,5
				pLineDst[2] = (pLineSrc[4]*13 + pLineSrc[5]*3) >> 4;	// 13,3
				pLineDst[3] = (pLineSrc[6]*15 + pLineSrc[7]) >> 4;		// 15,1
				pLineDst[4] = (pLineSrc[7] + pLineSrc[8]*15) >> 4;		// 1,15
				pLineDst[5] = (pLineSrc[9]*3 + pLineSrc[10]*13) >> 4;	// 3,13
				pLineDst[6] = (pLineSrc[11]*5 + pLineSrc[12]*11) >> 4;	// 5,11
				pLineDst[7] = (pLineSrc[13]*7 + pLineSrc[14]*9) >> 4;	// 7,9
			}
			// interpolation in Y direction
			for (int u=0; u<8; u++) {
				int *pLineSrc = pBlock1 + u;
				int *pLineDst = pBlock2 + u;
				pLineDst[0] = (pLineSrc[0]*9 + pLineSrc[8]*7) >> 4;				// 9,7
				pLineDst[8] = (pLineSrc[2*8]*11 + pLineSrc[3*8]*5) >> 4;		// 11,5
				pLineDst[2*8] = (pLineSrc[4*8]*13 + pLineSrc[5*8]*3) >> 4;		// 13,3
				pLineDst[3*8] = (pLineSrc[6*8]*15 + pLineSrc[7*8]) >> 4;		// 15,1
				pLineDst[4*8] = (pLineSrc[7*8] + pLineSrc[8*8]*15) >> 4;		// 1,15
				pLineDst[5*8] = (pLineSrc[9*8]*3 + pLineSrc[10*8]*13) >> 4;		// 3,13
				pLineDst[6*8] = (pLineSrc[11*8]*5 + pLineSrc[12*8]*11) >> 4;	// 5,11
				pLineDst[7*8] = (pLineSrc[13*8]*7 + pLineSrc[14*8]*9) >> 4;		// 7,9
			}
			// write a 8x8 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+8; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+8; xx++) {
					int val = pBlock2[i];
					if (val < clip_low) {
						pBuf[xx] = clip_low;
					} else if (val > clip_high) {
						pBuf[xx] = clip_high;
					} else {
						pBuf[xx] = val;
					}
					i++;
				}
			}
		}
	}

	return true;
}

bool CImageUtility::resize_15to8_bilinear_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 8/15 using bilinear interpolation
// The sample location follows the resize() in OpenCV
// This is a fixed-point implementation
//     0      1      2      3      4      5      6      7      8      9     10     11     12     13     14        <---- source image grid
//       *		       *             *            *           *           *            *             *            <---- destination image grid mapped to source image
//   (9,7)/16      (11,5)/16    (13,3)/16    (15,1)/16    (1,15)/16    (3,13)/16   (5,11)/16      (7,9)/16        <---- filters
//
// Luhong Liang, IC-ASD, ASTRI
// Feb. 4, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_15to8_bilinear_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*8 != iplDstImage->width*15 || iplSrcImage->height*8 != iplDstImage->height*15) {
		showErrMsg("Only support 15:8 downsampling in CImageUtility::resize_15to8_bilinear_8U()!\n");
		return false;
	}
	
	// downsample bilinearly (8x8 block, step = 8, all in destination image)
	int pBlock[15*15];
	int pBlock1[8*15];
	int pBlock2[8*8];
	for (int y=0, top=0; y<iplDstImage->height; y+=8, top+=15) {
		for (int x=0, left=0; x<iplDstImage->width; x+=8, left+=15) {
			// load a 15x15 block in source image
			int i = 0;
			for (int yy=top; yy<top+15; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);
				for (int xx=left; xx<left+15; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<15; v++) {
				int *pLineSrc = pBlock + v * 15;
				int *pLineDst = pBlock1 + v * 8;
				pLineDst[0] = (pLineSrc[0]*9 + pLineSrc[1]*7) >> 3;		// 9,7
				pLineDst[1] = (pLineSrc[2]*11 + pLineSrc[3]*5) >> 3;	// 11,5
				pLineDst[2] = (pLineSrc[4]*13 + pLineSrc[5]*3) >> 3;	// 13,3
				pLineDst[3] = (pLineSrc[6]*15 + pLineSrc[7]) >> 3;		// 15,1
				pLineDst[4] = (pLineSrc[7] + pLineSrc[8]*15) >> 3;		// 1,15
				pLineDst[5] = (pLineSrc[9]*3 + pLineSrc[10]*13) >> 3;	// 3,13
				pLineDst[6] = (pLineSrc[11]*5 + pLineSrc[12]*11) >> 3;	// 5,11
				pLineDst[7] = (pLineSrc[13]*7 + pLineSrc[14]*9) >> 3;	// 7,9
			}
			// interpolation in Y direction
			for (int u=0; u<8; u++) {
				int *pLineSrc = pBlock1 + u;
				int *pLineDst = pBlock2 + u;
				pLineDst[0] = (pLineSrc[0]*9 + pLineSrc[8]*7) >> 4;				// 9,7
				pLineDst[8] = (pLineSrc[2*8]*11 + pLineSrc[3*8]*5) >> 4;		// 11,5
				pLineDst[2*8] = (pLineSrc[4*8]*13 + pLineSrc[5*8]*3) >> 4;		// 13,3
				pLineDst[3*8] = (pLineSrc[6*8]*15 + pLineSrc[7*8]) >> 4;		// 15,1
				pLineDst[4*8] = (pLineSrc[7*8] + pLineSrc[8*8]*15) >> 4;		// 1,15
				pLineDst[5*8] = (pLineSrc[9*8]*3 + pLineSrc[10*8]*13) >> 4;		// 3,13
				pLineDst[6*8] = (pLineSrc[11*8]*5 + pLineSrc[12*8]*11) >> 4;	// 5,11
				pLineDst[7*8] = (pLineSrc[13*8]*7 + pLineSrc[14*8]*9) >> 4;		// 7,9
			}
			// write a 8x8 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+8; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+8; xx++) {
					int val = pBlock2[i];
					// rounding
					val = ((val&0x0001)==0) ? (val>>1) : ((val>>1)+1);
					// clipping
					val = (val > 255) ? 255 : val;
					pBuf[xx] = (unsigned char)val;
					i++;
				}
			}
		}
	}

	return true;
}

bool CImageUtility::resize_8to15_bicubic_int(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Resize the image to 15/8 using bicubic interpolation
// The sample location follows the resize() in OpenCV
// This is a fixed-point implementation
//   Ref Point			Filter * 256
// -2	-1	0	1	-8	62	228	-26
// -1	0	1	2	-28	212	84	-12
// -1	0	1	2	-4	41	241	-22
// 0	1	2	3	-28	194	106	-16
// 0	1	2	3	-2	23	251	-16
// 1	2	3	4	-27	174	129	-20
// 1	2	3	4	0	7	255	-6
// 2	3	4	5	-24	152	152	-24
// 3	4	5	6	-6	255	7	0
// 3	4	5	6	-20	129	174	-27
// 4	5	6	7	-16	251	23	-2
// 4	5	6	7	-16	106	194	-28
// 5	6	7	8	-22	241	41	-4
// 5	6	7	8	-12	84	212	-28
// 6	7	8	9	-26	228	62	-8
// 7	8	9	10	-8	62	228	-26
//
// Luhong Liang, IC-ASD, ASTRI
// Feb. 4, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_8to15_bicubic_int()!\n");
		return false;
	}
	if (iplSrcImage->width*15 != iplDstImage->width*8 || iplSrcImage->height*15 != iplDstImage->height*8) {
		showErrMsg("Only support 8:15 upsampling in CImageUtility::resize_8to15_bicubic_int()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (15x15 block, step = 15, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[12*12];		// 13x13 block in source image (8 points + padding)
	int pBlock1[15*12];		// after interpolation in X direction
	int pBlock2[15*15];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=15, top+=8) {
		for (int x=0, left=0; x<iplDstImage->width; x+=15, left+=8) {
			// load a 12x12 block in source image (8x8 + padding)
			int i = 0;
			for (int yy=top; yy<top+12; yy++) {
				int *pBuf = (int *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+12; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<12; v++) {
				int *pSrc = pBlock + v * 12;
				int *pDst = pBlock1 + v * 15;
				// calculation		   														   ref point          filter
				pDst[0] = (-8*pSrc[0] + 62*pSrc[1] + 228*pSrc[2] - 26*pSrc[3]) >> 8;		// 0	1	2	3	-8	62	228	-26
				pDst[1] = (-28*pSrc[1] + 212*pSrc[2] + 84*pSrc[3] - 12*pSrc[4]) >> 8;		// 1	2	3	4	-28	212	84	-12
				pDst[2] = (-4*pSrc[1] + 41*pSrc[2] + 241*pSrc[3] - 22*pSrc[4]) >> 8;		// 1	2	3	4	-4	41	241	-22
				pDst[3] = (-28*pSrc[2] + 194*pSrc[3] + 106*pSrc[4] - 16*pSrc[5]) >> 8;		// 2	3	4	5	-28	194	106	-16
				pDst[4] = (-2*pSrc[2] + 23*pSrc[3] + 251*pSrc[4] - 16*pSrc[5]) >> 8;			// 2	3	4	5	-2	23	251	-16
				pDst[5] = (-27*pSrc[3] + 174*pSrc[4] + 129*pSrc[5] - 20*pSrc[6]) >> 8;		// 3	4	5	6	-27	174	129	-20
				pDst[6] = (7*pSrc[4] + 255*pSrc[5] - 6*pSrc[6]) >> 8;						// 3	4	5	6	0	7	255	-6
				pDst[7] = (-24*pSrc[4] + 152*pSrc[5] + 152*pSrc[6] - 24*pSrc[7]) >> 8;		// 4	5	6	7	-24	152	152	-24
				pDst[8] = (-6*pSrc[5] + 255*pSrc[6] + 7*pSrc[7]) >> 8;						// 5	6	7	8	-6	255	7	0
				pDst[9] = (-20*pSrc[5] + 129*pSrc[6] + 174*pSrc[7] - 27*pSrc[8]) >> 8;		// 5	6	7	8	-20	129	174	-27
				pDst[10] = (-16*pSrc[6] + 251*pSrc[7] + 23*pSrc[8] - 2*pSrc[9]) >> 8;		// 6	7	8	9	-16	251	23	-2
				pDst[11] = (-16*pSrc[6] + 106*pSrc[7] + 194*pSrc[8] - 28*pSrc[9]) >> 8;		// 6	7	8	9	-16	106	194	-28
				pDst[12] = (-22*pSrc[7] + 241*pSrc[8] + 41*pSrc[9] - 4*pSrc[10]) >> 8;		// 7	8	9	10	-22	241	41	-4
				pDst[13] = (-12*pSrc[7] + 84*pSrc[8] + 212*pSrc[9] - 28*pSrc[10]) >> 8;		// 7	8	9	10	-12	84	212	-28
				pDst[14] = (-26*pSrc[8] + 228*pSrc[9] + 62*pSrc[10] - 8*pSrc[11]) >> 8;		// 8	9	10	11	-26	228	62	-8
			}
			// interpolation in Y direction
			for (int u=0; u<15; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		   																			 ref point             filter
				pDst[0] = (-8*pSrc[0] + 62*pSrc[15] + 228*pSrc[2*15] - 26*pSrc[3*15]) >> 8;					// 0	1	2	3	-8	62	228	-26
				pDst[15] = (-28*pSrc[15] + 212*pSrc[2*15] + 84*pSrc[3*15] - 12*pSrc[4*15]) >> 8;			// 1	2	3	4	-28	212	84	-12
				pDst[2*15] = (-4*pSrc[15] + 41*pSrc[2*15] + 241*pSrc[3*15] - 22*pSrc[4*15]) >> 8;			// 1	2	3	4	-4	41	241	-22
				pDst[3*15] = (-28*pSrc[2*15] + 194*pSrc[3*15] + 106*pSrc[4*15] - 16*pSrc[5*15]) >> 8;		// 2	3	4	5	-28	194	106	-16
				pDst[4*15] = (-2*pSrc[2*15] + 23*pSrc[3*15] + 251*pSrc[4*15] - 16*pSrc[5*15]) >> 8;			// 2	3	4	5	-2	23	251	-16
				pDst[5*15] = (-27*pSrc[3*15] + 174*pSrc[4*15] + 129*pSrc[5*15] - 20*pSrc[6*15]) >> 8;		// 3	4	5	6	-27	174	129	-20
				pDst[6*15] = (7*pSrc[4*15] + 255*pSrc[5*15] - 6*pSrc[6*15]) >> 8;							// 3	4	5	6	0	7	255	-6
				pDst[7*15] = (-24*pSrc[4*15] + 152*pSrc[5*15] + 152*pSrc[6*15] - 24*pSrc[7*15]) >> 8;		// 4	5	6	7	-24	152	152	-24
				pDst[8*15] = (-6*pSrc[5*15] + 255*pSrc[6*15] + 7*pSrc[7*15]) >> 8;							// 5	6	7	8	-6	255	7	0
				pDst[9*15] = (-20*pSrc[5*15] + 129*pSrc[6*15] + 174*pSrc[7*15] - 27*pSrc[8*15]) >> 8;		// 5	6	7	8	-20	129	174	-27
				pDst[10*15] = (-16*pSrc[6*15] + 251*pSrc[7*15] + 23*pSrc[8*15] - 2*pSrc[9*15]) >> 8;		// 6	7	8	9	-16	251	23	-2
				pDst[11*15] = (-16*pSrc[6*15] + 106*pSrc[7*15] + 194*pSrc[8*15] - 28*pSrc[9*15]) >> 8;		// 6	7	8	9	-16	106	194	-28
				pDst[12*15] = (-22*pSrc[7*15] + 241*pSrc[8*15] + 41*pSrc[9*15] - 4*pSrc[10*15]) >> 8;		// 7	8	9	10	-22	241	41	-4
				pDst[13*15] = (-12*pSrc[7*15] + 84*pSrc[8*15] + 212*pSrc[9*15] - 28*pSrc[10*15]) >> 8;		// 7	8	9	10	-12	84	212	-28
				pDst[14*15] = (-26*pSrc[8*15] + 228*pSrc[9*15] + 62*pSrc[10*15] - 8*pSrc[11*15]) >> 8;		// 8	9	10	11	-26	228	62	-8
			}
			// write a 16x16 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+15; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+15; xx++) {
					int val = pBlock2[i];
					if (val < clip_low) {
						pBuf[xx] = clip_low;
					} else if (val > clip_high) {
						pBuf[xx] = clip_high;
					} else {
						pBuf[xx] = val;
					}
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_8to15_bicubic_8U_10bit(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 15/8 using bicubic interpolation
// The sample location follows the resize() in OpenCV
// This is a fixed-point implementation
//   Ref Point			Filter * 256
// -2	-1	0	1	-8	62	228	-26
// -1	0	1	2	-28	212	84	-12
// -1	0	1	2	-4	41	241	-22
// 0	1	2	3	-28	194	106	-16
// 0	1	2	3	-2	23	251	-16
// 1	2	3	4	-27	174	129	-20
// 1	2	3	4	0	7	255	-6
// 2	3	4	5	-24	152	152	-24
// 3	4	5	6	-6	255	7	0
// 3	4	5	6	-20	129	174	-27
// 4	5	6	7	-16	251	23	-2
// 4	5	6	7	-16	106	194	-28
// 5	6	7	8	-22	241	41	-4
// 5	6	7	8	-12	84	212	-28
// 6	7	8	9	-26	228	62	-8
// 7	8	9	10	-8	62	228	-26
//
// Luhong Liang, IC-ASD, ASTRI
// Feb. 4, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_8to15_bicubic_8U_10bit()!\n");
		return false;
	}
	if (iplSrcImage->width*15 != iplDstImage->width*8 || iplSrcImage->height*15 != iplDstImage->height*8) {
		showErrMsg("Only support 8:15 upsampling in CImageUtility::resize_8to15_bicubic_8U_10bit()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (15x15 block, step = 15, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[12*12];		// 13x13 block in source image (8 points + padding)
	int pBlock1[15*12];		// after interpolation in X direction
	int pBlock2[15*15];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=15, top+=8) {
		for (int x=0, left=0; x<iplDstImage->width; x+=15, left+=8) {
			// load a 12x12 block in source image (8x8 + padding)
			int i = 0;
			for (int yy=top; yy<top+12; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+12; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<12; v++) {
				int *pSrc = pBlock + v * 12;
				int *pDst = pBlock1 + v * 15;
				// calculation		   														   ref point          filter
				pDst[0] = (-8*pSrc[0] + 62*pSrc[1] + 228*pSrc[2] - 26*pSrc[3]) >> 6;		// 0	1	2	3	-8	62	228	-26
				pDst[1] = (-28*pSrc[1] + 212*pSrc[2] + 84*pSrc[3] - 12*pSrc[4]) >> 6;		// 1	2	3	4	-28	212	84	-12
				pDst[2] = (-4*pSrc[1] + 41*pSrc[2] + 241*pSrc[3] - 22*pSrc[4]) >> 6;		// 1	2	3	4	-4	41	241	-22
				pDst[3] = (-28*pSrc[2] + 194*pSrc[3] + 106*pSrc[4] - 16*pSrc[5]) >> 6;		// 2	3	4	5	-28	194	106	-16
				pDst[4] = (-2*pSrc[2] + 23*pSrc[3] + 251*pSrc[4] - 16*pSrc[5]) >> 6;			// 2	3	4	5	-2	23	251	-16
				pDst[5] = (-27*pSrc[3] + 174*pSrc[4] + 129*pSrc[5] - 20*pSrc[6]) >> 6;		// 3	4	5	6	-27	174	129	-20
				pDst[6] = (7*pSrc[4] + 255*pSrc[5] - 6*pSrc[6]) >> 6;						// 3	4	5	6	0	7	255	-6
				pDst[7] = (-24*pSrc[4] + 152*pSrc[5] + 152*pSrc[6] - 24*pSrc[7]) >> 6;		// 4	5	6	7	-24	152	152	-24
				pDst[8] = (-6*pSrc[5] + 255*pSrc[6] + 7*pSrc[7]) >> 6;						// 5	6	7	8	-6	255	7	0
				pDst[9] = (-20*pSrc[5] + 129*pSrc[6] + 174*pSrc[7] - 27*pSrc[8]) >> 6;		// 5	6	7	8	-20	129	174	-27
				pDst[10] = (-16*pSrc[6] + 251*pSrc[7] + 23*pSrc[8] - 2*pSrc[9]) >> 6;		// 6	7	8	9	-16	251	23	-2
				pDst[11] = (-16*pSrc[6] + 106*pSrc[7] + 194*pSrc[8] - 28*pSrc[9]) >> 6;		// 6	7	8	9	-16	106	194	-28
				pDst[12] = (-22*pSrc[7] + 241*pSrc[8] + 41*pSrc[9] - 4*pSrc[10]) >> 6;		// 7	8	9	10	-22	241	41	-4
				pDst[13] = (-12*pSrc[7] + 84*pSrc[8] + 212*pSrc[9] - 28*pSrc[10]) >> 6;		// 7	8	9	10	-12	84	212	-28
				pDst[14] = (-26*pSrc[8] + 228*pSrc[9] + 62*pSrc[10] - 8*pSrc[11]) >> 6;		// 8	9	10	11	-26	228	62	-8
			}
			// interpolation in Y direction
			for (int u=0; u<15; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		   																			 ref point             filter
				pDst[0] = (-8*pSrc[0] + 62*pSrc[15] + 228*pSrc[2*15] - 26*pSrc[3*15]) >> 8;					// 0	1	2	3	-8	62	228	-26
				pDst[15] = (-28*pSrc[15] + 212*pSrc[2*15] + 84*pSrc[3*15] - 12*pSrc[4*15]) >> 8;			// 1	2	3	4	-28	212	84	-12
				pDst[2*15] = (-4*pSrc[15] + 41*pSrc[2*15] + 241*pSrc[3*15] - 22*pSrc[4*15]) >> 8;			// 1	2	3	4	-4	41	241	-22
				pDst[3*15] = (-28*pSrc[2*15] + 194*pSrc[3*15] + 106*pSrc[4*15] - 16*pSrc[5*15]) >> 8;		// 2	3	4	5	-28	194	106	-16
				pDst[4*15] = (-2*pSrc[2*15] + 23*pSrc[3*15] + 251*pSrc[4*15] - 16*pSrc[5*15]) >> 8;			// 2	3	4	5	-2	23	251	-16
				pDst[5*15] = (-27*pSrc[3*15] + 174*pSrc[4*15] + 129*pSrc[5*15] - 20*pSrc[6*15]) >> 8;		// 3	4	5	6	-27	174	129	-20
				pDst[6*15] = (7*pSrc[4*15] + 255*pSrc[5*15] - 6*pSrc[6*15]) >> 8;							// 3	4	5	6	0	7	255	-6
				pDst[7*15] = (-24*pSrc[4*15] + 152*pSrc[5*15] + 152*pSrc[6*15] - 24*pSrc[7*15]) >> 8;		// 4	5	6	7	-24	152	152	-24
				pDst[8*15] = (-6*pSrc[5*15] + 255*pSrc[6*15] + 7*pSrc[7*15]) >> 8;							// 5	6	7	8	-6	255	7	0
				pDst[9*15] = (-20*pSrc[5*15] + 129*pSrc[6*15] + 174*pSrc[7*15] - 27*pSrc[8*15]) >> 8;		// 5	6	7	8	-20	129	174	-27
				pDst[10*15] = (-16*pSrc[6*15] + 251*pSrc[7*15] + 23*pSrc[8*15] - 2*pSrc[9*15]) >> 8;		// 6	7	8	9	-16	251	23	-2
				pDst[11*15] = (-16*pSrc[6*15] + 106*pSrc[7*15] + 194*pSrc[8*15] - 28*pSrc[9*15]) >> 8;		// 6	7	8	9	-16	106	194	-28
				pDst[12*15] = (-22*pSrc[7*15] + 241*pSrc[8*15] + 41*pSrc[9*15] - 4*pSrc[10*15]) >> 8;		// 7	8	9	10	-22	241	41	-4
				pDst[13*15] = (-12*pSrc[7*15] + 84*pSrc[8*15] + 212*pSrc[9*15] - 28*pSrc[10*15]) >> 8;		// 7	8	9	10	-12	84	212	-28
				pDst[14*15] = (-26*pSrc[8*15] + 228*pSrc[9*15] + 62*pSrc[10*15] - 8*pSrc[11*15]) >> 8;		// 8	9	10	11	-26	228	62	-8
			}
			// write a 16x16 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+15; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+15; xx++) {
					// clip to 10-bit unsigned integer
					int val = pBlock2[i];
					if (val > 1023) {
						pBuf[xx] = 1023;
					} else if (val < 0) {
						pBuf[xx] = 0;
					} else {
						pBuf[xx] = val;
					}
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_8to15_bicubic_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 15/8 using bicubic interpolation
// The sample location follows the resize() in OpenCV
// This is a fixed-point implementation
//   Ref Point			Filter * 256
// -2	-1	0	1	-8	62	228	-26
// -1	0	1	2	-28	212	84	-12
// -1	0	1	2	-4	41	241	-22
// 0	1	2	3	-28	194	106	-16
// 0	1	2	3	-2	23	251	-16
// 1	2	3	4	-27	174	129	-20
// 1	2	3	4	0	7	255	-6
// 2	3	4	5	-24	152	152	-24
// 3	4	5	6	-6	255	7	0
// 3	4	5	6	-20	129	174	-27
// 4	5	6	7	-16	251	23	-2
// 4	5	6	7	-16	106	194	-28
// 5	6	7	8	-22	241	41	-4
// 5	6	7	8	-12	84	212	-28
// 6	7	8	9	-26	228	62	-8
// 7	8	9	10	-8	62	228	-26
//
// Luhong Liang, IC-ASD, ASTRI
// April 29, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_8to15_bicubic_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*15 != iplDstImage->width*8 || iplSrcImage->height*15 != iplDstImage->height*8) {
		showErrMsg("Only support 8:15 upsampling in CImageUtility::resize_8to15_bicubic_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (15x15 block, step = 15, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[12*12];		// 12x12 block in source image (8 points + padding)
	int pBlock1[15*12];		// after interpolation in X direction
	int pBlock2[15*15];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=15, top+=8) {
		for (int x=0, left=0; x<iplDstImage->width; x+=15, left+=8) {
			// load a 12x12 block in source image (8x8 + padding)
			int i = 0;
			for (int yy=top; yy<top+12; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+12; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction (preserve 9 bits)
			for (int v=0; v<12; v++) {
				int *pSrc = pBlock + v * 12;
				int *pDst = pBlock1 + v * 15;
				// calculation		   														   ref point          filter
				pDst[0] = (-8*pSrc[0] + 62*pSrc[1] + 228*pSrc[2] - 26*pSrc[3]) >> 7;		// 0	1	2	3	-8	62	228	-26
				pDst[1] = (-28*pSrc[1] + 212*pSrc[2] + 84*pSrc[3] - 12*pSrc[4]) >> 7;		// 1	2	3	4	-28	212	84	-12
				pDst[2] = (-4*pSrc[1] + 41*pSrc[2] + 241*pSrc[3] - 22*pSrc[4]) >> 7;		// 1	2	3	4	-4	41	241	-22
				pDst[3] = (-28*pSrc[2] + 194*pSrc[3] + 106*pSrc[4] - 16*pSrc[5]) >> 7;		// 2	3	4	5	-28	194	106	-16
				pDst[4] = (-2*pSrc[2] + 23*pSrc[3] + 251*pSrc[4] - 16*pSrc[5]) >> 7;		// 2	3	4	5	-2	23	251	-16
				pDst[5] = (-27*pSrc[3] + 174*pSrc[4] + 129*pSrc[5] - 20*pSrc[6]) >> 7;		// 3	4	5	6	-27	174	129	-20
				pDst[6] = (7*pSrc[4] + 255*pSrc[5] - 6*pSrc[6]) >> 7;						// 3	4	5	6	0	7	255	-6
				pDst[7] = (-24*pSrc[4] + 152*pSrc[5] + 152*pSrc[6] - 24*pSrc[7]) >> 7;		// 4	5	6	7	-24	152	152	-24
				pDst[8] = (-6*pSrc[5] + 255*pSrc[6] + 7*pSrc[7]) >> 7;						// 5	6	7	8	-6	255	7	0
				pDst[9] = (-20*pSrc[5] + 129*pSrc[6] + 174*pSrc[7] - 27*pSrc[8]) >> 7;		// 5	6	7	8	-20	129	174	-27
				pDst[10] = (-16*pSrc[6] + 251*pSrc[7] + 23*pSrc[8] - 2*pSrc[9]) >> 7;		// 6	7	8	9	-16	251	23	-2
				pDst[11] = (-16*pSrc[6] + 106*pSrc[7] + 194*pSrc[8] - 28*pSrc[9]) >> 7;		// 6	7	8	9	-16	106	194	-28
				pDst[12] = (-22*pSrc[7] + 241*pSrc[8] + 41*pSrc[9] - 4*pSrc[10]) >> 7;		// 7	8	9	10	-22	241	41	-4
				pDst[13] = (-12*pSrc[7] + 84*pSrc[8] + 212*pSrc[9] - 28*pSrc[10]) >> 7;		// 7	8	9	10	-12	84	212	-28
				pDst[14] = (-26*pSrc[8] + 228*pSrc[9] + 62*pSrc[10] - 8*pSrc[11]) >> 7;		// 8	9	10	11	-26	228	62	-8
			}
			// interpolation in Y direction (preserve 9 bits)
			for (int u=0; u<15; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		   																			 ref point             filter
				pDst[0] = (-8*pSrc[0] + 62*pSrc[15] + 228*pSrc[2*15] - 26*pSrc[3*15]) >> 8;					// 0	1	2	3	-8	62	228	-26
				pDst[15] = (-28*pSrc[15] + 212*pSrc[2*15] + 84*pSrc[3*15] - 12*pSrc[4*15]) >> 8;			// 1	2	3	4	-28	212	84	-12
				pDst[2*15] = (-4*pSrc[15] + 41*pSrc[2*15] + 241*pSrc[3*15] - 22*pSrc[4*15]) >> 8;			// 1	2	3	4	-4	41	241	-22
				pDst[3*15] = (-28*pSrc[2*15] + 194*pSrc[3*15] + 106*pSrc[4*15] - 16*pSrc[5*15]) >> 8;		// 2	3	4	5	-28	194	106	-16
				pDst[4*15] = (-2*pSrc[2*15] + 23*pSrc[3*15] + 251*pSrc[4*15] - 16*pSrc[5*15]) >> 8;			// 2	3	4	5	-2	23	251	-16
				pDst[5*15] = (-27*pSrc[3*15] + 174*pSrc[4*15] + 129*pSrc[5*15] - 20*pSrc[6*15]) >> 8;		// 3	4	5	6	-27	174	129	-20
				pDst[6*15] = (7*pSrc[4*15] + 255*pSrc[5*15] - 6*pSrc[6*15]) >> 8;							// 3	4	5	6	0	7	255	-6
				pDst[7*15] = (-24*pSrc[4*15] + 152*pSrc[5*15] + 152*pSrc[6*15] - 24*pSrc[7*15]) >> 8;		// 4	5	6	7	-24	152	152	-24
				pDst[8*15] = (-6*pSrc[5*15] + 255*pSrc[6*15] + 7*pSrc[7*15]) >> 8;							// 5	6	7	8	-6	255	7	0
				pDst[9*15] = (-20*pSrc[5*15] + 129*pSrc[6*15] + 174*pSrc[7*15] - 27*pSrc[8*15]) >> 8;		// 5	6	7	8	-20	129	174	-27
				pDst[10*15] = (-16*pSrc[6*15] + 251*pSrc[7*15] + 23*pSrc[8*15] - 2*pSrc[9*15]) >> 8;		// 6	7	8	9	-16	251	23	-2
				pDst[11*15] = (-16*pSrc[6*15] + 106*pSrc[7*15] + 194*pSrc[8*15] - 28*pSrc[9*15]) >> 8;		// 6	7	8	9	-16	106	194	-28
				pDst[12*15] = (-22*pSrc[7*15] + 241*pSrc[8*15] + 41*pSrc[9*15] - 4*pSrc[10*15]) >> 8;		// 7	8	9	10	-22	241	41	-4
				pDst[13*15] = (-12*pSrc[7*15] + 84*pSrc[8*15] + 212*pSrc[9*15] - 28*pSrc[10*15]) >> 8;		// 7	8	9	10	-12	84	212	-28
				pDst[14*15] = (-26*pSrc[8*15] + 228*pSrc[9*15] + 62*pSrc[10*15] - 8*pSrc[11*15]) >> 8;		// 8	9	10	11	-26	228	62	-8
			}
			// write a 16x16 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+15; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+15; xx++) {
					// rounding and clipping
					int val = pBlock2[i];
					pBuf[xx] = rndclp_9Uto8U(val);
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_8to15_cublin_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 15/8 using bicubic interpolation in X direction and bilinear interpolation in Y direction
// The sample location follows the resize() in OpenCV
// This is a fixed-point implementation
//   Ref Point			Filter * 256
// Bicubic filter:
// -2	-1	0	1	-8	62	228	-26
// -1	0	1	2	-28	212	84	-12
// -1	0	1	2	-4	41	241	-22
// 0	1	2	3	-28	194	106	-16
// 0	1	2	3	-2	23	251	-16
// 1	2	3	4	-27	174	129	-20
// 1	2	3	4	0	7	255	-6
// 2	3	4	5	-24	152	152	-24
// 3	4	5	6	-6	255	7	0
// 3	4	5	6	-20	129	174	-27
// 4	5	6	7	-16	251	23	-2
// 4	5	6	7	-16	106	194	-28
// 5	6	7	8	-22	241	41	-4
// 5	6	7	8	-12	84	212	-28
// 6	7	8	9	-26	228	62	-8
// 7	8	9	10	-8	62	228	-26
// Bilinear filter:
// -1	0			60	196
// 0	1			179	77
// 0	1			43	213
// 1	2			162	94
// 1	2			26	230
// 2	3			145	111
// 2	3			9	247
// 3	4			128	128
// 4	5			247	9
// 4	5			111	145
// 5	6			230	26
// 5	6			94	162
// 6	7			213	43
// 6	7			77	179
// 7	8			196	60
//
// Luhong Liang, IC-ASD, ASTRI
// Mar. 21, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_8to15_cublin_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*15 != iplDstImage->width*8 || iplSrcImage->height*15 != iplDstImage->height*8) {
		showErrMsg("Only support 8:15 upsampling in CImageUtility::resize_8to15_cublin_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (15x15 block, step = 15, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[12*10];		// 12x10 block in source image (8 points + padding)
	int pBlock1[15*10];		// after interpolation in X direction
	int pBlock2[15*15];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=15, top+=8) {
		for (int x=0, left=0; x<iplDstImage->width; x+=15, left+=8) {
			// load a 12x10 block in source image (8x8 + padding)
			int i = 0;
			for (int yy=top; yy<top+10; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+12; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// bicubic interpolation in X direction
			for (int v=0; v<10; v++) {
				int *pSrc = pBlock + v * 12;
				int *pDst = pBlock1 + v * 15;
				// calculation		   														   ref point          filter
				pDst[0] = (-8*pSrc[0] + 62*pSrc[1] + 228*pSrc[2] - 26*pSrc[3]) >> 6;		// 0	1	2	3	-8	62	228	-26
				pDst[1] = (-28*pSrc[1] + 212*pSrc[2] + 84*pSrc[3] - 12*pSrc[4]) >> 6;		// 1	2	3	4	-28	212	84	-12
				pDst[2] = (-4*pSrc[1] + 41*pSrc[2] + 241*pSrc[3] - 22*pSrc[4]) >> 6;		// 1	2	3	4	-4	41	241	-22
				pDst[3] = (-28*pSrc[2] + 194*pSrc[3] + 106*pSrc[4] - 16*pSrc[5]) >> 6;		// 2	3	4	5	-28	194	106	-16
				pDst[4] = (-2*pSrc[2] + 23*pSrc[3] + 251*pSrc[4] - 16*pSrc[5]) >> 6;			// 2	3	4	5	-2	23	251	-16
				pDst[5] = (-27*pSrc[3] + 174*pSrc[4] + 129*pSrc[5] - 20*pSrc[6]) >> 6;		// 3	4	5	6	-27	174	129	-20
				pDst[6] = (7*pSrc[4] + 255*pSrc[5] - 6*pSrc[6]) >> 6;						// 3	4	5	6	0	7	255	-6
				pDst[7] = (-24*pSrc[4] + 152*pSrc[5] + 152*pSrc[6] - 24*pSrc[7]) >> 6;		// 4	5	6	7	-24	152	152	-24
				pDst[8] = (-6*pSrc[5] + 255*pSrc[6] + 7*pSrc[7]) >> 6;						// 5	6	7	8	-6	255	7	0
				pDst[9] = (-20*pSrc[5] + 129*pSrc[6] + 174*pSrc[7] - 27*pSrc[8]) >> 6;		// 5	6	7	8	-20	129	174	-27
				pDst[10] = (-16*pSrc[6] + 251*pSrc[7] + 23*pSrc[8] - 2*pSrc[9]) >> 6;		// 6	7	8	9	-16	251	23	-2
				pDst[11] = (-16*pSrc[6] + 106*pSrc[7] + 194*pSrc[8] - 28*pSrc[9]) >> 6;		// 6	7	8	9	-16	106	194	-28
				pDst[12] = (-22*pSrc[7] + 241*pSrc[8] + 41*pSrc[9] - 4*pSrc[10]) >> 6;		// 7	8	9	10	-22	241	41	-4
				pDst[13] = (-12*pSrc[7] + 84*pSrc[8] + 212*pSrc[9] - 28*pSrc[10]) >> 6;		// 7	8	9	10	-12	84	212	-28
				pDst[14] = (-26*pSrc[8] + 228*pSrc[9] + 62*pSrc[10] - 8*pSrc[11]) >> 6;		// 8	9	10	11	-26	228	62	-8
			}
			// bilinear interpolation in Y direction
			for (int u=0; u<15; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		 									 ref point          filter
				pDst[0] = (60*pSrc[0] + 196*pSrc[15]) >> 9;				// -1	0			60	196
				pDst[15] = (179*pSrc[15] + 77*pSrc[2*15]) >> 9;			// 0	1			179	77
				pDst[2*15] = (43*pSrc[15] + 213*pSrc[2*15]) >> 9;		// 0	1			43	213
				pDst[3*15] = (162*pSrc[2*15] + 94*pSrc[3*15]) >> 9;		// 1	2			162	94
				pDst[4*15] = (26*pSrc[2*15] + 230*pSrc[3*15]) >> 9;		// 1	2			26	230
				pDst[5*15] = (145*pSrc[3*15] + 111*pSrc[4*15]) >> 9;	// 2	3			145	111
				pDst[6*15] = (9*pSrc[3*15] + 247*pSrc[4*15]) >> 9;		// 2	3			9	247
				pDst[7*15] = (128*pSrc[4*15] + 128*pSrc[5*15]) >> 9;	// 3	4			128	128
				pDst[8*15] = (247*pSrc[5*15] + 9*pSrc[6*15]) >> 9;		// 4	5			247	9
				pDst[9*15] = (111*pSrc[5*15] + 145*pSrc[6*15]) >> 9;	// 4	5			111	145
				pDst[10*15] = (230*pSrc[6*15] + 26*pSrc[7*15]) >> 9;	// 5	6			230	26
				pDst[11*15] = (94*pSrc[6*15] + 162*pSrc[7*15]) >> 9;	// 5	6			94	162
				pDst[12*15] = (213*pSrc[7*15] + 43*pSrc[8*15]) >> 9;	// 6	7			213	43
				pDst[13*15] = (77*pSrc[7*15] + 179*pSrc[8*15]) >> 9;	// 6	7			77	179
				pDst[14*15] = (196*pSrc[8*15] + 60*pSrc[9*15]) >> 9;	// 7	8			196	60
			}
			// write a 16x16 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+15; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+15; xx++) {
					int val = pBlock2[i];
					// to 8-bit
					val = ((val&0x0001)==0) ? (val>>1) : ((val>>1)+1);
					// clipping
					pBuf[xx] = (unsigned char)clip_0_255(val);
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_8to15_cublin_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float clip_low, float clip_high)
// Resize the image to 15/8 using bicubic interpolation in X direction and bilinear interpolation in Y direction
// The sample location follows the resize() in OpenCV
// This is a fixed-point implementation
//   Ref Point			Filter * 256
// Bicubic filter:
// -2	-1	0	1	-8	62	228	-26
// -1	0	1	2	-28	212	84	-12
// -1	0	1	2	-4	41	241	-22
// 0	1	2	3	-28	194	106	-16
// 0	1	2	3	-2	23	251	-16
// 1	2	3	4	-27	174	129	-20
// 1	2	3	4	0	7	255	-6
// 2	3	4	5	-24	152	152	-24
// 3	4	5	6	-6	255	7	0
// 3	4	5	6	-20	129	174	-27
// 4	5	6	7	-16	251	23	-2
// 4	5	6	7	-16	106	194	-28
// 5	6	7	8	-22	241	41	-4
// 5	6	7	8	-12	84	212	-28
// 6	7	8	9	-26	228	62	-8
// 7	8	9	10	-8	62	228	-26
// Bilinear filter:
// -1	0			60	196
// 0	1			179	77
// 0	1			43	213
// 1	2			162	94
// 1	2			26	230
// 2	3			145	111
// 2	3			9	247
// 3	4			128	128
// 4	5			247	9
// 4	5			111	145
// 5	6			230	26
// 5	6			94	162
// 6	7			213	43
// 6	7			77	179
// 7	8			196	60
//
// Luhong Liang, IC-ASD, ASTRI
// Mar. 21, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::resize_8to15_cublin_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*15 != iplDstImage->width*8 || iplSrcImage->height*15 != iplDstImage->height*8) {
		showErrMsg("Only support 8:15 upsampling in CImageUtility::resize_8to15_cublin_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (15x15 block, step = 15, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	float pBlock[12*10];		// 12x10 block in source image (8 points + padding)
	float pBlock1[15*10];		// after interpolation in X direction
	float pBlock2[15*15];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=15, top+=8) {
		for (int x=0, left=0; x<iplDstImage->width; x+=15, left+=8) {
			// load a 12x10 block in source image (8x8 + padding)
			int i = 0;
			for (int yy=top; yy<top+10; yy++) {
				float *pBuf = (float *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+12; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// bicubic interpolation in X direction
			for (int v=0; v<10; v++) {
				float *pSrc = pBlock + v * 12;
				float *pDst = pBlock1 + v * 15;
				// calculation		   														   ref point          filter
				pDst[0] = (-8*pSrc[0] + 62*pSrc[1] + 228*pSrc[2] - 26*pSrc[3]);			// 0	1	2	3	-8	62	228	-26
				pDst[1] = (-28*pSrc[1] + 212*pSrc[2] + 84*pSrc[3] - 12*pSrc[4]);		// 1	2	3	4	-28	212	84	-12
				pDst[2] = (-4*pSrc[1] + 41*pSrc[2] + 241*pSrc[3] - 22*pSrc[4]);			// 1	2	3	4	-4	41	241	-22
				pDst[3] = (-28*pSrc[2] + 194*pSrc[3] + 106*pSrc[4] - 16*pSrc[5]);		// 2	3	4	5	-28	194	106	-16
				pDst[4] = (-2*pSrc[2] + 23*pSrc[3] + 251*pSrc[4] - 16*pSrc[5]);			// 2	3	4	5	-2	23	251	-16
				pDst[5] = (-27*pSrc[3] + 174*pSrc[4] + 129*pSrc[5] - 20*pSrc[6]);		// 3	4	5	6	-27	174	129	-20
				pDst[6] = (7*pSrc[4] + 255*pSrc[5] - 6*pSrc[6]);						// 3	4	5	6	0	7	255	-6
				pDst[7] = (-24*pSrc[4] + 152*pSrc[5] + 152*pSrc[6] - 24*pSrc[7]);		// 4	5	6	7	-24	152	152	-24
				pDst[8] = (-6*pSrc[5] + 255*pSrc[6] + 7*pSrc[7]);						// 5	6	7	8	-6	255	7	0
				pDst[9] = (-20*pSrc[5] + 129*pSrc[6] + 174*pSrc[7] - 27*pSrc[8]);		// 5	6	7	8	-20	129	174	-27
				pDst[10] = (-16*pSrc[6] + 251*pSrc[7] + 23*pSrc[8] - 2*pSrc[9]);		// 6	7	8	9	-16	251	23	-2
				pDst[11] = (-16*pSrc[6] + 106*pSrc[7] + 194*pSrc[8] - 28*pSrc[9]);		// 6	7	8	9	-16	106	194	-28
				pDst[12] = (-22*pSrc[7] + 241*pSrc[8] + 41*pSrc[9] - 4*pSrc[10]);		// 7	8	9	10	-22	241	41	-4
				pDst[13] = (-12*pSrc[7] + 84*pSrc[8] + 212*pSrc[9] - 28*pSrc[10]);		// 7	8	9	10	-12	84	212	-28
				pDst[14] = (-26*pSrc[8] + 228*pSrc[9] + 62*pSrc[10] - 8*pSrc[11]);		// 8	9	10	11	-26	228	62	-8
			}
			// bilinear interpolation in Y direction
			for (int u=0; u<15; u++) {
				float *pSrc = pBlock1 + u;
				float *pDst = pBlock2 + u;
				// calculation		 													ref point          filter
				pDst[0] = (60*pSrc[0] + 196*pSrc[15]) / (256.0f * 256.0f);				// -1	0			60	196
				pDst[15] = (179*pSrc[15] + 77*pSrc[2*15]) / (256.0f * 256.0f);			// 0	1			179	77
				pDst[2*15] = (43*pSrc[15] + 213*pSrc[2*15]) / (256.0f * 256.0f);		// 0	1			43	213
				pDst[3*15] = (162*pSrc[2*15] + 94*pSrc[3*15]) / (256.0f * 256.0f);		// 1	2			162	94
				pDst[4*15] = (26*pSrc[2*15] + 230*pSrc[3*15]) / (256.0f * 256.0f);		// 1	2			26	230
				pDst[5*15] = (145*pSrc[3*15] + 111*pSrc[4*15]) / (256.0f * 256.0f);		// 2	3			145	111
				pDst[6*15] = (9*pSrc[3*15] + 247*pSrc[4*15]) / (256.0f * 256.0f);		// 2	3			9	247
				pDst[7*15] = (128*pSrc[4*15] + 128*pSrc[5*15]) / (256.0f * 256.0f);		// 3	4			128	128
				pDst[8*15] = (247*pSrc[5*15] + 9*pSrc[6*15]) / (256.0f * 256.0f);		// 4	5			247	9
				pDst[9*15] = (111*pSrc[5*15] + 145*pSrc[6*15]) / (256.0f * 256.0f);		// 4	5			111	145
				pDst[10*15] = (230*pSrc[6*15] + 26*pSrc[7*15]) / (256.0f * 256.0f);		// 5	6			230	26
				pDst[11*15] = (94*pSrc[6*15] + 162*pSrc[7*15]) / (256.0f * 256.0f);		// 5	6			94	162
				pDst[12*15] = (213*pSrc[7*15] + 43*pSrc[8*15]) / (256.0f * 256.0f);		// 6	7			213	43
				pDst[13*15] = (77*pSrc[7*15] + 179*pSrc[8*15]) / (256.0f * 256.0f);		// 6	7			77	179
				pDst[14*15] = (196*pSrc[8*15] + 60*pSrc[9*15]) / (256.0f * 256.0f);		// 7	8			196	60
			}
			// write a 16x16 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+15; yy++) {
				float *pBuf = (float *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+15; xx++) {
					float val = pBlock2[i];
					// clipping
					val = val < clip_low ? clip_low : val;
					pBuf[xx] = val > clip_high ? clip_high : val;
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_8to15_bilinear_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 15/8 using bilinear interpolation
// The sample location follows the resize() in OpenCV
// This is a fixed-point implementation
// Ref Point		Filter * 256
// -1	0			60	196
// 0	1			179	77
// 0	1			43	213
// 1	2			162	94
// 1	2			26	230
// 2	3			145	111
// 2	3			9	247
// 3	4			128	128
// 4	5			247	9
// 4	5			111	145
// 5	6			230	26
// 5	6			94	162
// 6	7			213	43
// 6	7			77	179
// 7	8			196	60
//
// Luhong Liang, IC-ASD, ASTRI
// Mar. 21, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_8to15_bilinear_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*15 != iplDstImage->width*8 || iplSrcImage->height*15 != iplDstImage->height*8) {
		showErrMsg("Only support 8:15 upsampling in CImageUtility::resize_8to15_bilinear_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (15x15 block, step = 15, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[10*10];		// 10x10 block in source image (8 points + padding)
	int pBlock1[15*10];		// after interpolation in X direction
	int pBlock2[15*15];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=15, top+=8) {
		for (int x=0, left=0; x<iplDstImage->width; x+=15, left+=8) {
			// load a 10x10 block in source image (8x8 + padding)
			int i = 0;
			for (int yy=top; yy<top+10; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+10; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<10; v++) {
				int *pSrc = pBlock + v * 10;
				int *pDst = pBlock1 + v * 15;
				// calculation		   					     ref point          filter
				pDst[0] = (60*pSrc[0] + 196*pSrc[1]) >> 6;	// -1	0			60	196
				pDst[1] = (179*pSrc[1] + 77*pSrc[2]) >> 6;	// 0	1			179	77
				pDst[2] = (43*pSrc[1] + 213*pSrc[2]) >> 6;	// 0	1			43	213
				pDst[3] = (162*pSrc[2] + 94*pSrc[3]) >> 6;	// 1	2			162	94
				pDst[4] = (26*pSrc[2] + 230*pSrc[3]) >> 6;	// 1	2			26	230
				pDst[5] = (145*pSrc[3] + 111*pSrc[4]) >> 6;	// 2	3			145	111
				pDst[6] = (9*pSrc[3] + 247*pSrc[4]) >> 6;	// 2	3			9	247
				pDst[7] = (128*pSrc[4] + 128*pSrc[5]) >> 6;	// 3	4			128	128
				pDst[8] = (247*pSrc[5] + 9*pSrc[6]) >> 6;	// 4	5			247	9
				pDst[9] = (111*pSrc[5] + 145*pSrc[6]) >> 6;	// 4	5			111	145
				pDst[10] = (230*pSrc[6] + 26*pSrc[7]) >> 6;	// 5	6			230	26
				pDst[11] = (94*pSrc[6] + 162*pSrc[7]) >> 6;	// 5	6			94	162
				pDst[12] = (213*pSrc[7] + 43*pSrc[8]) >> 6;	// 6	7			213	43
				pDst[13] = (77*pSrc[7] + 179*pSrc[8]) >> 6;	// 6	7			77	179
				pDst[14] = (196*pSrc[8] + 60*pSrc[9]) >> 6;	// 7	8			196	60
			}
			// interpolation in Y direction
			for (int u=0; u<15; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		 									 ref point          filter
				pDst[0] = (60*pSrc[0] + 196*pSrc[15]) >> 9;				// -1	0			60	196
				pDst[15] = (179*pSrc[15] + 77*pSrc[2*15]) >> 9;			// 0	1			179	77
				pDst[2*15] = (43*pSrc[15] + 213*pSrc[2*15]) >> 9;		// 0	1			43	213
				pDst[3*15] = (162*pSrc[2*15] + 94*pSrc[3*15]) >> 9;		// 1	2			162	94
				pDst[4*15] = (26*pSrc[2*15] + 230*pSrc[3*15]) >> 9;		// 1	2			26	230
				pDst[5*15] = (145*pSrc[3*15] + 111*pSrc[4*15]) >> 9;	// 2	3			145	111
				pDst[6*15] = (9*pSrc[3*15] + 247*pSrc[4*15]) >> 9;		// 2	3			9	247
				pDst[7*15] = (128*pSrc[4*15] + 128*pSrc[5*15]) >> 9;	// 3	4			128	128
				pDst[8*15] = (247*pSrc[5*15] + 9*pSrc[6*15]) >> 9;		// 4	5			247	9
				pDst[9*15] = (111*pSrc[5*15] + 145*pSrc[6*15]) >> 9;	// 4	5			111	145
				pDst[10*15] = (230*pSrc[6*15] + 26*pSrc[7*15]) >> 9;	// 5	6			230	26
				pDst[11*15] = (94*pSrc[6*15] + 162*pSrc[7*15]) >> 9;	// 5	6			94	162
				pDst[12*15] = (213*pSrc[7*15] + 43*pSrc[8*15]) >> 9;	// 6	7			213	43
				pDst[13*15] = (77*pSrc[7*15] + 179*pSrc[8*15]) >> 9;	// 6	7			77	179
				pDst[14*15] = (196*pSrc[8*15] + 60*pSrc[9*15]) >> 9;	// 7	8			196	60
			}
			// write a 16x16 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+15; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+15; xx++) {
					int val = pBlock2[i];
					// to 8-bit
					val = ((val&0x0001)==0) ? (val>>1) : ((val>>1)+1);
					// clipping
                    pBuf[xx] = (unsigned char)clip_0_255(val);
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_2to1_bilinear_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize image to 1/2 using bicubic interpolation
// The sample locations are (1-D) as example:
//				0     1     2     3      4
//                 *           *      
// The filter for new pixel '*' is (1, 1)
//
// Luhong Liang, IC-ASD, ASTRI
// May. 30, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::resize_2to1_bilinear_32f()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height*2) {
		showErrMsg("Only support 2:1 downsampling in CImageUtility::resize_2to1_bilinear_32f()!\n");
		return false;
	}

	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	float *pLine = new float[iplSrcImage->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_2to1_bilinear_32f()!\n");
	}
	for (int y=0, top=0; y<iplDstImage->height; y++, top+=2) {
		float *pBuf0 = (float *)(iplSrcImage->imageData + top * iplSrcImage->widthStep);
		float *pBuf1 = (float *)(iplSrcImage->imageData + (top+1) * iplSrcImage->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcImage->width; x++) {
			pLine[x] = pBuf0[x] + pBuf1[x];
		}
		// interpolation in X direction
		float *pDst = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x++, left+=2) {
			pDst[x] = (pLine[left] + pLine[left+1]) * 0.25f;
		}
	}

	delete [] pLine;

	return true;
}

bool CImageUtility::resize_2to1_bilinear_int(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize image to 1/2 using bicubic interpolation
// The sample locations are (1-D) as example:
//				0     1     2     3      4
//                 *           *      
// The filter for new pixel '*' is (1, 1)
//
// Luhong Liang, IC-ASD, ASTRI
// Feb. 7, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_2to1_bilinear_int()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height*2) {
		showErrMsg("Only support 2:1 downsampling in CImageUtility::resize_2to1_bilinear_int()!\n");
		return false;
	}

	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcImage->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_2to1_bilinear_int()!\n");
	}
	for (int y=0, top=0; y<iplDstImage->height; y++, top+=2) {
		int *pBuf0 = (int *)(iplSrcImage->imageData + top * iplSrcImage->widthStep);
		int *pBuf1 = (int *)(iplSrcImage->imageData + (top+1) * iplSrcImage->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcImage->width; x++) {
			pLine[x] = pBuf0[x] + pBuf1[x];
		}
		// interpolation in X direction
		int *pDst = (int *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x++, left+=2) {
			pDst[x] = (pLine[left] + pLine[left+1]) >> 2;
		}
	}

	delete [] pLine;

	return true;
}

bool CImageUtility::resize_2to1_bilinear_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize image to 1/2 using bicubic interpolation
// The sample locations are (1-D) as example:
//				0     1     2     3      4
//                 *           *      
// The filter for new pixel '*' is (1, 1)
//
// Luhong Liang, IC-ASD, ASTRI
// Feb. 7, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_2to1_bilinear_8U()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height*2) {
		showErrMsg("Only support 2:1 downsampling in CImageUtility::resize_2to1_bilinear_8U()!\n");
		return false;
	}

	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcImage->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_2to1_bilinear_8U()!\n");
		return false;
	}
	for (int y=0, top=0; y<iplDstImage->height; y++, top+=2) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcImage->imageData + top * iplSrcImage->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcImage->imageData + (top+1) * iplSrcImage->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcImage->width; x++) {
			pLine[x] = pBuf0[x] + pBuf1[x];
		}
		// interpolation in X direction
		unsigned char *pDst = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x++, left+=2) {
			int val = (pLine[left] + pLine[left+1]) >> 1;
			// rounding and clipping
			val = ((val&0x0001) == 0) ? (val>>1) : ((val>>1)+1);    // will never overflow
			pDst[x] = (unsigned char)val;
		}
	}

	delete [] pLine;

	return true;
}

bool CImageUtility::resize_2to1_bilinear_16U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize image to 1/2 using bicubic interpolation
// The sample locations are (1-D) as example:
//				0     1     2     3      4
//                 *           *       
// The filter for new pixel '*' is (1, 1)
//
// Luhong Liang, IC-ASD, ASTRI
// Sept. 17, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_16U || iplDstImage->depth != SR_DEPTH_16U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_2to1_bilinear_16U()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height*2) {
		showErrMsg("Only support 2:1 downsampling in CImageUtility::resize_2to1_bilinear_16U()!\n");
		return false;
	}

	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	unsigned int *pLine = new unsigned int[iplSrcImage->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_2to1_bilinear_16U()!\n");
		return false;
	}
	for (int y=0, top=0; y<iplDstImage->height; y++, top+=2) {
		unsigned short *pBuf0 = (unsigned short *)(iplSrcImage->imageData + top * iplSrcImage->widthStep);
		unsigned short *pBuf1 = (unsigned short *)(iplSrcImage->imageData + (top+1) * iplSrcImage->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcImage->width; x++) {
			pLine[x] = pBuf0[x] + pBuf1[x];
		}
		// interpolation in X direction
		unsigned short *pDst = (unsigned short *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x++, left+=2) {
			unsigned int val = (pLine[left] + pLine[left+1]) >> 1;
			// rounding and clipping
			val = ((val&0x0001) == 0) ? (val>>1) : ((val>>1)+1);        // will never overflow
			pDst[x] = (unsigned short)val;
		}
	}

	delete [] pLine;

	return true;
}

bool CImageUtility::resize_2to1_bicubic_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// downsample the image 1/2 using bicubic
// The sample locations are (1-D) as example:
// Idnex     -3      -2     -1    0     1      2     3     4     5     6
// Point                             *            *
// Filter    -3      -9     29   111   111    29    -9    -3				(bicubic, used)
//			 -1      -2      7    28    28     7    -2    -1				(bicubic, backup)
//			 -2     -11     30   111   111    30   -11    -2				(lanczos 2)
//  1    4   -9     -17     35   114   114    35   -17    -9     4     1	(lanczos 3) 
// Luhong Liang, IC-ASD, ASTRI
// March. 6, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_2to1_bicubic_8U()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height*2) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_2to1_bicubic_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 3, 3, 3, 3);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_2to1_bicubic_8U()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	for (int y=0, top=0; y<iplDstImage->height; y++, top+=2) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		unsigned char *pBuf2 = (unsigned char *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		unsigned char *pBuf3 = (unsigned char *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
		unsigned char *pBuf4 = (unsigned char *)(iplSrcPad->imageData + (top+4) * iplSrcPad->widthStep);
		unsigned char *pBuf5 = (unsigned char *)(iplSrcPad->imageData + (top+5) * iplSrcPad->widthStep);
		unsigned char *pBuf6 = (unsigned char *)(iplSrcPad->imageData + (top+6) * iplSrcPad->widthStep);
		unsigned char *pBuf7 = (unsigned char *)(iplSrcPad->imageData + (top+7) * iplSrcPad->widthStep);
		unsigned char *pDst = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			//  -3      -9     29   111   111    29    -9    -3
			pLine[x] = (- 3 * (int)(pBuf0[x]) - 9 * (int)(pBuf1[x]) + 29 * (int)(pBuf2[x]) + 111 * (int)(pBuf3[x]) 
					    - 3 * (int)(pBuf7[x]) - 9 * (int)(pBuf6[x]) + 29 * (int)(pBuf5[x]) + 111 * (int)(pBuf4[x])) >> 6;
			// pLine[x] --- 12-bit signed
		}
		// interpolation in X direction
		for (int x=0, left=0; x<iplDstImage->width; x++, left+=2) {
			//  -3      -9     29   111   111    29    -9    -3
			int pix = (- 3 * (int)(pLine[left])   - 9 * (int)(pLine[left+1]) + 29 * (int)(pLine[left+2]) + 111 * (int)(pLine[left+3]) 
					   - 3 * (int)(pLine[left+7]) - 9 * (int)(pLine[left+6]) + 29 * (int)(pLine[left+5]) + 111 * (int)(pLine[left+4])) >> 9;
			// pix --- 12-bit siged
			// rounding to 8-bit and clipping
			pix = ((pix&0x0001) == 0) ? (pix>>1) : ((pix>>1) + 1);
			pix = pix < 0 ? 0 : pix;
			pix = pix > 255 ? 255 : pix;
			pDst[x] = (unsigned char)pix;
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_2to1_lanczos2_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// downsample the image 1/2 using bicubic
// The sample locations are (1-D) as example:
// Idnex     -3      -2     -1    0     1      2     3     4     5     6
// Point                             *            *
// Filter    -3      -9     29   111   111    29    -9    -3				(bicubic, used)
//			 -1      -2      7    28    28     7    -2    -1				(bicubic, backup)
//			 -2     -11     30   111   111    30   -11    -2				(lanczos 2)
//  1    4   -9     -17     35   114   114    35   -17    -9     4     1	(lanczos 3) 
// Luhong Liang, IC-ASD, ASTRI
// March. 6, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_2to1_lanczos2_8U()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height*2) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_2to1_lanczos2_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 3, 3, 3, 3);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_2to1_lanczos2_8U()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	for (int y=0, top=0; y<iplDstImage->height; y++, top+=2) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		unsigned char *pBuf2 = (unsigned char *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		unsigned char *pBuf3 = (unsigned char *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
		unsigned char *pBuf4 = (unsigned char *)(iplSrcPad->imageData + (top+4) * iplSrcPad->widthStep);
		unsigned char *pBuf5 = (unsigned char *)(iplSrcPad->imageData + (top+5) * iplSrcPad->widthStep);
		unsigned char *pBuf6 = (unsigned char *)(iplSrcPad->imageData + (top+6) * iplSrcPad->widthStep);
		unsigned char *pBuf7 = (unsigned char *)(iplSrcPad->imageData + (top+7) * iplSrcPad->widthStep);
		unsigned char *pDst = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			// -2     -11     30   111   111    30   -11    -2
			pLine[x] = (- 2 * (int)(pBuf0[x]) - 11 * (int)(pBuf1[x]) + 30 * (int)(pBuf2[x]) + 111 * (int)(pBuf3[x]) 
					    - 2 * (int)(pBuf7[x]) - 11 * (int)(pBuf6[x]) + 30 * (int)(pBuf5[x]) + 111 * (int)(pBuf4[x])) >> 6;
			// pLine[x] --- 12-bit signed
		}
		// interpolation in X direction
		for (int x=0, left=0; x<iplDstImage->width; x++, left+=2) {
			// -2     -11     30   111   111    30   -11    -2
			int pix = (- 2 * (int)(pLine[left])   - 11 * (int)(pLine[left+1]) + 30 * (int)(pLine[left+2]) + 111 * (int)(pLine[left+3]) 
					   - 2 * (int)(pLine[left+7]) - 11 * (int)(pLine[left+6]) + 30 * (int)(pLine[left+5]) + 111 * (int)(pLine[left+4])) >> 9;
			// pix --- 12-bit siged
			// rounding to 8-bit and clipping
			pix = ((pix&0x0001) == 0) ? (pix>>1) : ((pix>>1) + 1);
			pix = pix < 0 ? 0 : pix;
			pix = pix > 255 ? 255 : pix;
			pDst[x] = (unsigned char)pix;
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_2to1_lanczos3_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// downsample the image 1/2 using bicubic
// The sample locations are (1-D) as example:
// Idnex     -3      -2     -1    0     1      2     3     4     5     6
// Point                             *            *
// Filter    -3      -9     29   111   111    29    -9    -3				(bicubic, used)
//			 -1      -2      7    28    28     7    -2    -1				(bicubic, backup)
//			 -2     -11     30   111   111    30   -11    -2				(lanczos 2)
//  1    4   -9     -17     35   114   114    35   -17    -9     4     1	(lanczos 3) 
// Luhong Liang, IC-ASD, ASTRI
// March. 6, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_2to1_lanczos3_8U()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height*2) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_2to1_lanczos3_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 5, 5, 5, 5);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_2to1_lanczos3_8U()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	for (int y=0, top=0; y<iplDstImage->height; y++, top+=2) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		unsigned char *pBuf2 = (unsigned char *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		unsigned char *pBuf3 = (unsigned char *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
		unsigned char *pBuf4 = (unsigned char *)(iplSrcPad->imageData + (top+4) * iplSrcPad->widthStep);
		unsigned char *pBuf5 = (unsigned char *)(iplSrcPad->imageData + (top+5) * iplSrcPad->widthStep);
		unsigned char *pBuf6 = (unsigned char *)(iplSrcPad->imageData + (top+6) * iplSrcPad->widthStep);
		unsigned char *pBuf7 = (unsigned char *)(iplSrcPad->imageData + (top+7) * iplSrcPad->widthStep);
		unsigned char *pBuf8 = (unsigned char *)(iplSrcPad->imageData + (top+8) * iplSrcPad->widthStep);
		unsigned char *pBuf9 = (unsigned char *)(iplSrcPad->imageData + (top+9) * iplSrcPad->widthStep);
		unsigned char *pBuf10 = (unsigned char *)(iplSrcPad->imageData + (top+10) * iplSrcPad->widthStep);
		unsigned char *pBuf11 = (unsigned char *)(iplSrcPad->imageData + (top+11) * iplSrcPad->widthStep);
		unsigned char *pDst = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			// 1    4   -9     -17     35   114   114    35   -17    -9     4     1
			pLine[x] = ( (int)pBuf0[x]  + 4*(int)pBuf1[x]  - 9*(int)pBuf2[x] - 17*(int)pBuf3[x] + 35*(int)pBuf4[x] + 114*(int)pBuf5[x] +
					     (int)pBuf11[x] + 4*(int)pBuf10[x] - 9*(int)pBuf9[x] - 17*(int)pBuf8[x] + 35*(int)pBuf7[x] + 114*(int)pBuf6[x] ) >> 6;
			// pLine[x] --- 12-bit signed
		}
		// interpolation in X direction
		for (int x=0, left=0; x<iplDstImage->width; x++, left+=2) {
			// 1    4   -9     -17     35   114   114    35   -17    -9     4     1
			int pix = ( (int)pLine[left]    + 4*(int)pLine[left+1]  - 9*(int)pLine[left+2] - 17*(int)pLine[left+3] + 35*(int)pLine[left+4] + 114*(int)pLine[left+5] +
					    (int)pLine[left+11] + 4*(int)pLine[left+10] - 9*(int)pLine[left+9] - 17*(int)pLine[left+8] + 35*(int)pLine[left+7] + 114*(int)pLine[left+6] ) >> 9;
			// pix --- 12-bit siged
			// rounding to 8-bit and clipping
			pix = ((pix&0x0001) == 0) ? (pix>>1) : ((pix>>1) + 1);
			pix = pix < 0 ? 0 : pix;
			pix = pix > 255 ? 255 : pix;
			pDst[x] = (unsigned char)pix;
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_2to1_enc4_8U(IplImage *iplSrcImage, IplImage *iplDstImage, unsigned char opt_code)
// downsample the image 1/2 using bicubic
// The sample locations are (1-D) as example:
//	opt_code -- option code of this module, lower 4 bits used:
//			bits:	|			3			|			2			|			1			|			0			|
//					|   options for compatible mode downsampling	|		options for effectiveness tuning        |
//					| 0-bilinear (default); 1-/w sharpening;        |        0~2(attenuationin backprojection)      | 
//					| 2-/w more sharpening                          |        0(default, full-functional)            |   <--- effective
//                  |           1           |           1           |            1          |           1           |   <--- bypass
// (opt_code>>2)       Filter                 shift
//    0               8     8                   4
//    1         -1    9     9     -1            4
//    2         -1    5     5     -1			3		(bicubic upsample filter)
//	Argument:
//		opt_code: 0x00 -- bilinear downsample (default); 0x01 -- downsample with slight sharpening;  0x02 -- downsample with more sharpening 
//
// Luhong Liang, IC-ASD, ASTRI
// March. 6, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_2to1_enc4_8U()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height*2) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_2to1_enc4_8U()!\n");
		return false;
	}

	// set variables for strength tuning
	unsigned short shift, mask;
	switch (opt_code) {
		case 0:
			shift = 1;
			mask = 0;
			break;
		case 1:
			shift = 3;
			mask = 0xFFFF;
			break;
		case 2:
			shift = 2;
			mask = 0xFFFF;
			break;
		default:
			showErrMsg("Only support option code 0, 1, 2, 0x0F and 0xFF in CImageUtility::resize_2to1_enc4_8U()!\n");
			return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	short *pLine = new short[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_2to1_enc4_8U()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	short pix;
	for (int y=0, top=0; y<iplDstImage->height; y++, top+=2) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		unsigned char *pBuf2 = (unsigned char *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		unsigned char *pBuf3 = (unsigned char *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
		unsigned char *pDst = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			// -1   5   5   -1
			pLine[x] = (short)( ( mask & ( -(short)pBuf0[x] + (short)pBuf1[x] + (short)pBuf2[x] - (short)pBuf3[x]) )+  
							    (((short)pBuf1[x])<<shift) + (((short)pBuf2[x])<<shift) ) >> shift;		// signed shift here!!!
			// pLine[x] --- 12-bit signed
		}
		// interpolation in X direction
		for (int x=0, left=0; x<iplDstImage->width; x++, left+=2) {
			pix =  (short)( (mask & ( -(short)pLine[left] + (short)pLine[left+1] + (short)pLine[left+2] - (short)pLine[left+3]) ) +  
						   (((short)pLine[left+1] + (short)pLine[left+2])<<shift) ) >> (shift+1);  // signed shift here!!!
			// pLine[x] --- 12-bit signed
			// pix --- 12-bit siged
			// rounding to 8-bit and clipping
			pix = ((pix&0x0001) == 0) ? (pix>>1) : ((pix>>1) + 1);
			pix = pix < 0 ? 0 : pix;
			pix = pix > 255 ? 255 : pix;
			pDst[x] = (unsigned char)pix;
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::inter_1to2_bicubic_8U_10bit(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Interpolate 1/2-pixel image using bicubic
// The sample locations are (1-D) as example:
//				0     1     2     3      4			<-- original image
//              *  o  *  o  *  o  *  o  ...			< --interpolated image
// The filter for new pixel 'o' is (-1/8, 5/8, 5/8, -1/8)
//
// Luhong Liang, IC-ASD, ASTRI
// Feb. 7, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_bicubic_8U_10bit()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_bicubic_8U_10bit()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 2, 1, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to2_bicubic_8U_10bit()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		unsigned char *pBuf2 = (unsigned char *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		unsigned char *pBuf3 = (unsigned char *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine[x] = - (int)(pBuf0[x]) + 5 * ((int)(pBuf1[x]) + (int)(pBuf2[x])) - (int)(pBuf3[x]);
		}
		// interpolation in X direction
		int *pDst0 = (int *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		int *pDst1 = (int *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
			int pix = ((int)pBuf1[left+1]) << 2;		// 8-bit to 10-bit
			pDst0[x] = CLIP_PIX(pix, clip_high, clip_low);
			pix = (- (int)(pBuf1[left]) + 5 * ((int)(pBuf1[left+1]) + (int)(pBuf1[left+2])) - (int)(pBuf1[left+3])) >> 1;
			pDst0[x+1] = CLIP_PIX(pix, clip_high, clip_low);
			// line 1
			pix = ((int)pLine[left+1]) >> 1;		// left+1 to compensate the 1-pixel padding!
			pDst1[x] = CLIP_PIX(pix, clip_high, clip_low);
			pix = (- (int)(pLine[left]) + 5 * ((int)(pLine[left+1]) + (int)(pLine[left+2])) - (int)(pLine[left+3])) >> 4;
			pDst1[x+1] = CLIP_PIX(pix, clip_high, clip_low);
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::inter_1to2_bicubic_8U_10bit_s5(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Interpolate 1/2-pixel image using bicubic
// The sample locations are (1-D) as example:
//				0     1     2     3      4			<-- original image
//              *  o  *  o  *  o  *  o  ...			< --interpolated image
// The filter for new pixel 'o' is (-1/8, 5/8, 5/8, -1/8)
// Different from inter_1to2_bicubic_8U_10bit(), this function did not pad the input image and output a smaller image
// Luhong Liang, IC-ASD, ASTRI
// May. 15, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_bicubic_8U_10bit()!\n");
		return false;
	}
	if ((iplSrcImage->width-3)*2 != iplDstImage->width || (iplSrcImage->height-3)*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_bicubic_8U_10bit()!\n");
		return false;
	}

	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcImage->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to2_bicubic_8U_10bit()!\n");
		return false;
	}
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcImage->imageData + top * iplSrcImage->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcImage->imageData + (top+1) * iplSrcImage->widthStep);
		unsigned char *pBuf2 = (unsigned char *)(iplSrcImage->imageData + (top+2) * iplSrcImage->widthStep);
		unsigned char *pBuf3 = (unsigned char *)(iplSrcImage->imageData + (top+3) * iplSrcImage->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcImage->width; x++) {
			pLine[x] = - (int)(pBuf0[x]) + 5 * ((int)(pBuf1[x]) + (int)(pBuf2[x])) - (int)(pBuf3[x]);
		}
		// interpolation in X direction
		int *pDst0 = (int *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		int *pDst1 = (int *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
			int pix = ((int)pBuf1[left+1]) << 2;		// 8-bit to 10-bit
			pDst0[x] = CLIP_PIX(pix, clip_high, clip_low);
			pix = (- (int)(pBuf1[left]) + 5 * ((int)(pBuf1[left+1]) + (int)(pBuf1[left+2])) - (int)(pBuf1[left+3])) >> 1;
			pDst0[x+1] = CLIP_PIX(pix, clip_high, clip_low);
			// line 1
			pix = ((int)pLine[left+1]) >> 1;		// left+1 to compensate the 1-pixel padding!
			pDst1[x] = CLIP_PIX(pix, clip_high, clip_low);
			pix = (- (int)(pLine[left]) + 5 * ((int)(pLine[left+1]) + (int)(pLine[left+2])) - (int)(pLine[left+3])) >> 4;
			pDst1[x+1] = CLIP_PIX(pix, clip_high, clip_low);
		}
	}

	delete [] pLine;

	return true;
}

bool CImageUtility::inter_1to2_bicubic_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Interpolate 1/2-pixel image using bicubic
// The sample locations are (1-D) as example:
//				0     1     2     3      4			<-- original image
//              *  o  *  o  *  o  *  o  ...			< --interpolated image
// The filter for new pixel 'o' is (-1/8, 5/8, 5/8, -1/8)
//
// Luhong Liang, IC-ASD, ASTRI
// April 25, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_bicubic_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_bicubic_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 2, 1, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to2_bicubic_8U()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		unsigned char *pBuf2 = (unsigned char *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		unsigned char *pBuf3 = (unsigned char *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine[x] = - (int)(pBuf0[x]) + 5 * ((int)(pBuf1[x]) + (int)(pBuf2[x])) - (int)(pBuf3[x]);
		}
		// interpolation in X direction
		unsigned char *pDst0 = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		unsigned char *pDst1 = (unsigned char *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
			pDst0[x] = pBuf1[left+1];
			int pix = (- (int)(pBuf1[left]) + 5 * ((int)(pBuf1[left+1]) + (int)(pBuf1[left+2])) - (int)(pBuf1[left+3])) >> 2;
			pDst0[x+1] = rndclp_9Uto8U(pix);
			// line 1
			pix = pLine[left+1] >> 2;		// left+1 to compensate the 1-pixel padding!
			pDst1[x] = rndclp_9Uto8U(pix);
			pix = (- (int)(pLine[left]) + 5 * ((int)(pLine[left+1]) + (int)(pLine[left+2])) - (int)(pLine[left+3])) >> 5;
			pDst1[x+1] = rndclp_9Uto8U(pix);
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}


bool CImageUtility::inter_1to2_bicubic_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Interpolate 1/2-pixel image using bicubic
// The sample locations are (1-D) as example:
//				0     1     2     3      4		    <-- original image
//              *  o  *  o  *  o  *  o  ...	    < --interpolated image
// The filter for new pixel 'o' is (-1/8, 5/8, 5/8, -1/8)
// Luhong Liang, IC-ASD, ASTRI
// March 7, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_bicubic_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_bicubic_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 2, 1, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	float *pLine = new float[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to2_bicubic_32f()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		float *pBuf0 = (float *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		float *pBuf1 = (float *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		float *pBuf2 = (float *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		float *pBuf3 = (float *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine[x] = 0.625f * (pBuf1[x] + pBuf2[x]) - 0.125f * (pBuf0[x] + pBuf3[x]);
		}
		// interpolation in X direction
		float *pDst0 = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		float *pDst1 = (float *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
			pDst0[x] = pBuf1[left+1];
			float pix = 0.625f * (pBuf1[left+1] + pBuf1[left+2]) - 0.125f * (pBuf1[left] + pBuf1[left+3]);
			pDst0[x+1] = pix;
			// line 1
			pDst1[x] = pLine[left+1];           // left+1 to compensate the 1-pixel padding!
			pix = 0.625f * (pLine[left+1] + pLine[left+2]) - 0.125f * (pLine[left] + pLine[left+3]);
			pDst1[x+1] = pix;
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::inter_1to2_bicubic_odd_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Interpolate 1/2-pixel image using bicubic
// The sample locations are (1-D) as example:
//				0     1     2     3      4		    <-- original image
//         *  o  *  o  *  o  *  o  ...	    < --interpolated image
// The filter for new pixel 'o' is (-1/16, 9/16, 9/16, -1/16)
// Luhong Liang, IC-ASD, ASTRI
// March 19, 2014
// April 8, 2014: Modify the cooefficients
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_bicubic_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_bicubic_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 1, 2, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	float *pLine = new float[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to2_bicubic_32f()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		float *pBuf0 = (float *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		float *pBuf1 = (float *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		float *pBuf2 = (float *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		float *pBuf3 = (float *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			//pLine[x] = 0.625f * (pBuf1[x] + pBuf2[x]) - 0.125f * (pBuf0[x] + pBuf3[x]);
            pLine[x] = 0.5625f * (pBuf1[x] + pBuf2[x]) - 0.0625f * (pBuf0[x] + pBuf3[x]);         // April 8, 2014: Modify the cooefficients
		}
		// interpolation in X direction
		float *pDst0 = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		float *pDst1 = (float *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
            //float pix = 0.625f * (pLine[left+1] + pLine[left+2]) - 0.125f * (pLine[left] + pLine[left+3]);
            float pix = 0.5625f * (pLine[left+1] + pLine[left+2]) - 0.0625f * (pLine[left] + pLine[left+3]);// April 8, 2014: Modify the cooefficients
            pDst0[x] = pix;
			pDst0[x+1] = pLine[left+2];
			// line 1
            //pix = 0.625f * (pBuf2[left+1] + pBuf2[left+2]) - 0.125f * (pBuf2[left] + pBuf2[left+3]);
            pix = 0.5625f * (pBuf2[left+1] + pBuf2[left+2]) - 0.0625f * (pBuf2[left] + pBuf2[left+3]);// April 8, 2014: Modify the cooefficients
            pDst1[x] = pix;
			pDst1[x+1] = pBuf2[left+2];
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::inter_1to2_bicubic_odd_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Interpolate 1/2-pixel image using bicubic
// The sample locations are (1-D) as example:
//				0     1     2     3      4		    <-- original image
//         *  o  *  o  *  o  *  o  ...	    < --interpolated image
// The filter for new pixel 'o' is (-1/16, 9/16, 9/16, -1/16)
// Luhong Liang, IC-ASD, ASTRI
// June 19, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_bicubic_odd_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_bicubic_odd_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 1, 2, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to2_bicubic_odd_8U()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		unsigned char *pBuf2 = (unsigned char *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		unsigned char *pBuf3 = (unsigned char *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
            pLine[x] = 9 * (pBuf1[x] + pBuf2[x]) - (pBuf0[x] + pBuf3[x]);         // (-510~4590) 14-bit signed
		}
		// interpolation in X direction
		unsigned char *pDst0 = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		unsigned char *pDst1 = (unsigned char *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
            int pix = 9 * (pLine[left+1] + pLine[left+2]) - (pLine[left] + pLine[left+3]);        // 18-bit signed (-1020~9*9*2*2*255)
            pix = pix < 0 ? 0 : pix;
            pix = pix >> 7;
            pDst0[x] = rndclp_9Uto8U(pix);

            pix = pLine[left+2];
            pix = pix < 0 ? 0 : pix;
            pix = pix >> 3;
			pDst0[x+1] = rndclp_9Uto8U(pix);

			// line 1
            pix = 9 * (pBuf2[left+1] + pBuf2[left+2]) - (pBuf2[left] + pBuf2[left+3]);
            pix = pix < 0 ? 0 : pix;
            pix = pix >> 3;
            pDst1[x] = rndclp_9Uto8U(pix);

            pDst1[x+1] = pBuf2[left+2];
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::inter_1to2_cublin_odd_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Interpolate 1/2-pixel image using bicubic in X direction firstly, and then using bilinear in Y direction.
// The sample locations are (1-D) as example:
//				0     1     2     3      4		    <-- original image
//         *  o  *  o  *  o  *  o  ...	    < --interpolated image
// The filter for new pixel 'o' is (-1/16, 9/16, 9/16, -1/16) for bicubic and (1/2, 1/2) for bilinear
// Luhong Liang, IC-ASD, ASTRI
// Sept 1, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_cublin_odd_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_cublin_odd_8U()!\n");
		return false;
	}

	// padding and intermediate image
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 1, 1, 0);
    IplImage *iplIntImg = createImage(iplSrcImage->width*2, iplSrcImage->height+1, iplSrcImage->depth, iplSrcImage->nChannels);
	if (iplSrcPad == NULL || iplIntImg == NULL) {
        safeReleaseImage(&iplSrcPad, &iplIntImg);
        return false;
    }

	// bicubic in X direction
    for (int y=0; y<iplIntImg->height; y++) {
        unsigned char *pSrc = (unsigned char *)(iplSrcPad->imageData + y * iplSrcPad->widthStep);
        unsigned char *pDst = (unsigned char *)(iplIntImg->imageData + y * iplIntImg->widthStep);
        for (int x=0, left=0; x<iplIntImg->width; x+=2, left++) {
            // point 0 (interplated)
            int pix = 9 * (pSrc[left+1] + pSrc[left+2]) - (pSrc[left] + pSrc[left+3]);
            pix = pix < 0 ? 0 : pix;
            pix = pix >> 3;
            pDst[x] = rndclp_9Uto8U(pix);
            // point 1 (copied)
			pDst[x+1] = pSrc[left+2];
        }
    }

    // bilinear in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		unsigned char *pBuf0 = (unsigned char *)(iplIntImg->imageData + top * iplIntImg->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplIntImg->imageData + (top+1) * iplIntImg->widthStep);
        unsigned char *pDst0 = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
        unsigned char *pDst1 = (unsigned char *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplDstImage->width; x++) {
            // line 0
            int pix = pBuf0[x] + pBuf1[x];
            pDst0[x] = rndclp_9Uto8U(pix);
            // line 1
            pDst1[x] = pBuf1[x];
		}
	}

	safeReleaseImage(&iplSrcPad, &iplIntImg);

	return true;
}

bool CImageUtility::inter_1to2_bicubic_odd_rgb_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Interpolate 1/2-pixel image using bicubic
// The sample locations are (1-D) as example:
//				0     1     2     3      4		    <-- original image
//         *  o  *  o  *  o  *  o  ...	    < --interpolated image
// The filter for new pixel 'o' is (-1/16, 9/16, 9/16, -1/16)
// Luhong Liang, IC-ASD, ASTRI
// June 24, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 3 || iplDstImage->nChannels != 3 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_bicubic_odd_rgb_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_bicubic_odd_rgb_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 1, 2, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
    int *pLine = new int[iplSrcPad->width*iplSrcPad->nChannels];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to2_bicubic_odd_rgb_8U()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		unsigned char *pBuf2 = (unsigned char *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		unsigned char *pBuf3 = (unsigned char *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width*iplSrcPad->nChannels; x++) {
            pLine[x] = 9 * (pBuf1[x] + pBuf2[x]) - (pBuf0[x] + pBuf3[x]);         // 13-bit
		}
		// interpolation in X direction
		unsigned char *pDst0 = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		unsigned char *pDst1 = (unsigned char *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
            // B
            int le = left * 3;
            int xx = x * 3;
			// line 0
            int pix = 9 * (pLine[le+3] + pLine[le+6]) - (pLine[le] + pLine[le+9]);        // 17-bit (0~9*9*4*255)
            pix = pix < 0 ? 0 : pix;
            pix = pix >> 7;
            pDst0[xx] = rndclp_9Uto8U(pix);

            pix = pLine[le+6];
            pix = pix < 0 ? 0 : pix;
            pix = pix >> 3;
			pDst0[xx+3] = rndclp_9Uto8U(pix);

			// line 1
            pix = 9 * (pBuf2[le+3] + pBuf2[le+6]) - (pBuf2[le] + pBuf2[le+9]);
            pix = pix < 0 ? 0 : pix;
            pix = pix >> 3;
            pDst1[xx] = rndclp_9Uto8U(pix);

            pDst1[xx+3] = pBuf2[le+6];

            // G
            le = left * 3 + 1;
            xx = x * 3 + 1;
			// line 0
            pix = 9 * (pLine[le+3] + pLine[le+6]) - (pLine[le] + pLine[le+9]);        // 17-bit (0~9*9*4*255)
            pix = pix < 0 ? 0 : pix;
            pix = pix >> 7;
            pDst0[xx] = rndclp_9Uto8U(pix);

            pix = pLine[le+6];
            pix = pix < 0 ? 0 : pix;
            pix = pix >> 3;
			pDst0[xx+3] = rndclp_9Uto8U(pix);

			// line 1
            pix = 9 * (pBuf2[le+3] + pBuf2[le+6]) - (pBuf2[le] + pBuf2[le+9]);
            pix = pix < 0 ? 0 : pix;
            pix = pix >> 3;
            pDst1[xx] = rndclp_9Uto8U(pix);

            pDst1[xx+3] = pBuf2[le+6];

            // R
            le = left * 3 + 2;
            xx = x * 3 + 2;
			// line 0
            pix = 9 * (pLine[le+3] + pLine[le+6]) - (pLine[le] + pLine[le+9]);        // 17-bit (0~9*9*4*255)
            pix = pix < 0 ? 0 : pix;
            pix = pix >> 7;
            pDst0[xx] = rndclp_9Uto8U(pix);

            pix = pLine[le+6];
            pix = pix < 0 ? 0 : pix;
            pix = pix >> 3;
			pDst0[xx+3] = rndclp_9Uto8U(pix);

			// line 1
            pix = 9 * (pBuf2[le+3] + pBuf2[le+6]) - (pBuf2[le] + pBuf2[le+9]);
            pix = pix < 0 ? 0 : pix;
            pix = pix >> 3;
            pDst1[xx] = rndclp_9Uto8U(pix);

            pDst1[xx+3] = pBuf2[le+6];
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::inter_1to2_lanczos3_odd_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Interpolate 1/2-pixel image using bicubic
// The sample locations are (1-D) as example:
//				0     1     2     3      4		    <-- original image
//         *  o  *  o  *  o  *  o  ...	    < --interpolated image
// The filter for new pixel 'o' is Lanczos-3 filter, i.e.  0.0245   -0.1359    0.6114    0.6114   -0.1359    0.0245  
// Luhong Liang, IC-ASD, ASTRI
// March 18, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_lanczos3_odd_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_lanczos3_odd_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 3, 2, 3, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by Lanczos-3 ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	float *pLine = new float[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to2_bicubic_32f()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		float *pBuf0 = (float *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		float *pBuf1 = (float *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		float *pBuf2 = (float *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		float *pBuf3 = (float *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
        float *pBuf4 = (float *)(iplSrcPad->imageData + (top+4) * iplSrcPad->widthStep);
        float *pBuf5 = (float *)(iplSrcPad->imageData + (top+5) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine[x] = 0.6114f * (pBuf2[x] + pBuf3[x]) - 0.1359f * (pBuf1[x] + pBuf4[x]) + 0.0245f * (pBuf0[x] + pBuf5[x]);     // 0.0245   -0.1359    0.6114    0.6114   -0.1359    0.0245  
		}
		// interpolation in X direction
		float *pDst0 = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		float *pDst1 = (float *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
            float pix = 0.6114f * (pLine[left+2] + pLine[left+3]) - 0.1359f * (pLine[left+1] + pLine[left+4]) + 0.0245f * (pLine[left] + pLine[left+5]);
			pDst0[x] = pix;
			pDst0[x+1] = pLine[left+3];
			// line 1
            pix = 0.6114f * (pBuf3[left+2] + pBuf3[left+3]) - 0.1359f * (pBuf3[left+1] + pBuf3[left+4]) + 0.0245f * (pBuf3[left] + pBuf3[left+5]);
			pDst1[x] = pix;
			pDst1[x+1] = pBuf3[left+3];
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_1to2_bicubic_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize image of magification factor of 2. The sampling location is the same as OpenCV!
// The sample locations are (1-D) as example:
//	 -2         -1          0           1            2  <-- original mage
//                       o     o     o     o     o		 <-- resized image
// The coefficients and indice are
// -0.0351563	0.2617188	0.8789063	-0.1054688		-2	-1	0	1
// -0.1054688	0.8789063	0.2617188	-0.0351563		-1	0	1	2
// Luhong Liang, IC-ASD, ASTRI
// May. 30, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::resize_1to2_bicubic_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_1to2_bicubic_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	float *pLine = new float[iplSrcPad->width*2];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_1to2_bicubic_32f()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	float *pLine0 = pLine;
	float *pLine1 = pLine + iplSrcPad->width;
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		float *pBuf0 = (float *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		float *pBuf1 = (float *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		float *pBuf2 = (float *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		float *pBuf3 = (float *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
		float *pBuf4 = (float *)(iplSrcPad->imageData + (top+4) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine0[x] = -0.0351563f*pBuf0[x] + 0.2617188f*pBuf1[x] + 0.8789063f*pBuf2[x] - 0.1054688f*pBuf3[x];	// -0.0351563	0.2617188	0.8789063	-0.1054688		-2	-1	0	1
			pLine1[x] = -0.1054688f*pBuf1[x] + 0.8789063f*pBuf2[x] + 0.2617188f*pBuf3[x] - 0.0351563f*pBuf4[x];	// -0.1054688	0.8789063	0.2617188	-0.0351563		-1	0	1	2
		}
		// interpolation in X direction
		float *pDst0 = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		float *pDst1 = (float *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
			float pix = -0.0351563f*pLine0[left] + 0.2617188f*pLine0[left+1] + 0.8789063f*pLine0[left+2] - 0.1054688f*pLine0[left+3];	// -0.0351563	0.2617188	0.8789063	-0.1054688		-2	-1	0	1
			pDst0[x] = pix;
			pix = -0.1054688f*pLine0[left+1] + 0.8789063f*pLine0[left+2] + 0.2617188f*pLine0[left+3] - 0.0351563f*pLine0[left+4];		// -0.1054688	0.8789063	0.2617188	-0.0351563		-1	0	1	2
			pDst0[x+1] = pix;
			// line 1
			pix = -0.0351563f*pLine1[left] + 0.2617188f*pLine1[left+1] + 0.8789063f*pLine1[left+2] - 0.1054688f*pLine1[left+3];			// -0.0351563	0.2617188	0.8789063	-0.1054688		-2	-1	0	1
			pDst1[x] = pix;
			pix = -0.1054688f*pLine1[left+1] + 0.8789063f*pLine1[left+2] + 0.2617188f*pLine1[left+3] - 0.0351563f*pLine1[left+4];		// -0.1054688	0.8789063	0.2617188	-0.0351563		-1	0	1	2
			pDst1[x+1] = pix;
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_1to2_bicubic_int(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Resize image of magification factor of 2. The sampling location is the same as OpenCV!
// The sample locations are (1-D) as example:
//	 -2         -1          0           1            2  <-- original mage
//                       o     o     o     o     o		 <-- resized image
// The indices and parameters (*256) of the filter is
// -2	-1	0	1	-9	67	225	-27
// -1	0	1	2	-27	225	67	-9
// Luhong Liang, IC-ASD, ASTRI
// Feb. 7, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_1to2_bicubic_int()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_1to2_bicubic_int()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width*2];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_1to2_bicubic_int()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	int *pLine0 = pLine;
	int *pLine1 = pLine + iplSrcPad->width;
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		int *pBuf0 = (int *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		int *pBuf1 = (int *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		int *pBuf2 = (int *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		int *pBuf3 = (int *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
		int *pBuf4 = (int *)(iplSrcPad->imageData + (top+4) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine0[x] = -9*pBuf0[x] + 67*pBuf1[x] + 225*pBuf2[x] - 27*pBuf3[x];	// -2	-1	0	1	-9	67	225	-27
			pLine1[x] = -27*pBuf1[x] + 225*pBuf2[x] + 67*pBuf3[x] - 9*pBuf4[x];	// -1	0	1	2	-27	225	67	-9
		}
		// interpolation in X direction
		int *pDst0 = (int *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		int *pDst1 = (int *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
			int pix = (-9*pLine0[left] + 67*pLine0[left+1] + 225*pLine0[left+2] - 27*pLine0[left+3]) >> 16;
			pDst0[x] = CLIP_PIX(pix, clip_high, clip_low);
			pix = (-27*pLine0[left+1] + 225*pLine0[left+2] + 67*pLine0[left+3] - 9*pLine0[left+4]) >> 16;
			pDst0[x+1] = CLIP_PIX(pix, clip_high, clip_low);
			// line 1
			pix = (-9*pLine1[left] + 67*pLine1[left+1] + 225*pLine1[left+2] - 27*pLine1[left+3]) >> 16;
			pDst1[x] = CLIP_PIX(pix, clip_high, clip_low);
			pix = (-27*pLine1[left+1] + 225*pLine1[left+2] + 67*pLine1[left+3] - 9*pLine1[left+4]) >> 16;
			pDst1[x+1] = CLIP_PIX(pix, clip_high, clip_low);
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_1to2_bicubic_int_s5(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Resize image of magification factor of 2. The sampling location is the same as OpenCV!
// The sample locations are (1-D) as example:
//	 -2         -1          0           1            2  <-- original mage
//                       o     o     o     o     o		<-- resized image
// The indices and parameters (*256) of the filter is
// -2	-1	0	1	-9	67	225	-27
// -1	0	1	2	-27	225	67	-9
// Different from resize_1to2_bicubic_int(), this function supposes the input image has been padded
// Luhong Liang, IC-ASD, ASTRI
// May. 27, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_1to2_bicubic_int_s5()!\n");
		return false;
	}
	if ((iplSrcImage->width-4)*2 != iplDstImage->width || (iplSrcImage->height-4)*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_1to2_bicubic_int_s5()!\n");
		return false;
	}

	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcImage->width*2];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_1to2_bicubic_int_s5()!\n");
	}
	int *pLine0 = pLine;
	int *pLine1 = pLine + iplSrcImage->width;
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		int *pBuf0 = (int *)(iplSrcImage->imageData + top * iplSrcImage->widthStep);
		int *pBuf1 = (int *)(iplSrcImage->imageData + (top+1) * iplSrcImage->widthStep);
		int *pBuf2 = (int *)(iplSrcImage->imageData + (top+2) * iplSrcImage->widthStep);
		int *pBuf3 = (int *)(iplSrcImage->imageData + (top+3) * iplSrcImage->widthStep);
		int *pBuf4 = (int *)(iplSrcImage->imageData + (top+4) * iplSrcImage->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcImage->width; x++) {
			pLine0[x] = -9*pBuf0[x] + 67*pBuf1[x] + 225*pBuf2[x] - 27*pBuf3[x];	// -2	-1	0	1	-9	67	225	-27
			pLine1[x] = -27*pBuf1[x] + 225*pBuf2[x] + 67*pBuf3[x] - 9*pBuf4[x];	// -1	0	1	2	-27	225	67	-9
		}
		// interpolation in X direction
		int *pDst0 = (int *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		int *pDst1 = (int *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
			int pix = (-9*pLine0[left] + 67*pLine0[left+1] + 225*pLine0[left+2] - 27*pLine0[left+3]) >> 16;
			pDst0[x] = CLIP_PIX(pix, clip_high, clip_low);
			pix = (-27*pLine0[left+1] + 225*pLine0[left+2] + 67*pLine0[left+3] - 9*pLine0[left+4]) >> 16;
			pDst0[x+1] = CLIP_PIX(pix, clip_high, clip_low);
			// line 1
			pix = (-9*pLine1[left] + 67*pLine1[left+1] + 225*pLine1[left+2] - 27*pLine1[left+3]) >> 16;
			pDst1[x] = CLIP_PIX(pix, clip_high, clip_low);
			pix = (-27*pLine1[left+1] + 225*pLine1[left+2] + 67*pLine1[left+3] - 9*pLine1[left+4]) >> 16;
			pDst1[x+1] = CLIP_PIX(pix, clip_high, clip_low);
		}
	}

	delete [] pLine;

	return true;
}

bool CImageUtility::resize_1to2_bilinear_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize image of magification factor of 2. The sampling location is the same as OpenCV!
// The sample locations are (1-D) as example:
//	 -1          0           1            2  <-- original mage
//            o     o     o     o     o		 <-- resized image
// The indices and parameters of the filter is [ 1/4, 3/4] and [3/4, 1/4]
// Luhong Liang, IC-ASD, ASTRI
// May 31, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::resize_1to2_bilinear_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_1to2_bilinear_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	float *pLine = new float[iplSrcPad->width*2];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_1to2_bilinear_32f()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	float *pLine0 = pLine;
	float *pLine1 = pLine + iplSrcPad->width;
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		float *pBuf0 = (float *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		float *pBuf1 = (float *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		float *pBuf2 = (float *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine0[x] = (pBuf0[x] + 3.0f*pBuf1[x]) * 0.25f;	// [1/4, 3/4]
			pLine1[x] = (3.0f*pBuf1[x] + pBuf2[x]) * 0.25f;	// [1/4, 3/4]
		}
		// interpolation in X direction
		float *pDst0 = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		float *pDst1 = (float *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
			float pix = (pLine0[left] + 3.0f*pLine0[left+1]) * 0.25f;
			pDst0[x] = pix;
			pix = (3.0f*pLine0[left+1] + pLine0[left+2]) * 0.25f;
			pDst0[x+1] = pix;
			// line 1
			pix = (pLine1[left] + 3.0f*pLine1[left+1]) * 0.25f;
			pDst1[x] = pix;
			pix = (3.0f*pLine1[left+1] + pLine1[left+2]) * 0.25f;
			pDst1[x+1] = pix;
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_nn_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize image using nearest neighbourhood. 
// The sampling location is the same as OpenCV!
// This is a low efficient implementation.
// Luhong Liang, ICDD-VIDEO, ASTRI
// Oct 3, 2015
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != iplDstImage->nChannels || 
        (iplDstImage->nChannels != 1 && iplDstImage->nChannels != 3) ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::resize_1to2_nn_32f()!\n");
		return false;
	}

    if (iplDstImage->nChannels == 1) {
        for (int y=0; y<iplDstImage->height; y++) {
            // fx = (float)((dx+0.5)*scale_x - 0.5);
            int fy = (int)((y + 0.5f) * iplSrcImage->height / iplDstImage->height);  // <--> round(...+0.5f)
            fy = fy > iplSrcImage->height-1 ? iplSrcImage->height-1 : fy;
		    float *pSrc = (float *)(iplSrcImage->imageData + fy * iplSrcImage->widthStep);
		    float *pDst = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		    for (int x=0; x<iplDstImage->width; x++) {
                int fx = (int)((x + 0.5f) * iplSrcImage->width / iplDstImage->width);
                fx = fx > iplSrcImage->width-1 ? iplSrcImage->width-1 : fx;
			    pDst[x] = pSrc[fx];
		    }
	    }
    } else { // channel == 3
        for (int y=0; y<iplDstImage->height; y++) {
            // fx = (float)((dx+0.5)*scale_x - 0.5);
            int fy = (int)((y + 0.5f) * iplSrcImage->height / iplDstImage->height);  // <--> round(...+0.5f)
            fy = fy > iplSrcImage->height-1 ? iplSrcImage->height-1 : fy;
		    float *pSrc = (float *)(iplSrcImage->imageData + fy * iplSrcImage->widthStep);
		    float *pDst = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		    for (int x=0; x<iplDstImage->width; x++) {
                int fx = (int)((x + 0.5f) * iplSrcImage->width / iplDstImage->width);
                fx = fx > iplSrcImage->width-1 ? iplSrcImage->width-1 : fx;
			    pDst[3*x] = pSrc[3*fx];
                pDst[3*x+1] = pSrc[3*fx+1];
                pDst[3*x+2] = pSrc[3*fx+2];
		    }
	    }
    }

	return true;
}

bool CImageUtility::resize_nn_16U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize image using nearest neighbourhood. 
// The sampling location is the same as OpenCV!
// This is a low efficient implementation.
// Luhong Liang, ICDD-VIDEO, ASTRI
// Oct 3, 2015
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != iplDstImage->nChannels || 
        (iplDstImage->nChannels != 1 && iplDstImage->nChannels != 3) ||
		iplSrcImage->depth != SR_DEPTH_16U || iplDstImage->depth != SR_DEPTH_16U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_1to2_nn_16U()!\n");
		return false;
	}

    if (iplDstImage->nChannels == 1) {
        for (int y=0; y<iplDstImage->height; y++) {
            // fx = (float)((dx+0.5)*scale_x - 0.5);
            int fy = (int)((y + 0.5f) * iplSrcImage->height / iplDstImage->height);  // <--> round(...+0.5f)
            fy = fy > iplSrcImage->height-1 ? iplSrcImage->height-1 : fy;
		    unsigned short *pSrc = (unsigned short *)(iplSrcImage->imageData + fy * iplSrcImage->widthStep);
		    unsigned short *pDst = (unsigned short *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		    for (int x=0; x<iplDstImage->width; x++) {
                int fx = (int)((x + 0.5f) * iplSrcImage->width / iplDstImage->width);
                fx = fx > iplSrcImage->width-1 ? iplSrcImage->width-1 : fx;
			    pDst[x] = pSrc[fx];
		    }
	    }
    } else { // channel == 3
        for (int y=0; y<iplDstImage->height; y++) {
            // fx = (float)((dx+0.5)*scale_x - 0.5);
            int fy = (int)((y + 0.5f) * iplSrcImage->height / iplDstImage->height);  // <--> round(...+0.5f)
            fy = fy > iplSrcImage->height-1 ? iplSrcImage->height-1 : fy;
		    unsigned short *pSrc = (unsigned short *)(iplSrcImage->imageData + fy * iplSrcImage->widthStep);
		    unsigned short *pDst = (unsigned short *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		    for (int x=0; x<iplDstImage->width; x++) {
                int fx = (int)((x + 0.5f) * iplSrcImage->width / iplDstImage->width);
                fx = fx > iplSrcImage->width-1 ? iplSrcImage->width-1 : fx;
			    pDst[3*x] = pSrc[3*fx];
                pDst[3*x+1] = pSrc[3*fx+1];
                pDst[3*x+2] = pSrc[3*fx+2];
		    }
	    }
    }

	return true;
}

bool CImageUtility::resize_nn_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize image using nearest neighbourhood. 
// The sampling location is the same as OpenCV!
// This is a low efficient implementation.
// Luhong Liang, ICDD-VIDEO, ASTRI
// Oct 3, 2015
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != iplDstImage->nChannels || 
        (iplDstImage->nChannels != 1 && iplDstImage->nChannels != 3) ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_1to2_nn_8U()!\n");
		return false;
	}

    if (iplDstImage->nChannels == 1) {
        for (int y=0; y<iplDstImage->height; y++) {
            // fx = (float)((dx+0.5)*scale_x - 0.5);
            int fy = (int)((y + 0.5f) * iplSrcImage->height / iplDstImage->height);  // <--> round(...+0.5f)
            fy = fy > iplSrcImage->height-1 ? iplSrcImage->height-1 : fy;
		    unsigned char *pSrc = (unsigned char *)(iplSrcImage->imageData + fy * iplSrcImage->widthStep);
		    unsigned char *pDst = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		    for (int x=0; x<iplDstImage->width; x++) {
                int fx = (int)((x + 0.5f) * iplSrcImage->width / iplDstImage->width);
                fx = fx > iplSrcImage->width-1 ? iplSrcImage->width-1 : fx;
			    pDst[x] = pSrc[fx];
		    }
	    }
    } else { // channel == 3
        for (int y=0; y<iplDstImage->height; y++) {
            // fx = (float)((dx+0.5)*scale_x - 0.5);
            int fy = (int)((y + 0.5f) * iplSrcImage->height / iplDstImage->height);  // <--> round(...+0.5f)
            fy = fy > iplSrcImage->height-1 ? iplSrcImage->height-1 : fy;
		    unsigned char *pSrc = (unsigned char *)(iplSrcImage->imageData + fy * iplSrcImage->widthStep);
		    unsigned char *pDst = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		    for (int x=0; x<iplDstImage->width; x++) {
                int fx = (int)((x + 0.5f) * iplSrcImage->width / iplDstImage->width);
                fx = fx > iplSrcImage->width-1 ? iplSrcImage->width-1 : fx;
			    pDst[3*x] = pSrc[3*fx];
                pDst[3*x+1] = pSrc[3*fx+1];
                pDst[3*x+2] = pSrc[3*fx+2];
		    }
	    }
    }

	return true;
}

bool CImageUtility::resize_1to2_bilinear_int(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Resize image of magification factor of 2. The sampling location is the same as OpenCV!
// The sample locations are (1-D) as example:
//	 -1          0           1            2  <-- original mage
//            o     o     o     o     o		 <-- resized image
// The indices and parameters of the filter is [ 1/4, 3/4] and [3/4, 1/4]
// Luhong Liang, IC-ASD, ASTRI
// April 9, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_1to2_bilinear_int()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_1to2_bilinear_int()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width*2];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_1to2_bilinear_int()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	int *pLine0 = pLine;
	int *pLine1 = pLine + iplSrcPad->width;
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		int *pBuf0 = (int *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		int *pBuf1 = (int *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		int *pBuf2 = (int *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine0[x] = (pBuf0[x] + 3*pBuf1[x]) >> 2;	// [1/4, 3/4]
			pLine1[x] = (3*pBuf1[x] + pBuf2[x]) >> 2;	// [1/4, 3/4]
		}
		// interpolation in X direction
		int *pDst0 = (int *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		int *pDst1 = (int *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
			int pix = (pLine0[left] + 3*pLine0[left+1]) >> 2;
			pDst0[x] = CLIP_PIX(pix, clip_high, clip_low);
			pix = (3*pLine0[left+1] + pLine0[left+2]) >> 2;
			pDst0[x+1] = CLIP_PIX(pix, clip_high, clip_low);
			// line 1
			pix = (pLine1[left] + 3*pLine1[left+1]) >> 2;
			pDst1[x] = CLIP_PIX(pix, clip_high, clip_low);
			pix = (3*pLine1[left+1] + pLine1[left+2]) >> 2;
			pDst1[x+1] = CLIP_PIX(pix, clip_high, clip_low);
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_1to2_bilinear_16U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize image of magification factor of 2. The sampling location is the same as OpenCV!
// The sample locations are (1-D) as example:
//	 -1          0           1            2  <-- original mage
//            o     o     o     o     o		 <-- resized image
// The indices and parameters of the filter is [ 1/4, 3/4] and [3/4, 1/4]
// Luhong Liang, IC-ASD, ASTRI
// Sept. 17, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_16U || iplDstImage->depth != SR_DEPTH_16U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_1to2_bilinear_16U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_1to2_bilinear_16U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplSrcPad == NULL) return false;
    //saveImage("_Padded.bmp", iplSrcPad, 0, 1.0f, 10);
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	unsigned int *pLine = new unsigned int[iplSrcPad->width*2];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_1to2_bilinear_16U()!\n");
		safeReleaseImage(&iplSrcPad);
		return false;
	}
	unsigned int *pLine0 = pLine;
	unsigned int *pLine1 = pLine + iplSrcPad->width;
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		unsigned short *pBuf0 = (unsigned short *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned short *pBuf1 = (unsigned short *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		unsigned short *pBuf2 = (unsigned short *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine0[x] = pBuf0[x] + 3*pBuf1[x];	// [1/4, 3/4]
			pLine1[x] = 3*pBuf1[x] + pBuf2[x];	// [1/4, 3/4]
		}
		// interpolation in X direction
		unsigned short *pDst0 = (unsigned short *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		unsigned short *pDst1 = (unsigned short *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
			unsigned int pix = (pLine0[left] + 3*pLine0[left+1]) >> 3;
			pDst0[x] = (unsigned short)(((pix&0x00000001)==0) ? (pix>>1) : ((pix>>1)+1)); // will never overflow
			pix = (3*pLine0[left+1] + pLine0[left+2]) >> 3;
			pDst0[x+1] = (unsigned short)(((pix&0x00000001)==0) ? (pix>>1) : ((pix>>1)+1));
			// line 1
			pix = (pLine1[left] + 3*pLine1[left+1]) >> 3;
			pDst1[x] = (unsigned short)(((pix&0x00000001)==0) ? (pix>>1) : ((pix>>1)+1));
			pix = (3*pLine1[left+1] + pLine1[left+2]) >> 3;
			pDst1[x+1] = (unsigned short)(((pix&0x00000001)==0) ? (pix>>1) : ((pix>>1)+1));
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_1to2_bilinear_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize image of magification factor of 2. The sampling location is the same as OpenCV!
// The sample locations are (1-D) as example:
//	 -1          0           1            2  <-- original mage
//            o     o     o     o     o		 <-- resized image
// The indices and parameters of the filter is [ 1/4, 3/4] and [3/4, 1/4]
// Luhong Liang, IC-ASD, ASTRI
// June 4, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_1to2_bilinear_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_1to2_bilinear_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width*2];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_1to2_bilinear_8U()!\n");
		safeReleaseImage(&iplSrcPad);
		return false;
	}
	int *pLine0 = pLine;
	int *pLine1 = pLine + iplSrcPad->width;
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		unsigned char *pBuf2 = (unsigned char *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine0[x] = pBuf0[x] + 3*pBuf1[x];	// [1/4, 3/4]
			pLine1[x] = 3*pBuf1[x] + pBuf2[x];	// [1/4, 3/4]
		}
		// interpolation in X direction
		unsigned char *pDst0 = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		unsigned char *pDst1 = (unsigned char *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
			int pix = (pLine0[left] + 3*pLine0[left+1]) >> 3;
			pDst0[x] = rndclp_9Uto8U(pix);
			pix = (3*pLine0[left+1] + pLine0[left+2]) >> 3;
			pDst0[x+1] = rndclp_9Uto8U(pix);
			// line 1
			pix = (pLine1[left] + 3*pLine1[left+1]) >> 3;
			pDst1[x] = rndclp_9Uto8U(pix);
			pix = (3*pLine1[left+1] + pLine1[left+2]) >> 3;
			pDst1[x+1] = rndclp_9Uto8U(pix);
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_1to2_cublin_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize image of magification factor of 2. The sampling location is the same as OpenCV!
// The sample locations are (1-D) as example:
//	 -2         -1          0           1            2   <-- original mage
//                       o     o     o     o     o		 <-- resized image
// In Y direction, the indices and parameters of the filter is
// 	-1	0	1/4 3/4
// 	0	1	3/4 1/4
// In X direction, the indices and parameters (*256) of the filter is
// -2	-1	0	1	-9	67	225	-27
// -1	0	1	2	-27	225	67	-9
// Luhong Liang, IC-ASD, ASTRI
// April 9, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_1to2_cublin_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_1to2_cublin_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width*2];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_1to2_bilinear_int()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	int *pLine0 = pLine;
	int *pLine1 = pLine + iplSrcPad->width;
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		unsigned char *pBuf2 = (unsigned char *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine0[x] = pBuf0[x] + 3*pBuf1[x];	// [1/4, 3/4]		<-- does not shift to keep 2 more bits in precision
			pLine1[x] = 3*pBuf1[x] + pBuf2[x];	// [1/4, 3/4]
		}
		// interpolation in X direction
		unsigned char *pDst0 = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		unsigned char *pDst1 = (unsigned char *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
			int pix = (-9*pLine0[left] + 67*pLine0[left+1] + 225*pLine0[left+2] - 27*pLine0[left+3]) >> 9; // keep 9-bit
			pix = ((pix&0x0001) == 0) ? (pix>>1) : ((pix>>1) + 1);  // rounding to 8-bit
			pix = pix > 255 ? 255 : pix;							// should clipping, since 1023-->256 above!
			pDst0[x] = (unsigned char)(pix < 0 ? 0 : pix);
			pix = (-27*pLine0[left+1] + 225*pLine0[left+2] + 67*pLine0[left+3] - 9*pLine0[left+4]) >> 9;
			pix = ((pix&0x0001) == 0) ? (pix>>1) : ((pix>>1) + 1);  // rounding to 8-bit
			pix = pix > 255 ? 255 : pix;							// should clipping, since 1023-->256 above!
			pDst0[x+1] = (unsigned char)(pix < 0 ? 0 : pix);
			// line 1
			pix = (-9*pLine1[left] + 67*pLine1[left+1] + 225*pLine1[left+2] - 27*pLine1[left+3]) >> 9;
			pix = ((pix&0x0001) == 0) ? (pix>>1) : ((pix>>1) + 1);  // rounding to 8-bit
			pix = pix > 255 ? 255 : pix;							// should clipping, since 1023-->256 above!
			pDst1[x] = (unsigned char)(pix < 0 ? 0 : pix);
			pix = (-27*pLine1[left+1] + 225*pLine1[left+2] + 67*pLine1[left+3] - 9*pLine1[left+4]) >> 9;
			pix = ((pix&0x0001) == 0) ? (pix>>1) : ((pix>>1) + 1);  // rounding to 8-bit
			pix = pix > 255 ? 255 : pix;							// should clipping, since 1023-->256 above!
			pDst1[x+1] = (unsigned char)(pix < 0 ? 0 : pix);
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::intp_chroma_4to15_bilinear_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// resize the chroma plane and covert from 4:2:0-like format to 4:4:4.
// Supposing the input chroma plane is resampled from a 4:4:4 image by interlacing (which is different from sampling location of 4:2:0), 
// this function enlarges the image 15/4 times (576p-to-1080p + 4:2:0-to-4:4:4) and make sure the result plane is aligned with the luma plane that upscaled
// by a 15/8 (576p to 1080p) RESIZE options.
// The indices and the filters (*256) are:
// -1	0	30	226
// 0	1	218	38
// 0	1	149	107
// 0	1	81	175
// 0	1	13	243
// 1	2	201	55
// 1	2	132	124
// 1	2	64	192
// 2	3	252	4
// 2	3	183	73
// 2	3	115	141
// 2	3	47	209
// 3	4	235	21
// 3	4	166	90
// 3	4	98	158
// Luhong Liang, IC-ASD, ASTRI
// April 26, 2013
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::intp_chroma_4to15_bilinear_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*15 != iplDstImage->width*4 || iplSrcImage->height*15 != iplDstImage->height*4) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::intp_chroma_4to15_bilinear_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (15x15 block, step = 15, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[6*6];		// 6x6 block in source image (4 points + padding)
	int pBlock1[15*6];		// after interpolation in X direction
	int pBlock2[15*15];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=15, top+=4) {
		for (int x=0, left=0; x<iplDstImage->width; x+=15, left+=4) {
			// load a 6x6 block in source image (4x4 + padding)
			int i = 0;
			for (int yy=top; yy<top+6; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+6; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction (preserve 9 bits)
			for (int v=0; v<6; v++) {
				int *pSrc = pBlock + v * 6;
				int *pDst = pBlock1 + v * 15;
				// calculation		   					     ref point       filter
				pDst[0] = (30*pSrc[0] + 226*pSrc[1]) >> 7;		// -1	0	30	226
				pDst[1] = (218*pSrc[1] + 38*pSrc[2]) >> 7;		// 0	1	218	38
				pDst[2] = (149*pSrc[1] + 107*pSrc[2]) >> 7;		// 0	1	149	107
				pDst[3] = (81*pSrc[1] + 175*pSrc[2]) >> 7;		// 0	1	81	175
				pDst[4] = (13*pSrc[1] + 243*pSrc[2]) >> 7;		// 0	1	13	243
				pDst[5] = (201*pSrc[2] + 55*pSrc[3]) >> 7;		// 1	2	201	55
				pDst[6] = (132*pSrc[2] + 124*pSrc[3]) >> 7;		// 1	2	132	124
				pDst[7] = (64*pSrc[2] + 192*pSrc[3]) >> 7;		// 1	2	64	192
				pDst[8] = (252*pSrc[3] + 4*pSrc[4]) >> 7;		// 2	3	252	4
				pDst[9] = (183*pSrc[3] + 73*pSrc[4]) >> 7;		// 2	3	183	73
				pDst[10] = (115*pSrc[3] + 141*pSrc[4]) >> 7;	// 2	3	115	141
				pDst[11] = (47*pSrc[3] + 209*pSrc[4]) >> 7;		// 2	3	47	209
				pDst[12] = (235*pSrc[4] + 21*pSrc[5]) >> 7;		// 3	4	235	21
				pDst[13] = (166*pSrc[4] + 90*pSrc[5]) >> 7;		// 3	4	166	90
				pDst[14] = (98*pSrc[4] + 158*pSrc[5]) >> 7;		// 3	4	98	158
			}
			// interpolation in Y direction (preserve 9 bits)
			for (int u=0; u<15; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		 									 ref point          filter
				pDst[0] = (30*pSrc[0] + 226*pSrc[15]) >> 8;				// -1	0	30	226
				pDst[15] = (218*pSrc[15] + 38*pSrc[2*15]) >> 8;			// 0	1	218	38
				pDst[2*15] = (149*pSrc[15] + 107*pSrc[2*15]) >> 8;		// 0	1	149	107
				pDst[3*15] = (81*pSrc[15] + 175*pSrc[2*15]) >> 8;		// 0	1	81	175
				pDst[4*15] = (13*pSrc[15] + 243*pSrc[2*15]) >> 8;		// 0	1	13	243
				pDst[5*15] = (201*pSrc[2*15] + 55*pSrc[3*15]) >> 8;		// 1	2	201	55
				pDst[6*15] = (132*pSrc[2*15] + 124*pSrc[3*15]) >> 8;	// 1	2	132	124
				pDst[7*15] = (64*pSrc[2*15] + 192*pSrc[3*15]) >> 8;		// 1	2	64	192
				pDst[8*15] = (252*pSrc[3*15] + 4*pSrc[4*15]) >> 8;		// 2	3	252	4
				pDst[9*15] = (183*pSrc[3*15] + 73*pSrc[4*15]) >> 8;		// 2	3	183	73
				pDst[10*15] = (115*pSrc[3*15] + 141*pSrc[4*15]) >> 8;	// 2	3	115	141
				pDst[11*15] = (47*pSrc[3*15] + 209*pSrc[4*15]) >> 8;	// 2	3	47	209
				pDst[12*15] = (235*pSrc[4*15] + 21*pSrc[5*15]) >> 8;	// 3	4	235	21
				pDst[13*15] = (166*pSrc[4*15] + 90*pSrc[5*15]) >> 8;	// 3	4	166	90
				pDst[14*15] = (98*pSrc[4*15] + 158*pSrc[5*15]) >> 8;	// 3	4	98	158
			}
			// write a 15x15 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+15; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+15; xx++) {
					// rounding and clipping
					int val = pBlock2[i];
					pBuf[xx] = rndclp_9Uto8U(val);
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::intp_chroma_4to15_bicubic_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// resize the chroma plane and covert from 4:2:0-like format to 4:4:4.
// Supposing the input chroma plane is resampled from a 4:4:4 image by interlacing (which is different from sampling location of 4:2:0), 
// this function enlarges the image 15/4 times (576p-to-1080p + 4:2:0-to-4:4:4) and make sure the result plane is aligned with the luma plane that upscaled
// by a 15/8 (576p to 1080p) RESIZE options.
// The indices and the filters (*256) are:
// -2	-1	0	1	-2	27	248	-17
// -1	0	1	2	-21	245	36	-4
// -1	0	1	2	-27	179	123	-19
// -1	0	1	2	-13	89	208	-28
// -1	0	1	2	0	11	254	-9
// 0	1	2	3	-26	233	56	-7
// 0	1	2	3	-25	158	146	-23
// 0	1	2	3	-9	67	225	-27
// 1	2	3	4	-3	256	3	0
// 1	2	3	4	-28	217	78	-11
// 1	2	3	4	-21	134	169	-26
// 1	2	3	4	-5	46	238	-23
// 2	3	4	5	-13	252	18	-1
// 2	3	4	5	-28	199	100	-15
// 2	3	4	5	-17	112	189	-28
// Luhong Liang, IC-ASD, ASTRI
// April 26, 2013
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::intp_chroma_4to15_bicubic_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*15 != iplDstImage->width*4 || iplSrcImage->height*15 != iplDstImage->height*4) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::intp_chroma_4to15_bicubic_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (15x15 block, step = 15, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[8*8];		// 8x8 block in source image (4 points + padding)
	int pBlock1[15*8];		// after interpolation in X direction
	int pBlock2[15*15];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=15, top+=4) {
		for (int x=0, left=0; x<iplDstImage->width; x+=15, left+=4) {
			// load a 8x8 block in source image (4x4 + padding)
			int i = 0;
			for (int yy=top; yy<top+8; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+8; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction (preserve 9 bits)
			for (int v=0; v<8; v++) {
				int *pSrc = pBlock + v * 8;
				int *pDst = pBlock1 + v * 15;
				// calculation		   					     ref point       filter
				pDst[0] = (-2*pSrc[0] + 27*pSrc[1] + 248*pSrc[2] - 17*pSrc[3]) >> 7;		// -2	-1	0	1	-2	27	248	-17
				pDst[1] = (-21*pSrc[1] + 245*pSrc[2] + 36*pSrc[3] - 4*pSrc[4]) >> 7;		// -1	0	1	2	-21	245	36	-4
				pDst[2] = (-27*pSrc[1] + 179*pSrc[2] + 123*pSrc[3] - 19*pSrc[4]) >> 7;		// -1	0	1	2	-27	179	123	-19
				pDst[3] = (-13*pSrc[1] + 89*pSrc[2] + 208*pSrc[3] - 28*pSrc[4]) >> 7;		// -1	0	1	2	-13	89	208	-28
				pDst[4] = (-0*pSrc[1] + 11*pSrc[2] + 254*pSrc[3] - 9*pSrc[4]) >> 7;			// -1	0	1	2	0	11	254	-9
				pDst[5] = (-26*pSrc[2] + 233*pSrc[3] + 56*pSrc[4] - 7*pSrc[5]) >> 7;		// 0	1	2	3	-26	233	56	-7
				pDst[6] = (-25*pSrc[2] + 158*pSrc[3] + 146*pSrc[4] - 23*pSrc[5]) >> 7;		// 0	1	2	3	-25	158	146	-23
				pDst[7] = (-9*pSrc[2] + 67*pSrc[3] + 225*pSrc[4] - 27*pSrc[5]) >> 7;		// 0	1	2	3	-9	67	225	-27
				pDst[8] = (-3*pSrc[3] + 256*pSrc[4] + 3*pSrc[5] - 0*pSrc[6]) >> 7;			// 1	2	3	4	-3	256	3	0
				pDst[9] = (-28*pSrc[3] + 217*pSrc[4] + 78*pSrc[5] - 11*pSrc[6]) >> 7;		// 1	2	3	4	-28	217	78	-11
				pDst[10] = (-21*pSrc[3] + 134*pSrc[4] + 169*pSrc[5] - 26*pSrc[6]) >> 7;		// 1	2	3	4	-21	134	169	-26
				pDst[11] = (-5*pSrc[3] + 46*pSrc[4] + 238*pSrc[5] - 23*pSrc[6]) >> 7;		// 1	2	3	4	-5	46	238	-23
				pDst[12] = (-13*pSrc[4] + 252*pSrc[5] + 18*pSrc[6] - 1*pSrc[7]) >> 7;		// 2	3	4	5	-13	252	18	-1
				pDst[13] = (-28*pSrc[4] + 199*pSrc[5] + 100*pSrc[6] - 15*pSrc[7]) >> 7;		// 2	3	4	5	-28	199	100	-15
				pDst[14] = (-17*pSrc[4] + 112*pSrc[5] + 189*pSrc[6] - 28*pSrc[7]) >> 7;		// 2	3	4	5	-17	112	189	-28
			}
			// interpolation in Y direction (preserve 9 bits)
			for (int u=0; u<15; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		 																	 ref point          filter
				pDst[0*15] = (-2*pSrc[0*15] + 27*pSrc[1*15] + 248*pSrc[2*15] - 17*pSrc[3*15]) >> 8;		// -2	-1	0	1	-2	27	248	-17
				pDst[1*15] = (-21*pSrc[1*15] + 245*pSrc[2*15] + 36*pSrc[3*15] - 4*pSrc[4*15]) >> 8;		// -1	0	1	2	-21	245	36	-4
				pDst[2*15] = (-27*pSrc[1*15] + 179*pSrc[2*15] + 123*pSrc[3*15] - 19*pSrc[4*15]) >> 8;	// -1	0	1	2	-27	179	123	-19
				pDst[3*15] = (-13*pSrc[1*15] + 89*pSrc[2*15] + 208*pSrc[3*15] - 28*pSrc[4*15]) >> 8;	// -1	0	1	2	-13	89	208	-28
				pDst[4*15] = (-0*pSrc[1*15] + 11*pSrc[2*15] + 254*pSrc[3*15] - 9*pSrc[4*15]) >> 8;		// -1	0	1	2	0	11	254	-9
				pDst[5*15] = (-26*pSrc[2*15] + 233*pSrc[3*15] + 56*pSrc[4*15] - 7*pSrc[5*15]) >> 8;		// 0	1	2	3	-26	233	56	-7
				pDst[6*15] = (-25*pSrc[2*15] + 158*pSrc[3*15] + 146*pSrc[4*15] - 23*pSrc[5*15]) >> 8;	// 0	1	2	3	-25	158	146	-23
				pDst[7*15] = (-9*pSrc[2*15] + 67*pSrc[3*15] + 225*pSrc[4*15] - 27*pSrc[5*15]) >> 8;		// 0	1	2	3	-9	67	225	-27
				pDst[8*15] = (-3*pSrc[3*15] + 256*pSrc[4*15] + 3*pSrc[5*15] - 0*pSrc[6*15]) >> 8;		// 1	2	3	4	-3	256	3	0
				pDst[9*15] = (-28*pSrc[3*15] + 217*pSrc[4*15] + 78*pSrc[5*15] - 11*pSrc[6*15]) >> 8;	// 1	2	3	4	-28	217	78	-11
				pDst[10*15] = (-21*pSrc[3*15] + 134*pSrc[4*15] + 169*pSrc[5*15] - 26*pSrc[6*15]) >> 8;	// 1	2	3	4	-21	134	169	-26
				pDst[11*15] = (-5*pSrc[3*15] + 46*pSrc[4*15] + 238*pSrc[5*15] - 23*pSrc[6*15]) >> 8;	// 1	2	3	4	-5	46	238	-23
				pDst[12*15] = (-13*pSrc[4*15] + 252*pSrc[5*15] + 18*pSrc[6*15] - 1*pSrc[7*15]) >> 8;	// 2	3	4	5	-13	252	18	-1
				pDst[13*15] = (-28*pSrc[4*15] + 199*pSrc[5*15] + 100*pSrc[6*15] - 15*pSrc[7*15]) >> 8;	// 2	3	4	5	-28	199	100	-15
				pDst[14*15] = (-17*pSrc[4*15] + 112*pSrc[5*15] + 189*pSrc[6*15] - 28*pSrc[7*15]) >> 8;	// 2	3	4	5	-17	112	189	-28
			}
			// write a 15x15 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+15; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+15; xx++) {
					// rounding and clipping
					int val = pBlock2[i];
					pBuf[xx] = rndclp_9Uto8U(val);
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::intp_chroma_4to15_cublin_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// resize the chroma plane and covert from 4:2:0-like format to 4:4:4.
// Supposing the input chroma plane is resampled from a 4:4:4 image by interlacing (which is different from sampling location of 4:2:0), 
// this function enlarges the image 15/4 times (576p-to-1080p + 4:2:0-to-4:4:4) and make sure the result plane is aligned with the luma plane that upscaled
// by a 15/8 (576p to 1080p) RESIZE options.
// The indices and the filters (*256) in X direction are:
// -2	-1	0	1	-2	27	248	-17
// -1	0	1	2	-21	245	36	-4
// -1	0	1	2	-27	179	123	-19
// -1	0	1	2	-13	89	208	-28
// -1	0	1	2	0	11	254	-9
// 0	1	2	3	-26	233	56	-7
// 0	1	2	3	-25	158	146	-23
// 0	1	2	3	-9	67	225	-27
// 1	2	3	4	-3	256	3	0
// 1	2	3	4	-28	217	78	-11
// 1	2	3	4	-21	134	169	-26
// 1	2	3	4	-5	46	238	-23
// 2	3	4	5	-13	252	18	-1
// 2	3	4	5	-28	199	100	-15
// 2	3	4	5	-17	112	189	-28
// The indices and the filters (*256) in Y direction are:
// -1	0	30	226
// 0	1	218	38
// 0	1	149	107
// 0	1	81	175
// 0	1	13	243
// 1	2	201	55
// 1	2	132	124
// 1	2	64	192
// 2	3	252	4
// 2	3	183	73
// 2	3	115	141
// 2	3	47	209
// 3	4	235	21
// 3	4	166	90
// 3	4	98	158
// Luhong Liang, IC-ASD, ASTRI
// April 26, 2013
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::intp_chroma_4to15_cublin_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*15 != iplDstImage->width*4 || iplSrcImage->height*15 != iplDstImage->height*4) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::intp_chroma_4to15_cublin_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (15x15 block, step = 15, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[8*6];		// 8x6 block in source image (4 points + padding)
	int pBlock1[15*6];		// after interpolation in X direction
	int pBlock2[15*15];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=15, top+=4) {
		for (int x=0, left=0; x<iplDstImage->width; x+=15, left+=4) {
			// load a 8x6 block in source image (4x4 + padding)
			int i = 0;
			for (int yy=top; yy<top+6; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+8; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction (preserve 9 bits)
			for (int v=0; v<6; v++) {
				int *pSrc = pBlock + v * 8;
				int *pDst = pBlock1 + v * 15;
				// calculation		   					     ref point       filter
				pDst[0] = (-2*pSrc[0] + 27*pSrc[1] + 248*pSrc[2] - 17*pSrc[3]) >> 7;		// -2	-1	0	1	-2	27	248	-17
				pDst[1] = (-21*pSrc[1] + 245*pSrc[2] + 36*pSrc[3] - 4*pSrc[4]) >> 7;		// -1	0	1	2	-21	245	36	-4
				pDst[2] = (-27*pSrc[1] + 179*pSrc[2] + 123*pSrc[3] - 19*pSrc[4]) >> 7;		// -1	0	1	2	-27	179	123	-19
				pDst[3] = (-13*pSrc[1] + 89*pSrc[2] + 208*pSrc[3] - 28*pSrc[4]) >> 7;		// -1	0	1	2	-13	89	208	-28
				pDst[4] = (-0*pSrc[1] + 11*pSrc[2] + 254*pSrc[3] - 9*pSrc[4]) >> 7;			// -1	0	1	2	0	11	254	-9
				pDst[5] = (-26*pSrc[2] + 233*pSrc[3] + 56*pSrc[4] - 7*pSrc[5]) >> 7;		// 0	1	2	3	-26	233	56	-7
				pDst[6] = (-25*pSrc[2] + 158*pSrc[3] + 146*pSrc[4] - 23*pSrc[5]) >> 7;		// 0	1	2	3	-25	158	146	-23
				pDst[7] = (-9*pSrc[2] + 67*pSrc[3] + 225*pSrc[4] - 27*pSrc[5]) >> 7;		// 0	1	2	3	-9	67	225	-27
				pDst[8] = (-3*pSrc[3] + 256*pSrc[4] + 3*pSrc[5] - 0*pSrc[6]) >> 7;			// 1	2	3	4	-3	256	3	0
				pDst[9] = (-28*pSrc[3] + 217*pSrc[4] + 78*pSrc[5] - 11*pSrc[6]) >> 7;		// 1	2	3	4	-28	217	78	-11
				pDst[10] = (-21*pSrc[3] + 134*pSrc[4] + 169*pSrc[5] - 26*pSrc[6]) >> 7;		// 1	2	3	4	-21	134	169	-26
				pDst[11] = (-5*pSrc[3] + 46*pSrc[4] + 238*pSrc[5] - 23*pSrc[6]) >> 7;		// 1	2	3	4	-5	46	238	-23
				pDst[12] = (-13*pSrc[4] + 252*pSrc[5] + 18*pSrc[6] - 1*pSrc[7]) >> 7;		// 2	3	4	5	-13	252	18	-1
				pDst[13] = (-28*pSrc[4] + 199*pSrc[5] + 100*pSrc[6] - 15*pSrc[7]) >> 7;		// 2	3	4	5	-28	199	100	-15
				pDst[14] = (-17*pSrc[4] + 112*pSrc[5] + 189*pSrc[6] - 28*pSrc[7]) >> 7;		// 2	3	4	5	-17	112	189	-28
			}
			// interpolation in Y direction (preserve 9 bits)
			for (int u=0; u<15; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		 									 ref point   filter
				pDst[0] = (30*pSrc[0] + 226*pSrc[15]) >> 8;				// -1	0	30	226
				pDst[15] = (218*pSrc[15] + 38*pSrc[2*15]) >> 8;			// 0	1	218	38
				pDst[2*15] = (149*pSrc[15] + 107*pSrc[2*15]) >> 8;		// 0	1	149	107
				pDst[3*15] = (81*pSrc[15] + 175*pSrc[2*15]) >> 8;		// 0	1	81	175
				pDst[4*15] = (13*pSrc[15] + 243*pSrc[2*15]) >> 8;		// 0	1	13	243
				pDst[5*15] = (201*pSrc[2*15] + 55*pSrc[3*15]) >> 8;		// 1	2	201	55
				pDst[6*15] = (132*pSrc[2*15] + 124*pSrc[3*15]) >> 8;	// 1	2	132	124
				pDst[7*15] = (64*pSrc[2*15] + 192*pSrc[3*15]) >> 8;		// 1	2	64	192
				pDst[8*15] = (252*pSrc[3*15] + 4*pSrc[4*15]) >> 8;		// 2	3	252	4
				pDst[9*15] = (183*pSrc[3*15] + 73*pSrc[4*15]) >> 8;		// 2	3	183	73
				pDst[10*15] = (115*pSrc[3*15] + 141*pSrc[4*15]) >> 8;	// 2	3	115	141
				pDst[11*15] = (47*pSrc[3*15] + 209*pSrc[4*15]) >> 8;	// 2	3	47	209
				pDst[12*15] = (235*pSrc[4*15] + 21*pSrc[5*15]) >> 8;	// 3	4	235	21
				pDst[13*15] = (166*pSrc[4*15] + 90*pSrc[5*15]) >> 8;	// 3	4	166	90
				pDst[14*15] = (98*pSrc[4*15] + 158*pSrc[5*15]) >> 8;	// 3	4	98	158
			}
			// write a 15x15 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+15; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+15; xx++) {
					// rounding and clipping
					int val = pBlock2[i];
					pBuf[xx] = rndclp_9Uto8U(val);
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::intp_chroma_1to4_bilinear_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// resize the chroma plane and covert from 4:2:0-like format to 4:4:4.
// Supposing the input chroma plane is resampled from a 4:4:4 image by interlacing (which is different from sampling location of 4:2:0), 
// this function enlarges the image 4 times (like 540p-to-1080p + 4:2:0-to-4:4:4) and make sure the result plane is aligned with the luma plane that upscaled
// by a 2 (like 540p-to-1080p) RESIZE options.
// The bilinear interpolation is used and the filters are:
//	Index	Filter*8
//	-1	0	1	7
//	0	1	7	1
//	0	1	5	3
//	0	1	3	5
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::intp_chroma_1to4_bilinear_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*4 != iplDstImage->width || iplSrcImage->height*4 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::intp_chroma_1to4_bilinear_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bilinear, every pixel creates 4x4 pixels, i.e. 3x3 block creates 4x4 block considering boundary/padding
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[3*3];		// 3x3 block in source image (1 points + padding)
	int pBlock1[4*3];		// after interpolation in X direction
	int pBlock2[4*4];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=4, top++) {
		for (int x=0, left=0; x<iplDstImage->width; x+=4, left++) {
			// load a 3x3 block in source image (1x1 + padding)
			int i = 0;
			for (int yy=top; yy<top+3; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+3; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction (preserve 9 bits)
			for (int v=0; v<3; v++) {
				int *pSrc = pBlock + v * 3;
				int *pDst = pBlock1 + v * 4;
				// calculation		   					     ref point      filter
				pDst[0] = (pSrc[0] + 7*pSrc[1]) >> 2;		//	-1	0		1	7
				pDst[1] = (7*pSrc[1] + pSrc[2]) >> 2;		//	0	1		7	1
				pDst[2] = (5*pSrc[1] + 3*pSrc[2]) >> 2;		//	0	1		5	3
				pDst[3] = (3*pSrc[1] + 5*pSrc[2]) >> 2;		//	0	1		3	5
			}
			// interpolation in Y direction (preserve 9 bits)
			for (int u=0; u<4; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		 						 ref point      filter
				pDst[0] = (pSrc[0] + 7*pSrc[4]) >> 3;		//	-1	0		1	7
				pDst[4] = (7*pSrc[4] + pSrc[8]) >> 3;		//	0	1		7	1
				pDst[8] = (5*pSrc[4] + 3*pSrc[8]) >> 3;		//	0	1		5	3
				pDst[12] = (3*pSrc[4] + 5*pSrc[8]) >> 3;	//	0	1		3	5
			}
			// write a 4x4 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+4; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+4; xx++) {
					// rounding and clipping
					int val = pBlock2[i];
					pBuf[xx] = rndclp_9Uto8U(val);
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::intp_chroma_1to4_bicubic_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// resize the chroma plane and covert from 4:2:0-like format to 4:4:4.
// Supposing the input chroma plane is resampled from a 4:4:4 image by interlacing (which is different from sampling location of 4:2:0), 
// this function enlarges the image 4 times (like 540p-to-1080p + 4:2:0-to-4:4:4) and make sure the result plane is aligned with the luma plane that upscaled
// by a 2 (like 540p-to-1080p) RESIZE options.
// The bicubic interpolation is used and the filters are:
//		Index			Filter*256
//	-2	-1	0	1	-3	29	248	-18
//	-1	0	1	2	-18	248	29	-3
//	-1	0	1	2	-28	192	109	-17
//	-1	0	1	2	-17	109	192	-28
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::intp_chroma_1to4_bicubic_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*4 != iplDstImage->width || iplSrcImage->height*4 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::intp_chroma_1to4_bicubic_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (4x4 block, step = 4, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[5*5];		// 5x5 block in source image (1x1 block + padding)
	int pBlock1[4*5];		// after interpolation in X direction
	int pBlock2[4*4];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=4, top++) {
		for (int x=0, left=0; x<iplDstImage->width; x+=4, left++) {
			// load a 5x5 block in source image (1x1 + padding)
			int i = 0;
			for (int yy=top; yy<top+5; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+5; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction (preserve 9 bits)
			for (int v=0; v<5; v++) {
				int *pSrc = pBlock + v * 5;
				int *pDst = pBlock1 + v * 4;												//		Index		  Filter*256
				pDst[0] = (-3*pSrc[0] + 29*pSrc[1] + 248*pSrc[2] - 18*pSrc[3]) >> 7;		//	-2	-1	0	1	-3	29	248	-18
				pDst[1] = (-18*pSrc[1] + 248*pSrc[2] + 29*pSrc[3] - 3*pSrc[4]) >> 7;		//	-1	0	1	2	-18	248	29	-3
				pDst[2] = (-28*pSrc[1] + 192*pSrc[2] + 109*pSrc[3] - 17*pSrc[4]) >> 7;		//	-1	0	1	2	-28	192	109	-17
				pDst[3] = (-17*pSrc[1] + 109*pSrc[2] + 192*pSrc[3] - 28*pSrc[4]) >> 7;		//	-1	0	1	2	-17	109	192	-28
			}
			// interpolation in Y direction (preserve 9 bits)
			for (int u=0; u<4; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;													//		Index		  Filter*256
				pDst[0] = (-3*pSrc[0] + 29*pSrc[4] + 248*pSrc[8] - 18*pSrc[12]) >> 8;		//	-2	-1	0	1	-3	29	248	-18
				pDst[4] = (-18*pSrc[4] + 248*pSrc[8] + 29*pSrc[12] - 3*pSrc[16]) >> 8;		//	-1	0	1	2	-18	248	29	-3
				pDst[8] = (-28*pSrc[4] + 192*pSrc[8] + 109*pSrc[12] - 17*pSrc[16]) >> 8;	//	-1	0	1	2	-28	192	109	-17
				pDst[12] = (-17*pSrc[4] + 109*pSrc[8] + 192*pSrc[12] - 28*pSrc[16]) >> 8;	//	-1	0	1	2	-17	109	192	-28
			}
			// write a 4x4 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+4; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+4; xx++) {
					// rounding and clipping
					int val = pBlock2[i];
					pBuf[xx] = rndclp_9Uto8U(val);
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}


bool CImageUtility::intp_chroma_1to4_cublin_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// resize the chroma plane and covert from 4:2:0-like format to 4:4:4.
// Supposing the input chroma plane is resampled from a 4:4:4 image by interlacing (which is different from sampling location of 4:2:0), 
// this function enlarges the image 4 times (like 540p-to-1080p + 4:2:0-to-4:4:4) and make sure the result plane is aligned with the luma plane that upscaled
// by a 2 (like 540p-to-1080p) RESIZE options.
// The bicubic interpolation is used in X direction and the filters are:
//		Index			Filter*256
//	-2	-1	0	1	-3	29	248	-18
//	-1	0	1	2	-18	248	29	-3
//	-1	0	1	2	-28	192	109	-17
//	-1	0	1	2	-17	109	192	-28
// The bilinear interpolation is used in Y direction and the filters are:
//	Index	Filter*8
//	-1	0	1	7
//	0	1	7	1
//	0	1	5	3
//	0	1	3	5
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::intp_chroma_1to4_cublin_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*4 != iplDstImage->width || iplSrcImage->height*4 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::intp_chroma_1to4_cublin_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic (4x4 block, step = 4, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int pBlock[5*3];		// 5x3 block in source image (1x1 block + padding)
	int pBlock1[4*3];		// after interpolation in X direction
	int pBlock2[4*4];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=4, top++) {
		for (int x=0, left=0; x<iplDstImage->width; x+=4, left++) {
			// load a 5x5 block in source image (1x1 + padding)
			int i = 0;
			for (int yy=top; yy<top+3; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+5; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction (preserve 9 bits)
			for (int v=0; v<3; v++) {
				int *pSrc = pBlock + v * 5;
				int *pDst = pBlock1 + v * 4;												//		Index		  Filter*256
				pDst[0] = (-3*pSrc[0] + 29*pSrc[1] + 248*pSrc[2] - 18*pSrc[3]) >> 7;		//	-2	-1	0	1	-3	29	248	-18
				pDst[1] = (-18*pSrc[1] + 248*pSrc[2] + 29*pSrc[3] - 3*pSrc[4]) >> 7;		//	-1	0	1	2	-18	248	29	-3
				pDst[2] = (-28*pSrc[1] + 192*pSrc[2] + 109*pSrc[3] - 17*pSrc[4]) >> 7;		//	-1	0	1	2	-28	192	109	-17
				pDst[3] = (-17*pSrc[1] + 109*pSrc[2] + 192*pSrc[3] - 28*pSrc[4]) >> 7;		//	-1	0	1	2	-17	109	192	-28
			}
			// interpolation in Y direction (preserve 9 bits)
			for (int u=0; u<4; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;					//	Index	  Filter*8
				pDst[0] = (pSrc[0] + 7*pSrc[4]) >> 3;		//	-1	0		1	7
				pDst[4] = (7*pSrc[4] + pSrc[8]) >> 3;		//	0	1		7	1
				pDst[8] = (5*pSrc[4] + 3*pSrc[8]) >> 3;		//	0	1		5	3
				pDst[12] = (3*pSrc[4] + 5*pSrc[8]) >> 3;	//	0	1		3	5
			}
			// write a 4x4 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+4; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+4; xx++) {
					// rounding and clipping
					int val = pBlock2[i];
					pBuf[xx] = rndclp_9Uto8U(val);
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::inter_1to2_cublin_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Covert from 4:2:0-like format to 4:4:4.
// Supposing the input chroma plane is resampled from a 4:4:4 image by interlacing (which is different from sampling location of 4:2:0), 
// this function enlarges the image 2 times (1080p-to-1080p + 4:2:0-to-4:4:4) and make sure the result plane is aligned with the
// original luma plane (1080p-to-1080p).
//
// Interpolate 1/2-pixel image using bicubic in X direction
// The sample locations are (1-D) as example:
//		-1     0     1     2     3      4     5	<-- original image (padding 1, 2)
//             *  o  *  o  *  o  *  o			< --interpolated image
// The filter for new pixel 'o' is (-1/8, 5/8, 5/8, -1/8)
// Interpolate 1/2-pixel image using bilinear in Y direction
//				0     1     2     3      4			<-- original image  (padding 0, 1)
//              *  o  *  o  *  o  *  o  			< --interpolated image
// The filter for new pixel 'o' is (1/2, 1/2)
// Luhong Liang, IC-ASD, ASTRI
// April 25, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_cublin_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_cublin_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 2, 0, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to2_cublin_8U()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine[x] = ((int)pBuf0[x] + (int)pBuf1[x]);		// 9-bit
		}
		// interpolation in X direction
		unsigned char *pDst0 = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		unsigned char *pDst1 = (unsigned char *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0 (interpolation of original pixels)
			pDst0[x] = pBuf0[left+1];
			int pix = (- (int)(pBuf0[left]) + 5 * ((int)(pBuf0[left+1]) + (int)(pBuf0[left+2])) - (int)(pBuf0[left+3])) >> 2;
			pDst0[x+1] = rndclp_9Uto8U(pix);
			// line 1 (interpolation of interpolated pixels)
			pix = pLine[left+1];		// left+1 to compensate the 1-pixel padding!
			pDst1[x] = rndclp_9Uto8U(pix);
			pix = (- pLine[left] + 5 * (pLine[left+1] + pLine[left+2]) - pLine[left+3]) >> 3;
			pDst1[x+1] = rndclp_9Uto8U(pix);
		}
	}
	
	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::inter_1to2_bilinear_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Covert from 4:2:0-like format to 4:4:4.
// Supposing the input chroma plane is resampled from a 4:4:4 image by interlacing (which is different from sampling location of 4:2:0), 
// this function enlarges the image 2 times (1080p-to-1080p + 4:2:0-to-4:4:4) and make sure the result plane is aligned with the
// original luma plane (1080p-to-1080p).
//
// Interpolate 1/2-pixel image using bilinear
//				0     1     2     3      4			<-- original image  (padding 0, 1)
//              *  o  *  o  *  o  *  o  			< --interpolated image
// The filter for new pixel 'o' is (1/2, 1/2)
// Luhong Liang, IC-ASD, ASTRI
// April 25, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_bilinear_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_bilinear_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 0, 1, 0, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to2_bilinear_8U()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine[x] = ((int)pBuf0[x] + (int)pBuf1[x]);		// 9-bit
		}
		// interpolation in X direction
		unsigned char *pDst0 = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		unsigned char *pDst1 = (unsigned char *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0 (interpolation of original pixels)
			pDst0[x] = pBuf0[left];
			int pix = ((int)(pBuf0[left]) + (int)(pBuf0[left+1]));
			pDst0[x+1] = rndclp_9Uto8U(pix);
			// line 1 (interpolation of interpolated pixels)
			pix = pLine[left];
			pDst1[x] = rndclp_9Uto8U(pix);
			pix = (pLine[left] + pLine[left+1]) >> 1;
			pDst1[x+1] = rndclp_9Uto8U(pix);
		}
	}
	
	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::inter_1to2_bilinear_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Covert from 4:2:0-like format to 4:4:4.
// Supposing the input chroma plane is resampled from a 4:4:4 image by interlacing (which is different from sampling location of 4:2:0), 
// this function enlarges the image 2 times (1080p-to-1080p + 4:2:0-to-4:4:4) and make sure the result plane is aligned with the
// original luma plane (1080p-to-1080p).
//
// Interpolate 1/2-pixel image using bilinear
//				0     1     2     3      4			<-- original image  (padding 0, 1)
//              *  o  *  o  *  o  *  o  			< --interpolated image
// The filter for new pixel 'o' is (1/2, 1/2)
// Luhong Liang, IC-ASD, ASTRI
// Oct 29, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_bilinear_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_bilinear_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 0, 1, 0, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	float *pLine = new float[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to2_bilinear_32f()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		float *pBuf0 = (float *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		float *pBuf1 = (float *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine[x] = (pBuf0[x] + pBuf1[x]) * 0.5f;
		}
		// interpolation in X direction
		float *pDst0 = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		float *pDst1 = (float *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0 (interpolation of original pixels)
			pDst0[x] = pBuf0[left];
			float pix = pBuf0[left] + pBuf0[left+1];
			pDst0[x+1] = pix * 0.5f;
			// line 1 (interpolation of interpolated pixels)
			pix = pLine[left];
			pDst1[x] = pix;
			pix = pLine[left] + pLine[left+1];
			pDst1[x+1] = pix * 0.5f;
		}
	}
	
	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::inter_1to2_bilinear_odd_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Interpolate 1/2-pixel image using bilinear
//          *     *      *     *      *     *      *     *    <--- '*' interpolated pixels
//                o            o            o            o    <--- 'o' orginal pixels
// The filter for new pixel 'o' is (1/2, 1/2)
// Luhong Liang, IC-ASD, ASTRI
// March 18, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_bilinear_odd_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_bilinear_odd_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 0, 1, 0);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	float *pLine = new float[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to2_bilinear_odd_32f()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		float *pBuf0 = (float *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		float *pBuf1 = (float *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine[x] = (pBuf0[x] + pBuf1[x]) * 0.5f;
		}
		// interpolation in X direction
		float *pDst0 = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		float *pDst1 = (float *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0 (interpolation of original pixels)
            float pix = (pLine[left] + pLine[left+1]) * 0.5f;
			pDst0[x] = pix;
			pDst0[x+1] = pLine[left+1];
			// line 1 (interpolation of interpolated pixels)
			pix = (pBuf1[left] + pBuf1[left+1]) * 0.5f;
			pDst1[x] = pix;
			pDst1[x+1] = pBuf1[left+1];
		}
	}
	
	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::inter_1to2_bilinear_odd_Int(IplImage *iplSrcImage, IplImage *iplDstImage)
// Interpolate 1/2-pixel image using bilinear
//          *     *      *     *      *     *       *     *    <--- * interpolated pixels
//          *    O      *    O      *    O      *    O    < --- O orginal pixels
// The filter for new pixel 'o' is (1/2, 1/2)
// Luhong Liang, IC-ASD, ASTRI
// July 3, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_bilinear_odd_Int()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_bilinear_odd_Int()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 0, 1, 0);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to2_bilinear_odd_Int()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		int *pBuf0 = (int *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		int *pBuf1 = (int *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine[x] = pBuf0[x] + pBuf1[x];
		}
		// interpolation in X direction
		int *pDst0 = (int *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		int *pDst1 = (int *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0 (interpolation of original pixels)
            pDst0[x] = (pLine[left] + pLine[left+1]) >> 2;      // truncation
			pDst0[x+1] = pLine[left+1] >> 1;
			// line 1 (interpolation of interpolated pixels)
			pDst1[x] = (pBuf1[left] + pBuf1[left+1]) >> 1;
			pDst1[x+1] = pBuf1[left+1];
		}
	}
	
	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::inter_1to2_bilinear_odd_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Interpolate 1/2-pixel image using bilinear
//          *     *      *     *      *     *       *     *    <--- * interpolated pixels
//          *    O      *    O      *    O      *    O    < --- O orginal pixels
// The filter for new pixel 'o' is (1/2, 1/2)
// Luhong Liang, IC-ASD, ASTRI
// June 28, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_bilinear_odd_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_bilinear_odd_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 0, 1, 0);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to2_bilinear_odd_8U()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine[x] = pBuf0[x] + pBuf1[x];
		}
		// interpolation in X direction
		unsigned char *pDst0 = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		unsigned char *pDst1 = (unsigned char *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0 (interpolation of original pixels)
            int pix = (pLine[left] + pLine[left+1]) >> 1;
			pDst0[x] = rndclp_9Uto8U(pix);
			pDst0[x+1] = rndclp_9Uto8U(pLine[left+1]);
			// line 1 (interpolation of interpolated pixels)
			pix = pBuf1[left] + pBuf1[left+1];
			pDst1[x] = rndclp_9Uto8U(pix);
			pDst1[x+1] = pBuf1[left+1];
		}
	}
	
	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::inter_1to4_bilinear_odd_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Interpolate 1/4-pixel image using bilinear
//     x                                     o  <--- 'o' orginal pixels ('x' padded)
//           *          *          *         *  <--- '*' interpolated pixels
//       (3/4,1/4)  (1/2,1/2)  (1/4,3/4)
// Luhong Liang, IC-ASD, ASTRI
// March 2, 2015
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to4_bilinear_odd_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*4 != iplDstImage->width || iplSrcImage->height*4 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to4_bilinear_odd_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 0, 1, 0);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bilinear ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	float *pLine = new float[iplSrcPad->width*3];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to4_bilinear_odd_32f()!\n");
		safeReleaseImage(&iplSrcPad);
	}
    float *pLine0 = pLine;
    float *pLine1 = pLine + iplSrcPad->width;
    float *pLine2 = pLine1 + iplSrcPad->width;
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=4, top++) {
		float *pBuf0 = (float *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		float *pBuf1 = (float *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
            pLine0[x] = pBuf0[x] * 0.75f + pBuf1[x] * 0.25f;
			pLine1[x] = (pBuf0[x] + pBuf1[x]) * 0.5f;
            pLine2[x] = pBuf0[x] * 0.25f + pBuf1[x] * 0.75f;
		}
		// interpolation in X direction
		float *pDst0 = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		float *pDst1 = (float *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
        float *pDst2 = (float *)(iplDstImage->imageData + (y+2) * iplDstImage->widthStep);
        float *pDst3 = (float *)(iplDstImage->imageData + (y+3) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=4, left++) {
			// line 0 (interpolation of original pixels)
            pDst0[x] = pLine0[left] * 0.75f + pLine0[left+1] * 0.25f;
			pDst0[x+1] = (pLine0[left] + pLine0[left+1]) * 0.5f;
            pDst0[x+2] = pLine0[left] * 0.25f + pLine0[left+1] * 0.75f;
			pDst0[x+3] = pLine0[left+1];
			// line 1 (interpolation of original pixels)
            pDst1[x] = pLine1[left] * 0.75f + pLine1[left+1] * 0.25f;
			pDst1[x+1] = (pLine1[left] + pLine1[left+1]) * 0.5f;
            pDst1[x+2] = pLine1[left] * 0.25f + pLine1[left+1] * 0.75f;
			pDst1[x+3] = pLine1[left+1];
			// line 2 (interpolation of original pixels)
            pDst2[x] = pLine2[left] * 0.75f + pLine2[left+1] * 0.25f;
			pDst2[x+1] = (pLine2[left] + pLine2[left+1]) * 0.5f;
            pDst2[x+2] = pLine2[left] * 0.25f + pLine2[left+1] * 0.75f;
			pDst2[x+3] = pLine2[left+1];
			// line 3 (interpolation of original pixels)
            pDst3[x] = pBuf1[left] * 0.75f + pBuf1[left+1] * 0.25f;
			pDst3[x+1] = (pBuf1[left] + pBuf1[left+1]) * 0.5f;
            pDst3[x+2] = pBuf1[left] * 0.25f + pBuf1[left+1] * 0.75f;
			pDst3[x+3] = pBuf1[left+1];
		}
	}
	
	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::inter_1to4_H264_odd_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Interpolate 1/4-pixel image using H.264/AVC quarter pixel interpolation.
// The sampling locations are as below.
//     x                                     o  <--- 'o' orginal pixels ('x' padded)
//           *          *          *         *  <--- '*' interpolated pixels
// In the H.264/AVC standard, a 6-tap FIR filter (1, -5, 20, 20, -5, 1)/32 is at first applied for half-pixel interpolation, and then
// a bi-linear filter is used for quarter-pixel estimation. 
// Luhong Liang, IC-ASD, ASTRI
// March 2, 2015
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to4_H264_odd_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*4 != iplDstImage->width || iplSrcImage->height*4 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to4_H264_odd_32f()!\n");
		return false;
	}

    // NOTE: This is the implementation with best readability, but the overhead is very high!

    // Step 1. 6-tap FIR
    //   x     x     x     o     o     o     o     x     x    <--- 'o' orginal pixels ('x' padded)
    //               #  *  *  *  *  *  *  *  *                <--- '*' interpolated pixels ('#' padded for quarter interpolation)
	// padding & allocate buffer
	IplImage *iplSrcPad = padding(iplSrcImage, 3, 2, 3, 2);
    IplImage *iplMid = createImage(iplSrcImage->width*2+1, iplSrcImage->height*2+1, iplSrcImage->depth, 1);
    float *pLine = new float[iplSrcPad->width * 2];     // for both input and intermediate layers
	if (iplSrcPad == NULL || iplMid == NULL || pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to4_H264_odd_32f()!\n");
		safeReleaseImage(&iplSrcPad, &iplMid);
        if (pLine != NULL) delete [] pLine;
	}
	//setZero(iplDstImage);
	for (int y=1, top=0; y<iplMid->height; y+=2, top++) {
		float *pBuf0 = (float *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		float *pBuf1 = (float *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
        float *pBuf2 = (float *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
        float *pBuf3 = (float *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
        float *pBuf4 = (float *)(iplSrcPad->imageData + (top+4) * iplSrcPad->widthStep);
        float *pBuf5 = (float *)(iplSrcPad->imageData + (top+5) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine[x] = 0.03125f * (pBuf0[x] + pBuf5[x]) - 0.15625f * (pBuf1[x] + pBuf4[x]) + 0.625f * (pBuf2[x] + pBuf3[x]);
		}
		// interpolation in X direction
		float *pDst0 = (float *)(iplMid->imageData + y * iplMid->widthStep);
		float *pDst1 = (float *)(iplMid->imageData + (y+1) * iplMid->widthStep);
		for (int x=1, left=0; x<iplMid->width; x+=2, left++) {
			// line 0 (interpolation of original pixels)
            float pix = 0.03125f * (pLine[left] + pLine[left+5]) - 0.15625f * (pLine[left+1] + pLine[left+4]) + 0.625f * (pLine[left+2] + pLine[left+3]);
			pDst0[x] = pix;
			pDst0[x+1] = pLine[left+3];
			// line 1 (interpolation of interpolated pixels)
			pix = 0.03125f * (pBuf3[left] + pBuf3[left+5]) - 0.15625f * (pBuf3[left+1] + pBuf3[left+4]) + 0.625f * (pBuf3[left+2] + pBuf3[left+3]);
			pDst1[x] = pix;
			pDst1[x+1] = pBuf3[left+3];
		}
        // padding in X here!
        pDst0[0] = pDst0[1];
        pDst1[0] = pDst1[1];
	}
    // padding in Y here
    float *pBuf0 = (float *)(iplMid->imageData);
    float *pBuf1 = (float *)(iplMid->imageData + iplMid->widthStep);
    memcpy(pBuf0, pBuf1, iplMid->widthStep);
    //saveImage("_H264mid.bmp", iplMid);

    // Step 2. Interpolate using bilinear
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		float *pBuf0 = (float *)(iplMid->imageData + top * iplMid->widthStep);
		float *pBuf1 = (float *)(iplMid->imageData + (top+1) * iplMid->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplMid->width; x++) {
			pLine[x] = (pBuf0[x] + pBuf1[x]) * 0.5f;
		}
		// interpolation in X direction
		float *pDst0 = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		float *pDst1 = (float *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0 (interpolation of original pixels)
            float pix = (pLine[left] + pLine[left+1]) * 0.5f;
			pDst0[x] = pix;
			pDst0[x+1] = pLine[left+1];
			// line 1 (interpolation of interpolated pixels)
			pix = (pBuf1[left] + pBuf1[left+1]) * 0.5f;
			pDst1[x] = pix;
			pDst1[x+1] = pBuf1[left+1];
		}
	}

    safeReleaseImage(&iplSrcPad, &iplMid);
    delete [] pLine;

	return true;
}

bool CImageUtility::inter_1to2_hybrid_odd_32f(IplImage *iplSrcImage, IplImage *iplDstImage, int degree)
// Interpolate 1/2-pixel image using hybrid of bicubic and bilinear interpolation
// The parameter 'degree' controls the weight of bilinear and bicubic, rangine 0 (bilinear) ~ 100 (bicubic)
// The sample locations are (1-D) as example:
//			  0     1     2     3      4	<-- original image
//         *  o  *  o  *  o  *  o  ...	    < --interpolated image
// The filter for new pixel 'o' is (-1/16, 9/16, 9/16, -1/16) for bicubic, and (0, 1/2, 1/2, 0) for bilinear
// Luhong Liang, IC-ASD, ASTRI
// September 18, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::inter_1to2_hybrid_odd_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_1to2_hybrid_odd_32f()!\n");
		return false;
	}
    if (degree < 0 || degree > 100) {
		showErrMsg("Parameter 'degree' should be 0~100 in CImageUtility::inter_1to2_hybrid_odd_32f()!\n");
		return false;
	}

    // calculate coefficients
    float w2 = (float)degree / 100.0f;
    float w1 = 1.0f - w2;
    float c0 = - 0.0625f * w1;
    float c1 = 0.5625f * w1 + 0.5f * w2;

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 1, 2, 1);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	float *pLine = new float[iplSrcPad->width];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::inter_1to2_hybrid_odd_32f()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		float *pBuf0 = (float *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		float *pBuf1 = (float *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		float *pBuf2 = (float *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		float *pBuf3 = (float *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
            pLine[x] = c1 * (pBuf1[x] + pBuf2[x]) + c0 * (pBuf0[x] + pBuf3[x]);
		}
		// interpolation in X direction
		float *pDst0 = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		float *pDst1 = (float *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
            float pix = c1 * (pLine[left+1] + pLine[left+2]) + c0 * (pLine[left] + pLine[left+3]);
            pDst0[x] = pix;
			pDst0[x+1] = pLine[left+2];
			// line 1
            pix = c1 * (pBuf2[left+1] + pBuf2[left+2]) + c0 * (pBuf2[left] + pBuf2[left+3]);
            pDst1[x] = pix;
			pDst1[x+1] = pBuf2[left+2];
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::inter_2to1_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// extract even colums and rows of an 32F image
// Interpolate 1/2-pixel image using bilinear
//				0     1     2     3      4			<-- original image
//              *            *             *		    < --downsampled image
// Luhong Liang, IC-ASD, ASTRI
// March 10, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::inter_2to1_32f()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height*2) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_2to1_32f()!\n");
		return false;
	}

	for (int y=0, yy=0; y<iplDstImage->height; y++, yy+=2) {
		float *pSrc = (float *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);
		float *pDst = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, xx=0; x<iplDstImage->width; x++, xx+=2) {
            pDst[x] = pSrc[xx];
        }
    }

    return true;
}

bool CImageUtility::inter_2to1_odd_Int(IplImage *iplSrcImage, IplImage *iplDstImage)
// extract even colums and rows of an 32S image
// Interpolate 1/2-pixel image using bilinear
//				0     1     2     3      4     5		 	<-- original image
//                    *            *             *		    < --downsampled image
// Luhong Liang, IC-ASD, ASTRI
// July 2, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::inter_2to1_odd_Int()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height*2) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_2to1_odd_Int()!\n");
		return false;
	}

	for (int y=0, yy=1; y<iplDstImage->height; y++, yy+=2) {
		int *pSrc = (int *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);
		int *pDst = (int *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, xx=1; x<iplDstImage->width; x++, xx+=2) {
            pDst[x] = pSrc[xx];
        }
    }

    return true;
}

bool CImageUtility::inter_2to1_odd_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// extract even colums and rows of an 32F image
// Interpolate 1/2-pixel image using bilinear
//				0     1     2     3      4     5		 	<-- original image
//                    *            *             *		    < --downsampled image
// Luhong Liang, IC-ASD, ASTRI
// March 18, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::inter_2to1_odd_8U()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height*2) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_2to1_odd_8U()!\n");
		return false;
	}

	for (int y=0, yy=1; y<iplDstImage->height; y++, yy+=2) {
		unsigned char *pSrc = (unsigned char *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);
		unsigned char *pDst = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, xx=1; x<iplDstImage->width; x++, xx+=2) {
            pDst[x] = pSrc[xx];
        }
    }

    return true;
}

bool CImageUtility::inter_2to1_odd_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// extract even colums and rows of an 32F image
// Interpolate 1/2-pixel image using bilinear
//				0     1     2     3      4     5		 	<-- original image
//                    *            *             *		    < --downsampled image
// Luhong Liang, IC-ASD, ASTRI
// March 18, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::inter_2to1_odd_32f()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*2 || iplSrcImage->height != iplDstImage->height*2) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_2to1_odd_32f()!\n");
		return false;
	}

	for (int y=0, yy=1; y<iplDstImage->height; y++, yy+=2) {
		float *pSrc = (float *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);
		float *pDst = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, xx=1; x<iplDstImage->width; x++, xx+=2) {
            pDst[x] = pSrc[xx];
        }
    }

    return true;
}

bool CImageUtility::inter_4to1_odd_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// extract even colums and rows of an 32F image
// Interpolate 1/2-pixel image using bilinear
//				0  1  2  3  4  5  6   7   8   9   10  11  12  <-- original image
//                       o            o                o      < --downsampled image
// Luhong Liang, IC-ASD, ASTRI
// March 1, 2015
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::inter_4to1_odd_32f()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width*4 || iplSrcImage->height != iplDstImage->height*4) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::inter_4to1_odd_32f()!\n");
		return false;
	}

	for (int y=0, yy=1; y<iplDstImage->height; y++, yy+=4) {
		float *pSrc = (float *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);
		float *pDst = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, xx=1; x<iplDstImage->width; x++, xx+=4) {
            pDst[x] = pSrc[xx];
        }
    }

    return true;
}

bool CImageUtility::resize_1to2_bicubic_8U_int(IplImage *iplSrcImage, IplImage *iplDstImage, int bit_depth, int clip_low, int clip_high)
// Resize image of magification factor of 2. The sampling location is the same as OpenCV!
// The sample locations are (1-D) as example:
//	 -2         -1          0           1            2   <-- original mage
//                       o     o     o     o     o		 <-- resized image
// The indices and parameters (*256) of the filter is
// -2	-1	0	1	-9	67	225	-27
// -1	0	1	2	-27	225	67	-9
// Luhong Liang, IC-ASD, ASTRI
// Feb. 28, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_1to2_bicubic_8U_int()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_1to2_bicubic_8U_int()!\n");
		return false;
	}
	if (bit_depth < 1 || bit_depth > 16) {
		showErrMsg("Only support target image with bit depth 1~16 in CImageUtility::resize_1to2_bicubic_8U_int()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width*2];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_1to2_bicubic_8U_int()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	int *pLine0 = pLine;
	int *pLine1 = pLine + iplSrcPad->width;
	//setZero(iplDstImage);
	int shift = 16 - bit_depth + 8;
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		unsigned char *pBuf2 = (unsigned char *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		unsigned char *pBuf3 = (unsigned char *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
		unsigned char *pBuf4 = (unsigned char *)(iplSrcPad->imageData + (top+4) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine0[x] = -9*pBuf0[x] + 67*pBuf1[x] + 225*pBuf2[x] - 27*pBuf3[x];	// -2	-1	0	1	-9	67	225	-27
			pLine1[x] = -27*pBuf1[x] + 225*pBuf2[x] + 67*pBuf3[x] - 9*pBuf4[x];	// -1	0	1	2	-27	225	67	-9
		}
		// interpolation in X direction
		int *pDst0 = (int *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		int *pDst1 = (int *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
			int pix = (-9*pLine0[left] + 67*pLine0[left+1] + 225*pLine0[left+2] - 27*pLine0[left+3]) >> shift;
			pDst0[x] = CLIP_PIX(pix, clip_high, clip_low);
			pix = (-27*pLine0[left+1] + 225*pLine0[left+2] + 67*pLine0[left+3] - 9*pLine0[left+4]) >> shift;
			pDst0[x+1] = CLIP_PIX(pix, clip_high, clip_low);
			// line 1
			pix = (-9*pLine1[left] + 67*pLine1[left+1] + 225*pLine1[left+2] - 27*pLine1[left+3]) >> shift;
			pDst1[x] = CLIP_PIX(pix, clip_high, clip_low);
			pix = (-27*pLine1[left+1] + 225*pLine1[left+2] + 67*pLine1[left+3] - 9*pLine1[left+4]) >> shift;
			pDst1[x+1] = CLIP_PIX(pix, clip_high, clip_low);
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_1to2_bicubic_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize image of magification factor of 2. The sampling location is the same as OpenCV!
// The sample locations are (1-D) as example:
//	 -2         -1          0           1            2   <-- original mage
//                       o     o     o     o     o		 <-- resized image
// The indices and parameters (*256) of the filter is
// -2	-1	0	1	-9	67	225	-27
// -1	0	1	2	-27	225	67	-9
// Luhong Liang, IC-ASD, ASTRI
// May 15, 2013
// Memory leak check, June 27, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_1to2_bicubic_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_1to2_bicubic_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width*2];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_1to2_bicubic_8U_int()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	int *pLine0 = pLine;
	int *pLine1 = pLine + iplSrcPad->width;
	//setZero(iplDstImage);
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		unsigned char *pBuf2 = (unsigned char *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		unsigned char *pBuf3 = (unsigned char *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
		unsigned char *pBuf4 = (unsigned char *)(iplSrcPad->imageData + (top+4) * iplSrcPad->widthStep);
		// interpolate in Y direction
		for (int x=0; x<iplSrcPad->width; x++) {
			pLine0[x] = -9*pBuf0[x] + 67*pBuf1[x] + 225*pBuf2[x] - 27*pBuf3[x];	// -2	-1	0	1	-9	67	225	-27
			pLine1[x] = -27*pBuf1[x] + 225*pBuf2[x] + 67*pBuf3[x] - 9*pBuf4[x];	// -1	0	1	2	-27	225	67	-9
		}
		// interpolation in X direction
		unsigned char *pDst0 = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		unsigned char *pDst1 = (unsigned char *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
			int pix = (-9*pLine0[left] + 67*pLine0[left+1] + 225*pLine0[left+2] - 27*pLine0[left+3]) >> 15;			// preserve 9 bits
			pDst0[x] = rndclp_9Uto8U(pix);
			pix = (-27*pLine0[left+1] + 225*pLine0[left+2] + 67*pLine0[left+3] - 9*pLine0[left+4]) >> 15;
			pDst0[x+1] = rndclp_9Uto8U(pix);
			// line 1
			pix = (-9*pLine1[left] + 67*pLine1[left+1] + 225*pLine1[left+2] - 27*pLine1[left+3]) >> 15;
			pDst1[x] = rndclp_9Uto8U(pix);
			pix = (-27*pLine1[left+1] + 225*pLine1[left+2] + 67*pLine1[left+3] - 9*pLine1[left+4]) >> 15;
			pDst1[x+1] = rndclp_9Uto8U(pix);
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_1to2_bicubic_8U_s1(IplImage *iplSrcImage, IplImage *iplDstImage)
	// Resize image of magification factor of 2. The sampling location is the same as OpenCV!
	// The sample locations are (1-D) as example:
	//	 -2         -1          0           1            2   <-- original mage
	//                       o     o     o     o     o		 <-- resized image
	// This function is same to resize_1to2_bicubic_8U() but using smaller bicubic coefficients for memory saving.
	// Added by Chao SHI, Mar 10, 2016
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
			showErrMsg("Invalid input image type in CImageUtility::resize_1to2_bicubic_8U()!\n");
			return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_1to2_bicubic_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;

	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	int *pLine = new int[iplSrcPad->width*2];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_1to2_bicubic_8U_int()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	int *pLine0 = pLine;
	int *pLine1 = pLine + iplSrcPad->width;
	//setZero(iplDstImage);

	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
             unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
             unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
             unsigned char *pBuf2 = (unsigned char *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
             unsigned char *pBuf3 = (unsigned char *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
             unsigned char *pBuf4 = (unsigned char *)(iplSrcPad->imageData + (top+4) * iplSrcPad->widthStep);
             // interpolate in Y direction
             for (int x=0; x<iplSrcPad->width; x++) {
                  int pLine0_x_tmp = (-1*pBuf0[x] + 8*pBuf1[x] + 28*pBuf2[x] - 3*pBuf3[x]) >> 4;      // -2  -1     0       1      -9     67     225    -27
                  int pLine1_x_tmp = (-3*pBuf1[x] + 28*pBuf2[x] + 8*pBuf3[x] - 1*pBuf4[x]) >> 4;  // -1  0       1      2      -27    225    67       -9
                  
                    pLine0[x] = rndclp_9Uto8U(pLine0_x_tmp);
                    pLine1[x] = rndclp_9Uto8U(pLine1_x_tmp);

             }
             // interpolation in X direction
             unsigned char *pDst0 = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
             unsigned char *pDst1 = (unsigned char *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
             for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
                    // line 0
                    int pix = (-1*pLine0[left] + 8*pLine0[left+1] + 28*pLine0[left+2] - 3*pLine0[left+3]) >> 4;               // preserve 9 bits
                    pDst0[x] = rndclp_9Uto8U(pix);
                    pix = (-3*pLine0[left+1] + 28*pLine0[left+2] + 8*pLine0[left+3] - 1*pLine0[left+4]) >> 4;
                    pDst0[x+1] = rndclp_9Uto8U(pix);
                    // line 1
                    pix = (-1*pLine1[left] + 8*pLine1[left+1] + 28*pLine1[left+2] - 3*pLine1[left+3]) >> 4;
                    pDst1[x] = rndclp_9Uto8U(pix);
                    pix = (-3*pLine1[left+1] + 28*pLine1[left+2] + 8*pLine1[left+3] - 1*pLine1[left+4]) >> 4;
                    pDst1[x+1] = rndclp_9Uto8U(pix);
             }
       }


	//for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
	//	unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
	//	unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
	//	unsigned char *pBuf2 = (unsigned char *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
	//	unsigned char *pBuf3 = (unsigned char *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
	//	unsigned char *pBuf4 = (unsigned char *)(iplSrcPad->imageData + (top+4) * iplSrcPad->widthStep);
	//	// interpolate in Y direction
	//	for (int x=0; x<iplSrcPad->width; x++) {
	//		int pLine0_x_tmp = (-2*pBuf0[x] + 17*pBuf1[x] + 56*pBuf2[x] - 7*pBuf3[x]) >> 5;      // -2  -1     0       1      -9     67     225    -27
	//		int pLine1_x_tmp = (-7*pBuf1[x] + 56*pBuf2[x] + 17*pBuf3[x] - 2*pBuf4[x]) >> 5;  // -1  0       1      2      -27    225    67       -9

	//		pLine0[x] = rndclp_9Uto8U(pLine0_x_tmp);
	//		pLine1[x] = rndclp_9Uto8U(pLine1_x_tmp);

	//	}
	//	// interpolation in X direction
	//	unsigned char *pDst0 = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
	//	unsigned char *pDst1 = (unsigned char *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
	//	for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
	//		// line 0
	//		int pix = (-2*pLine0[left] + 17*pLine0[left+1] + 56*pLine0[left+2] - 7*pLine0[left+3]) >> 5;               // preserve 9 bits
	//		pDst0[x] = rndclp_9Uto8U(pix);
	//		pix = (-7*pLine0[left+1] + 56*pLine0[left+2] + 17*pLine0[left+3] - 2*pLine0[left+4]) >> 5;
	//		pDst0[x+1] = rndclp_9Uto8U(pix);
	//		// line 1
	//		pix = (-2*pLine1[left] + 17*pLine1[left+1] + 56*pLine1[left+2] - 7*pLine1[left+3]) >> 5;
	//		pDst1[x] = rndclp_9Uto8U(pix);
	//		pix = (-7*pLine1[left+1] + 56*pLine1[left+2] + 17*pLine1[left+3] - 2*pLine1[left+4]) >> 5;
	//		pDst1[x+1] = rndclp_9Uto8U(pix);
	//	}
	//}


	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_1to2_bicubic_32f(IplImage *iplSrcImage, IplImage *iplDstImage, bool clip)
// Resize image of magification factor of 2. The sampling location is the same as OpenCV!
// The sample locations are (1-D) as example:
//	 -2         -1          0           1            2   <-- original mage
//                       o     o     o     o     o		 <-- resized image
// The indices and parameters (*256) of the filter is
// -2	-1	0	1	-9	67	225	-27
// -1	0	1	2	-27	225	67	-9
// Luhong Liang, IC-ASD, ASTRI
// Feb. 18, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::resize_1to2_bicubic_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_1to2_bicubic_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// upscaling by bicubic ( two lines at one time, all in destination image)
	// NOTE: This is the implementation with best readability, but the overhead is very high!
	float *pLine = new float[iplSrcPad->width*2];
	if (pLine == NULL) {
		showErrMsg("Fail to allocate line buffer in CImageUtility::resize_1to2_bicubic_32f()!\n");
		safeReleaseImage(&iplSrcPad);
	}
	float *pLine0 = pLine;
	float *pLine1 = pLine + iplSrcPad->width;
	//setZero(iplDstImage);
	if (clip) {
		for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
			float *pBuf0 = (float *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
			float *pBuf1 = (float *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
			float *pBuf2 = (float *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
			float *pBuf3 = (float *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
			float *pBuf4 = (float *)(iplSrcPad->imageData + (top+4) * iplSrcPad->widthStep);
			// interpolate in Y direction
			for (int x=0; x<iplSrcPad->width; x++) {
				pLine0[x] = -0.03515625f*pBuf0[x] + 0.26171875f*pBuf1[x] + 0.87890625f*pBuf2[x] - 0.10546875f*pBuf3[x];	// -2	-1	0	1	-9	67	225	-27
				pLine1[x] = -0.10546875f*pBuf1[x] + 0.87890625f*pBuf2[x] + 0.26171875f*pBuf3[x] - 0.03515625f*pBuf4[x];	// -1	0	1	2	-27	225	67	-9
			}
			// interpolation in X direction
			float *pDst0 = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
			float *pDst1 = (float *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
			for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
				// line 0
				float pix = -0.03515625f*pLine0[left] + 0.26171875f*pLine0[left+1] + 0.87890625f*pLine0[left+2] - 0.10546875f*pLine0[left+3];
				pDst0[x] = CLIP_PIX(pix, 255.0f, 0.0f);
				pix = -0.10546875f*pLine0[left+1] + 0.87890625f*pLine0[left+2] + 0.26171875f*pLine0[left+3] - 0.03515625f*pLine0[left+4];
				pDst0[x+1] = CLIP_PIX(pix, 255.0f, 0.0f);
				// line 1
				pix = -0.03515625f*pLine1[left] + 0.26171875f*pLine1[left+1] + 0.87890625f*pLine1[left+2] - 0.10546875f*pLine1[left+3];
				pDst1[x] = CLIP_PIX(pix, 255.0f, 0.0f);
				pix = -0.10546875f*pLine1[left+1] + 0.87890625f*pLine1[left+2] + 0.26171875f*pLine1[left+3] - 0.03515625f*pLine1[left+4];
				pDst1[x+1] = CLIP_PIX(pix, 255.0f, 0.0f);
			}
		}
	} else {
		for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
			float *pBuf0 = (float *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
			float *pBuf1 = (float *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
			float *pBuf2 = (float *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
			float *pBuf3 = (float *)(iplSrcPad->imageData + (top+3) * iplSrcPad->widthStep);
			float *pBuf4 = (float *)(iplSrcPad->imageData + (top+4) * iplSrcPad->widthStep);
			// interpolate in Y direction
			for (int x=0; x<iplSrcPad->width; x++) {
				pLine0[x] = -0.03515625f*pBuf0[x] + 0.26171875f*pBuf1[x] + 0.87890625f*pBuf2[x] - 0.10546875f*pBuf3[x];	// -2	-1	0	1	-9	67	225	-27
				pLine1[x] = -0.10546875f*pBuf1[x] + 0.87890625f*pBuf2[x] + 0.26171875f*pBuf3[x] - 0.03515625f*pBuf4[x];	// -1	0	1	2	-27	225	67	-9
			}
			// interpolation in X direction
			float *pDst0 = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
			float *pDst1 = (float *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
			for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
				// line 0
				pDst0[x] = -0.03515625f*pLine0[left] + 0.26171875f*pLine0[left+1] + 0.87890625f*pLine0[left+2] - 0.10546875f*pLine0[left+3];
				pDst0[x+1] = -0.10546875f*pLine0[left+1] + 0.87890625f*pLine0[left+2] + 0.26171875f*pLine0[left+3] - 0.03515625f*pLine0[left+4];
				// line 1
				pDst1[x] = -0.03515625f*pLine1[left] + 0.26171875f*pLine1[left+1] + 0.87890625f*pLine1[left+2] - 0.10546875f*pLine1[left+3];
				pDst1[x+1] = -0.10546875f*pLine1[left+1] + 0.87890625f*pLine1[left+2] + 0.26171875f*pLine1[left+3] - 0.03515625f*pLine1[left+4];
			}
		}
	}

	delete [] pLine;
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_16to15_bicubic_int(IplImage *iplSrcImage, IplImage *iplDstImage, int clip_low, int clip_high)
// Resize the image to 15/16 using bicubic interpolation
// The sample location and filter follow the resize() in OpenCV, but the filter is an approximation!
// This is a fixed-point implementation
//   Ref Point			Filter * 2048
// -1	0	1	2	-6	255	7	0
// 0	1	2	3	-16	251	23	-2
// 1	2	3	4	-22	241	41	-4
// 2	3	4	5	-26	228	62	-8
// 3	4	5	6	-28	212	84	-12
// 4	5	6	7	-28	194	106	-16
// 5	6	7	8	-27	174	129	-20
// 6	7	8	9	-24	152	152	-24
// 7	8	9	10	-20	129	174	-27
// 8	9	10	11	-16	106	194	-28
// 9	10	11	12	-12	84	212	-28
// 10	11	12	13	-8	62	228	-26
// 11	12	13	14	-4	41	241	-22
// 12	13	14	15	-2	23	251	-16
// 13	14	15	16	0	7	255	-6
//
// Luhong Liang, IC-ASD, ASTRI
// Feb. 08, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_16to15_bicubic_int()!\n");
		return false;
	}
	if (iplSrcImage->width*15 != iplDstImage->width*16 || iplSrcImage->height*15 != iplDstImage->height*16) {
		showErrMsg("Only support 16:15 upsampling in CImageUtility::resize_16to15_bicubic_int()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// downsample by bicubic
	int pBlock[18*18];		// 18x18 block in source image (16 points + padding)
	int pBlock1[15*18];		// after interpolation in X direction
	int pBlock2[15*15];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=15, top+=16) {
		for (int x=0, left=0; x<iplDstImage->width; x+=15, left+=16) {
			// load a 18x18 block in source image (16x16 + padding)
			int i = 0;
			for (int yy=top; yy<top+18; yy++) {
				int *pBuf = (int *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+18; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<18; v++) {
				int *pSrc = pBlock + v * 18;
				int *pDst = pBlock1 + v * 15;
				// calculation		   											                      ref point             filter
				pDst[0] = (-6*pSrc[0] + 255*pSrc[1] + 7*pSrc[2]) >> 8;						//	0	1	2	3	-6	255	7	0
				pDst[1] = (-16*pSrc[1] + 251*pSrc[2] + 23*pSrc[3] -2*pSrc[4]) >> 8;			//	1	2	3	4	-16	251	23	-2
				pDst[2] = (-22*pSrc[2] + 241*pSrc[3] + 41*pSrc[4] -4*pSrc[5]) >> 8;			//	2	3	4	5	-22	241	41	-4
				pDst[3] = (-26*pSrc[3] + 228*pSrc[4] + 62*pSrc[5] -8*pSrc[6]) >> 8;			//	3	4	5	6	-26	228	62	-8
				pDst[4] = (-28*pSrc[4] + 212*pSrc[5] + 84*pSrc[6] -12*pSrc[7]) >> 8;		//	4	5	6	7	-28	212	84	-12
				pDst[5] = (-28*pSrc[5] + 194*pSrc[6] + 106*pSrc[7] -16*pSrc[8]) >> 8;		//	5	6	7	8	-28	194	106	-16
				pDst[6] = (-27*pSrc[6] + 174*pSrc[7] + 129*pSrc[8] -20*pSrc[9]) >> 8;		//	6	7	8	9	-27	174	129	20
				pDst[7] = (-24*pSrc[7] + 152*pSrc[8] + 152*pSrc[9] -24*pSrc[10]) >> 8;		//	7	8	9	10	-24	152	152	-24
				pDst[8] = (-20*pSrc[8] + 129*pSrc[9] + 174*pSrc[10] -27*pSrc[11]) >> 8;		//	8	9	10	11	-20	129	174	-27
				pDst[9] = (-16*pSrc[9] + 106*pSrc[10] + 194*pSrc[11] -28*pSrc[12]) >> 8;	//	9	10	11	12	-16	106	194	-28
				pDst[10] = (-12*pSrc[10] + 84*pSrc[11] + 212*pSrc[12] -28*pSrc[13]) >> 8;	//	10	11	12	13	-12	84	212	-28
				pDst[11] = (-8*pSrc[11] + 62*pSrc[12] + 228*pSrc[13] -26*pSrc[14]) >> 8;	//	11	12	13	14	-8	62	228	-26
				pDst[12] = (-4*pSrc[12] + 41*pSrc[13] + 241*pSrc[14] -22*pSrc[15]) >> 8;	//	12	13	14	15	-4	41	241	-22
				pDst[13] = (-2*pSrc[13] + 23*pSrc[14] + 251*pSrc[15] -16*pSrc[16]) >> 8;	//	13	14	15	16	-2	23	251	-16
				pDst[14] = (7*pSrc[15] + 255*pSrc[16] -6*pSrc[17]) >> 8;					//	14	15	16	17	0	7	255	-6
			}
			// interpolation in Y direction
			for (int u=0; u<15; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		   																		 ref point             filter
				pDst[0] = (-6*pSrc[0] + 255*pSrc[15] + 7*pSrc[2*15]) >> 8;								//	0	1	2	3	-6	255	7	0
				pDst[15] = (-16*pSrc[15] + 251*pSrc[2*15] + 23*pSrc[3*15] -2*pSrc[4*15]) >> 8;			//	1	2	3	4	-16	251	23	-2
				pDst[2*15] = (-22*pSrc[2*15] + 241*pSrc[3*15] + 41*pSrc[4*15] -4*pSrc[5*15]) >> 8;		//	2	3	4	5	-22	241	41	-4
				pDst[3*15] = (-26*pSrc[3*15] + 228*pSrc[4*15] + 62*pSrc[5*15] -8*pSrc[6*15]) >> 8;		//	3	4	5	6	-26	228	62	-8
				pDst[4*15] = (-28*pSrc[4*15] + 212*pSrc[5*15] + 84*pSrc[6*15] -12*pSrc[7*15]) >> 8;		//	4	5	6	7	-28	212	84	-12
				pDst[5*15] = (-28*pSrc[5*15] + 194*pSrc[6*15] + 106*pSrc[7*15] -16*pSrc[8*15]) >> 8;	//	5	6	7	8	-28	194	106	-16
				pDst[6*15] = (-27*pSrc[6*15] + 174*pSrc[7*15] + 129*pSrc[8*15] -20*pSrc[9*15]) >> 8;	//	6	7	8	9	-27	174	129	20
				pDst[7*15] = (-24*pSrc[7*15] + 152*pSrc[8*15] + 152*pSrc[9*15] -24*pSrc[10*15]) >> 8;	//	7	8	9	10	-24	152	152	-24
				pDst[8*15] = (-20*pSrc[8*15] + 129*pSrc[9*15] + 174*pSrc[10*15] -27*pSrc[11*15]) >> 8;	//	8	9	10	11	-20	129	174	-27
				pDst[9*15] = (-16*pSrc[9*15] + 106*pSrc[10*15] + 194*pSrc[11*15] -28*pSrc[12*15]) >> 8;	//	9	10	11	12	-16	106	194	-28
				pDst[10*15] = (-12*pSrc[10*15] + 84*pSrc[11*15] + 212*pSrc[12*15] -28*pSrc[13*15]) >> 8;//	10	11	12	13	-12	84	212	-28
				pDst[11*15] = (-8*pSrc[11*15] + 62*pSrc[12*15] + 228*pSrc[13*15] -26*pSrc[14*15]) >> 8;	//	11	12	13	14	-8	62	228	-26
				pDst[12*15] = (-4*pSrc[12*15] + 41*pSrc[13*15] + 241*pSrc[14*15] -22*pSrc[15*15]) >> 8;	//	12	13	14	15	-4	41	241	-22
				pDst[13*15] = (-2*pSrc[13*15] + 23*pSrc[14*15] + 251*pSrc[15*15] -16*pSrc[16*15]) >> 8;	//	13	14	15	16	-2	23	251	-16
				pDst[14*15] = (7*pSrc[15*15] + 255*pSrc[16*15] -6*pSrc[17*15]) >> 8;					//	14	15	16	17	0	7	255	-6
			}
			// write a 15x15 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+15; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+15; xx++) {
					int val = pBlock2[i];
					if (val < clip_low) {
						pBuf[xx] = clip_low;
					} else if (val > clip_high) {
						pBuf[xx] = clip_high;
					} else {
						pBuf[xx] = val;
					}
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_16to15_bicubic_int_8U(IplImage *iplSrcImage, IplImage *iplDstImage, int bit_depth)
// Resize the image to 15/16 using bicubic interpolation
// The input bit depth should be between 9~15. The output is 8U.
// The sample location and filter follow the resize() in OpenCV, but the filter is an approximation!
// This is a fixed-point implementation
//   Ref Point			Filter * 2048
// -1	0	1	2	-6	255	7	0
// 0	1	2	3	-16	251	23	-2
// 1	2	3	4	-22	241	41	-4
// 2	3	4	5	-26	228	62	-8
// 3	4	5	6	-28	212	84	-12
// 4	5	6	7	-28	194	106	-16
// 5	6	7	8	-27	174	129	-20
// 6	7	8	9	-24	152	152	-24
// 7	8	9	10	-20	129	174	-27
// 8	9	10	11	-16	106	194	-28
// 9	10	11	12	-12	84	212	-28
// 10	11	12	13	-8	62	228	-26
// 11	12	13	14	-4	41	241	-22
// 12	13	14	15	-2	23	251	-16
// 13	14	15	16	0	7	255	-6
//
// Luhong Liang, IC-ASD, ASTRI
// Feb. 08, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_16to15_bicubic_int()!\n");
		return false;
	}
	if (iplSrcImage->width*15 != iplDstImage->width*16 || iplSrcImage->height*15 != iplDstImage->height*16) {
		showErrMsg("Only support 16:15 upsampling in CImageUtility::resize_16to15_bicubic_int()!\n");
		return false;
	}
	if (bit_depth > 15 || bit_depth < 9) {
		showErrMsg("Only support input image with bit depth 9~15 in CImageUtility::resize_16to15_bicubic_int()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// downsample by bicubic
	int pBlock[18*18];		// 18x18 block in source image (16 points + padding)
	int pBlock1[15*18];		// after interpolation in X direction
	int pBlock2[15*15];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=15, top+=16) {
		for (int x=0, left=0; x<iplDstImage->width; x+=15, left+=16) {
			// load a 18x18 block in source image (16x16 + padding)
			int i = 0;
			for (int yy=top; yy<top+18; yy++) {
				int *pBuf = (int *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+18; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<18; v++) {
				int *pSrc = pBlock + v * 18;
				int *pDst = pBlock1 + v * 15;
				// calculation		   											                      ref point             filter
				pDst[0] = (-6*pSrc[0] + 255*pSrc[1] + 7*pSrc[2]) >> 8;						//	0	1	2	3	-6	255	7	0
				pDst[1] = (-16*pSrc[1] + 251*pSrc[2] + 23*pSrc[3] -2*pSrc[4]) >> 8;			//	1	2	3	4	-16	251	23	-2
				pDst[2] = (-22*pSrc[2] + 241*pSrc[3] + 41*pSrc[4] -4*pSrc[5]) >> 8;			//	2	3	4	5	-22	241	41	-4
				pDst[3] = (-26*pSrc[3] + 228*pSrc[4] + 62*pSrc[5] -8*pSrc[6]) >> 8;			//	3	4	5	6	-26	228	62	-8
				pDst[4] = (-28*pSrc[4] + 212*pSrc[5] + 84*pSrc[6] -12*pSrc[7]) >> 8;		//	4	5	6	7	-28	212	84	-12
				pDst[5] = (-28*pSrc[5] + 194*pSrc[6] + 106*pSrc[7] -16*pSrc[8]) >> 8;		//	5	6	7	8	-28	194	106	-16
				pDst[6] = (-27*pSrc[6] + 174*pSrc[7] + 129*pSrc[8] -20*pSrc[9]) >> 8;		//	6	7	8	9	-27	174	129	20
				pDst[7] = (-24*pSrc[7] + 152*pSrc[8] + 152*pSrc[9] -24*pSrc[10]) >> 8;		//	7	8	9	10	-24	152	152	-24
				pDst[8] = (-20*pSrc[8] + 129*pSrc[9] + 174*pSrc[10] -27*pSrc[11]) >> 8;		//	8	9	10	11	-20	129	174	-27
				pDst[9] = (-16*pSrc[9] + 106*pSrc[10] + 194*pSrc[11] -28*pSrc[12]) >> 8;	//	9	10	11	12	-16	106	194	-28
				pDst[10] = (-12*pSrc[10] + 84*pSrc[11] + 212*pSrc[12] -28*pSrc[13]) >> 8;	//	10	11	12	13	-12	84	212	-28
				pDst[11] = (-8*pSrc[11] + 62*pSrc[12] + 228*pSrc[13] -26*pSrc[14]) >> 8;	//	11	12	13	14	-8	62	228	-26
				pDst[12] = (-4*pSrc[12] + 41*pSrc[13] + 241*pSrc[14] -22*pSrc[15]) >> 8;	//	12	13	14	15	-4	41	241	-22
				pDst[13] = (-2*pSrc[13] + 23*pSrc[14] + 251*pSrc[15] -16*pSrc[16]) >> 8;	//	13	14	15	16	-2	23	251	-16
				pDst[14] = (7*pSrc[15] + 255*pSrc[16] -6*pSrc[17]) >> 8;					//	14	15	16	17	0	7	255	-6
			}
			// interpolation in Y direction
			for (int u=0; u<15; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		   																		 ref point             filter
				pDst[0] = (-6*pSrc[0] + 255*pSrc[15] + 7*pSrc[2*15]) >> 8;								//	0	1	2	3	-6	255	7	0
				pDst[15] = (-16*pSrc[15] + 251*pSrc[2*15] + 23*pSrc[3*15] -2*pSrc[4*15]) >> 8;			//	1	2	3	4	-16	251	23	-2
				pDst[2*15] = (-22*pSrc[2*15] + 241*pSrc[3*15] + 41*pSrc[4*15] -4*pSrc[5*15]) >> 8;		//	2	3	4	5	-22	241	41	-4
				pDst[3*15] = (-26*pSrc[3*15] + 228*pSrc[4*15] + 62*pSrc[5*15] -8*pSrc[6*15]) >> 8;		//	3	4	5	6	-26	228	62	-8
				pDst[4*15] = (-28*pSrc[4*15] + 212*pSrc[5*15] + 84*pSrc[6*15] -12*pSrc[7*15]) >> 8;		//	4	5	6	7	-28	212	84	-12
				pDst[5*15] = (-28*pSrc[5*15] + 194*pSrc[6*15] + 106*pSrc[7*15] -16*pSrc[8*15]) >> 8;	//	5	6	7	8	-28	194	106	-16
				pDst[6*15] = (-27*pSrc[6*15] + 174*pSrc[7*15] + 129*pSrc[8*15] -20*pSrc[9*15]) >> 8;	//	6	7	8	9	-27	174	129	20
				pDst[7*15] = (-24*pSrc[7*15] + 152*pSrc[8*15] + 152*pSrc[9*15] -24*pSrc[10*15]) >> 8;	//	7	8	9	10	-24	152	152	-24
				pDst[8*15] = (-20*pSrc[8*15] + 129*pSrc[9*15] + 174*pSrc[10*15] -27*pSrc[11*15]) >> 8;	//	8	9	10	11	-20	129	174	-27
				pDst[9*15] = (-16*pSrc[9*15] + 106*pSrc[10*15] + 194*pSrc[11*15] -28*pSrc[12*15]) >> 8;	//	9	10	11	12	-16	106	194	-28
				pDst[10*15] = (-12*pSrc[10*15] + 84*pSrc[11*15] + 212*pSrc[12*15] -28*pSrc[13*15]) >> 8;//	10	11	12	13	-12	84	212	-28
				pDst[11*15] = (-8*pSrc[11*15] + 62*pSrc[12*15] + 228*pSrc[13*15] -26*pSrc[14*15]) >> 8;	//	11	12	13	14	-8	62	228	-26
				pDst[12*15] = (-4*pSrc[12*15] + 41*pSrc[13*15] + 241*pSrc[14*15] -22*pSrc[15*15]) >> 8;	//	12	13	14	15	-4	41	241	-22
				pDst[13*15] = (-2*pSrc[13*15] + 23*pSrc[14*15] + 251*pSrc[15*15] -16*pSrc[16*15]) >> 8;	//	13	14	15	16	-2	23	251	-16
				pDst[14*15] = (7*pSrc[15*15] + 255*pSrc[16*15] -6*pSrc[17*15]) >> 8;					//	14	15	16	17	0	7	255	-6
			}
			// write a 15x15 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+15; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+15; xx++) {
					// convert to 8-bit and rounding
					int val = pBlock2[i];
					val = val >> (bit_depth - 9);
					val = ((val&0x0001) == 0) ? (val>>1) : ((val>>1) + 1);
					val = val > 255 ? 255 : val;				// should clipping, since 1023-->256 above!
					pBuf[xx] = (unsigned char)(val < 0 ? 0 : val);
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_16to15_bicubic_8U_10U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 15/16 using bicubic interpolation
// The input is 8U and the output is 10-bit unsigned numbers in 32S data type.
// The sample location and filter follow the resize() in OpenCV, but the filter is an approximation!
// This is a fixed-point implementation
//   Ref Point			Filter * 256
// -1	0	1	2	-6	255	7	0
// 0	1	2	3	-16	251	23	-2
// 1	2	3	4	-22	241	41	-4
// 2	3	4	5	-26	228	62	-8
// 3	4	5	6	-28	212	84	-12
// 4	5	6	7	-28	194	106	-16
// 5	6	7	8	-27	174	129	-20
// 6	7	8	9	-24	152	152	-24
// 7	8	9	10	-20	129	174	-27
// 8	9	10	11	-16	106	194	-28
// 9	10	11	12	-12	84	212	-28
// 10	11	12	13	-8	62	228	-26
// 11	12	13	14	-4	41	241	-22
// 12	13	14	15	-2	23	251	-16
// 13	14	15	16	0	7	255	-6
//
// Luhong Liang, IC-ASD, ASTRI
// Feb. 27, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_16to15_bicubic_8U_10U()!\n");
		return false;
	}
	if (iplSrcImage->width*15 != iplDstImage->width*16 || iplSrcImage->height*15 != iplDstImage->height*16) {
		showErrMsg("Only support 16:15 upsampling in CImageUtility::resize_16to15_bicubic_8U_10U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// downsample by bicubic
	int pBlock[18*18];		// 18x18 block in source image (16 points + padding)
	int pBlock1[15*18];		// after interpolation in X direction
	int pBlock2[15*15];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=15, top+=16) {
		for (int x=0, left=0; x<iplDstImage->width; x+=15, left+=16) {
			// load a 18x18 block in source image (16x16 + padding)
			int i = 0;
			for (int yy=top; yy<top+18; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+18; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<18; v++) {
				int *pSrc = pBlock + v * 18;
				int *pDst = pBlock1 + v * 15;
				// calculation		   											                      ref point             filter
				pDst[0] = (-6*pSrc[0] + 255*pSrc[1] + 7*pSrc[2]) >> 7;						//	0	1	2	3	-6	255	7	0
				pDst[1] = (-16*pSrc[1] + 251*pSrc[2] + 23*pSrc[3] -2*pSrc[4]) >> 7;			//	1	2	3	4	-16	251	23	-2
				pDst[2] = (-22*pSrc[2] + 241*pSrc[3] + 41*pSrc[4] -4*pSrc[5]) >> 7;			//	2	3	4	5	-22	241	41	-4
				pDst[3] = (-26*pSrc[3] + 228*pSrc[4] + 62*pSrc[5] -8*pSrc[6]) >> 7;			//	3	4	5	6	-26	228	62	-8
				pDst[4] = (-28*pSrc[4] + 212*pSrc[5] + 84*pSrc[6] -12*pSrc[7]) >> 7;		//	4	5	6	7	-28	212	84	-12
				pDst[5] = (-28*pSrc[5] + 194*pSrc[6] + 106*pSrc[7] -16*pSrc[8]) >> 7;		//	5	6	7	8	-28	194	106	-16
				pDst[6] = (-27*pSrc[6] + 174*pSrc[7] + 129*pSrc[8] -20*pSrc[9]) >> 7;		//	6	7	8	9	-27	174	129	20
				pDst[7] = (-24*pSrc[7] + 152*pSrc[8] + 152*pSrc[9] -24*pSrc[10]) >> 7;		//	7	8	9	10	-24	152	152	-24
				pDst[8] = (-20*pSrc[8] + 129*pSrc[9] + 174*pSrc[10] -27*pSrc[11]) >> 7;		//	8	9	10	11	-20	129	174	-27
				pDst[9] = (-16*pSrc[9] + 106*pSrc[10] + 194*pSrc[11] -28*pSrc[12]) >> 7;	//	9	10	11	12	-16	106	194	-28
				pDst[10] = (-12*pSrc[10] + 84*pSrc[11] + 212*pSrc[12] -28*pSrc[13]) >> 7;	//	10	11	12	13	-12	84	212	-28
				pDst[11] = (-8*pSrc[11] + 62*pSrc[12] + 228*pSrc[13] -26*pSrc[14]) >> 7;	//	11	12	13	14	-8	62	228	-26
				pDst[12] = (-4*pSrc[12] + 41*pSrc[13] + 241*pSrc[14] -22*pSrc[15]) >> 7;	//	12	13	14	15	-4	41	241	-22
				pDst[13] = (-2*pSrc[13] + 23*pSrc[14] + 251*pSrc[15] -16*pSrc[16]) >> 7;	//	13	14	15	16	-2	23	251	-16
				pDst[14] = (7*pSrc[15] + 255*pSrc[16] -6*pSrc[17]) >> 7;					//	14	15	16	17	0	7	255	-6
			}
			// interpolation in Y direction
			for (int u=0; u<15; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		   																		 ref point             filter
				pDst[0] = (-6*pSrc[0] + 255*pSrc[15] + 7*pSrc[2*15]) >> 7;								//	0	1	2	3	-6	255	7	0
				pDst[15] = (-16*pSrc[15] + 251*pSrc[2*15] + 23*pSrc[3*15] -2*pSrc[4*15]) >> 7;			//	1	2	3	4	-16	251	23	-2
				pDst[2*15] = (-22*pSrc[2*15] + 241*pSrc[3*15] + 41*pSrc[4*15] -4*pSrc[5*15]) >> 7;		//	2	3	4	5	-22	241	41	-4
				pDst[3*15] = (-26*pSrc[3*15] + 228*pSrc[4*15] + 62*pSrc[5*15] -8*pSrc[6*15]) >> 7;		//	3	4	5	6	-26	228	62	-8
				pDst[4*15] = (-28*pSrc[4*15] + 212*pSrc[5*15] + 84*pSrc[6*15] -12*pSrc[7*15]) >> 7;		//	4	5	6	7	-28	212	84	-12
				pDst[5*15] = (-28*pSrc[5*15] + 194*pSrc[6*15] + 106*pSrc[7*15] -16*pSrc[8*15]) >> 7;	//	5	6	7	8	-28	194	106	-16
				pDst[6*15] = (-27*pSrc[6*15] + 174*pSrc[7*15] + 129*pSrc[8*15] -20*pSrc[9*15]) >> 7;	//	6	7	8	9	-27	174	129	20
				pDst[7*15] = (-24*pSrc[7*15] + 152*pSrc[8*15] + 152*pSrc[9*15] -24*pSrc[10*15]) >> 7;	//	7	8	9	10	-24	152	152	-24
				pDst[8*15] = (-20*pSrc[8*15] + 129*pSrc[9*15] + 174*pSrc[10*15] -27*pSrc[11*15]) >> 7;	//	8	9	10	11	-20	129	174	-27
				pDst[9*15] = (-16*pSrc[9*15] + 106*pSrc[10*15] + 194*pSrc[11*15] -28*pSrc[12*15]) >> 7;	//	9	10	11	12	-16	106	194	-28
				pDst[10*15] = (-12*pSrc[10*15] + 84*pSrc[11*15] + 212*pSrc[12*15] -28*pSrc[13*15]) >> 7;//	10	11	12	13	-12	84	212	-28
				pDst[11*15] = (-8*pSrc[11*15] + 62*pSrc[12*15] + 228*pSrc[13*15] -26*pSrc[14*15]) >> 7;	//	11	12	13	14	-8	62	228	-26
				pDst[12*15] = (-4*pSrc[12*15] + 41*pSrc[13*15] + 241*pSrc[14*15] -22*pSrc[15*15]) >> 7;	//	12	13	14	15	-4	41	241	-22
				pDst[13*15] = (-2*pSrc[13*15] + 23*pSrc[14*15] + 251*pSrc[15*15] -16*pSrc[16*15]) >> 7;	//	13	14	15	16	-2	23	251	-16
				pDst[14*15] = (7*pSrc[15*15] + 255*pSrc[16*15] -6*pSrc[17*15]) >> 7;					//	14	15	16	17	0	7	255	-6
			}
			// write a 15x15 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+15; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+15; xx++) {
					// clipping
					int val = pBlock2[i];
					val = val > 1023 ? 1023 : val;
					pBuf[xx] = val < 0 ? 0 : val;
					i++;
				}
			}
		}
	}
	
	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_16to15_lanczos3_8U_10U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 15/16 using Lanczos-3 interpolation
// The input is 8U and the output is 10-bit unsigned numbers in 32S data type.
// The sample location and filter follow the resize() in OpenCV, but the filter is an approximation!
// This is a fixed-point implementation
//		Ref Point					Filter * 256
//-3	-2	-1	0	1	2	3		1	-5	7	241	21	-10	1
//-2	-1	0	1	2	3	4		0	-2	-6	238	38	-14	2
//-1	0	1	2	3	4	5		0	1	-16	231	56	-19	3
//1	2	3	4	5	6	7	4		-24	220	75	-23	4	0
//2	3	4	5	6	7	8	6		-30	207	95	-27	5	0
//3	4	5	6	7	8	9	7		-33	192	115	-31	6	0
//4	5	6	7	8	9	10	7		-35	175	136	-34	7	0
//5	6	7	8	9	10	11	7		-35	156	156	-35	7	0
//6	7	8	9	10	11	12	7		-34	136	175	-35	7	0
//7	8	9	10	11	12	13	6		-31	115	192	-33	7	0
//8	9	10	11	12	13	14	5		-27	95	207	-30	6	0
//9	10	11	12	13	14	15	4		-23	75	220	-24	4	0
//10	11	12	13	14	15	16		3	-19	56	231	-16	1	0
//11	12	13	14	15	16	17		2	-14	38	238	-6	-2	0
//12	13	14	15	16	17	18		1	-10	21	241	7	-5	1
//
// Luhong Liang, IC-ASD, ASTRI
// Mar. 5, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_16to15_lanczos3_8U_10U()!\n");
		return false;
	}
	if (iplSrcImage->width*15 != iplDstImage->width*16 || iplSrcImage->height*15 != iplDstImage->height*16) {
		showErrMsg("Only support 16:15 upsampling in CImageUtility::resize_16to15_lanczos3_8U_10U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 3, 3, 3, 3);		// 7-tap filter
	if (iplSrcPad == NULL) return false;
	
	// downsample by bicubic
	int pBlock[22*22];		// 22x22 block in source image (16 points + padding)
	int pBlock1[15*22];		// after interpolation in X direction
	int pBlock2[15*15];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=15, top+=16) {
		for (int x=0, left=0; x<iplDstImage->width; x+=15, left+=16) {
			// load a 22x22 block in source image (16x16 + padding)
			int i = 0;
			for (int yy=top; yy<top+22; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+22; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<22; v++) {
				int *pSrc = pBlock + v * 22;
				int *pDst = pBlock1 + v * 15;
				// calculation		   																									 ref point						filter
				pDst[0] = ( pSrc[0] -5 * pSrc[1] + 7 * pSrc[2] + 241 * pSrc[3] + 21 * pSrc[4] -10 * pSrc[5] + pSrc[6] ) >> 7;	// -3  -2  -1  0  1  2  3  	1  -5  7  241  21  -10  1  (256)
				pDst[1] = (  -2 * pSrc[2] -6 * pSrc[3] + 238 * pSrc[4] + 38 * pSrc[5] -14 * pSrc[6] + 2 * pSrc[7] ) >> 7;		// -2  -1  0  1  2  3  4  	0  -2  -6  238  38  -14  2  (256)
				pDst[2] = ( pSrc[3] -16 * pSrc[4] + 231 * pSrc[5] + 56 * pSrc[6] -19 * pSrc[7] + 3 * pSrc[8] ) >> 7;			// -1  0  1  2  3  4  5  	0  1  -16  231  56  -19  3  (256)
				pDst[3] = (4 * pSrc[4] -24 * pSrc[5] + 220 * pSrc[6] + 75 * pSrc[7] -23 * pSrc[8] + 4 * pSrc[9] ) >> 7;			// 1  2  3  4  5  6  7  	4  -24  220  75  -23  4  0  (256)
				pDst[4] = (6 * pSrc[5] -30 * pSrc[6] + 207 * pSrc[7] + 95 * pSrc[8] -27 * pSrc[9] + 5 * pSrc[10] ) >> 7;		// 2  3  4  5  6  7  8  	6  -30  207  95  -27  5  0  (256)
				pDst[5] = (7 * pSrc[6] -33 * pSrc[7] + 192 * pSrc[8] + 115 * pSrc[9] -31 * pSrc[10] + 6 * pSrc[11] ) >> 7;		// 3  4  5  6  7  8  9  	7  -33  192  115  -31  6  0  (256)
				pDst[6] = (7 * pSrc[7] -35 * pSrc[8] + 175 * pSrc[9] + 136 * pSrc[10] -34 * pSrc[11] + 7 * pSrc[12] ) >> 7;		// 4  5  6  7  8  9  10  	7  -35  175  136  -34  7  0  (256)
				pDst[7] = (7 * pSrc[8] -35 * pSrc[9] + 156 * pSrc[10] + 156 * pSrc[11] -35 * pSrc[12] + 7 * pSrc[13] ) >> 7;	// 5  6  7  8  9  10  11  	7  -35  156  156  -35  7  0  (256)
				pDst[8] = (7 * pSrc[9] -34 * pSrc[10] + 136 * pSrc[11] + 175 * pSrc[12] -35 * pSrc[13] + 7 * pSrc[14] ) >> 7;	// 6  7  8  9  10  11  12  	7  -34  136  175  -35  7  0  (256)
				pDst[9] = (6 * pSrc[10] -31 * pSrc[11] + 115 * pSrc[12] + 192 * pSrc[13] -33 * pSrc[14] + 7 * pSrc[15] ) >> 7;	// 7  8  9  10  11  12  13  	6  -31  115  192  -33  7  0  (256)
				pDst[10] = (5 * pSrc[11] -27 * pSrc[12] + 95 * pSrc[13] + 207 * pSrc[14] -30 * pSrc[15] + 6 * pSrc[16] ) >> 7;	// 8  9  10  11  12  13  14  	5  -27  95  207  -30  6  0  (256)
				pDst[11] = (4 * pSrc[12] -23 * pSrc[13] + 75 * pSrc[14] + 220 * pSrc[15] -24 * pSrc[16] + 4 * pSrc[17] ) >> 7;	// 9  10  11  12  13  14  15  	4  -23  75  220  -24  4  0  (256)
				pDst[12] = (3 * pSrc[13] -19 * pSrc[14] + 56 * pSrc[15] + 231 * pSrc[16] -16 * pSrc[17] + pSrc[18] ) >> 7;		// 10  11  12  13  14  15  16  	3  -19  56  231  -16  1  0  (256)
				pDst[13] = (2 * pSrc[14] -14 * pSrc[15] + 38 * pSrc[16] + 238 * pSrc[17] -6 * pSrc[18] -2 * pSrc[19] ) >> 7;	// 11  12  13  14  15  16  17  	2  -14  38  238  -6  -2  0  (256)
				pDst[14] = ( pSrc[15] -10 * pSrc[16] + 21 * pSrc[17] + 241 * pSrc[18] + 7 * pSrc[19] -5 * pSrc[20] + pSrc[21] ) >> 7;	// 12  13  14  15  16  17  18  	1  -10  21  241  7  -5  1  (256)
			}
			// interpolation in Y direction
			for (int u=0; u<15; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		   																										 ref point					   filter
				pDst[0] = ( pSrc[0] -5 * pSrc[15] + 7 * pSrc[30] + 241 * pSrc[45] + 21 * pSrc[60] -10 * pSrc[75] + pSrc[90] ) >> 7;	// -3  -2  -1  0  1  2  3  	1  -5  7  241  21  -10  1  (256)
				pDst[15] = (  -2 * pSrc[30] -6 * pSrc[45] + 238 * pSrc[60] + 38 * pSrc[75] -14 * pSrc[90] + 2 * pSrc[105] ) >> 7;	// -2  -1  0  1  2  3  4  	0  -2  -6  238  38  -14  2  (256)
				pDst[30] = ( pSrc[45] -16 * pSrc[60] + 231 * pSrc[75] + 56 * pSrc[90] -19 * pSrc[105] + 3 * pSrc[120] ) >> 7;		// -1  0  1  2  3  4  5  	0  1  -16  231  56  -19  3  (256)
				pDst[45] = (4 * pSrc[60] -24 * pSrc[75] + 220 * pSrc[90] + 75 * pSrc[105] -23 * pSrc[120] + 4 * pSrc[135] ) >> 7;	// 1  2  3  4  5  6  7  	4  -24  220  75  -23  4  0  (256)
				pDst[60] = (6 * pSrc[75] -30 * pSrc[90] + 207 * pSrc[105] + 95 * pSrc[120] -27 * pSrc[135] + 5 * pSrc[150] ) >> 7;	// 2  3  4  5  6  7  8  	6  -30  207  95  -27  5  0  (256)
				pDst[75] = (7 * pSrc[90] -33 * pSrc[105] + 192 * pSrc[120] + 115 * pSrc[135] -31 * pSrc[150] + 6 * pSrc[165] ) >> 7;	// 3  4  5  6  7  8  9  	7  -33  192  115  -31  6  0  (256)
				pDst[90] = (7 * pSrc[105] -35 * pSrc[120] + 175 * pSrc[135] + 136 * pSrc[150] -34 * pSrc[165] + 7 * pSrc[180] ) >> 7;	// 4  5  6  7  8  9  10  	7  -35  175  136  -34  7  0  (256)
				pDst[105] = (7 * pSrc[120] -35 * pSrc[135] + 156 * pSrc[150] + 156 * pSrc[165] -35 * pSrc[180] + 7 * pSrc[195] ) >> 7;	// 5  6  7  8  9  10  11  	7  -35  156  156  -35  7  0  (256)
				pDst[120] = (7 * pSrc[135] -34 * pSrc[150] + 136 * pSrc[165] + 175 * pSrc[180] -35 * pSrc[195] + 7 * pSrc[210] ) >> 7;	// 6  7  8  9  10  11  12  	7  -34  136  175  -35  7  0  (256)
				pDst[135] = (6 * pSrc[150] -31 * pSrc[165] + 115 * pSrc[180] + 192 * pSrc[195] -33 * pSrc[210] + 7 * pSrc[225] ) >> 7;	// 7  8  9  10  11  12  13  	6  -31  115  192  -33  7  0  (256)
				pDst[150] = (5 * pSrc[165] -27 * pSrc[180] + 95 * pSrc[195] + 207 * pSrc[210] -30 * pSrc[225] + 6 * pSrc[240] ) >> 7;	// 8  9  10  11  12  13  14  	5  -27  95  207  -30  6  0  (256)
				pDst[165] = (4 * pSrc[180] -23 * pSrc[195] + 75 * pSrc[210] + 220 * pSrc[225] -24 * pSrc[240] + 4 * pSrc[255] ) >> 7;	// 9  10  11  12  13  14  15  	4  -23  75  220  -24  4  0  (256)
				pDst[180] = (3 * pSrc[195] -19 * pSrc[210] + 56 * pSrc[225] + 231 * pSrc[240] -16 * pSrc[255] + pSrc[270] ) >> 7;		// 10  11  12  13  14  15  16  	3  -19  56  231  -16  1  0  (256)
				pDst[195] = (2 * pSrc[210] -14 * pSrc[225] + 38 * pSrc[240] + 238 * pSrc[255] -6 * pSrc[270] -2 * pSrc[285] ) >> 7;		// 11  12  13  14  15  16  17  	2  -14  38  238  -6  -2  0  (256)
				pDst[210] = ( pSrc[225] -10 * pSrc[240] + 21 * pSrc[255] + 241 * pSrc[270] + 7 * pSrc[285] -5 * pSrc[300] + pSrc[315] ) >> 7;	// 12  13  14  15  16  17  18  	1  -10  21  241  7  -5  1  (256)
			}
			// write a 15x15 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+15; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+15; xx++) {
					// clipping
					int val = pBlock2[i];
					val = val > 1023 ? 1023 : val;
					pBuf[xx] = val < 0 ? 0 : val;
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_8to9_bicubic_8U_10U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 9/8 using bicubic interpolation
// The input is 8U and the output is 10-bit unsigned numbers in 32S data type.
// The sample location and filter follow the resize() in OpenCV, but the filter is an approximation!
// This is a fixed-point implementation
//   Ref Point			Filter * 256
//	-2	-1	0	1	-1	12	255	-10
//	-1	0	1	2	-4	41	241	-22
//	0	1	2	3	-11	76	219	-28
//	1	2	3	4	-18	114	188	-28
//	2	3	4	5	-24	152	152	-24
//	3	4	5	6	-28	188	114	-18
//	4	5	6	7	-28	219	76	-11
//	5	6	7	8	-22	241	41	-4
//	6	7	8	9	-10	255	12	-1
//
// Luhong Liang, IC-ASD, ASTRI
// Mar. 25, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input image type in CImageUtility::resize_8to9_bicubic_8U_10U()!\n");
		return false;
	}
	if (iplSrcImage->width*9 != iplDstImage->width*8 || iplSrcImage->height*9 != iplDstImage->height*8) {
		showErrMsg("Only support 8:9 upsampling in CImageUtility::resize_8to9_bicubic_8U_10U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// downsample by bicubic
	int pBlock[12*12];		// 12x12 block in source image (8 points + padding)
	int pBlock1[9*12];		// after interpolation in X direction
	int pBlock2[9*9];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=9, top+=8) {
		for (int x=0, left=0; x<iplDstImage->width; x+=9, left+=8) {
			// load a 12x12 block in source image (8x8 + padding)
			int i = 0;
			for (int yy=top; yy<top+12; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+12; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<12; v++) {
				int *pSrc = pBlock + v * 12;
				int *pDst = pBlock1 + v * 9;
				// calculation		   															 ref point          filter
				pDst[0] = (-pSrc[0] + 12*pSrc[1] + 255*pSrc[2] - 10*pSrc[3]) >> 7;			// 0	1	2	3	-1	12	255	-10
				pDst[1] = (-4*pSrc[1] + 41*pSrc[2] + 241*pSrc[3] - 22*pSrc[4]) >> 7;		// 1	2	3	4	-4	41	241	-22
				pDst[2] = (-11*pSrc[2] + 76*pSrc[3] + 219*pSrc[4] - 28*pSrc[5]) >> 7;		// 2	3	4	5	-11	76	219	-28
				pDst[3] = (-18*pSrc[3] + 114*pSrc[4] + 188*pSrc[5] - 28*pSrc[6]) >> 7;		// 3	4	5	6	-18	114	188	-28
				pDst[4] = (-24*pSrc[4] + 152*pSrc[5] + 152*pSrc[6] - 24*pSrc[7]) >> 7;		// 4	5	6	7	-24	152	152	-24
				pDst[5] = (-28*pSrc[5] + 188*pSrc[6] + 114*pSrc[7] - 18*pSrc[8]) >> 7;		// 5	6	7	8	-28	188	114	-18
				pDst[6] = (-28*pSrc[6] + 219*pSrc[7] + 76*pSrc[8] - 11*pSrc[9]) >> 7;		// 6	7	8	9	-28	219	76	-11
				pDst[7] = (-22*pSrc[7] + 241*pSrc[8] + 41*pSrc[9] - 4*pSrc[10]) >> 7;		// 7	8	9	10	-22	241	41	-4
				pDst[8] = (-10*pSrc[8] + 255*pSrc[9] + 12*pSrc[10] - pSrc[11]) >> 7;		// 8	9	10	11	-10	255	12	-1
			}
			// interpolation in Y direction
			for (int u=0; u<9; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		   																    ref point           filter
				pDst[0] = (-pSrc[0] + 12*pSrc[9] + 255*pSrc[2*9] - 10*pSrc[3*9]) >> 7;				// 0	1	2	3	-1	12	255	-10
				pDst[9] = (-4*pSrc[9] + 41*pSrc[2*9] + 241*pSrc[3*9] - 22*pSrc[4*9]) >> 7;			// 1	2	3	4	-4	41	241	-22
				pDst[2*9] = (-11*pSrc[2*9] + 76*pSrc[3*9] + 219*pSrc[4*9] - 28*pSrc[5*9]) >> 7;		// 2	3	4	5	-11	76	219	-28
				pDst[3*9] = (-18*pSrc[3*9] + 114*pSrc[4*9] + 188*pSrc[5*9] - 28*pSrc[6*9]) >> 7;	// 3	4	5	6	-18	114	188	-28
				pDst[4*9] = (-24*pSrc[4*9] + 152*pSrc[5*9] + 152*pSrc[6*9] - 24*pSrc[7*9]) >> 7;	// 4	5	6	7	-24	152	152	-24
				pDst[5*9] = (-28*pSrc[5*9] + 188*pSrc[6*9] + 114*pSrc[7*9] - 18*pSrc[8*9]) >> 7;	// 5	6	7	8	-28	188	114	-18
				pDst[6*9] = (-28*pSrc[6*9] + 219*pSrc[7*9] + 76*pSrc[8*9] - 11*pSrc[9*9]) >> 7;		// 6	7	8	9	-28	219	76	-11
				pDst[7*9] = (-22*pSrc[7*9] + 241*pSrc[8*9] + 41*pSrc[9*9] - 4*pSrc[10*9]) >> 7;		// 7	8	9	10	-22	241	41	-4
				pDst[8*9] = (-10*pSrc[8*9] + 255*pSrc[9*9] + 12*pSrc[10*9] - pSrc[11*9]) >> 7;		// 8	9	10	11	-10	255	12	-1
			}
			// write a 9x9 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+9; yy++) {
				int *pBuf = (int *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+9; xx++) {
					// clipping
					int val = pBlock2[i];
					val = val > 1023 ? 1023 : val;
					pBuf[xx] = val < 0 ? 0 : val;
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_8to9_bicubic_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 9/8 using bicubic interpolation
// The input and output are 8U data type.
// The sample location and filter follow the resize() in OpenCV, but the filter is an approximation!
// This is a fixed-point implementation
//   Ref Point			Filter * 256
//	-2	-1	0	1	-1	12	255	-10
//	-1	0	1	2	-4	41	241	-22
//	0	1	2	3	-11	76	219	-28
//	1	2	3	4	-18	114	188	-28
//	2	3	4	5	-24	152	152	-24
//	3	4	5	6	-28	188	114	-18
//	4	5	6	7	-28	219	76	-11
//	5	6	7	8	-22	241	41	-4
//	6	7	8	9	-10	255	12	-1
//
// Luhong Liang, IC-ASD, ASTRI
// Mar. 25, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_8to9_bicubic_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*9 != iplDstImage->width*8 || iplSrcImage->height*9 != iplDstImage->height*8) {
		showErrMsg("Only support 8:9 upsampling in CImageUtility::resize_8to9_bicubic_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// downsample by bicubic
	int pBlock[12*12];		// 12x12 block in source image (8 points + padding)
	int pBlock1[9*12];		// after interpolation in X direction
	int pBlock2[9*9];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=9, top+=8) {
		for (int x=0, left=0; x<iplDstImage->width; x+=9, left+=8) {
			// load a 12x12 block in source image (8x8 + padding)
			int i = 0;
			for (int yy=top; yy<top+12; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+12; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<12; v++) {
				int *pSrc = pBlock + v * 12;
				int *pDst = pBlock1 + v * 9;
				// calculation		   															 ref point          filter
				pDst[0] = (-pSrc[0] + 12*pSrc[1] + 255*pSrc[2] - 10*pSrc[3]) >> 7;			// 0	1	2	3	-1	12	255	-10
				pDst[1] = (-4*pSrc[1] + 41*pSrc[2] + 241*pSrc[3] - 22*pSrc[4]) >> 7;		// 1	2	3	4	-4	41	241	-22
				pDst[2] = (-11*pSrc[2] + 76*pSrc[3] + 219*pSrc[4] - 28*pSrc[5]) >> 7;		// 2	3	4	5	-11	76	219	-28
				pDst[3] = (-18*pSrc[3] + 114*pSrc[4] + 188*pSrc[5] - 28*pSrc[6]) >> 7;		// 3	4	5	6	-18	114	188	-28
				pDst[4] = (-24*pSrc[4] + 152*pSrc[5] + 152*pSrc[6] - 24*pSrc[7]) >> 7;		// 4	5	6	7	-24	152	152	-24
				pDst[5] = (-28*pSrc[5] + 188*pSrc[6] + 114*pSrc[7] - 18*pSrc[8]) >> 7;		// 5	6	7	8	-28	188	114	-18
				pDst[6] = (-28*pSrc[6] + 219*pSrc[7] + 76*pSrc[8] - 11*pSrc[9]) >> 7;		// 6	7	8	9	-28	219	76	-11
				pDst[7] = (-22*pSrc[7] + 241*pSrc[8] + 41*pSrc[9] - 4*pSrc[10]) >> 7;		// 7	8	9	10	-22	241	41	-4
				pDst[8] = (-10*pSrc[8] + 255*pSrc[9] + 12*pSrc[10] - pSrc[11]) >> 7;		// 8	9	10	11	-10	255	12	-1
			}
			// interpolation in Y direction
			for (int u=0; u<9; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		   																    ref point           filter
				pDst[0] = (-pSrc[0] + 12*pSrc[9] + 255*pSrc[2*9] - 10*pSrc[3*9]) >> 8;				// 0	1	2	3	-1	12	255	-10
				pDst[9] = (-4*pSrc[9] + 41*pSrc[2*9] + 241*pSrc[3*9] - 22*pSrc[4*9]) >> 8;			// 1	2	3	4	-4	41	241	-22
				pDst[2*9] = (-11*pSrc[2*9] + 76*pSrc[3*9] + 219*pSrc[4*9] - 28*pSrc[5*9]) >> 8;		// 2	3	4	5	-11	76	219	-28
				pDst[3*9] = (-18*pSrc[3*9] + 114*pSrc[4*9] + 188*pSrc[5*9] - 28*pSrc[6*9]) >> 8;	// 3	4	5	6	-18	114	188	-28
				pDst[4*9] = (-24*pSrc[4*9] + 152*pSrc[5*9] + 152*pSrc[6*9] - 24*pSrc[7*9]) >> 8;	// 4	5	6	7	-24	152	152	-24
				pDst[5*9] = (-28*pSrc[5*9] + 188*pSrc[6*9] + 114*pSrc[7*9] - 18*pSrc[8*9]) >> 8;	// 5	6	7	8	-28	188	114	-18
				pDst[6*9] = (-28*pSrc[6*9] + 219*pSrc[7*9] + 76*pSrc[8*9] - 11*pSrc[9*9]) >> 8;		// 6	7	8	9	-28	219	76	-11
				pDst[7*9] = (-22*pSrc[7*9] + 241*pSrc[8*9] + 41*pSrc[9*9] - 4*pSrc[10*9]) >> 8;		// 7	8	9	10	-22	241	41	-4
				pDst[8*9] = (-10*pSrc[8*9] + 255*pSrc[9*9] + 12*pSrc[10*9] - pSrc[11*9]) >> 8;		// 8	9	10	11	-10	255	12	-1
			}
			// write a 9x9 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+9; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+9; xx++) {
					// rounding and clipping
					int val = pBlock2[i];
					val = ((val&0x0001) == 0) ? (val>>1) : ((val>>1) + 1);
					val = val > 255 ? 255 : val;
					pBuf[xx] = (unsigned char)(val < 0 ? 0 : val);
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_4to9_bicubic_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 9/4 using bicubic interpolation
// The input and output are 8U data type.
// The sample location and filter follow the resize() in OpenCV, but the filter is an approximation!
// This is a fixed-point implementation
//   Ref Point			Filter * 256
// -2	-1	0	1	-11	76	219	-28
// -1	0	1	2	-22	241	41	-4
// -1	0	1	2	-18	114	188	-28
// 0	1	2	3	-10	255	12	-1
// 0	1	2	3	-24	152	152	-24
// 0	1	2	3	-1	12	255	-10
// 1	2	3	4	-28	188	114	-18
// 1	2	3	4	-4	41	241	-22
// 2	3	4	5	-28	219	76	-11
//
// Luhong Liang, IC-ASD, ASTRI
// Mar. 25, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_4to9_bicubic_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*9 != iplDstImage->width*4 || iplSrcImage->height*9 != iplDstImage->height*4) {
		showErrMsg("Only support 4:9 upsampling in CImageUtility::resize_4to9_bicubic_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) return false;
	
	// downsample by bicubic
	int pBlock[8*8];		// 8x8 block in source image (4 points + padding)
	int pBlock1[9*8];		// after interpolation in X direction
	int pBlock2[9*9];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=9, top+=4) {
		for (int x=0, left=0; x<iplDstImage->width; x+=9, left+=4) {
			// load a 8x8 block in source image (8x8 + padding)
			int i = 0;
			for (int yy=top; yy<top+8; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+8; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<8; v++) {
				int *pSrc = pBlock + v * 8;
				int *pDst = pBlock1 + v * 9;
				// calculation		   															 ref point          filter
				pDst[0] = (-11*pSrc[0] + 76*pSrc[1] + 219*pSrc[2] - 28*pSrc[3]) >> 7;			// 0	1	2	3	-11	76	219	-28
				pDst[1] = (-22*pSrc[1] + 241*pSrc[2] + 41*pSrc[3] - 4*pSrc[4]) >> 7;			// 1	2	3	4	-22	241	41	-4
				pDst[2] = (-18*pSrc[1] + 114*pSrc[2] + 188*pSrc[3] - 28*pSrc[4]) >> 7;			// 1	2	3	4	-18	114	188	-28
				pDst[3] = (-10*pSrc[2] + 255*pSrc[3] + 12*pSrc[4] - pSrc[5]) >> 7;				// 2	3	4	5	-10	255	12	-1
				pDst[4] = (-24*pSrc[2] + 152*pSrc[3] + 152*pSrc[4] - 24*pSrc[5]) >> 7;			// 2	3	4	5	-24	152	152	-24
				pDst[5] = (-pSrc[2] + 12*pSrc[3] + 255*pSrc[4] - 10*pSrc[5]) >> 7;				// 2	3	4	5	-1	12	255	-10
				pDst[6] = (-28*pSrc[3] + 188*pSrc[4] + 114*pSrc[5] - 18*pSrc[6]) >> 7;			// 3	4	5	6	-28	188	114	-18
				pDst[7] = (-4*pSrc[3] + 41*pSrc[4] + 241*pSrc[5] - 22*pSrc[6]) >> 7;			// 3	4	5	6	-4	41	241	-22
				pDst[8] = (-28*pSrc[4] + 219*pSrc[5] + 76*pSrc[6] - 11*pSrc[7]) >> 7;			// 4	5	6	7	-28	219	76	-11
			}
			// interpolation in Y direction
			for (int u=0; u<9; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		   																    ref point           filter
				pDst[0] = (-11*pSrc[0] + 76*pSrc[9] + 219*pSrc[2*9] - 28*pSrc[3*9]) >> 8;			// 0	1	2	3	-11	76	219	-28
				pDst[9] = (-22*pSrc[9] + 241*pSrc[2*9] + 41*pSrc[3*9] - 4*pSrc[4*9]) >> 8;			// 1	2	3	4	-22	241	41	-4
				pDst[2*9] = (-18*pSrc[9] + 114*pSrc[2*9] + 188*pSrc[3*9] - 28*pSrc[4*9]) >> 8;		// 1	2	3	4	-18	114	188	-28
				pDst[3*9] = (-10*pSrc[2*9] + 255*pSrc[3*9] + 12*pSrc[4*9] - pSrc[5*9]) >> 8;		// 2	3	4	5	-10	255	12	-1
				pDst[4*9] = (-24*pSrc[2*9] + 152*pSrc[3*9] + 152*pSrc[4*9] - 24*pSrc[5*9]) >> 8;	// 2	3	4	5	-24	152	152	-24
				pDst[5*9] = (-pSrc[2*9] + 12*pSrc[3*9] + 255*pSrc[4*9] - 10*pSrc[5*9]) >> 8;		// 2	3	4	5	-1	12	255	-10
				pDst[6*9] = (-28*pSrc[3*9] + 188*pSrc[4*9] + 114*pSrc[5*9] - 18*pSrc[6*9]) >> 8;	// 3	4	5	6	-28	188	114	-18
				pDst[7*9] = (-4*pSrc[3*9] + 41*pSrc[4*9] + 241*pSrc[5*9] - 22*pSrc[6*9]) >> 8;		// 3	4	5	6	-4	41	241	-22
				pDst[8*9] = (-28*pSrc[4*9] + 219*pSrc[5*9] + 76*pSrc[6*9] - 11*pSrc[7*9]) >> 8;		// 4	5	6	7	-28	219	76	-11
			}
			// write a 9x9 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+9; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+9; xx++) {
					// rounding and clipping
					int val = pBlock2[i];
					val = ((val&0x0001) == 0) ? (val>>1) : ((val>>1) + 1);
					val = val > 255 ? 255 : val;
					pBuf[xx] = (unsigned char)(val < 0 ? 0 : val);
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::resize_4to9_cublin_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Resize the image to 9/4 using bicubic interpolation in X direction and bilinear interpolation in Y direction.
// The input and output are 8U data type.
// The sample location and filter follow the resize() in OpenCV, but the filter is an approximation!
// This is a fixed-point implementation
//   Ref Point			Filter * 256
// bicubic filter
// -2	-1	0	1	-11	76	219	-28
// -1	0	1	2	-22	241	41	-4
// -1	0	1	2	-18	114	188	-28
// 0	1	2	3	-10	255	12	-1
// 0	1	2	3	-24	152	152	-24
// 0	1	2	3	-1	12	255	-10
// 1	2	3	4	-28	188	114	-18
// 1	2	3	4	-4	41	241	-22
// 2	3	4	5	-28	219	76	-11
// bilinear filter
// -1	0	71	185
// 0	1	213	43
// 0	1	100	156
// 1	2	242	14
// 1	2	128	128
// 1	2	14	242
// 2	3	156	100
// 2	3	43	213
// 3	4	185	71
//
// Luhong Liang, IC-ASD, ASTRI
// Mar. 25, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::resize_4to9_cublin_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*9 != iplDstImage->width*4 || iplSrcImage->height*9 != iplDstImage->height*4) {
		showErrMsg("Only support 4:9 upsampling in CImageUtility::resize_4to9_cublin_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	// downsample by bicubic
	int pBlock[8*6];		// 8x6 block in source image (4 points + padding)
	int pBlock1[9*6];		// after interpolation in X direction
	int pBlock2[9*9];		// after interpolation in Y direction
	for (int y=0, top=0; y<iplDstImage->height; y+=9, top+=4) {
		for (int x=0, left=0; x<iplDstImage->width; x+=9, left+=4) {
			// load a 8x6 block in source image (8x8 + padding)
			int i = 0;
			for (int yy=top; yy<top+6; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplSrcPad->imageData + yy * iplSrcPad->widthStep);
				for (int xx=left; xx<left+8; xx++) {
					pBlock[i] = pBuf[xx];
					i++;
				}
			}
			// interpolation in X direction
			for (int v=0; v<6; v++) {
				int *pSrc = pBlock + v * 8;
				int *pDst = pBlock1 + v * 9;
				// calculation		   															 ref point          filter
				pDst[0] = (-11*pSrc[0] + 76*pSrc[1] + 219*pSrc[2] - 28*pSrc[3]) >> 7;			// 0	1	2	3	-11	76	219	-28
				pDst[1] = (-22*pSrc[1] + 241*pSrc[2] + 41*pSrc[3] - 4*pSrc[4]) >> 7;			// 1	2	3	4	-22	241	41	-4
				pDst[2] = (-18*pSrc[1] + 114*pSrc[2] + 188*pSrc[3] - 28*pSrc[4]) >> 7;			// 1	2	3	4	-18	114	188	-28
				pDst[3] = (-10*pSrc[2] + 255*pSrc[3] + 12*pSrc[4] - pSrc[5]) >> 7;				// 2	3	4	5	-10	255	12	-1
				pDst[4] = (-24*pSrc[2] + 152*pSrc[3] + 152*pSrc[4] - 24*pSrc[5]) >> 7;			// 2	3	4	5	-24	152	152	-24
				pDst[5] = (-pSrc[2] + 12*pSrc[3] + 255*pSrc[4] - 10*pSrc[5]) >> 7;				// 2	3	4	5	-1	12	255	-10
				pDst[6] = (-28*pSrc[3] + 188*pSrc[4] + 114*pSrc[5] - 18*pSrc[6]) >> 7;			// 3	4	5	6	-28	188	114	-18
				pDst[7] = (-4*pSrc[3] + 41*pSrc[4] + 241*pSrc[5] - 22*pSrc[6]) >> 7;			// 3	4	5	6	-4	41	241	-22
				pDst[8] = (-28*pSrc[4] + 219*pSrc[5] + 76*pSrc[6] - 11*pSrc[7]) >> 7;			// 4	5	6	7	-28	219	76	-11
			}
			// interpolation in Y direction
			for (int u=0; u<9; u++) {
				int *pSrc = pBlock1 + u;
				int *pDst = pBlock2 + u;
				// calculation		   								   point    filter
				pDst[0] = (71*pSrc[0] + 185*pSrc[9]) >> 8;			// 0	1	71	185
				pDst[9] = (213*pSrc[9] + 43*pSrc[2*9]) >> 8;		// 1	2	213	43
				pDst[2*9] = (100*pSrc[9] + 156*pSrc[2*9]) >> 8;		// 1	2	100	156
				pDst[3*9] = (242*pSrc[2*9] + 14*pSrc[3*9]) >> 8;	// 2	3	242	14
				pDst[4*9] = (128*pSrc[2*9] + 128*pSrc[3*9]) >> 8;	// 2	3	128	128
				pDst[5*9] = (14*pSrc[2*9] + 242*pSrc[3*9]) >> 8;	// 2	3	14	242
				pDst[6*9] = (156*pSrc[3*9] + 100*pSrc[4*9]) >> 8;	// 3	4	156	100
				pDst[7*9] = (43*pSrc[3*9] + 213*pSrc[4*9]) >> 8;	// 3	4	43	213
				pDst[8*9] = (185*pSrc[4*9] + 71*pSrc[5*9]) >> 8;	// 4	5	185	71
			}
			// write a 9x9 block to destination image & clipping
			i = 0;
			for (int yy=y; yy<y+9; yy++) {
				unsigned char *pBuf = (unsigned char *)(iplDstImage->imageData + yy * iplDstImage->widthStep);
				for (int xx=x; xx<x+9; xx++) {
					// rounding and clipping
					int val = pBlock2[i];
					val = ((val&0x0001) == 0) ? (val>>1) : ((val>>1) + 1);
					val = val > 255 ? 255 : val;
					pBuf[xx] = (unsigned char)(val < 0 ? 0 : val);
					i++;
				}
			}
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::stretchX_8to15_cubic_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// 8:15 stretch the image in X direction using cubic interpolation
// The sample location follows the resize() in OpenCV
// This is a fixed-point implementation
//   Ref Point			Filter * 256
// Cubic filter:
// -2	-1	0	1	-8	62	228	-26
// -1	0	1	2	-28	212	84	-12
// -1	0	1	2	-4	41	241	-22
// 0	1	2	3	-28	194	106	-16
// 0	1	2	3	-2	23	251	-16
// 1	2	3	4	-27	174	129	-20
// 1	2	3	4	0	7	255	-6
// 2	3	4	5	-24	152	152	-24
// 3	4	5	6	-6	255	7	0
// 3	4	5	6	-20	129	174	-27
// 4	5	6	7	-16	251	23	-2
// 4	5	6	7	-16	106	194	-28
// 5	6	7	8	-22	241	41	-4
// 5	6	7	8	-12	84	212	-28
// 6	7	8	9	-26	228	62	-8
// 7	8	9	10	-8	62	228	-26
//
// Luhong Liang, IC-ASD, ASTRI
// Jul. 3, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::stretchX_8to15_cubic_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*15 != iplDstImage->width*8 || iplSrcImage->height != iplDstImage->height) {
		showErrMsg("Only support 8:15 upsampling in CImageUtility::stretchX_8to15_cubic_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 0, 0);
	if (iplSrcPad == NULL) return false;

    for (int y=0; y<iplDstImage->height; y++) {
		for (int x=0, left=0; x<iplDstImage->width; x+=15, left+=8) {
			unsigned char *pSrc = (unsigned char *)(iplSrcPad->imageData + y * iplSrcPad->widthStep);
            unsigned char *pDst = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
            int pix;
			// calculation		   														   ref point          filter
			pix = -8*pSrc[left+0] + 62*pSrc[left+1] + 228*pSrc[left+2] - 26*pSrc[left+3];		// 0	1	2	3	-8	62	228	-26
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst[x] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = -28*pSrc[left+1] + 212*pSrc[left+2] + 84*pSrc[left+3] - 12*pSrc[left+4];		// 1	2	3	4	-28	212	84	-12
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst[x+1] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = -4*pSrc[left+1] + 41*pSrc[left+2] + 241*pSrc[left+3] - 22*pSrc[left+4];		// 1	2	3	4	-4	41	241	-22
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst[x+2] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = -28*pSrc[left+2] + 194*pSrc[left+3] + 106*pSrc[left+4] - 16*pSrc[left+5];		// 2	3	4	5	-28	194	106	-16
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst[x+3] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = -2*pSrc[left+2] + 23*pSrc[left+3] + 251*pSrc[left+4] - 16*pSrc[left+5];		// 2	3	4	5	-2	23	251	-16
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst[x+4] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = -27*pSrc[left+3] + 174*pSrc[left+4] + 129*pSrc[left+5] - 20*pSrc[left+6];		// 3	4	5	6	-27	174	129	-20
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst[x+5] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = 7*pSrc[left+4] + 255*pSrc[left+5] - 6*pSrc[left+6];						    // 3	4	5	6	0	7	255	-6
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst[x+6] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = -24*pSrc[left+4] + 152*pSrc[left+5] + 152*pSrc[left+6] - 24*pSrc[left+7];		// 4	5	6	7	-24	152	152	-24
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst[x+7] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = -6*pSrc[left+5] + 255*pSrc[left+6] + 7*pSrc[left+7];						    // 5	6	7	8	-6	255	7	0
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst[x+8] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = -20*pSrc[left+5] + 129*pSrc[left+6] + 174*pSrc[left+7] - 27*pSrc[left+8];		// 5	6	7	8	-20	129	174	-27
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst[x+9] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = -16*pSrc[left+6] + 251*pSrc[left+7] + 23*pSrc[left+8] - 2*pSrc[left+9];		// 6	7	8	9	-16	251	23	-2
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst[x+10] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = -16*pSrc[left+6] + 106*pSrc[left+7] + 194*pSrc[left+8] - 28*pSrc[left+9];		// 6	7	8	9	-16	106	194	-28
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst[x+11] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = -22*pSrc[left+7] + 241*pSrc[left+8] + 41*pSrc[left+9] - 4*pSrc[left+10];		// 7	8	9	10	-22	241	41	-4
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst[x+12] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = -12*pSrc[left+7] + 84*pSrc[left+8] + 212*pSrc[left+9] - 28*pSrc[left+10];		// 7	8	9	10	-12	84	212	-28
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst[x+13] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = -26*pSrc[left+8] + 228*pSrc[left+9] + 62*pSrc[left+10] - 8*pSrc[left+11];		// 8	9	10	11	-26	228	62	-8
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst[x+14] = (unsigned char)(pix > 255 ? 255 : pix);
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::stretchY_8to15_linear_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
    // 8:15 stretch the image in Y direction using linear interpolation
// The sample location follows the resize() in OpenCV
// This is a fixed-point implementation
//   Ref Point			Filter * 256
// -1	0			60	196
// 0	1			179	77
// 0	1			43	213
// 1	2			162	94
// 1	2			26	230
// 2	3			145	111
// 2	3			9	247
// 3	4			128	128
// 4	5			247	9
// 4	5			111	145
// 5	6			230	26
// 5	6			94	162
// 6	7			213	43
// 6	7			77	179
// 7	8			196	60
//
// Luhong Liang, IC-ASD, ASTRI
// Jul. 3, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::stretchY_8to15_linear_8U()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width || iplSrcImage->height*15 != iplDstImage->height*8) {
		showErrMsg("Only support 8:15 upsampling in CImageUtility::stretchY_8to15_linear_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 0, 0, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	for (int y=0, top=0; y<iplDstImage->height; y+=15, top+=8) {
        unsigned char *pSrc0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
        unsigned char *pSrc1 = (unsigned char *)(iplSrcPad->imageData + (top + 1) * iplSrcPad->widthStep);
        unsigned char *pSrc2 = (unsigned char *)(iplSrcPad->imageData + (top + 2) * iplSrcPad->widthStep);
        unsigned char *pSrc3 = (unsigned char *)(iplSrcPad->imageData + (top + 3) * iplSrcPad->widthStep);
        unsigned char *pSrc4 = (unsigned char *)(iplSrcPad->imageData + (top + 4) * iplSrcPad->widthStep);
        unsigned char *pSrc5 = (unsigned char *)(iplSrcPad->imageData + (top + 5) * iplSrcPad->widthStep);
        unsigned char *pSrc6 = (unsigned char *)(iplSrcPad->imageData + (top + 6) * iplSrcPad->widthStep);
        unsigned char *pSrc7 = (unsigned char *)(iplSrcPad->imageData + (top + 7) * iplSrcPad->widthStep);
        unsigned char *pSrc8 = (unsigned char *)(iplSrcPad->imageData + (top + 8) * iplSrcPad->widthStep);
        unsigned char *pSrc9 = (unsigned char *)(iplSrcPad->imageData + (top + 9) * iplSrcPad->widthStep);
        unsigned char *pDst0 = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
        unsigned char *pDst1 = (unsigned char *)(iplDstImage->imageData + (y + 1) * iplDstImage->widthStep);
        unsigned char *pDst2 = (unsigned char *)(iplDstImage->imageData + (y + 2) * iplDstImage->widthStep);
        unsigned char *pDst3 = (unsigned char *)(iplDstImage->imageData + (y + 3) * iplDstImage->widthStep);
        unsigned char *pDst4 = (unsigned char *)(iplDstImage->imageData + (y + 4) * iplDstImage->widthStep);
        unsigned char *pDst5 = (unsigned char *)(iplDstImage->imageData + (y + 5) * iplDstImage->widthStep);
        unsigned char *pDst6 = (unsigned char *)(iplDstImage->imageData + (y + 6) * iplDstImage->widthStep);
        unsigned char *pDst7 = (unsigned char *)(iplDstImage->imageData + (y + 7) * iplDstImage->widthStep);
        unsigned char *pDst8 = (unsigned char *)(iplDstImage->imageData + (y + 8) * iplDstImage->widthStep);
        unsigned char *pDst9 = (unsigned char *)(iplDstImage->imageData + (y + 9) * iplDstImage->widthStep);
        unsigned char *pDst10 = (unsigned char *)(iplDstImage->imageData + (y + 10) * iplDstImage->widthStep);
        unsigned char *pDst11 = (unsigned char *)(iplDstImage->imageData + (y + 11) * iplDstImage->widthStep);
        unsigned char *pDst12 = (unsigned char *)(iplDstImage->imageData + (y + 12) * iplDstImage->widthStep);
        unsigned char *pDst13 = (unsigned char *)(iplDstImage->imageData + (y + 13) * iplDstImage->widthStep);
        unsigned char *pDst14 = (unsigned char *)(iplDstImage->imageData + (y + 14) * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			// bicubic interpolation in X direction
            int pix;
			// calculation		 						 ref point          filter
			pix =  60 * pSrc0[x] + 196 * pSrc1[x];		// -1	0			60	196
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst0[x] = (unsigned char)(pix > 255 ? 255 : pix);
            pix = 179 * pSrc1[x] +  77 * pSrc2[x];		// 0	1			179	77
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst1[x] = (unsigned char)(pix > 255 ? 255 : pix);
			pix =  43 * pSrc1[x] + 213 * pSrc2[x];		// 0	1			43	213
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst2[x] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = 162 * pSrc2[x] +  94 * pSrc3[x];	    // 1	2			162	94
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst3[x] = (unsigned char)(pix > 255 ? 255 : pix);
			pix =  26 * pSrc2[x] + 230 * pSrc3[x];	    // 1	2			26	230
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst4[x] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = 145 * pSrc3[x] + 111 * pSrc4[x];	    // 2	3			145	111
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst5[x] = (unsigned char)(pix > 255 ? 255 : pix);
			pix =   9 * pSrc3[x] + 247 * pSrc4[x];	    // 2	3			9	247
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst6[x] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = 128 * pSrc4[x] + 128 * pSrc5[x];	    // 3	4			128	128
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst7[x] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = 247 * pSrc5[x] +   9 * pSrc6[x];	    // 4	5			247	9
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst8[x] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = 111 * pSrc5[x] + 145 * pSrc6[x];	    // 4	5			111	145
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst9[x] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = 230 * pSrc6[x] +  26 * pSrc7[x];	    // 5	6			230	26
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst10[x] = (unsigned char)(pix > 255 ? 255 : pix);
			pix =  94 * pSrc6[x] + 162 * pSrc7[x];	    // 5	6			94	162
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst11[x] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = 213 * pSrc7[x] +  43 * pSrc8[x];	    // 6	7			213	43
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst12[x] = (unsigned char)(pix > 255 ? 255 : pix);
			pix =  77 * pSrc7[x] + 179 * pSrc8[x];	    // 6	7			77	179
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst13[x] = (unsigned char)(pix > 255 ? 255 : pix);
			pix = 196 * pSrc8[x] +  60 * pSrc9[x];	    // 7	8			196	60
            pix = pix >= 0 ? pix >> 7 : 0;
            pix = ((pix&0x0001)==0) ? (pix>>1) : ((pix>>1)+1);
            pDst14[x] = (unsigned char)(pix > 255 ? 255 : pix);
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::stretchX_1to2_cubic_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Stretch image of magification factor of 2 in X direction. The sampling location is the same as OpenCV!
// The sample locations are (1-D) as example:
//	 -2         -1          0           1            2   <-- original mage
//                       o     o     o     o     o		 <-- resized image
// In X direction, the indices and parameters (*256) of the filter is
// -2	-1	0	1	-9	67	225	-27
// -1	0	1	2	-27	225	67	-9
// Luhong Liang, IC-ASD, ASTRI
// Jul. 3, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::stretchX_1to2_cubic_8U()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::stretchX_1to2_cubic_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 0, 0);
	if (iplSrcPad == NULL) return false;
	
	for (int y=0; y<iplDstImage->height; y++) {
		unsigned char *pSrc = (unsigned char *)(iplSrcPad->imageData + y * iplSrcPad->widthStep);
        unsigned char *pDst = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0, left=0; x<iplDstImage->width; x+=2, left++) {
			// line 0
			int pix = -9*pSrc[left] + 67*pSrc[left+1] + 225*pSrc[left+2] - 27*pSrc[left+3];
            pix = pix >= 0 ? pix >> 7 : 0;
			pix = ((pix&0x0001) == 0) ? (pix>>1) : ((pix>>1) + 1);      // rounding to 8-bit
			pDst[x] = (unsigned char)(pix > 255 ? 255 : pix);			// should clipping, since 1023-->256 above!
			pix = -27*pSrc[left+1] + 225*pSrc[left+2] + 67*pSrc[left+3] - 9*pSrc[left+4];
            pix = pix >= 0 ? pix >> 7 : 0;
			pix = ((pix&0x0001) == 0) ? (pix>>1) : ((pix>>1) + 1);      // rounding to 8-bit
			pDst[x+1] = (unsigned char)(pix > 255 ? 255 : pix);			// should clipping, since 1023-->256 above!
		}
	}

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::stretchY_1to2_linear_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// Stretch image of magification factor of 2 in Y direction. The sampling location is the same as OpenCV!
// The sample locations are (1-D) as example:
//	 -2         -1          0           1            2   <-- original mage
//                       o     o     o     o     o		 <-- resized image
// In Y direction, the indices and parameters of the filter is
// 	-1	0	1/4 3/4
// 	0	1	3/4 1/4
// Luhong Liang, IC-ASD, ASTRI
// Jul. 3, 2013
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type in CImageUtility::stretchY_1to2_linear_8U()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::stretchY_1to2_linear_8U()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 0, 0, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		unsigned char *pBuf0 = (unsigned char *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		unsigned char *pBuf1 = (unsigned char *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		unsigned char *pBuf2 = (unsigned char *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		// interpolation in Y direction
		unsigned char *pDst0 = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		unsigned char *pDst1 = (unsigned char *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0; x<iplSrcPad->width; x++) {
            int pix;
			pix = pBuf0[x] + 3*pBuf1[x];	                            // [1/4, 3/4]	
            pix = pix >= 0 ? pix >> 1 : 0;
			pix = ((pix&0x0001) == 0) ? (pix>>1) : ((pix>>1) + 1);      // rounding to 8-bit
			pDst0[x] = (unsigned char)(pix > 255 ? 255 : pix);			// should clipping, since 1023-->256 above!
			pix = 3*pBuf1[x] + pBuf2[x];	                            // [3/4, 1/4]
            pix = pix >= 0 ? pix >> 1 : 0;
			pix = ((pix&0x0001) == 0) ? (pix>>1) : ((pix>>1) + 1);      // rounding to 8-bit
			pDst1[x] = (unsigned char)(pix > 255 ? 255 : pix);			// should clipping, since 1023-->256 above!
		}
    }

	safeReleaseImage(&iplSrcPad);

	return true;
}

bool CImageUtility::stretchY_1to2_linear_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Stretch image of magification factor of 2 in Y direction. The sampling location is the same as OpenCV!
// The sample locations are (1-D) as example:
//	 -2         -1          0           1            2   <-- original mage
//                       o     o     o     o     o		 <-- resized image
// In Y direction, the indices and parameters of the filter is
// 	-1	0	1/4 3/4
// 	0	1	3/4 1/4
// Luhong Liang, ICDD, ASTRI
// Jul. 7, 2015
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::SR_DEPTH_32F()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::SR_DEPTH_32F()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 0, 0, 1, 1);
	if (iplSrcPad == NULL) return false;
	
	for (int y=0, top=0; y<iplDstImage->height; y+=2, top++) {
		float *pBuf0 = (float *)(iplSrcPad->imageData + top * iplSrcPad->widthStep);
		float *pBuf1 = (float *)(iplSrcPad->imageData + (top+1) * iplSrcPad->widthStep);
		float *pBuf2 = (float *)(iplSrcPad->imageData + (top+2) * iplSrcPad->widthStep);
		// interpolation in Y direction
		float *pDst0 = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
		float *pDst1 = (float *)(iplDstImage->imageData + (y+1) * iplDstImage->widthStep);
		for (int x=0; x<iplSrcPad->width; x++) {
            float pix;
			pix = 0.25f * pBuf0[x] + 0.75f * pBuf1[x];	                            // [1/4, 3/4]	
			pDst0[x] = pix;
			pix = 0.75f * pBuf1[x] + 0.25f * pBuf2[x];	                            // [3/4, 1/4]
			pDst1[x] = pix;
		}
    }

	safeReleaseImage(&iplSrcPad);

	return true;
}

IplImage *CImageUtility::padding(IplImage *iplImage, int left, int right, int top, int bottom, int type)
// padding each direction [left, right, top, bottom] pixels
// by Luhong Liang, ICD-ASD, ASTRI
// Argument:
//      iplImage -- [I] input image
//      left, righ, top, bottom -- [I] pixels padded in each direction
//      type -- [I] indicates the pixels to be padded
//                     0 (default) -- replication of the boundary pixels
//                     1               -- replication on left and right, 0 on top and bottom
//                     2               -- replication on left and right, 128 on top and bottom
//                     3               -- filling 0
//                     4               -- filling 128
//                     5               -- filling array with mirror reflections of itself.
// Dec. 15, 2012
// Added support on 32S data type, Dec. 20, 2012
// Added support on 16U data type, Sept. 17, 2012
// Added support on RGB or other 3-channel image, May 15, 2014
{
	if (iplImage == NULL || (iplImage->nChannels != 1 && iplImage->nChannels != 3) || left < 0 || right < 0 || top < 0 || bottom < 0) {
		showErrMsg("Invalid input image or argument in CImageUtility::padding()!\n");
		return NULL;
	}

    IplImage *iplPadded = createImage(iplImage->width+left+right, iplImage->height+top+bottom, iplImage->depth, iplImage->nChannels);
    if (iplPadded == NULL) {
        showErrMsg("Fail to allocate image buffer in CImageUtility::padding()!\n");
        return NULL;
    }

    if (padding(iplImage, iplPadded, left, right, top, bottom, type) == NULL)  {
        safeReleaseImage(&iplPadded);
    }

    return iplPadded;
}

bool CImageUtility::padding(IplImage *iplImage, IplImage *iplPadded, int left, int right, int top, int bottom, int type)
// padding each direction [left, right, top, bottom] pixels
// by Luhong Liang, ICD-ASD, ASTRI
// Argument:
//      iplImage -- [I] input image
//      iplPadded -- [O] padded image
//      left, righ, top, bottom -- [I] pixels padded in each direction
//      type -- [I] indicates the pixels to be padded
//                     0 (default) -- replication of the boundary pixels
//                     1               -- replication on left and right, 0 on top and bottom
//                     2               -- replication on left and right, 128 on top and bottom
//                     3               -- filling 0
//                     4               -- filling 128
//                     5               -- filling array with mirror reflections of itself.
// Dec. 15, 2012
// Added support on 32S data type, Dec. 20, 2012
// Added support on 16U data type, Sept. 17, 2012
// Added support on RGB or other 3-channel image, May 15, 2014
{
	if (iplImage == NULL || (iplImage->nChannels != 1 && iplImage->nChannels != 3) || left < 0 || right < 0 || top < 0 || bottom < 0) {
		showErrMsg("Invalid input image or argument in CImageUtility::padding()!\n");
		return false;
	}

    if (iplPadded->width != iplImage->width+left+right || iplPadded->height != iplImage->height+top+bottom) {
        showErrMsg("Invalid input padding pixel number(s) in CImageUtility::padding()!\n");
        return false;
    }

    //setZero(iplPadded);	// for debug

	if (iplImage->depth == SR_DEPTH_8U) {
        unsigned char s0=0, s1=0, s2=0;
		// left and right
		for (int y=0; y<iplImage->height; y++) {
			unsigned char *pSrc = (unsigned char*)iplImage->imageData + y * iplImage->widthStep;
			unsigned char *pDst = (unsigned char*)iplPadded->imageData + (y+top) * iplPadded->widthStep;
            if (type == 5) {
                if (iplImage->nChannels == 1) {
                    for (int x=left-1, x1=0; x>=0; x--, x1++) {
                        pDst[x] = pSrc[x1]; // padding in left
                    }
                } else {
                    for (int x = left-1, x1=0; x>=0; x--,x1++) {
                        pDst[x*3] = pSrc[x1*3];      pDst[x*3+1] = pSrc[x1*3+1];      pDst[x*3+2] = pSrc[x1*3+2];  // padding in left
                    }
                }
                pDst += left * iplImage->nChannels;
                memcpy(pDst, pSrc, iplImage->width*iplImage->nChannels*sizeof(char));
                if (iplImage->nChannels == 1) {
                    for (int x=iplImage->width, x1=iplImage->width-1; x<iplImage->width+right; x++, x1--) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x] = pSrc[x1]; // padding in right
                    }
                } else {
                    for (int x=iplImage->width, x1=iplImage->width-1; x<iplImage->width+right; x++, x1--) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x*3] = pSrc[x1*3];     pDst[x*3+1] = pSrc[x1*3+1];     pDst[x*3+2] = pSrc[x1*3+2]; // padding in right
                    }
                }
            } else {
                if (type == 0 || type == 1 || type == 2) {  // replication
                    s0 = pSrc[0];
                    if (iplImage->nChannels == 3) {
                        s1 = pSrc[1];   s2 = pSrc[2];                    
                    }
                } else if (type == 3) {
                    s0 = 0;
                    if (iplImage->nChannels == 3) {
                        s1 = 0;   s2 = 0;
                    }
                } else if (type == 4) {
                    s0 = 128;
                    if (iplImage->nChannels == 3) {
                        s1 = 128;   s2 = 128;
                    }
                }
                if (iplImage->nChannels == 1) {
                    for (int x=0; x<left; x++) {
                        pDst[x] = s0;
                    }
                } else {
                    for (int x=0; x<left; x++) {
                        pDst[x*3] = s0;     pDst[x*3+1] = s1;   pDst[x*3+2] = s2;
                    }
                }
                pDst += left * iplImage->nChannels;
                memcpy(pDst, pSrc, iplImage->width*iplImage->nChannels*sizeof(char));
                if (type == 0 || type == 1 || type == 2) {  // replication
                    s0 = pSrc[iplImage->width-1];
                    if (iplImage->nChannels == 3) {
                        s1 = pSrc[(iplImage->width-1)*3+1], s2 = pSrc[(iplImage->width-1)*3+2];                   
                    }
                }       // For other types, the pixels have been set
                if (iplImage->nChannels == 1) {
                    for (int x=iplImage->width; x<iplImage->width+right; x++) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x] = s0;
                    }
                } else {
                    for (int x=iplImage->width; x<iplImage->width+right; x++) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x*3] = s0;     pDst[x*3+1] = s1;   pDst[x*3+2] = s2;
                    }
                }
            }
		}
		//saveImage("_PaddedX.bmp", iplPadded);  // for debug
		
		// top and bottom
        if (type == 0) {
		    unsigned char *pSrc = (unsigned char*)iplPadded->imageData + top * iplPadded->widthStep;
		    for (int y=0; y<top; y++) {
			    unsigned char *pDst = (unsigned char*)iplPadded->imageData + y * iplPadded->widthStep;
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = pSrc[x];
			    }
		    }
		    pSrc = (unsigned char*)iplPadded->imageData + (iplImage->height + top - 1) * iplPadded->widthStep;
		    for (int y=iplImage->height+top; y<iplImage->height+top+bottom; y++) {
			    unsigned char *pDst = (unsigned char*)iplPadded->imageData + y * iplPadded->widthStep;
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = pSrc[x];
			    }
		    }
        } else if (type == 1 || type == 3) {
            for (int y=0; y<top; y++) {
                unsigned char *pDst = (unsigned char*)iplPadded->imageData + y * iplPadded->widthStep;
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 0;
			    }
            }
            for (int y=iplImage->height+top; y<iplImage->height+top+bottom; y++) {
                unsigned char *pDst = (unsigned char*)iplPadded->imageData + y * iplPadded->widthStep;
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 0;
			    }
            }
        } else if (type == 2 || type == 4) {
            for (int y=0; y<top; y++) {
                unsigned char *pDst = (unsigned char*)iplPadded->imageData + y * iplPadded->widthStep;
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 128;
			    }
            }
            for (int y=iplImage->height+top; y<iplImage->height+top+bottom; y++) {
                unsigned char *pDst = (unsigned char*)iplPadded->imageData + y * iplPadded->widthStep;
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 128;
			    }
            }
        } else if (type == 5) {
            for (int y=top-1, y1=top; y>=0; y--, y1++) {  // top and bottom
                unsigned char *pSrc = (unsigned char *)(iplPadded->imageData + y1 * iplPadded->widthStep);
                unsigned char *pDst = (unsigned char *)(iplPadded->imageData + y * iplPadded->widthStep);
                for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
                    pDst[x] = pSrc[x]; // padding in top
                }
            }    
            for (int y=iplImage->height+top, y1=iplImage->height+top-1; y<iplImage->height+top+bottom; y++, y1--) {
                unsigned char *pSrc = (unsigned char *)(iplPadded->imageData + y1 * iplPadded->widthStep);
                unsigned char *pDst = (unsigned char *)(iplPadded->imageData + y * iplPadded->widthStep);
                for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
                    pDst[x] = pSrc[x];   // padding in bottom
                }
            }
        }
		//saveImage("_PaddedY.bmp", iplPadded);  // for debug
	} else if (iplImage->depth == SR_DEPTH_32F) {
        float s0=0.0f, s1=0.0f, s2=0.0f;
		// left and right
		for (int y=0; y<iplImage->height; y++) {
			float *pSrc = (float*)(iplImage->imageData + y * iplImage->widthStep);
			float *pDst = (float*)(iplPadded->imageData + (y+top) * iplPadded->widthStep);
            if (type == 5) {
                if (iplImage->nChannels == 1) {
                    for (int x=left-1, x1=0; x>=0; x--, x1++) {
                        pDst[x] = pSrc[x1]; // padding in left
                    }
                } else {
                    for (int x = left-1, x1=0; x>=0; x--,x1++) {
                        pDst[x*3] = pSrc[x1*3];      pDst[x*3+1] = pSrc[x1*3+1];      pDst[x*3+2] = pSrc[x1*3+2];  // padding in left
                    }
                }
                pDst += left * iplImage->nChannels;
                memcpy(pDst, pSrc, iplImage->width*iplImage->nChannels*sizeof(float));
                if (iplImage->nChannels == 1) {
                    for (int x=iplImage->width, x1=iplImage->width-1; x<iplImage->width+right; x++, x1--) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x] = pSrc[x1]; // padding in right
                    }
                } else {
                    for (int x=iplImage->width, x1=iplImage->width-1; x<iplImage->width+right; x++, x1--) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x*3] = pSrc[x1*3];     pDst[x*3+1] = pSrc[x1*3+1];     pDst[x*3+2] = pSrc[x1*3+2]; // padding in right
                    }
                }
            } else {
                if (type == 0 || type == 1 || type == 2) {  // replication
                    s0 = pSrc[0];
                    if (iplImage->nChannels == 3) {
                        s1 = pSrc[1];   s2 = pSrc[2];                    
                    }
                } else if (type == 3) {
                    s0 = 0.0f;
                    if (iplImage->nChannels == 3) {
                        s1 = 0.0f;   s2 = 0.0f;
                    }
                } else if (type == 4) {
                    s0 = 128.0f;
                    if (iplImage->nChannels == 3) {
                        s1 = 128.0f;   s2 = 128.0f;
                    }
                }
                if (iplImage->nChannels == 1) {
                    for (int x=0; x<left; x++) {
                        pDst[x] = s0;
                    }
                } else {
                    for (int x=0; x<left; x++) {
                        pDst[x*3] = s0;     pDst[x*3+1] = s1;   pDst[x*3+2] = s2;
                    }
                }
                pDst += left * iplImage->nChannels;
                memcpy(pDst, pSrc, iplImage->width*iplImage->nChannels*sizeof(float));
                if (type == 0 || type == 1 || type == 2) {  // replication
                    s0 = pSrc[iplImage->width-1];
                    if (iplImage->nChannels == 3) {
                        s1 = pSrc[(iplImage->width-1)*3+1], s2 = pSrc[(iplImage->width-1)*3+2];                   
                    }
                }       // For other types, the pixels have been set
                if (iplImage->nChannels == 1) {
                    for (int x=iplImage->width; x<iplImage->width+right; x++) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x] = s0;
                    }
                } else {
                    for (int x=iplImage->width; x<iplImage->width+right; x++) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x*3] = s0;     pDst[x*3+1] = s1;   pDst[x*3+2] = s2;
                    }
                }
            }
		}
		//saveImage("_PaddedX.bmp", iplPadded);  // for debug
		
		// top and bottom
        if (type == 0) {
		    float *pSrc = (float*)(iplPadded->imageData + top * iplPadded->widthStep);
		    for (int y=0; y<top; y++) {
			    float *pDst = (float*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = pSrc[x];
			    }
		    }
		    pSrc = (float*)(iplPadded->imageData + (iplImage->height + top - 1) * iplPadded->widthStep);
		    for (int y=iplImage->height+top; y<iplImage->height+top+bottom; y++) {
			    float *pDst = (float*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = pSrc[x];
			    }
		    }
        } else if (type == 1 || type == 3) {
            for (int y=0; y<top; y++) {
                float *pDst = (float*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 0.0f;
			    }
            }
            for (int y=iplImage->height+top; y<iplImage->height+top+bottom; y++) {
                float *pDst = (float*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 0.0f;
			    }
            }
        } else if (type == 2 || type == 4) {
            for (int y=0; y<top; y++) {
                float *pDst = (float*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 128.0f;
			    }
            }
            for (int y=iplImage->height+top; y<iplImage->height+top+bottom; y++) {
                float *pDst = (float*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 128.0f;
			    }
            }
        } else if (type == 5) {
            for (int y=top-1, y1=top; y>=0; y--, y1++) {  // top and bottom
                float *pSrc = (float *)(iplPadded->imageData + y1 * iplPadded->widthStep);
                float *pDst = (float *)(iplPadded->imageData + y * iplPadded->widthStep);
                for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
                    pDst[x] = pSrc[x]; // padding in top
                }
            }    
            for (int y=iplImage->height+top, y1=iplImage->height+top-1; y<iplImage->height+top+bottom; y++, y1--) {
                float *pSrc = (float *)(iplPadded->imageData + y1 * iplPadded->widthStep);
                float *pDst = (float *)(iplPadded->imageData + y * iplPadded->widthStep);
                for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
                    pDst[x] = pSrc[x];   // padding in bottom
                }
            }
        }
		//saveImage("_PaddedY.bmp", iplPadded);  // for debug
	} else if (iplImage->depth == SR_DEPTH_32S) {
        int s0=0, s1=0, s2=0;
		// left and right
		for (int y=0; y<iplImage->height; y++) {
			int *pSrc = (int*)(iplImage->imageData + y * iplImage->widthStep);
			int *pDst = (int*)(iplPadded->imageData + (y+top) * iplPadded->widthStep);
            if (type == 5) {
                 if (iplImage->nChannels == 1) {
                    for (int x=left-1, x1=0; x>=0; x--, x1++) {
                        pDst[x] = pSrc[x1]; // padding in left
                    }
                } else {
                    for (int x = left-1, x1=0; x>=0; x--,x1++) {
                        pDst[x*3] = pSrc[x1*3];      pDst[x*3+1] = pSrc[x1*3+1];      pDst[x*3+2] = pSrc[x1*3+2];  // padding in left
                    }
                }
                pDst += left * iplImage->nChannels;
                memcpy(pDst, pSrc, iplImage->width*iplImage->nChannels*sizeof(int));
                if (iplImage->nChannels == 1) {
                    for (int x=iplImage->width, x1=iplImage->width-1; x<iplImage->width+right; x++, x1--) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x] = pSrc[x1]; // padding in right
                    }
                } else {
                    for (int x=iplImage->width, x1=iplImage->width-1; x<iplImage->width+right; x++, x1--) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x*3] = pSrc[x1*3];     pDst[x*3+1] = pSrc[x1*3+1];     pDst[x*3+2] = pSrc[x1*3+2]; // padding in right
                    }
                }
            } else {
                if (type == 0 || type == 1 || type == 2) {  // replication
                    s0 = pSrc[0];
                    if (iplImage->nChannels == 3) {
                        s1 = pSrc[1];   s2 = pSrc[2];                    
                    }
                } else if (type == 3) {
                    s0 = 0;
                    if (iplImage->nChannels == 3) {
                        s1 = 0;   s2 = 0;
                    }
                } else if (type == 4) {
                    s0 = 128;
                    if (iplImage->nChannels == 3) {
                        s1 = 128;   s2 = 128;
                    }
                }
                if (iplImage->nChannels == 1) {
                    for (int x=0; x<left; x++) {
                        pDst[x] = s0;
                    } 
                } else {
                    for (int x=0; x<left; x++) {
                        pDst[x*3] = s0;     pDst[x*3+1] = s1;   pDst[x*3+2] = s2;
                    }
                }
                pDst += left * iplImage->nChannels;
                memcpy(pDst, pSrc, iplImage->width*iplImage->nChannels*sizeof(int));
                if (type == 0 || type == 1 || type == 2) {  // replication
                    s0 = pSrc[iplImage->width-1];
                    if (iplImage->nChannels == 3) {
                        s1 = pSrc[(iplImage->width-1)*3+1], s2 = pSrc[(iplImage->width-1)*3+2];                   
                    }
                }       // For other types, the pixels have been set
                if (iplImage->nChannels == 1) {
                    for (int x=iplImage->width; x<iplImage->width+right; x++) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x] = s0;
                    }
                } else {
                    for (int x=iplImage->width; x<iplImage->width+right; x++) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x*3] = s0;     pDst[x*3+1] = s1;   pDst[x*3+2] = s2;
                    }
                }
            }
		}
		//saveImage("_PaddedX.bmp", iplPadded);  // for debug
		
		// top and bottom
        if (type == 0) {
		    int *pSrc = (int*)(iplPadded->imageData + top * iplPadded->widthStep);
		    for (int y=0; y<top; y++) {
			    int *pDst = (int*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = pSrc[x];
			    }
		    }
		    pSrc = (int*)(iplPadded->imageData + (iplImage->height + top - 1) * iplPadded->widthStep);
		    for (int y=iplImage->height+top; y<iplImage->height+top+bottom; y++) {
			    int *pDst = (int*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = pSrc[x];
			    }
		    }
        } else if (type == 1 || type == 3) {
            for (int y=0; y<top; y++) {
                int *pDst = (int*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 0;
			    }
            }
            for (int y=iplImage->height+top; y<iplImage->height+top+bottom; y++) {
                int *pDst = (int*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 0;
			    }
            }
        } else if (type == 2 || type == 4) {
            for (int y=0; y<top; y++) {
                int *pDst = (int*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 128;
			    }
            }
            for (int y=iplImage->height+top; y<iplImage->height+top+bottom; y++) {
                int *pDst = (int*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 128;
			    }
            }
        } else if (type == 5) { 
            for (int y=top-1, y1=top; y>=0; y--, y1++) {  // top and bottom
                int *pSrc = (int *)(iplPadded->imageData + y1 * iplPadded->widthStep);
                int *pDst = (int *)(iplPadded->imageData + y * iplPadded->widthStep);
                for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
                    pDst[x] = pSrc[x]; // padding in top
                }
            }    
            for (int y=iplImage->height+top, y1=iplImage->height+top-1; y<iplImage->height+top+bottom; y++, y1--) {
                int *pSrc = (int *)(iplPadded->imageData + y1 * iplPadded->widthStep);
                int *pDst = (int *)(iplPadded->imageData + y * iplPadded->widthStep);
                for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
                    pDst[x] = pSrc[x];   // padding in bottom
                }
            }
        } 
		//saveImage("_PaddedY.bmp", iplPadded);  // for debug
	} else if (iplImage->depth == SR_DEPTH_16U) {
        unsigned short s0=0, s1=0, s2=0;
		// left and right
		for (int y=0; y<iplImage->height; y++) {
			unsigned short *pSrc = (unsigned short*)(iplImage->imageData + y * iplImage->widthStep);
			unsigned short *pDst = (unsigned short*)(iplPadded->imageData + (y+top) * iplPadded->widthStep);
            if (type == 5) {
                if (iplImage->nChannels == 1) {
                    for (int x=left-1, x1=0; x>=0; x--, x1++) {
                        pDst[x] = pSrc[x1]; // padding in left
                    }
                } else {
                    for (int x = left-1, x1=0; x>=0; x--,x1++) {
                        pDst[x*3] = pSrc[x1*3];      pDst[x*3+1] = pSrc[x1*3+1];      pDst[x*3+2] = pSrc[x1*3+2];  // padding in left
                    }
                }
                pDst += left * iplImage->nChannels;
                memcpy(pDst, pSrc, iplImage->width*iplImage->nChannels*sizeof(unsigned short));
                if (iplImage->nChannels == 1) {
                    for (int x=iplImage->width, x1=iplImage->width-1; x<iplImage->width+right; x++, x1--) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x] = pSrc[x1]; // padding in right
                    }
                } else {
                    for (int x=iplImage->width, x1=iplImage->width-1; x<iplImage->width+right; x++, x1--) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x*3] = pSrc[x1*3];     pDst[x*3+1] = pSrc[x1*3+1];     pDst[x*3+2] = pSrc[x1*3+2]; // padding in right
                    }
                }
            } else {
                if (type == 0 || type == 1 || type == 2) {  // replication
                    s0 = pSrc[0];
                    if (iplImage->nChannels == 3) {
                        s1 = pSrc[1];   s2 = pSrc[2];                    
                    }
                } else if (type == 3) {
                    s0 = 0;
                    if (iplImage->nChannels == 3) {
                        s1 = 0;   s2 = 0;
                    }
                } else if (type == 4) {
                    s0 = 128;
                    if (iplImage->nChannels == 3) {
                        s1 = 128;   s2 = 128;
                    }
                }
                if (iplImage->nChannels == 1) {
                    for (int x=0; x<left; x++) {
                        pDst[x] = s0;
                    }
                } else {
                    for (int x=0; x<left; x++) {
                        pDst[x*3] = s0;     pDst[x*3+1] = s1;   pDst[x*3+2] = s2;
                    }
                }
                pDst += left * iplImage->nChannels;
                memcpy(pDst, pSrc, iplImage->width*iplImage->nChannels*sizeof(unsigned short));
                if (type == 0 || type == 1 || type == 2) {  // replication
                    s0 = pSrc[iplImage->width-1];
                    if (iplImage->nChannels == 3) {
                        s1 = pSrc[(iplImage->width-1)*3+1], s2 = pSrc[(iplImage->width-1)*3+2];                   
                    }
                }       // For other types, the pixels have been set
                if (iplImage->nChannels == 1) {
                    for (int x=iplImage->width; x<iplImage->width+right; x++) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x] = s0;
                    }
                } else {
                    for (int x=iplImage->width; x<iplImage->width+right; x++) {		// note: pDst has been shifted 'left' pixels!
                        pDst[x*3] = s0;     pDst[x*3+1] = s1;   pDst[x*3+2] = s2;
                    }
                }
            }
		}
		//saveImage("_PaddedX.bmp", iplPadded);  // for debug
		
		// top and bottom
        if (type == 0) {
		    unsigned short *pSrc = (unsigned short*)(iplPadded->imageData + top * iplPadded->widthStep);
		    for (int y=0; y<top; y++) {
			    unsigned short *pDst = (unsigned short*)(iplPadded->imageData + y * iplPadded->widthStep);     // (int *) --> bug fixed, September 12, 2014
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = pSrc[x];
			    }
		    }
		    pSrc = (unsigned short*)(iplPadded->imageData + (iplImage->height + top - 1) * iplPadded->widthStep);
		    for (int y=iplImage->height+top; y<iplImage->height+top+bottom; y++) {
			    unsigned short *pDst = (unsigned short*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = pSrc[x];
			    }
		    }
        } else if (type == 1 || type == 3) {
            for (int y=0; y<top; y++) {
                unsigned short *pDst = (unsigned short*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 0;
			    }
            }
            for (int y=iplImage->height+top; y<iplImage->height+top+bottom; y++) {
                unsigned short *pDst = (unsigned short*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 0;
			    }
            }
        } else if (type == 2 || type == 4) {
            for (int y=0; y<top; y++) {
                unsigned short *pDst = (unsigned short*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 128;
			    }
            }
            for (int y=iplImage->height+top; y<iplImage->height+top+bottom; y++) {
                unsigned short *pDst = (unsigned short*)(iplPadded->imageData + y * iplPadded->widthStep);
			    for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
				    pDst[x] = 128;
			    }
            }
        } else if (type == 5) {
            for (int y=top-1, y1=top; y>=0; y--, y1++) {  // top and bottom
                unsigned short *pSrc = (unsigned short *)(iplPadded->imageData + y1 * iplPadded->widthStep);
                unsigned short *pDst = (unsigned short *)(iplPadded->imageData + y * iplPadded->widthStep);
                for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
                    pDst[x] = pSrc[x]; // padding in top
                }
            }    
            for (int y=iplImage->height+top, y1=iplImage->height+top-1; y<iplImage->height+top+bottom; y++, y1--) {
                unsigned short *pSrc = (unsigned short *)(iplPadded->imageData + y1 * iplPadded->widthStep);
                unsigned short *pDst = (unsigned short *)(iplPadded->imageData + y * iplPadded->widthStep);
                for (int x=0; x<iplPadded->width*iplPadded->nChannels; x++) {
                    pDst[x] = pSrc[x];   // padding in bottom
                }
            }
        }
		//saveImage("_PaddedY.bmp", iplPadded);  // for debug
	} else {
		showErrMsg("Unsupported image data type in CImageUtility::padding()!\n");
		return false;
	}

    return true;
}

IplImage *CImageUtility::padding_R_0(IplImage *iplImage, int left, int right, int top, int bottom)
// padding left and right pixels on the left and right sides of the image
// add top and bottom zeros on the top and bottom sides fo the image
// by Luhong Liang, ICD-ASD, ASTRI
// April 9, 2013
// May 15, 2014: Major modification
{
    return padding(iplImage, left, right, top, bottom, 1);
}

IplImage *CImageUtility::padding_R_128(IplImage *iplImage, int left, int right, int top, int bottom)
// padding left and right pixels on the left and right sides of the image
// add top and bottom 128 on the top and bottom sides fo the image
// by Luhong Liang, ICD-ASD, ASTRI
// May 15, 2014: Major modification
{
    return padding(iplImage, left, right, top, bottom, 2);
}

bool CImageUtility::padding_R_128(IplImage *iplImage, IplImage *iplPadded, int left, int right, int top, int bottom)
// padding left and right pixels on the left and right sides of the image
// add top and bottom 128 on the top and bottom sides fo the image
// by Luhong Liang, ICD-ASD, ASTRI
// April 9, 2013
// May 15, 2014: Major modification
{
    return padding(iplImage, iplPadded, left, right, top, bottom, 2);
}

IplImage *CImageUtility::padding_0_0(IplImage *iplImage, int left, int right, int top, int bottom)
// padding zeros to left, right, top and bottom sides
// by Luhong Liang, ICD-ASD, ASTRI
// May 13, 2013
// May 15, 2014: Major modification
{
    return padding(iplImage, left, right, top, bottom, 3);
}

bool CImageUtility::padding_0_0(IplImage *iplImage, IplImage *iplPadded, int left, int right, int top, int bottom)
// padding zeros to left, right, top and bottom sides
// by Luhong Liang, ICD-ASD, ASTRI
// May 13, 2013
// May 15, 2014: Major modification
{
    return padding(iplImage, iplPadded, left, right, top, bottom, 3);
}

IplImage *CImageUtility::padding_128_128(IplImage *iplImage, int left, int right, int top, int bottom)
// padding 128 to left, right, top and bottom sides
// by Luhong Liang, ICD-ASD, ASTRI
// May 13, 2013
// May 15, 2014: Major modification
{
    return padding(iplImage, left, right, top, bottom, 4);
}

bool CImageUtility::padding_128_128(IplImage *iplImage, IplImage *iplPadded, int left, int right, int top, int bottom)
// padding 128 to left, right, top and bottom sides
// by Luhong Liang, ICD-ASD, ASTRI
// May 13, 2013
// May 15, 2014: Major modification
{
    return padding(iplImage, iplPadded, left, right, top, bottom, 4);
}

IplImage *CImageUtility::unpadding(IplImage *iplImage, int left, int right, int top, int bottom)
// inverse opeartion of padding
{
	if (iplImage == NULL || left < 0 || right < 0 || top < 0 || bottom < 0) {
		showErrMsg("Invalid input argument in CImageUtility::unpadding()!\n");
		return NULL;
	}

	int nTarWidth = iplImage->width - left - right;
	int nTarHeight = iplImage->height - top - bottom;
	if (nTarWidth < 4 || nTarHeight < 4) {
		showErrMsg("The size of the unpadded image is smaller than 4x4 in CImageUtility::unpadding()!\n");
		return false;
	}

	IplImage *iplUnpad = createImage(nTarWidth, nTarHeight, iplImage->depth, iplImage->nChannels);
	if (iplUnpad == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::unpadding()!\n");
		return false;
	}

	if (unpadding(iplImage, iplUnpad, left, top))
		return iplUnpad;
	else
		return NULL;
}

bool CImageUtility::unpadding(IplImage *iplImage, IplImage *iplDstImage, int left, int top)
// crop an image at (left, top)
// September, 2014: add support on multi-channel images
{
	if (iplImage == NULL || left < 0 || top < 0 || iplDstImage == NULL || iplDstImage->nChannels != iplImage->nChannels ||
		left + iplDstImage->width > iplImage->width || top + iplDstImage->height > iplImage->height) {
		showErrMsg("Invalid input image or argument in CImageUtility::unpadding()!\n");
		return false;
	}
	if (iplImage->depth != iplDstImage->depth) {
		showErrMsg("Source and destination images must have the same data type in CImageUtility::unpadding()!\n");
		return false;
	}

	if (iplImage->depth == SR_DEPTH_8U) {
		for (int y=0; y<iplDstImage->height; y++) {
            char *pSrc = (char*)iplImage->imageData + (y+top) * iplImage->widthStep + left*iplImage->nChannels;
			char *pDst = (char*)iplDstImage->imageData + y * iplDstImage->widthStep;
			memcpy(pDst, pSrc, iplDstImage->width*iplImage->nChannels);
		}
		return true;
	} else if (iplImage->depth == SR_DEPTH_32F) {
		for (int y=0; y<iplDstImage->height; y++) {
			float *pSrc = (float *)((char*)iplImage->imageData + (y+top) * iplImage->widthStep) + left*iplImage->nChannels;
			float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
			memcpy(pDst, pSrc, iplDstImage->width*sizeof(float)*iplImage->nChannels);
		}
		return true;
	} else if (iplImage->depth == SR_DEPTH_32S) {
		for (int y=0; y<iplDstImage->height; y++) {
			int *pSrc = (int *)((char*)iplImage->imageData + (y+top) * iplImage->widthStep) + left*iplImage->nChannels;
			int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
			memcpy(pDst, pSrc, iplDstImage->width*sizeof(int)*iplImage->nChannels);
		}
		return true;
	} else {
		showErrMsg("Unsupported image data type in CImageUtility::unpadding()!\n");
		return false;
	}
}

bool CImageUtility::unpadding_8U_10U(IplImage *iplImage, IplImage *iplDstImage, int left, int top)
// crop an image at (left, top)
// NOTE: this is a highly specified function to crop a region from an image with 8-bit data and copy to an image with 10-bit data,
// so there is a 8-bit to 10-bit conversion in this function (by x4)
{
	if (iplImage == NULL || iplImage->nChannels != 1 || left < 0 || top < 0 || iplDstImage == NULL || iplDstImage->nChannels != 1 ||
		left + iplDstImage->width > iplImage->width || top + iplDstImage->height > iplImage->height) {
		showErrMsg("Invalid input image or argument in CImageUtility::unpadding_8U_10U()!\n");
		return false;
	}
	if (iplImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid data depth in CImageUtility::unpadding_8U_10U()!\n");
		return false;
	}

	for (int y=0; y<iplDstImage->height; y++) {
		unsigned char *pSrc = (unsigned char*)iplImage->imageData + (y+top) * iplImage->widthStep + left;
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = ((int)pSrc[x]) << 2;
		}
	}
	return true;
}

bool CImageUtility::detDarkband_8U(IplImage *iplImage, int TH_dark, int TH_contrast, int TH_max_tb, int TH_max_lr, 
                                                         int &top, int &bottom, int &left, int &right, char *szDebugFilePre)
// darkband detection, it detects (top, bottom, left, right) darkband
// Input image has to be 1920x1080, 720x576, 720x480 and only 1 channel Y
// Four threshold input and their default values
// TH_dark = 9'd40 and TH_contrast = 7'47, max allowable top/bottom darkband TH_max_tb = 300, TH_max_lr = 600
// by Tim K. L. Wong, ICD-ASD, ASTRI
// June 12, 2013
// modified by Luhong, July 17, 2013
{       
	int TH_max_tb_upd, TH_max_lr_upd;
	int row, col, sum_row, sum_col;
	int row_avg_div, col_avg_div;

    // check arguments
	if (iplImage == NULL || iplImage->nChannels != 1) {
		showErrMsg("Invalid input image or argument in CImageUtility::detDarkband_8U()!\n");
		return false;
	}

	if (iplImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid data depth in CImageUtility::detDarkband_8U()!\n");
		return false;
	}

    row = iplImage->height;
	col = iplImage->width;

    int *avg_row = new int[row];
    int *avg_col = new int[col];
    if (avg_row == NULL || avg_col == NULL) {
        showErrMsg("Fail to allocate buffer in CImageUtility::detDarkband_8U()!\n");
        if (avg_row != NULL) delete []avg_row;
        if (avg_col != NULL) delete []avg_col;
        return false;
    }
  
    if ((iplImage->width == 1920 && iplImage->height == 1080) ||       // TODO: check the dimension 
        (iplImage->width == 720 && iplImage->height == 576) || 
        (iplImage->width == 720 && iplImage->height == 480)) {
        //
        // for Fixed point implementation in HAST
        //
        col_avg_div = (row == 1080) ? 1024 : 512;               // Set avg row and col Divisor based on image dimension due to easier hardware implementation
        row_avg_div = (col == 1920) ? 2048 : 512;
        TH_max_tb_upd = (TH_max_tb > 300) ? 300 : TH_max_tb;    // Set absolute maximum top/bottom darkband, clip to 300
	    TH_max_lr_upd = (TH_max_lr > 600) ? 600 : TH_max_lr;    // Set absolute maximum left/right darkband, clip to 600
    } else {
        //
        // for other implementations like VEUHD
        //
		//showErrMsg("Invalid image dimension (not 1080p/480p/576p) CImageUtility::detDarkband_8U()!\n");
        col_avg_div = row;                                      // Set avg row and col Divisor based on image dimension due to easier hardware implementation
        row_avg_div = col;
        TH_max_tb_upd = row / 4 - 1;                            // Set absolute maximum top/bottom darkband
	    TH_max_lr_upd = col / 4 - 1;                            // Set absolute maximum left/right darkband
	}


	//Initialize variables
	top = 0;
	bottom = 0;
	left = 0;
	right = 0;

    // Calculate row average
	for (int y=0; y<row; y++) {
		unsigned char *pRowY = (unsigned char*)iplImage->imageData + y * iplImage->widthStep;
		sum_row = 0;
		for (int x=0; x<col; x++) {
            sum_row += pRowY[x];			
		}
		
		avg_row[y] = sum_row / row_avg_div;
		//showErrMsg("Avg row in floating point = %.2f, cast int = %6d", (float) sum_row/row_avg_div ,avg_row[y]);
	}

	// Calculate col average
	for (int x=0; x<col; x++) {
		sum_col = 0;
  	    for (int y=0; y<row; y++) {
		    unsigned char *pRowY = (unsigned char*)iplImage->imageData + y * iplImage->widthStep;
            sum_col += pRowY[x];			
		}
		avg_col[x] = sum_col / col_avg_div;
        //showErrMsg("Avg col in floating point = %.2f, cast int = %d",  (float) sum_col/col_avg_div ,avg_col[x]);
	}

    // XJ on Aug02: for IPU debug
    if (szDebugFilePre != NULL) {
        char szFilename[256];
        // row data file
        sprintf(szFilename, "%s_Darkband_row_avg.txt", szDebugFilePre);   	
        FILE *fid1 = fopen(szFilename, "wt+");
        if (fid1 == NULL) {
            showErrMsg("Fail to open debug data file %s in CImageUtility::detDarkband_8U()!\n", szFilename);
            return false;
        }
        for (int y=0; y<row; y++) {
            fprintf(fid1, "%02x \n", avg_row[y]);     // XJ on Aug02: for IPU debug
        }
        fclose(fid1);
        // column data file
        sprintf(szFilename, "%s_Darkband_col_avg.txt", szDebugFilePre);   	
        FILE *fid2 = fopen(szFilename, "wt+");
        if (fid2 == NULL) {
            showErrMsg("Fail to open debug data file %s in CImageUtility::detDarkband_8U()!\n", szFilename);
            return false;
        }
        for (int x=0; x<col; x++) {
            fprintf(fid2, "%02x \n", avg_col[x]);     // XJ on Aug02: for IPU debug
        }
        fclose(fid2);
    }

	// Calculate top
	for (int n=0; n<TH_max_tb_upd; n++) {
		if ((avg_row[n]<TH_dark) || (avg_row[n+1]-avg_row[n] >= TH_contrast)) {
			top = n + 1;
        } else {
		    break;
        }
	}

	// Calculate bottom
	for (int n=row-1; n>=row-TH_max_tb_upd; n--) {
		if ((avg_row[n]<TH_dark) || (avg_row[n-1]-avg_row[n] >= TH_contrast)) {
			bottom = row - n;
        } else {
		    break;
        }
	}

	// Calculate left
	for (int n=0; n<TH_max_lr_upd; n++) {
		if ((avg_col[n]<TH_dark) || (avg_col[n+1]-avg_col[n] >= TH_contrast)) {
			left = n+1;
        } else {
		    break;
        }
	}

	// Calculate right
	for (int n=col-1; n>=col-TH_max_lr_upd; n--) {
		if ((avg_col[n]<TH_dark) || (avg_col[n-1]-avg_col[n] >= TH_contrast)) {
			right = col-n;
        } else {
			break;
        }
	}

    delete []avg_row;
    delete []avg_col;

	return true;
}

bool CImageUtility::detDarkband_32f(IplImage *iplImage, int TH_dark, int TH_contrast, int TH_max_tb, int TH_max_lr, 
                                                         int &top, int &bottom, int &left, int &right)
// darkband detection, it detects (top, bottom, left, right) darkband
// Input image has to be 1920x1080, 720x576, 720x480 and only 1 channel Y
// Four threshold input and their default values
// TH_dark = 9'd40 and TH_contrast = 7'47, max allowable top/bottom darkband TH_max_tb = 300, TH_max_lr = 600
// by Tim K. L. Wong, ICD-ASD, ASTRI
// June 12, 2013
// modified by Luhong, July 17, 2013, Oct. 2014
{       
    // check arguments
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image or argument in CImageUtility::detDarkband_8U()!\n");
		return false;
	}

    int TH_max_tb_upd, TH_max_lr_upd;
	int row, col;
    float sum_row, sum_col;
	int row_avg_div, col_avg_div;
    row = iplImage->height;
	col = iplImage->width;

    float *avg_row = new float[row];
    float *avg_col = new float[col];
    if (avg_row == NULL || avg_col == NULL) {
        showErrMsg("Fail to allocate buffer in CImageUtility::detDarkband_32f()!\n");
        if (avg_row != NULL) delete []avg_row;
        if (avg_col != NULL) delete []avg_col;
        return false;
    }
  
    if ((iplImage->width == 1920 && iplImage->height == 1080) ||       // TODO: check the dimension 
        (iplImage->width == 720 && iplImage->height == 576) || 
        (iplImage->width == 720 && iplImage->height == 480)) {
        //
        // for Fixed point implementation in HAST
        //
        col_avg_div = (row == 1080) ? 1024 : 512;               // Set avg row and col Divisor based on image dimension due to easier hardware implementation
        row_avg_div = (col == 1920) ? 2048 : 512;
        TH_max_tb_upd = (TH_max_tb > 300) ? 300 : TH_max_tb;    // Set absolute maximum top/bottom darkband, clip to 300
	    TH_max_lr_upd = (TH_max_lr > 600) ? 600 : TH_max_lr;    // Set absolute maximum left/right darkband, clip to 600
    } else {
        //
        // for other implementations like VEUHD
        //
		//showErrMsg("Invalid image dimension (not 1080p/480p/576p) CImageUtility::detDarkband_8U()!\n");
        col_avg_div = row;                                      // Set avg row and col Divisor based on image dimension due to easier hardware implementation
        row_avg_div = col;
        TH_max_tb_upd = row / 4 - 1;                            // Set absolute maximum top/bottom darkband
	    TH_max_lr_upd = col / 4 - 1;                            // Set absolute maximum left/right darkband
	}


	//Initialize variables
	top = 0;
	bottom = 0;
	left = 0;
	right = 0;

    // Calculate row average
	for (int y=0; y<row; y++) {
		float *pRowY = (float*)(iplImage->imageData + y * iplImage->widthStep);
		sum_row = 0;
		for (int x=0; x<col; x++) {
            sum_row += pRowY[x];			
		}
		
		avg_row[y] = sum_row / row_avg_div;
		//showErrMsg("Avg row in floating point = %.2f, cast int = %6d", (float) sum_row/row_avg_div ,avg_row[y]);
	}

	// Calculate col average
	for (int x=0; x<col; x++) {
		sum_col = 0;
  	    for (int y=0; y<row; y++) {
		    float *pRowY = (float*)(iplImage->imageData + y * iplImage->widthStep);
            sum_col += pRowY[x];			
		}
		avg_col[x] = sum_col / col_avg_div;
        //showErrMsg("Avg col in floating point = %.2f, cast int = %d",  (float) sum_col/col_avg_div ,avg_col[x]);
	}

	// Calculate top
	for (int n=0; n<TH_max_tb_upd; n++) {
		if ((avg_row[n]<TH_dark) || (avg_row[n+1]-avg_row[n] >= TH_contrast)) {
			top = n + 1;
        } else {
		    break;
        }
	}

	// Calculate bottom
	for (int n=row-1; n>=row-TH_max_tb_upd; n--) {
		if ((avg_row[n]<TH_dark) || (avg_row[n-1]-avg_row[n] >= TH_contrast)) {
			bottom = row - n;
        } else {
		    break;
        }
	}

	// Calculate left
	for (int n=0; n<TH_max_lr_upd; n++) {
		if ((avg_col[n]<TH_dark) || (avg_col[n+1]-avg_col[n] >= TH_contrast)) {
			left = n+1;
        } else {
		    break;
        }
	}

	// Calculate right
	for (int n=col-1; n>=col-TH_max_lr_upd; n--) {
		if ((avg_col[n]<TH_dark) || (avg_col[n-1]-avg_col[n] >= TH_contrast)) {
			right = col-n;
        } else {
			break;
        }
	}

    delete []avg_row;
    delete []avg_col;

	return true;
}

bool CImageUtility::fetchBlock(IplImage *iplImage, IplImage *iplBlock, int x, int y)
{
	if (iplImage == NULL || iplBlock == NULL || x < 0 || y < 0) {
		showErrMsg("Invalid input image or argument in CImageUtility::fetchBlock()!"); 
		return false;
	}

	if (iplImage->nChannels != 1 || iplBlock->nChannels !=1) {
		showErrMsg("Only support 1-channel image in CImageUtility::fetchBlock()!"); 
		return false;
	}

	int right = x + iplBlock->width;
	right = right < iplImage->width ? right : iplImage->width;
	int bottom = y + iplBlock->height;
	bottom = bottom < iplImage->height ? bottom : iplImage->height;

	if (right < 1 || bottom < 1) {
		showErrMsg("ROI is out of the source image in CImageUtility::fetchBlock()!"); 
		return false;
	}

	if (iplImage->depth == SR_DEPTH_32F) {
		if (iplBlock->depth != SR_DEPTH_32F) {
			showErrMsg("Data types in source and destination image do not match in CImageUtility::fetchBlock()!"); 
			return false;
		}
		// copy data
		for (int ys=y, yd=0; ys<bottom; ys++, yd++) {
			float *pSrc = (float *)((char *)iplImage->imageData + ys * iplImage->widthStep);
			float *pDst = (float *)((char *)iplBlock->imageData + yd * iplBlock->widthStep);
			for (int xs=x, xd=0; xs<right; xs++, xd++) {
				pDst[xd] = pSrc[xs];
			}
		}
	} else {
		showErrMsg("Unsupported image data type in CImageUtility::fetchBlock()!"); 
		return false;
	}

	return true;
}

IplImage *CImageUtility::synGaussNoise_32f(int width, int height, float var, int seed)
// Create a gassian noise image with variance of 'var'
// This function use the Box-Muller transform to convert a random uniform distribution to normal distribution
{
	IplImage *iplImage = createImage(width, height, SR_DEPTH_32F, 1);
	if (iplImage == NULL) {
		showErrMsg("Fail to allocate image buffer in CImageUtility::synGaussNoise_32f()!\n");
		return false;
	}

	synGaussNoise_32f(iplImage, var, seed);

	return iplImage;
}

bool CImageUtility::synGaussNoise_32f(IplImage *iplImage, float var, int seed)
// Create a gassian noise image with variance of 'var'
// This function use the Box-Muller transform to convert a random uniform distribution to normal distribution
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid image format in CImageUtility::synGaussNoise_32f()!\n");
		return false;
	}

	srand(seed);		// srand(time(NULL));
	for (int y=0; y<iplImage->height; y++) {
		float *pImg = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
		for (int x=0; x<iplImage->width; x++) {
            //if (x==139 && y == 1)
            //    int p = 0;
			float u1 = (float)( (rand() % 1024) + 1 ) / 1024.0f;
            float u2 = (float)( (rand() % 1024) + 1 ) / 1024.0f;
			float z0 = sqrt( - 2.0f * log(u1) ) * cos (2.0f * 3.1415927f * u2);
			pImg[x] = z0 * var;
		}
	}

	return true;
}

bool CImageUtility::visWeight(char stFilename[], IplImage *iplWeight, float fFactor, IplImage *iplLabel, int bit_depth)
// Visualize a weight image where each pixel has a label indicating the its class
// arguments:
//			stFilename -- [I] image file name
//			iplWeight -- [I] a 32-bit floating point image; NOTE: data will be changed in this function!
//			fFactor -- [I] factor to normalize the weight to 0~255 for visualization
//							factor < 0 means using max(iplWeight)/255 as factor
//			iplLabel -- [I] label image where
//							0 -- visualize in grey; 1 -- blue; 2 -- green; 3 -- red
//							NULL for not showing labels
//			bit_depth -- [I] indicates the bit_depth when the image is 32S
// Luhong Liang, IC-ASD, ASTRI
// Jan. 27, 2012
// Major modification: Jan. 7, 2013 (added support on 32S)
{
	if (iplWeight == NULL || stFilename == NULL || ((iplWeight->depth != SR_DEPTH_32F) && (iplWeight->depth != SR_DEPTH_32S))) {
		showErrMsg("Invalid input argument in visWeight()!\n");
		return false;
	}

	if (iplWeight->depth == SR_DEPTH_32F) {
		// get factor
		if (fFactor < 0.0f) {
			float max_weight = -FLT_MAX;
			for (int y=0; y<iplWeight->height; y++) {
				float *pWeight = (float *)(iplWeight->imageData + y * iplWeight->widthStep);
				for (int x=0; x<iplWeight->width; x++) {
					if (pWeight[x] > max_weight)
						max_weight = pWeight[x];
				}
			}
			fFactor = max_weight > 0.0f ? 255.0f / max_weight : 1.0f;
		}

		// save weigth image only
		if (iplLabel == NULL) {
			mulImage_32f(iplWeight, fFactor);
			IplImage *iplImage8U = cvtImage32Fto8U(iplWeight, 0);
			if (iplImage8U == NULL)
				return false;
			saveImage8U(stFilename, iplImage8U);
			releaseImage(&iplImage8U);
			return true;
		} 

		if (iplWeight->width != iplLabel->width || iplWeight->height != iplLabel->height || iplLabel->nChannels != 1) {
			showErrMsg("Invalid label image in visWeight()!\n");
			return false;
		}

		// save weight with colorful class label
		mulImage_32f(iplWeight, fFactor);
		IplImage *iplImage8U = cvtImage32Fto8U(iplWeight, 0);
		if (iplImage8U == NULL) {
			showErrMsg("Fail to allocate image buffer in visWeight()!\n");
			return false;
		}
		IplImage *iplColor = createImage( iplLabel->width, iplLabel->height, SR_DEPTH_8U, 3);
		if (iplColor == NULL) {
			releaseImage(&iplImage8U);
			showErrMsg("Fail to allocate image buffer in visWeight()!\n");
			return false;
		}

		// visualize class
		setZero(iplColor);
		for (int y=0; y<iplColor->height; y++) {
			unsigned char *pWeight = (unsigned char *)(iplImage8U->imageData + y * iplImage8U->widthStep);
			unsigned char *pColor = (unsigned char *)(iplColor->imageData + y * iplColor->widthStep);
			unsigned char *pLabel = (unsigned char *)(iplLabel->imageData + y * iplLabel->widthStep);
			for (int x=0; x<iplColor->width; x++) {
				int index = x * 3;
				if (pLabel[x] == 1) 
					pColor[index] = pWeight[x];	// B
				else if (pLabel[x] == 2)
					pColor[index+1] = pWeight[x];	// G
				else if (pLabel[x] == 3)
					pColor[index+2] = pWeight[x];	// G
				else {
					pColor[index] = pWeight[x];	// grey
					pColor[index+1] = pWeight[x];
					pColor[index+2] = pWeight[x];
				}
			}
		}

		saveImage8U(stFilename, iplColor);
		releaseImage(&iplImage8U);
		releaseImage(&iplColor);
	} else if (iplWeight->depth == SR_DEPTH_32S) {
		// get factor
		if (fFactor < 0.0f) {
			int max_weight = -65535;
			int max_x = 0, max_y = 0;
			for (int y=0; y<iplWeight->height; y++) {
				int *pWeight = (int *)(iplWeight->imageData + y * iplWeight->widthStep);
				for (int x=0; x<iplWeight->width; x++) {
					if (pWeight[x] > max_weight) {
						max_weight = pWeight[x];
						max_x = x;
						max_y = y;
					}
				}
			}
			int max_intensity = 256;
			max_intensity = max_intensity << (bit_depth - 8);
			fFactor = max_weight > 0 ? (float)(max_intensity - 1) / (float)max_weight : 1.0f;
		}

		// save weigth image only
		if (iplLabel == NULL) {
			IplImage *iplImage8U = cvtImageIntto8U(iplWeight, bit_depth, 0, fFactor);
			if (iplImage8U == NULL)
				return false;
			saveImage8U(stFilename, iplImage8U);
			releaseImage(&iplImage8U);
			return true;
		} 

		if (iplWeight->width != iplLabel->width || iplWeight->height != iplLabel->height || iplLabel->nChannels != 1) {
			showErrMsg("Invalid label image in visWeight()!\n");
			return false;
		}

		// save weight with colorful class label
		IplImage *iplImage8U = cvtImageIntto8U(iplWeight, bit_depth, 0, fFactor);
		if (iplImage8U == NULL) {
			showErrMsg("Fail to allocate image buffer in visWeight()!\n");
			return false;
		}
		IplImage *iplColor = createImage( iplLabel->width, iplLabel->height, SR_DEPTH_8U, 3);
		if (iplColor == NULL) {
			releaseImage(&iplImage8U);
			showErrMsg("Fail to allocate image buffer in visWeight()!\n");
			return false;
		}

		// visualize class
		setZero(iplColor);
		for (int y=0; y<iplColor->height; y++) {
			unsigned char *pWeight = (unsigned char *)(iplImage8U->imageData + y * iplImage8U->widthStep);
			unsigned char *pColor = (unsigned char *)(iplColor->imageData + y * iplColor->widthStep);
			unsigned char *pLabel = (unsigned char *)(iplLabel->imageData + y * iplLabel->widthStep);
			for (int x=0; x<iplColor->width; x++) {
				int index = x * 3;
				if (pLabel[x] == 1) 
					pColor[index] = pWeight[x];	// B
				else if (pLabel[x] == 2)
					pColor[index+1] = pWeight[x];	// G
				else if (pLabel[x] == 3)
					pColor[index+2] = pWeight[x];	// G
				else {
					pColor[index] = pWeight[x];	// grey
					pColor[index+1] = pWeight[x];
					pColor[index+2] = pWeight[x];
				}
			}
		}

		saveImage8U(stFilename, iplColor);
		releaseImage(&iplImage8U);
		releaseImage(&iplColor);
	}

	return true;
}

bool CImageUtility::visWeightSum(char stFilename[], IplImage *iplSum, IplImage *iplWeight, int bit_depth)
// Visualize the weighted sum image, where each pixel is the division of the sum and the weight
// arguments:
//			stFilename -- [I] image file name
//			iplSum -- [I] a 32-bit floating point image for the summed image, must be 1-channel
//			iplWeight -- [I] a 32-bit floating point image for weight, must be 1-channel
//			bit_depth -- [I] indicates the bit_depth when the image is 32S
// Luhong Liang, IC-ASD, ASTRI
// Oct. 15, 2012
// Major modification: Jan. 7, 2013 (added support on 32S)
{
	if (stFilename == NULL || iplWeight == NULL ||  ((iplWeight->depth != SR_DEPTH_32F) && (iplWeight->depth != SR_DEPTH_32S)) || 
		iplWeight->nChannels != 1 || iplSum == NULL || ((iplSum->depth != SR_DEPTH_32F) && (iplSum->depth != SR_DEPTH_32S)) || 
		iplSum->nChannels != 1 || iplWeight->width != iplSum->width || iplWeight->height != iplSum->height) {
		showErrMsg("Invalid input argument in visWeightSum()!\n");
		return false;
	}

	// create image for normalized image
	IplImage *iplNorm = createImage( iplSum->width, iplSum->height, iplSum->depth, iplSum->nChannels);
	if (iplNorm == NULL) {
		showErrMsg("Fail to allocate buffer in visWeightSum()!\n");
		return false;
	}

	// normalize
	if (iplWeight->depth == SR_DEPTH_32F) {
		for (int y=0; y<iplNorm->height; y++) {
			float *pNorm = (float *)((char *)iplNorm->imageData + y * iplWeight->widthStep);
			float *pSum = (float *)((char *)iplSum->imageData + y * iplWeight->widthStep);
			float *pWeight = (float *)((char *)iplWeight->imageData + y * iplWeight->widthStep);
			for (int x=0; x<iplNorm->width; x++) {
				float weight = pWeight[x];
				if (weight <= 0.0f) 
					pNorm[x] = 0.0f;
				else
					pNorm[x] = pSum[x] / weight;
			}
		}
	} else if  (iplWeight->depth == SR_DEPTH_32S) {
		for (int y=0; y<iplNorm->height; y++) {
			unsigned int *pNorm = (unsigned int *)((char *)iplNorm->imageData + y * iplWeight->widthStep);
			unsigned int *pSum = (unsigned int *)((char *)iplSum->imageData + y * iplWeight->widthStep);
			int *pWeight = (int *)((char *)iplWeight->imageData + y * iplWeight->widthStep);
			for (int x=0; x<iplNorm->width; x++) {
				int weight = pWeight[x];
				if (weight <= 0) 
					pNorm[x] = 0;
				else
					pNorm[x] = pSum[x] / (unsigned int)weight;
			}
		}
	}
	
	// save image
	saveImage(stFilename, iplNorm, 0, 1.0f, bit_depth);
	
	safeReleaseImage(&iplNorm);

	return true;
}

bool CImageUtility::visIntRecImage(char stFilename[], IplImage *iplBuild, IplImage *iplWeight)
// Show the intermediate reconstruction image (blending result)
{
	if (iplBuild == NULL || iplWeight == NULL || stFilename == NULL || 
		iplBuild->depth != SR_DEPTH_32F || iplWeight->depth != SR_DEPTH_32F || iplBuild->nChannels != 1 ||
		iplBuild->width != iplWeight->width || iplBuild->height != iplWeight->height || iplBuild->nChannels != iplWeight->nChannels) {
		showErrMsg("Invalid input argument in visIntRecImage()!\n");
		return false;
	}
	
	IplImage *iplVis = createImage( iplBuild->width, iplBuild->height, SR_DEPTH_32F, 1);
	if (iplVis == NULL) {
		showErrMsg("Fail to allocate temp image in visIntRecImage()!\n");
		return false;
	}

	for (int row=0; row<iplBuild->height; row++) {	
		float *pWeight = (float *)((char *)iplWeight->imageData + row * iplWeight->widthStep);
		float *pBuild = (float *)((char *)iplBuild->imageData + row * iplBuild->widthStep);
		float *pVis = (float *)((char *)iplVis->imageData + row * iplVis->widthStep);
		for (int col=0; col<iplBuild->width; col++) {   
			float fW = pWeight[col];
			float fB = pBuild[col];
			if (fW > 0.0f) {
				pVis[col] = fB / fW;
			} else {
				pVis[col] = 0.0f;
			}
		}
	}

	IplImage *iplImage8U = cvtImage32Fto8U(iplVis, 0);
	releaseImage(&iplVis);
	if (iplImage8U == NULL) return false;

	saveImage8U(stFilename, iplImage8U);
	releaseImage(&iplImage8U);

	return true;
}

bool CImageUtility::visPatch(char stFilename[], float *pfPatch, int width, int height, int scale)
// Show the intermediate reconstruction image (blending result)
{
	if (pfPatch == NULL || width < 4 || height < 4 || scale < 1) {
		showErrMsg("Invalid input argument in visPatch()!\n");
		return false;
	}
	
	IplImage *iplVis0 = createImage( width, height, SR_DEPTH_32F, 1);
	IplImage *iplVis1 = createImage( width*scale, height*scale, SR_DEPTH_32F, 1);
	if (iplVis0 == NULL || iplVis1 == NULL) {
		showErrMsg("Fail to allocate temp image in visPatch()!\n");
		safeReleaseImage(&iplVis0, &iplVis1);
		return false;
	}

	// build image
	for (int row=0; row<iplVis0->height; row++) {	
		float *pVis0 = (float *)((char *)iplVis0->imageData + row * iplVis0->widthStep);
		float *pPat = pfPatch + row * width;
		for (int col=0; col<iplVis0->width; col++) {   
			pVis0[col] = pPat[col];
		}
	}

	// resize
	resize(iplVis0, iplVis1, SR_INTER_NN);

	// save
	IplImage *iplImage8U = cvtImage32Fto8U(iplVis1, 0);
	safeReleaseImage(&iplVis0, &iplVis1);
	if (iplImage8U == NULL) return false;

	saveImage8U(stFilename, iplImage8U);
	safeReleaseImage(&iplImage8U);

	return true;
}

bool CImageUtility::cmpImages(IplImage *iplImage1, IplImage *iplImage2, int max_error, float flt_th,
							  int top, int bottom, int left, int right)
// compare two images in a pixel-to-pixel manner
// max_error -- maximum nubmer of errors reported
// flt_th -- threshold to report error when the input is floating point
// top, bottom, left, right -- invalid lines/columns (not compare) in each direction
{
	// check image
	if (iplImage1 == NULL || iplImage2 == 0) {
		showErrMsg("Invalid input image in CImageUtility::cmpImage()!\n");
		return false;
	}

	if (iplImage1->width != iplImage2->width || iplImage1->height != iplImage2->height) {
		showErrMsg("The two input images are of different sizes in CImageUtility::cmpImage()!\n");
		return false;
	}

	if (iplImage1->depth != iplImage2->depth || iplImage1->nChannels != iplImage2->nChannels) {
		showErrMsg("The two input images are of different channels or bit-depths in CImageUtility::cmpImage()!\n");
		return false;
	}

	if (iplImage1->depth != SR_DEPTH_8U && iplImage1->depth != SR_DEPTH_32S && iplImage1->depth != SR_DEPTH_32F) {
		showErrMsg("Only support comparison of 8U, 32F and 32S images in CImageUtility::cmpImage()!\n");
		return false;
	}

	if (flt_th < 0.0f) {
		showErrMsg("Error threshold for floating point numbers must be positive in CImageUtility::cmpImage()!\n");
		return false;
	}

	// compare
	int err_count = 0;

	if (iplImage1->depth == SR_DEPTH_8U) {		// 8U
		for (int y=top; y<iplImage2->height-bottom; y++) {
			unsigned char *pImg1 = (unsigned char *)iplImage1->imageData + y * iplImage1->widthStep;
			unsigned char *pImg2 = (unsigned char *)iplImage2->imageData + y * iplImage2->widthStep;
			for (int x=left; x<iplImage2->width-right; x++) {
				for (int c=0; c<iplImage2->nChannels; c++) {
					int index = x * iplImage2->nChannels + c;
					if (pImg1[index] != pImg2[index]) {
						if (err_count < max_error) {
							showMessage("Mismatch at <%d, %d>\t\t Image1  %d <----> %d Image2\n", x, y, pImg1[index], pImg2[index]);
						}
						err_count ++;
					}
				}
			}
		}
	} else if (iplImage1->depth == SR_DEPTH_32S) {		// 32S
		for (int y=top; y<iplImage2->height-bottom; y++) {
			int *pImg1 = (int *)((char *)iplImage1->imageData + y * iplImage1->widthStep);
			int *pImg2 = (int *)((char *)iplImage2->imageData + y * iplImage2->widthStep);
			for (int x=left; x<iplImage2->width-right; x++) {
				for (int c=0; c<iplImage2->nChannels; c++) {
					int index = x * iplImage2->nChannels + c;
					if (pImg1[index] != pImg2[index]) {
						if (err_count < max_error) {
							showMessage("Mismatch at <%d, %d>\t\t Image1  %d <----> %d Image2\n", x, y, pImg1[index], pImg2[index]);
						}
						err_count ++;
					}
				}
			}
		}
	}
	else if (iplImage1->depth == SR_DEPTH_32F) {		// 32F
		for (int y=top; y<iplImage2->height-bottom; y++) {
			float *pImg1 = (float *)((char *)iplImage1->imageData + y * iplImage1->widthStep);
			float *pImg2 = (float *)((char *)iplImage2->imageData + y * iplImage2->widthStep);
			for (int x=left; x<iplImage2->width-right; x++) {
				for (int c=0; c<iplImage2->nChannels; c++) {
					int index = x * iplImage2->nChannels + c;
					if (fabs(pImg1[index] - pImg2[index]) > flt_th) {
						if (err_count < max_error) {
							showMessage("Mismatch at <%d, %d>\t\t Image1  %f <----> %f Image2\n", x, y, pImg1[index], pImg2[index]);
						}
						err_count ++;
					}
				}
			}
		}
	}

	int width = iplImage2->width - left - right;
	int height = iplImage2->height - top - bottom;
	if (err_count > 0) {
		showMessage("%d mismatches found from %d pixels (%dx%d)!\n", err_count, width*height, width, height);
		return false;
	} else {
		showMessage("The two images (%dx%d, %d pixels) are exactly the same!\n", width, height, width*height);
		return true;
	}

}

float CImageUtility::getImagePixel(IplImage *iplImage, int x, int y)
{
	if (iplImage == NULL || iplImage->nChannels != 1 || x < 0 || y < 0 || x >= iplImage->width || y >= iplImage->height) {
		showErrMsg("Invalid input image or coordinate in CImageUtility::getImagePixel()!\n");
		return -FLT_MAX;
	}

	if (iplImage->depth == SR_DEPTH_8U) {
		unsigned char *pImg = (unsigned char *)(iplImage->imageData + y * iplImage->widthStep);
		return (float)pImg[x];
	} else if (iplImage->depth == SR_DEPTH_32F) {
		float *pImg = (float *)(iplImage->imageData + y * iplImage->widthStep);
		return pImg[x];
	} else if (iplImage->depth == SR_DEPTH_32S) {
		int *pImg = (int *)(iplImage->imageData + y * iplImage->widthStep);
		return (float)pImg[x];
	} else {
		showErrMsg("Unsuported image data type in CImageUtility::getImagePixel()!\n");
		return -FLT_MAX;
	}
}

bool CImageUtility::usm_linear_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float lamda)
// Linear Unsharp Masking (L-USM) for image sharpening (Laplacian correction term).
// This function supports in-place operation.
// Arguments:
//  iplSrcImage -- [I] Input image
//  iplDstImage -- [O] resultant image
//  lamda -- [I] sharpening strength factor
// by Luhong Liang, IC-ASD, ASTRI
// Jan. 15, 2014
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::usm_linear_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplPadded = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::usm_linear_32f()!\n");
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		float *pSrc0 = (float *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		float *pSrc1 = (float *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		float *pSrc2 = (float *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            // Laplacian correction operator
            float z_xy = 4.0f * pSrc1[x+1] - pSrc1[x] - pSrc1[x+2] - pSrc0[x+1] - pSrc2[x+1];
            // enhancement
            pDst[x] = pSrc1[x+1] + lamda * z_xy;
		}
	}

    safeReleaseImage(&iplPadded);

	return true;
}

bool CImageUtility::usm_cubic_32f(IplImage *iplSrcImage, IplImage *iplDstImage, int type, float lamda)
// Cubic Unsharp Masking (CUM) for image sharpening. This function is an implementation of algorithm 
// "A Cubic Unsharp Masking Technique for Contrast Enhancement" (Giovanni Ramponi, 1998)
// This function supports in-place operation.
// Arguments:
//  iplSrcImage -- [I] Input image
//  iplDstImage -- [O] resultant image
//  type -- type of the USM: 1 -- "separable" (S-CUM), 2 -- "nonseparable" (NS-CUM), 3 -- hybrid (SNS-CUM)
//  lamda -- [I] sharpening strength factor
// by Luhong Liang, IC-ASD, ASTRI
// Jan. 15, 2014
// Feb. 24, 2015 (align the effects to linear USM)
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::usm_cubic_32f()!\n");
		return false;
	}

    const float lamda_factor = 0.0025f;
    lamda = lamda * lamda_factor;       // adjust lamda to align the effects to linear USM

	// padding
	IplImage *iplPadded = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::usm_cubic_32f()!\n");
		return false;
	}

    if (type == 1) {
	    // "separable" CUM
	    for (int y=0; y<iplDstImage->height; y++) {
		    float *pSrc0 = (float *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		    float *pSrc1 = (float *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		    float *pSrc2 = (float *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
		    float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		    for (int x=0; x<iplDstImage->width; x++) {
                // Laplacian correction operators in X and Y directions
                float c_x = pSrc1[x] - pSrc1[x+2];
                float z_x = c_x * c_x * ( 2.0f * pSrc1[x+1] - pSrc1[x] - pSrc1[x+2] );
                float c_y = pSrc0[x+1] - pSrc2[x+1];
                float z_y = c_y * c_y * ( 2.0f * pSrc1[x+1] - pSrc0[x+1] - pSrc2[x+1] );
                float z_xy = z_x + z_y;
                // enhancement
                pDst[x] = pSrc1[x+1] + lamda * z_xy;
		    }
	    }
    } else if (type == 2) {
	    // "nonseparable" CUM
	    for (int y=0; y<iplDstImage->height; y++) {
		    float *pSrc0 = (float *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		    float *pSrc1 = (float *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		    float *pSrc2 = (float *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
		    float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		    for (int x=0; x<iplDstImage->width; x++) {
                // Laplacian correction operators in X and Y directions
                float c_xy = pSrc1[x] + pSrc1[x+2] - pSrc0[x+1] - pSrc2[x+1];
                float z_xy = c_xy * c_xy * ( 4.0f * pSrc1[x+1] - pSrc0[x+1] - pSrc2[x+1] - pSrc1[x] - pSrc1[x+2] );
                // enhancement
                pDst[x] = pSrc1[x+1] + lamda * z_xy;
		    }
	    }
    } else if (type == 3) {
        // SNSC-USM
	    for (int y=0; y<iplDstImage->height; y++) {
		    float *pSrc0 = (float *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		    float *pSrc1 = (float *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		    float *pSrc2 = (float *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
		    float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		    for (int x=0; x<iplDstImage->width; x++) {
                // Separable Laplacian correction operator
                float c_x = pSrc1[x] - pSrc1[x+2];
                float z_x = c_x * c_x * ( 2.0f * pSrc1[x+1] - pSrc1[x] - pSrc1[x+2] );
                float c_y = pSrc0[x+1] - pSrc2[x+1];
                float z_y = c_y * c_y * ( 2.0f * pSrc1[x+1] - pSrc0[x+1] - pSrc2[x+1] );
                float z_xy_s = z_x + z_y;
                // Nonseparable Laplacian correction operator
                float c_xy = pSrc1[x] + pSrc1[x+2] - pSrc0[x+1] - pSrc2[x+1];
                float z_xy_ns = c_xy * c_xy * ( 4.0f * pSrc1[x+1] - pSrc0[x+1] - pSrc2[x+1] - pSrc1[x] - pSrc1[x+2] );
                // enhancement
                pDst[x] = pSrc1[x+1] + lamda * (z_xy_s + z_xy_ns) * 0.5f;
		    }
	    }
    } else {
        showErrMsg("Invalid CUM type in CImageUtility::usm_cubic_32f()!\n");
        safeReleaseImage(&iplPadded);
        return false;
    }

    safeReleaseImage(&iplPadded);

	return true;
}

bool CImageUtility::usm_rational_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float lamda, float g0)
// Rational Unsharp Masking (R-USM) for image sharpening. This function is an implementation of algorithm 
// "A Rational Unsharp Masking Technique" (Giovanni Ramponi abd Abdrea Polesel, 1997)
// This function supports in-place operation.
// Arguments:
//  iplSrcImage -- [I] Input image
//  iplDstImage -- [O] resultant image
//  lamda -- [I] sharpening strength factor
//  g0 -- [I] g0 parameter to determine the rational control function
// by Luhong Liang, IC-ASD, ASTRI
// Jan. 15, 2014
// Mar. 10, 2015 (added a clipping threshold)
{
	if (g0 <= 0.0f || iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::usm_cubic_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplPadded = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::usm_cubic_32f()!\n");
		return false;
	}

    // calculate k and h
    float h = 0.5f * g0;
    float k = 0.5f / g0;
    const float clipping = 32.0f;
    const float clip_atten = 0.125f;

    // enhancement
    for (int y=0; y<iplDstImage->height; y++) {
        float *pSrc0 = (float *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
        float *pSrc1 = (float *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
        float *pSrc2 = (float *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
        float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            // Laplacian correction operators in X and Y directions
            float c_x = pSrc1[x] - pSrc1[x+2];
            float g_x = c_x * c_x;
            float cn_x = g_x / ( k * g_x * g_x + h );
            float z_x = 2.0f * pSrc1[x+1] - pSrc1[x] - pSrc1[x+2];

            float c_y = pSrc0[x+1] - pSrc2[x+1];
            float g_y = c_y * c_y;
            float cn_y = g_y / ( k * g_y * g_y + h );
            float z_y = 2.0f * pSrc1[x+1] - pSrc0[x+1] - pSrc2[x+1];

            // enhancement
            float enh = lamda * ( cn_x * z_x + cn_y * z_y );
            if (enh > clipping) {
                enh = (enh - clipping) * clip_atten + clipping;
            } else if (enh < -clipping) {
                enh = - ((-enh - clipping) * clip_atten + clipping);
            }
            pDst[x] = pSrc1[x+1] + enh;
        }
    }

    safeReleaseImage(&iplPadded);
    
    return true;
}

bool CImageUtility::sharpen_lap8_8U(IplImage *iplSrcImage, IplImage *iplDstImage, int strength)
// image sharpening by Lapace 8 filter
// strength -- the presentage of the strength
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U ||
        strength < 0 || strength > 100) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::sharpen_8U()!\n");
		return false;
	}

    if (strength == 0) {
        copy(iplSrcImage, iplDstImage);
        return true;
    }

    IplImage *iplPadded = padding(iplSrcImage, 1, 1, 1, 1);
    if (iplPadded == NULL) return false;

    const int pLut[] = { 12800, 6400, 4267, 3200, 2560, 2133, 1829, 1600, 1422, 1280, 1164, 1067, 985, 914, 853, 800, 753, 711, 674, 640, 610, 582, 557, 533, 512,
                                  492, 474, 457, 441, 427, 413, 400, 388, 376, 366, 356, 346, 337, 328, 320, 312, 305, 298, 291, 284, 278, 272, 267, 261, 256,
                                  251, 246, 242, 237, 233, 229, 225, 221, 217, 213, 210, 206, 203, 200, 197, 194, 191, 188, 186, 183, 180, 178, 175, 173, 171,
                                  168, 166, 164, 162, 160, 158, 156, 154, 152, 151, 149, 147, 145, 144, 142, 141, 139, 138, 136, 135, 133, 132, 131, 129, 128 };
    int factor = pLut[100-strength];

    for (int y=0; y<iplDstImage->height; y++) {
        unsigned char *pSrc0 = (unsigned char *)(iplPadded->imageData + y * iplPadded->widthStep);
        unsigned char *pSrc1 = (unsigned char *)(iplPadded->imageData + (y+1) * iplPadded->widthStep);
        unsigned char *pSrc2 = (unsigned char *)(iplPadded->imageData + (y+2) * iplPadded->widthStep);
        unsigned char *pDst = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            int pixel = ( ((pSrc1[x+1] * factor) << 3) - 
                              (factor - 128) * (pSrc0[x] + pSrc0[x+1] + pSrc0[x+2] + pSrc1[x] +pSrc1[x+2] + pSrc2[x] + pSrc2[x+1] + pSrc2[x+2]) ) >> 9;     // 9-bit
            pDst[x] = rndclp_9Uto8U(pixel);
        }
    }

    safeReleaseImage(&iplPadded);

    return true;
}

bool CImageUtility::sharpen_lap8a_8U(IplImage *iplSrcImage, IplImage *iplDstImage, int strength, int th0, int th1)
// image sharpening by Lapace 8 filter
// strength -- the presentage of the strength
// th0 -- when the gradient magnitude is lower than this threshold, fully sharpen the image
// th1 -- when the gradient magnitude is higher than this threshold, do not sharpen the image
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U ||
        strength < 0 || strength > 100 || th0 >= th1 || th0 < 0 || th1 > 256) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::sharpen_lap8a_8U()!\n");
		return false;
	}

    if (strength == 0) {
        copy(iplSrcImage, iplDstImage);
        return true;
    }

    IplImage *iplPadded = padding(iplSrcImage, 1, 1, 1, 1);
    if (iplPadded == NULL) return false;

    const int pLut[] = { 12800, 6400, 4267, 3200, 2560, 2133, 1829, 1600, 1422, 1280, 1164, 1067, 985, 914, 853, 800, 753, 711, 674, 640, 610, 582, 557, 533, 512,
                                  492, 474, 457, 441, 427, 413, 400, 388, 376, 366, 356, 346, 337, 328, 320, 312, 305, 298, 291, 284, 278, 272, 267, 261, 256,
                                  251, 246, 242, 237, 233, 229, 225, 221, 217, 213, 210, 206, 203, 200, 197, 194, 191, 188, 186, 183, 180, 178, 175, 173, 171,
                                  168, 166, 164, 162, 160, 158, 156, 154, 152, 151, 149, 147, 145, 144, 142, 141, 139, 138, 136, 135, 133, 132, 131, 129, 128 };
    int factor = pLut[100-strength];

    for (int y=0; y<iplDstImage->height; y++) {
        unsigned char *pSrc0 = (unsigned char *)(iplPadded->imageData + y * iplPadded->widthStep);
        unsigned char *pSrc1 = (unsigned char *)(iplPadded->imageData + (y+1) * iplPadded->widthStep);
        unsigned char *pSrc2 = (unsigned char *)(iplPadded->imageData + (y+2) * iplPadded->widthStep);
        unsigned char *pDst = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            // calculate the gradient magnitude
            int grad_h = - pSrc0[x]     + pSrc0[x+2]
							    - (pSrc1[x]<<1) + (pSrc1[x+2]<<1)
						        - pSrc2[x]     + pSrc2[x+2];
            grad_h = grad_h < 0 ? - grad_h : grad_h;
            int grad_v = - pSrc0[x] - (pSrc0[x+1]<<1) - pSrc0[x+2]
                              + pSrc2[x] + (pSrc2[x+1]<<1) + pSrc2[x+2];
            grad_v = grad_v < 0 ? - grad_v : grad_v;
            int grad = (grad_h + grad_v) >> 1;
            grad = grad > 255 ? 255 : grad;     // clipping
            // tune the factor
            int factor1; 
            if (grad < th0) {
                factor1 = factor;
            } else if (grad > th1) {
                factor1 = 128;
            } else {
                factor1 = ( (factor - 128) * (th1 - grad)) / (th1 - th0) + 128;
            }
            //if (grad < th0) {
            //    if (th0 <= 0) {
            //        factor1 = factor;
            //    } else {
            //        factor1 = (factor - 128) * grad / th0 + 128;
            //    }
            //} else if (grad > th1) {
            //    if (th1 >= 256) {
            //        factor1 = factor;
            //    } else {
            //        factor1 = (factor - 128) * (256 - grad) / (256 - th1) + 128;
            //    }
            //} else {
            //    factor1 = factor;
            //}
            // sharpening
            int pixel = ( ((pSrc1[x+1] * factor1) << 3) - 
                              (factor1 - 128) * (pSrc0[x] + pSrc0[x+1] + pSrc0[x+2] + pSrc1[x] +pSrc1[x+2] + pSrc2[x] + pSrc2[x+1] + pSrc2[x+2]) ) >> 9;     // 9-bit
            pDst[x] = rndclp_9Uto8U(pixel);
        }
    }

    safeReleaseImage(&iplPadded);

    return true;
}

bool CImageUtility::sharpen_lap8a_8U(IplImage *iplSrcImage, IplImage *iplDstImage, int strength, int thr0, int thr1, int thr2, int thr3)
// image sharpening by Lapace 8 filter
// strength -- the presentage of the strength
// th0 -- threshold to keep the flat region unsharpened (lowest)
// th1 -- threshold to start fully sharpening (2nd lowest)
// th2 -- threshold to attenuate the sharpening (2nd highest)
// th3 -- threshold to keep the high contrast region unsharpened (highest)
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U ||
        strength < 0 || strength > 100 || 
        thr0 >= thr1 || thr1 >= thr2 || thr2 >= thr3 || thr0 < 0 || thr3 > 256) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::sharpen_lap8a_8U()!\n");
		return false;
	}

    if (strength == 0) {
        copy(iplSrcImage, iplDstImage);
        return true;
    }

    IplImage *iplPadded = padding(iplSrcImage, 1, 1, 1, 1);
    if (iplPadded == NULL) return false;

    const int pLut[] = { 12800, 6400, 4267, 3200, 2560, 2133, 1829, 1600, 1422, 1280, 1164, 1067, 985, 914, 853, 800, 753, 711, 674, 640, 610, 582, 557, 533, 512,
                                  492, 474, 457, 441, 427, 413, 400, 388, 376, 366, 356, 346, 337, 328, 320, 312, 305, 298, 291, 284, 278, 272, 267, 261, 256,
                                  251, 246, 242, 237, 233, 229, 225, 221, 217, 213, 210, 206, 203, 200, 197, 194, 191, 188, 186, 183, 180, 178, 175, 173, 171,
                                  168, 166, 164, 162, 160, 158, 156, 154, 152, 151, 149, 147, 145, 144, 142, 141, 139, 138, 136, 135, 133, 132, 131, 129, 128 };
    int factor = pLut[100-strength];

    for (int y=0; y<iplDstImage->height; y++) {
        unsigned char *pSrc0 = (unsigned char *)(iplPadded->imageData + y * iplPadded->widthStep);
        unsigned char *pSrc1 = (unsigned char *)(iplPadded->imageData + (y+1) * iplPadded->widthStep);
        unsigned char *pSrc2 = (unsigned char *)(iplPadded->imageData + (y+2) * iplPadded->widthStep);
        unsigned char *pDst = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            // calculate the gradient magnitude
            int grad_h = - pSrc0[x]     + pSrc0[x+2]
							    - (pSrc1[x]<<1) + (pSrc1[x+2]<<1)
						        - pSrc2[x]     + pSrc2[x+2];
            grad_h = grad_h < 0 ? - grad_h : grad_h;
            int grad_v = - pSrc0[x] - (pSrc0[x+1]<<1) - pSrc0[x+2]
                              + pSrc2[x] + (pSrc2[x+1]<<1) + pSrc2[x+2];
            grad_v = grad_v < 0 ? - grad_v : grad_v;
            int grad = (grad_h + grad_v) >> 1;
            grad = grad > 255 ? 255 : grad;     // clipping
            // tune the factor
            int factor1; 
            if (grad < thr0) {
                factor1 = 128;      // no sharpening
            } else if (grad < thr1) {
                factor1 = (factor - 128) * (grad - thr0) / (thr1 - thr0) + 128;
            } else if (grad < thr2) {
                factor1 = factor;
            } else if (grad < thr3) {
                factor1 = (factor - 128) * (thr3 - grad) / (thr3 - thr2) + 128;
            } else {
                factor1 = 128;
            }
            // sharpening
            int pixel = ( ((pSrc1[x+1] * factor1) << 3) - 
                              (factor1 - 128) * (pSrc0[x] + pSrc0[x+1] + pSrc0[x+2] + pSrc1[x] +pSrc1[x+2] + pSrc2[x] + pSrc2[x+1] + pSrc2[x+2]) ) >> 9;     // 9-bit
            pDst[x] = rndclp_9Uto8U(pixel);
        }
    }

    safeReleaseImage(&iplPadded);

    return true;
}

bool CImageUtility::sharpen_lap8b_8U(IplImage *iplSrcImage, IplImage *iplDstImage, int strength, int thr0, int thr2)
// image sharpening by Lapace 8 filter
// Different to sharpen_lap8a_8U(), this function:
// 1. fixes the differences between thr1 and thr0 to 8, and thr2 and thr3 to 15.
// 2. reduce the number strength levels from 100 to 16, where the correspondences are:
//     new:         0   1      2      3       4       5       6       7       8       9        10     11      12      13     14   15
//     orignal:    0   10   20     30     35     40      45      50     55     60      65      68      70      72     74    76
//     new:        16   17      18      19      20       21      22      23      24      25      26     27      28     29    30   31
//     original:   77   78     79      80      81        82      83      84      85      86      87     88      89     90    95   99    
// strength -- the presentage of the strength
// th0 -- threshold to keep the flat region unsharpened (lowest)
// th2 -- threshold to attenuate the sharpening (2nd highest)
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U ||
        strength < 0 || strength > 31 || thr0 >= thr2 || thr0 < 0 || thr2 > 240) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::sharpen_lap8b_8U()!\n");
		return false;
	}

    if (strength == 0) {
        copy(iplSrcImage, iplDstImage);
        return true;
    }

    IplImage *iplPadded = padding(iplSrcImage, 1, 1, 1, 1);
    if (iplPadded == NULL) return false;

    const int pLut[] = { 12800, 1164, 610, 413, 356, 312, 278, 251, 229, 210, 194, 186, 180, 175, 171, 166, 
                                       164, 162, 160, 158, 156, 154, 152, 151, 149, 147, 145, 144, 142, 141, 133, 128 };
    //const int pLut[] = { 12800, 6400, 4267, 3200, 2560, 2133, 1829, 1600, 1422, 1280, 1164, 1067, 985, 914, 853, 800, 753, 711, 674, 640, 610, 582, 557, 533, 512,
                                  //492, 474, 457, 441, 427, 413, 400, 388, 376, 366, 356, 346, 337, 328, 320, 312, 305, 298, 291, 284, 278, 272, 267, 261, 256,
                                  //251, 246, 242, 237, 233, 229, 225, 221, 217, 213, 210, 206, 203, 200, 197, 194, 191, 188, 186, 183, 180, 178, 175, 173, 171,
                                  //168, 166, 164, 162, 160, 158, 156, 154, 152, 151, 149, 147, 145, 144, 142, 141, 139, 138, 136, 135, 133, 132, 131, 129, 128 };
    int factor = pLut[31-strength];
    int thr1 = thr0 + 8;
    int thr3 = thr2 + 16;

    for (int y=0; y<iplDstImage->height; y++) {
        unsigned char *pSrc0 = (unsigned char *)(iplPadded->imageData + y * iplPadded->widthStep);
        unsigned char *pSrc1 = (unsigned char *)(iplPadded->imageData + (y+1) * iplPadded->widthStep);
        unsigned char *pSrc2 = (unsigned char *)(iplPadded->imageData + (y+2) * iplPadded->widthStep);
        unsigned char *pDst = (unsigned char *)(iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            // calculate the gradient magnitude
            int grad_h = - pSrc0[x]     + pSrc0[x+2]
							    - (pSrc1[x]<<1) + (pSrc1[x+2]<<1)
						        - pSrc2[x]     + pSrc2[x+2];
            grad_h = grad_h < 0 ? - grad_h : grad_h;
            int grad_v = - pSrc0[x] - (pSrc0[x+1]<<1) - pSrc0[x+2]
                              + pSrc2[x] + (pSrc2[x+1]<<1) + pSrc2[x+2];
            grad_v = grad_v < 0 ? - grad_v : grad_v;
            int grad = (grad_h + grad_v) >> 1;
            grad = grad > 255 ? 255 : grad;     // clipping
            // tune the factor
            int factor1; 
            if (grad < thr0) {
                factor1 = 128;      // no sharpening
            } else if (grad < thr1) {
                factor1 = (((factor - 128) * (grad - thr0)) >> 3) + 128;
            } else if (grad < thr2) {
                factor1 = factor;
            } else if (grad < thr3) {
                factor1 = (((factor - 128) * (thr3 - grad)) >> 4) + 128;
            } else {
                factor1 = 128;
            }
            // sharpening
            int pixel = ( ((pSrc1[x+1] * factor1) << 3) - 
                              (factor1 - 128) * (pSrc0[x] + pSrc0[x+1] + pSrc0[x+2] + pSrc1[x] +pSrc1[x+2] + pSrc2[x] + pSrc2[x+1] + pSrc2[x+2]) ) >> 9;     // 9-bit
            pDst[x] = rndclp_9Uto8U(pixel);
        }
    }

    safeReleaseImage(&iplPadded);

    return true;
}


IplImage *CImageUtility::errDiffuseFS(IplImage *iplImage, float dim, int threshold)
// Error diffusion with Floyd's and Steinberg's filter weights
//    X  7
// 3  5  1
// "threshold" is the threshold to set the pixel 255 or 0.
// "dim" is the factor that reduce the intensity of the image before error diffusion.
// Both input and output images are 8-bit format.
{
    if (iplImage == NULL || iplImage->nChannels != 1) {
		showErrMsg("Invalide input image in errorDiffuseFS()!\n");
		return NULL;
	}

	IplImage *iplDstImage = createImage(iplImage->width, iplImage->height, SR_DEPTH_8U, 1);
	if (iplDstImage == NULL) {
		showErrMsg("Fail to allcoate result image in errorDiffuseFS()!\n");
		return NULL;
	}

	if (errDiffuseFS(iplImage, iplDstImage, dim, threshold))
		return iplDstImage;
	else
		return NULL;
}

 bool CImageUtility::errDiffuseFS(IplImage *iplImage, IplImage *iplBin, float dim, int threshold)
// Error diffusion with Floyd's and Steinberg's filter weights
//    X  7
// 3  5  1
// "threshold" is the threshold to set the pixel 255 or 0.
// "dim" is the factor that reduce the intensity of the image before error diffusion.
// Both input and output images are 8-bit format.
{
	if (iplImage == NULL || iplImage->nChannels != 1) {
		showErrMsg("Invalide input image in errorDiffuseFS()!\n");
		return NULL;
	}

	// dim 
	if (dim != 1.0f) {
		for (int y=0; y<iplImage->height; y++) {
			unsigned char *pSrc = (unsigned char *)(iplImage->imageData + y * iplImage->widthStep);
			unsigned char *pDst = (unsigned char *)(iplBin->imageData + y * iplBin->widthStep);
			for (int x=0; x<iplImage->width; x++) {
				int value = (int)(pSrc[x] * dim + 0.5f);
				pDst[x] = (unsigned char)clip_0_255(value);
			}
		}
	} else {
		copy(iplImage, iplBin);
	}

	// error diffusion
	int point_num = 0;
	int *pLine1 = new int[iplBin->width];
	if (pLine1 == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::errorDiffuseFS()!\n");
	}
	unsigned char *pSrc = (unsigned char *)(iplBin->imageData);
	for (int x=0; x<iplImage->width; x++) {
		pLine1[x] = pSrc[x];
	}

	int err;
	for (int y=0; y<iplBin->height-1; y++) {
		unsigned char *pDst = (unsigned char *)(iplBin->imageData + y * iplBin->widthStep);
		unsigned char *pSrc1 = (unsigned char *)(iplBin->imageData + (y+1) * iplBin->widthStep);
		// first pixel
		if (pLine1[0] > threshold) {
			pDst[0] = 255;
			err = pLine1[0] - 255;
			point_num ++;
		} else {
			pDst[0] = 0;
			err = pLine1[0];
		}
		int nNext = pLine1[1] + (err * 7) / 16;	// next pixel this line
		pLine1[0] = pSrc1[0] + (err * 5) / 16;	// below pixel
		pLine1[1] = pSrc1[1] + err / 16;		// bottom right pixel
		// pixels in the middle
		for (int x=1; x<iplBin->width-1; x++) {
			if (nNext > threshold) {
				pDst[x] = 255;
				err = nNext - 255;
				point_num ++;
			} else {
				pDst[x] = 0;
				err = nNext;
			}
			nNext = pLine1[x+1] + (err * 7) / 16;	// next pixel this line
			pLine1[x-1] += (err * 3) / 16;		// bottom left pixel
			pLine1[x] += (err * 5) / 16;		// below pixel
			pLine1[x+1] = pSrc1[x+1] + err / 16;// bottom right pixel
		}
		// last pixel
		if (nNext > threshold) {
			pDst[iplBin->width-1] = 255;
			err = nNext - 255;
			point_num ++;
		} else {
			pDst[iplBin->width-1] = 0;
			err = nNext;
		}
		pLine1[iplBin->width-2] += (err * 3) / 16;		// bottom left pixel
		pLine1[iplBin->width-1] += (err * 5) / 16;		// below pixel
	}
	// last line
	unsigned char *pDst = (unsigned char *)(iplBin->imageData + (iplBin->height-1)*iplBin->widthStep);
	for (int x=0; x<iplBin->width-1; x++) {
		if (pLine1[x] > threshold) {
			pDst[x] = 255;
			point_num ++;
			pLine1[x+1] += ((pLine1[x]-255) * 7) / 16;		// next pixel this line
		} else {
			pDst[x] = 0;
			pLine1[x+1] += (pLine1[x] * 7) / 16;			// next pixel this line
		}
	}
	if (pLine1[iplBin->width-1] > threshold) {
		pDst[iplBin->width-1] = 255;
		point_num ++;
	} else
		pDst[iplBin->width-1] = 0;

	delete [] pLine1;

	showErrMsg("%.2f percent, %d white points obtained in error diffusion.\n", point_num*100.0f/(iplBin->width*iplBin->height), point_num);

	return true;
}

IplImage *CImageUtility::extrStructMap_32f(IplImage *iplImage, int wnd_size, int ds_level)
// Calculate the tensor map of an image
// Supposing gx = Gradx(I) and gy = Grady(I), the tensor matrix is T = [ sum(gx*gx) sum(gx*gy); sum(gy*gx), sum(gy*gy) ]
// the tensor-based isotropy at a point is (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2)). Moreover, the corner
// point likelihood is alphs*eg2. The function map a sum of the isotropy and the corner likelihood to 0~1, where 1 denotes 
// the pixel in structure region. This function supports the tensor estimation on a downsampled image, where ds_level denotes 
// the level (1/2) of the pyramid image (0 denotes no downsample)
// Argument:
//		iplImage -- [I] 1-channel input image, 32F or 8U datatype
//		wnd_size -- [I] window size in calculating the tensor
//		ds_level -- [I] downsample level, 0 for no downsample
// Return: 32F image
// by Luhong Liang, IC-ASD, ASTRI, Nov. 5, 2012
{
	if (iplImage == NULL || iplImage->nChannels != 1) {
		showErrMsg("Invalid input argument in CImageUtility::extrStructMap_32f()!\n");
		return NULL;
	}

	// allocate destination image
	int ds_factor = 1;
	if (ds_level > 0) {
		ds_factor = ds_factor << ds_level;
	} 
	int nWidth = iplImage->width >> ds_level;
	int nHeight = iplImage->height >> ds_level;
	IplImage *iplStruct = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	if (iplStruct == NULL) {
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap_32f()!\n");
		return NULL;
	}

	if (extrStructMap_32f(iplImage, iplStruct, wnd_size, ds_level)) {
		return iplStruct;
	} else {
		safeReleaseImage(&iplStruct);
		return NULL;
	}
}

IplImage *CImageUtility::extrStructMap_MS_32f(IplImage *iplImage, int wnd_size)
// Calculate the multi-scale tensor map of an image
// Supposing gx = Gradx(I) and gy = Grady(I), the tensor matrix is T = [ sum(gx*gx) sum(gx*gy); sum(gy*gx), sum(gy*gy) ]
// the tensor-based isotropy at a point is (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2)). Moreover, the corner
// point likelihood is alphs*eg2. The function map a sum of the isotropy and the corner likelihood to 0~1, where 1 denotes 
// the pixel in structure region. This function supports the tensor estimation on a downsampled image, where ds_level denotes 
// the level (1/2) of the pyramid image (0 denotes no downsample)
// Argument:
//		iplImage -- [I] 1-channel input image, 32F or 8U datatype
//		wnd_size -- [I] window size in calculating the tensor
// Return: 32F image
// by Luhong Liang, IC-ASD, ASTRI, Mar. 18, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1) {
		showErrMsg("Invalid input argument in CImageUtility::extrStructMap_MS_32f()!\n");
		return NULL;
	}

	// allocate destination image
	//int ds_factor = 1;
	//if (ds_level > 0) {
	//	ds_factor = ds_factor << ds_level;
	//} 
	//int nWidth = iplImage->width >> ds_level;
	//int nHeight = iplImage->height >> ds_level;
	IplImage *iplRegular = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplCorner = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	if (iplRegular == NULL) {
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap_MS_32f()!\n");
		safeReleaseImage(&iplRegular, &iplCorner);
		return NULL;
	}

	//char stName[256];
	//sprintf(stName, "_Org_L0.bmp");  saveImage(stName, iplImage, 0, 1.0f);
	//IplImage *iplTemp = cvtImage32Fto8U(iplImage);
	//IplImage *iplCanny = cvtImage32Fto8U(iplRegular);
	//int can1 = 0;//10;
	//int can2 = 0;//25;
	//cvCanny(iplTemp, iplCanny, can1, can2);
	//cvtImage8Uto32F(iplCanny, iplImage);
	//sprintf(stName, "_Canny_%d_%d.bmp", can1, can2);  saveImage(stName, iplImage, 0, 1.0f);
	wnd_size = 5;
	for (int i=0; i<1; i++) {
		if (!extrStructMap_32f(iplImage, iplRegular, iplCorner, wnd_size, i)) {
			safeReleaseImage(&iplRegular, &iplCorner);
			return NULL;
		}

		//sprintf(stName, "_TensorOrg%d_can%d_%d_%d_L%d.bmp", wnd_size, can1, can2, wnd_size, i);  saveImage(stName, iplRegular, 0, 255.0f);
		//sprintf(stName, "_CornerOrg%d_can%d_%d_%d_L%d.bmp", wnd_size, can1, can2, wnd_size, i);  saveImage(stName, iplCorner, 0, 255.0f);
		// cvAdd(iplRegular, iplCorner, iplRegular);
		addImage_32f(iplRegular, iplCorner, iplRegular);
		//sprintf(stName, "_TensorCorner_can%d_%d_%d_L%d.bmp", can1, can2, wnd_size, i);  saveImage(stName, iplRegular, 0, 255.0f);
	}

	safeReleaseImage(&iplCorner);

	return iplRegular;
}

bool CImageUtility::extrStructMap_32f(IplImage *iplImage, IplImage *iplStruct, int wnd_size, int ds_level)
// Calculate the tensor map of an image
// Supposing gx = Gradx(I) and gy = Grady(I), the tensor matrix is T = [ sum(gx*gx) sum(gx*gy); sum(gy*gx), sum(gy*gy) ]
// the tensor-based isotropy at a point is (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2)). Moreover, the corner
// point likelihood is alphs*eg2. The function map a sum of the isotropy and the corner likelihood to 0~1, where 1 denotes 
// the pixel in structure region. This function supports the tensor estimation on a downsampled image, where ds_level denotes 
// the level (1/2) of the pyramid image (0 denotes no downsample)
// Argument:
//		iplImage -- [I] 1-channel input image, 32F or 8U datatype
//		iplStruct -- [O] 1-channel result image, 32F datatype
//		wnd_size -- [I] window size in calculating the tensor
//		ds_level -- [I] downsample level, 0 for no downsample
// by Luhong Liang, IC-ASD, ASTRI, Nov. 5, 2012
{
	if (iplImage == NULL || iplStruct == NULL || ds_level < 0 || wnd_size < 3 ||
		iplImage->nChannels != 1 || iplStruct->nChannels != 1 || iplStruct->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type or argument in CImageUtility::extrStructMap_32f()!\n");
		return false;
	}

	int ds_factor = 1;
	if (ds_level > 0) {
		ds_factor = ds_factor << ds_level;
	} 
	int nWidth = iplImage->width >> ds_level;
	int nHeight = iplImage->height >> ds_level;
	if (nWidth * ds_factor != iplImage->width || nHeight * ds_factor != iplImage->height) {
		showErrMsg("Warning: non-integer multiplication in the pyramid in CImageUtility::extrStructMap_32f()!\n");
	}

	IplImage *iplSrc0 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplSrc = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplGx = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplGy = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplGxy = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplTen = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	if (iplSrc0 == NULL ||iplSrc == NULL || iplGx == NULL || iplGy == NULL || iplGxy == NULL || iplTen == NULL)  {
		safeReleaseImage(&iplSrc0, &iplSrc, &iplGx, &iplGy, &iplGxy, &iplTen);
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap_32f()!\n");
		return false;
	}

	// data type conversion
	if (iplImage->depth == SR_DEPTH_32F) {
		copy(iplImage, iplSrc0);
	} else if (iplImage->depth == SR_DEPTH_8U) {
		cvtImage8Uto32F(iplImage, iplSrc0);
	} else {
		showErrMsg("Input image must be 8U or 32F in CImageUtility::extrStructMap_32f()!\n");
		safeReleaseImage(&iplSrc, &iplGx, &iplGy, &iplGxy, &iplTen);
		return false;
	}

	// calculate pyramid image
	if (!meanPyrDown_32f(iplSrc0, iplSrc, ds_level)) {
		safeReleaseImage(&iplSrc0, &iplSrc, &iplGx, &iplGy, &iplGxy, &iplTen);
		return false;
	}
	//saveImage("_Pyramid.bmp", iplSrc);

	// calculate gradient
	//cvSobel(iplSrc, iplGx, 1, 0, 3);
	sobel_32f(iplSrc, iplGx, 0);			// do not use OpenCV function here
	//saveImage("_SobelX.bmp", iplGx, 128, 1.0f);
	//cvSobel(iplSrc, iplGy, 0, 1, 3);
	sobel_32f(iplSrc, iplGy, 1);
	//saveImage("_SobelY.bmp", iplGy, 128, 1.0f);

	// calculate tensor 
	mulImage_32f(iplGx, iplGy, iplGxy);
	mulImage_32f(iplGx, iplGx, iplGx);
	mulImage_32f(iplGy, iplGy, iplGy);
	
	setZero(iplStruct);
	int start = wnd_size >> 1;
	int end = wnd_size - start - 1;
	//float max_eg2 = -FLT_MAX;
	//IplImage *iplTenOnly = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );		// for debug only
	//IplImage *iplCorOnly = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );	// for debug only
	for (int y=start; y<iplTen->height-end; y++) {
		float *pTen = (float*)((char *)iplTen->imageData + y * iplTen->widthStep);
		//float *pTenOnly = (float*)((char *)iplTenOnly->imageData + y * iplTenOnly->widthStep);	// for debug only
		//float *pCorOnly = (float*)((char *)iplCorOnly->imageData + y * iplCorOnly->widthStep);	// for debug only
		for (int x=start; x<iplTen->width-end; x++) {
			// calculate tensor matrix T = [pxx pxy; pxy pyy] in wnd_num * wnd_num window
			float pxx = 0.0f, pxy = 0.0f, pyy = 0.0f;
			for (int v = y - start; v < y - start + wnd_size; v++) {
				float *pGxx = (float*)((char *)iplGx->imageData + v * iplGx->widthStep);
				float *pGyy = (float*)((char *)iplGy->imageData + v * iplGy->widthStep);
				float *pGxy = (float*)((char *)iplGxy->imageData + v * iplGxy->widthStep);
				for (int u = x - start; u < x - start + wnd_size; u++) {
					pxx += pGxx[u];
					pxy += pGxy[u];
					pyy += pGyy[u];
				}
			}
			// calculate eigenvalues
			float k = (pxx+pyy) * (pxx+pyy) - 4 * (pxx * pyy - pxy * pxy);
			if ( k<=0.0f) continue;
			float temp1 = (float)sqrt(k);// * 0.5f;
			float temp2 = (pxx + pyy);// * 0.5f;
			float eg1 =  temp2 + temp1;		// since temp2 > 0 && temp1 > 0, eg1 must be larger than eg2
			float eg2 = temp2 - temp1;
			eg2 = eg2 < 0 ? -eg2 : eg2;	// abs
			// calculate the degree of anisotropy 
			float edge_regular;
			if (eg2 == 0.0f) {		// this equals to eg1 == eg2 == 0!
				edge_regular = 1.0;		// NOTE: we consider a constant window as "well-aligned" (i.e. regular region)
			} else {
				edge_regular = (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2));
			}
			//pTenOnly[x] = edge_regular;
			// calculate corner
			float corner = eg2 / (1024.0f * 128.0f);
			corner = corner > 1.0f ? 1.0f : corner;
			//pCorOnly[x] = corner;
			// fusion
			pTen[x] = edge_regular + corner;
			//if (eg2 > max_eg2) max_eg2 = eg2;
		}
	}
	//char stName[256];  sprintf(stName, "_TensorOrg_L%d.bmp", ds_level);  saveImage(stName, iplTenOnly, 0, 255.0f);
	//sprintf(stName, "_CornerOrg_L%d.bmp", ds_level);  saveImage(stName, iplCorOnly, 0, 255.0f);
	//sprintf(stName, "_TensorCornerOrg_L%d.bmp", ds_level);  saveImage(stName, iplTen, 0, 255.0f);
	//safeReleaseImage(&iplTenOnly, &iplCorOnly);

	// resize
	if (nWidth != iplStruct->width || nHeight != iplStruct->height) {
		resize(iplTen, iplStruct, SR_INTER_NN);		// considering implemention in the loop, use NN
	} else {
		copy(iplTen, iplStruct);
	}

	safeReleaseImage(&iplSrc0, &iplSrc, &iplGx, &iplGy, &iplGxy, &iplTen);

	return true;
}

bool CImageUtility::extrStructMap_32f(IplImage *iplImage, IplImage *iplRegularity, IplImage *iplCorner, int wnd_size, int ds_level)
// Calculate the tensor map of an image
// Supposing gx = Gradx(I) and gy = Grady(I), the tensor matrix is T = [ sum(gx*gx) sum(gx*gy); sum(gy*gx), sum(gy*gy) ]
// the tensor-based isotropy at a point is (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2)). 
// Moreover, the corner point likelihood is alphs*eg2. 
//This function supports the tensor estimation on a downsampled image, where ds_level denotes 
// the level (1/2) of the pyramid image (0 denotes no downsample)
// Argument:
//		iplImage -- [I] 1-channel input image, 32F or 8U datatype
//		iplStruct -- [O] 1-channel result image, 32F datatype
//		wnd_size -- [I] window size in calculating the tensor
//		ds_level -- [I] downsample level, 0 for no downsample
// by Luhong Liang, IC-ASD, ASTRI, Mar. 18, 2013
{
	if (iplImage == NULL || iplRegularity == NULL || iplCorner == NULL || ds_level < 0 || wnd_size < 3 || iplImage->nChannels != 1 || 
		iplRegularity->nChannels != 1 || iplRegularity->depth != SR_DEPTH_32F || iplCorner->nChannels != 1 || iplCorner->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type or argument in CImageUtility::extrStructMap_32f()!\n");
		return false;
	}

	int ds_factor = 1;
	if (ds_level > 0) {
		ds_factor = ds_factor << ds_level;
	} 
	int nWidth = iplImage->width >> ds_level;
	int nHeight = iplImage->height >> ds_level;
	if (nWidth * ds_factor != iplImage->width || nHeight * ds_factor != iplImage->height) {
		showErrMsg("Warning: non-integer multiplication in the pyramid in CImageUtility::extrStructMap_32f()!\n");
	}

	IplImage *iplSrc0 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplSrc = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplGx = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplGy = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplGxy = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplTenOnly = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );		// for debug only
	IplImage *iplCorOnly = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );		// for debug only
	if (iplSrc0 == NULL ||iplSrc == NULL || iplGx == NULL || iplGy == NULL || iplGxy == NULL || iplCorOnly == NULL || iplTenOnly == NULL)  {
		safeReleaseImage(&iplSrc0, &iplSrc, &iplGx, &iplGy, &iplGxy);
		safeReleaseImage(&iplCorOnly, &iplTenOnly);
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap_32f()!\n");
		return false;
	}

	// data type conversion
	if (iplImage->depth == SR_DEPTH_32F) {
		copy(iplImage, iplSrc0);
	} else if (iplImage->depth == SR_DEPTH_8U) {
		cvtImage8Uto32F(iplImage, iplSrc0);
	} else {
		showErrMsg("Input image must be 8U or 32F in CImageUtility::extrStructMap_32f()!\n");
		safeReleaseImage(&iplSrc0, &iplSrc, &iplGx, &iplGy, &iplGxy);
		safeReleaseImage(&iplCorOnly, &iplTenOnly);
		return false;
	}

	// calculate pyramid image
	if (!meanPyrDown_32f(iplSrc0, iplSrc, ds_level)) {
		safeReleaseImage(&iplSrc0, &iplSrc, &iplGx, &iplGy, &iplGxy);
		safeReleaseImage(&iplCorOnly, &iplTenOnly);
		return false;
	}
	//saveImage("_Pyramid.bmp", iplSrc);

	// calculate gradient
	//cvSobel(iplSrc, iplGx, 1, 0, 3);
	sobel_32f(iplSrc, iplGx, 0);			// do not use OpenCV function here
	//saveImage("_SobelX.bmp", iplGx, 128, 1.0f);
	//cvSobel(iplSrc, iplGy, 0, 1, 3);
	sobel_32f(iplSrc, iplGy, 1);
	//saveImage("_SobelY.bmp", iplGy, 128, 1.0f);

	// calculate tensor 
	mulImage_32f(iplGx, iplGy, iplGxy);
	mulImage_32f(iplGx, iplGx, iplGx);
	mulImage_32f(iplGy, iplGy, iplGy);
	
	setZero(iplTenOnly);
	setZero(iplCorOnly);
	int start = wnd_size >> 1;
	int end = wnd_size - start - 1;
	const float eps = 0.1f;
	//float max_eg2 = -FLT_MAX;
	for (int y=start; y<iplTenOnly->height-end; y++) {
		float *pTenOnly = (float*)((char *)iplTenOnly->imageData + y * iplTenOnly->widthStep);	// for debug only
		float *pCorOnly = (float*)((char *)iplCorOnly->imageData + y * iplCorOnly->widthStep);	// for debug only
		for (int x=start; x<iplTenOnly->width-end; x++) {
			//if (x==406&&y==190 || x==294&&y==64) 
			//	int p = 0;
			// calculate tensor matrix T = [pxx pxy; pxy pyy] in wnd_num * wnd_num window
			float pxx = 0.0f, pxy = 0.0f, pyy = 0.0f;
			for (int v = y - start; v < y - start + wnd_size; v++) {
				float *pGxx = (float*)((char *)iplGx->imageData + v * iplGx->widthStep);
				float *pGyy = (float*)((char *)iplGy->imageData + v * iplGy->widthStep);
				float *pGxy = (float*)((char *)iplGxy->imageData + v * iplGxy->widthStep);
				for (int u = x - start; u < x - start + wnd_size; u++) {
					pxx += pGxx[u];
					pxy += pGxy[u];
					pyy += pGyy[u];
				}
			}
			// calculate eigenvalues
			float edge_regular, corner;
			float k = (pxx+pyy) * (pxx+pyy) - 4 * (pxx * pyy - pxy * pxy);
			if ( k<=eps) {
				edge_regular = 1.0f;
				corner = 0.0f;
			} else {
				float temp1 = (float)sqrt(k);// * 0.5f;
				float temp2 = (pxx + pyy);// * 0.5f;
				float eg1 =  temp2 + temp1;		// since temp2 > 0 && temp1 > 0, eg1 must be larger than eg2
				float eg2 = temp2 - temp1;
				eg2 = eg2 < 0 ? -eg2 : eg2;	// abs
				// calculate the degree of anisotropy 
				if (eg1 == 0.0f) {		// this equals to eg1 == eg2 == 0!
					edge_regular = 1.0;		// NOTE: we consider a constant window as "well-aligned" (i.e. regular region)
				} else {
					edge_regular =  (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2));
				}
				// calculate corner
				//corner = eg2 / (1024.0f * 128.0f);
				//corner = corner > 1.0f ? 1.0f : corner;
				corner = 2 * eg1 * eg2 / (eg1 + eg2 + eps);
				corner = corner * 0.00001f;
			}
			pTenOnly[x] = edge_regular;
			pCorOnly[x] = corner;
		}
	}

	// resize
	if (nWidth != iplRegularity->width || nHeight != iplRegularity->height) {
		resize(iplTenOnly, iplRegularity, SR_INTER_LINEAR);		// considering implemention in the loop, use NN
	} else {
		copy(iplTenOnly, iplRegularity);
	}

	if (nWidth != iplCorner->width || nHeight != iplCorner->height) {
		resize(iplCorOnly, iplCorner, SR_INTER_LINEAR);		// considering implemention in the loop, use NN
	} else {
		copy(iplCorOnly, iplCorner);
	}

	safeReleaseImage(&iplSrc0, &iplSrc, &iplGx, &iplGy, &iplGxy);
	safeReleaseImage(&iplCorOnly, &iplTenOnly);

	return true;
}

IplImage *CImageUtility::extrStructMap5x5_32f(IplImage *iplImage, int ds_level)
// Calculate the tensor map of an image, using 5x5 window
// Supposing gx = Gradx(I) and gy = Grady(I), the tensor matrix is T = [ sum(gx*gx) sum(gx*gy); sum(gy*gx), sum(gy*gy) ]
// the tensor-based isotropy at a point is (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2)). Moreover, the corner
// point likelihood is alphs*eg2. The function map a sum of the isotropy and the corner likelihood to 0~1, where 1 denotes 
// the pixel in structure region. This function supports the tensor estimation on a downsampled image, where ds_level denotes 
// the level (1/2) of the pyramid image (0 denotes no downsample)
// Argument:
//		iplImage -- [I] 1-channel input image, 32F or 8U datatype
//		ds_level -- [I] downsample level, 0 for no downsample
// Return: 32F image
// by Luhong Liang, IC-ASD, ASTRI, Feb. 19, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1) {
		showErrMsg("Invalid input argument in CImageUtility::extrStructMap5x5_32f()!\n");
		return NULL;
	}

	// allocate destination image
	int ds_factor = 1;
	if (ds_level > 0) {
		ds_factor = ds_factor << ds_level;
	} 
	int nWidth = iplImage->width >> ds_level;
	int nHeight = iplImage->height >> ds_level;
	IplImage *iplStruct = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	if (iplStruct == NULL) {
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap5x5_32f()!\n");
		return NULL;
	}

	if (extrStructMap5x5_32f(iplImage, iplStruct, ds_level)) {
		return iplStruct;
	} else {
		safeReleaseImage(&iplStruct);
		return NULL;
	}
}

IplImage *CImageUtility::extrStructMap5x5_o1_32f(IplImage *iplImage, int ds_level)
// Calculate the tensor map of an image, using 5x5 window
// Supposing gx = Gradx(I) and gy = Grady(I), the tensor matrix is T = [ sum(gx*gx) sum(gx*gy); sum(gy*gx), sum(gy*gy) ]
// the tensor-based isotropy at a point is (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2)). Moreover, the corner
// point likelihood is alphs*eg2. The function map a sum of the isotropy and the corner likelihood to 0~1, where 1 denotes 
// the pixel in structure region. This function supports the tensor estimation on a downsampled image, where ds_level denotes 
// the level (1/2) of the pyramid image (0 denotes no downsample)
// Different from function extrStructMap5x5_32f(), this function (1) uses ;
// Argument:
//		iplImage -- [I] 1-channel input image, 32F or 8U datatype
//		ds_level -- [I] downsample level, 0 for no downsample
// Return: 32F image
// by Luhong Liang, IC-ASD, ASTRI, Aug. 26, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1) {
		showErrMsg("Invalid input argument in CImageUtility::extrStructMap5x5_32f()!\n");
		return NULL;
	}

	// allocate destination image
	int ds_factor = 1;
	if (ds_level > 0) {
		ds_factor = ds_factor << ds_level;
	} 
	int nWidth = iplImage->width >> ds_level;
	int nHeight = iplImage->height >> ds_level;
	IplImage *iplStruct = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	if (iplStruct == NULL) {
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap5x5_32f()!\n");
		return NULL;
	}

	if (extrStructMap5x5_o1_32f(iplImage, iplStruct, ds_level)) {
		return iplStruct;
	} else {
		safeReleaseImage(&iplStruct);
		return NULL;
	}
}

bool CImageUtility::extrStructMap5x5_32f(IplImage *iplImage, IplImage *iplStruct, int ds_level)
// Calculate the tensor map of an image, using 5x5 window
// Supposing gx = Gradx(I) and gy = Grady(I), the tensor matrix is T = [ sum(gx*gx) sum(gx*gy); sum(gy*gx), sum(gy*gy) ]
// the tensor-based isotropy at a point is (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2)). Moreover, the corner
// point likelihood is alphs*eg2. The function map a sum of the isotropy and the corner likelihood to 0~1, where 1 denotes 
// the pixel in structure region. This function supports the tensor estimation on a downsampled image, where ds_level denotes 
// the level (1/2) of the pyramid image (0 denotes no downsample)
// Argument:
//		iplImage -- [I] 1-channel input image, 32F or 8U datatype
//		iplStruct -- [O] 1-channel result image, 32F datatype
//		ds_level -- [I] downsample level, 0 for no downsample
// by Luhong Liang, IC-ASD, ASTRI, Feb. 19, 2013
{
	if (iplImage == NULL || iplStruct == NULL || ds_level < 0 ||
		iplImage->nChannels != 1 || iplStruct->nChannels != 1 || iplStruct->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type or argument in CImageUtility::extrStructMap5x5_32f()!\n");
		return false;
	}

	int ds_factor = 1;
	if (ds_level > 0) {
		ds_factor = ds_factor << ds_level;
	} 
	int nWidth = iplImage->width >> ds_level;
	int nHeight = iplImage->height >> ds_level;
	if (nWidth * ds_factor != iplImage->width || nHeight * ds_factor != iplImage->height) {
		showErrMsg("Warning: non-integer multiplication in the pyramid in CImageUtility::extrStructMap5x5_32f()!\n");
	}

	IplImage *iplSrc0 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplSrc = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplGx = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplGy = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplGxy = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplTen = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
    IplImage *iplCor = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	float *pGxxLine = new float[iplImage->width];		// use line buffer instead of FIFO to simplify the management
	float *pGxyLine = new float[iplImage->width];
	float *pGyyLine = new float[iplImage->width];
	if (iplSrc0 == NULL ||iplSrc == NULL || iplGx == NULL || iplGy == NULL || iplGxy == NULL || iplTen == NULL ||
		iplCor == NULL || pGxxLine == NULL || pGxyLine == NULL || pGyyLine == NULL)  {
		safeReleaseImage(&iplSrc0, &iplSrc, &iplGx, &iplGy, &iplGxy);
        safeReleaseImage(&iplCor, &iplTen);
		if (pGxxLine != NULL) delete [] pGxxLine;
		if (pGxyLine != NULL) delete [] pGxyLine;
		if (pGyyLine != NULL) delete [] pGyyLine;
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap5x5_32f()!\n");
		return false;
	}

	// data type conversion
	if (iplImage->depth == SR_DEPTH_32F) {
		copy(iplImage, iplSrc0);
	} else if (iplImage->depth == SR_DEPTH_8U) {
		cvtImage8Uto32F(iplImage, iplSrc0);
	} else {
		showErrMsg("Input image must be 8U or 32F in CImageUtility::extrStructMap5x5_32f()!\n");
		safeReleaseImage(&iplSrc0, &iplSrc, &iplGx, &iplGy, &iplGxy);
        safeReleaseImage(&iplCor, &iplTen);
		return false;
	}

	// calculate pyramid image
	if (!meanPyrDown_32f(iplSrc0, iplSrc, ds_level)) {
		safeReleaseImage(&iplSrc0, &iplSrc, &iplGx, &iplGy, &iplGxy);
        safeReleaseImage(&iplCor, &iplTen);
	    if (pGxxLine != NULL) delete [] pGxxLine;
	    if (pGxyLine != NULL) delete [] pGxyLine;
	    if (pGyyLine != NULL) delete [] pGyyLine;
        return false;
	}

	// calculate gradient
	sobel_32f(iplSrc, iplGx, 0);			// do not use OpenCV function here
	sobel_32f(iplSrc, iplGy, 1);

	// calculate tensor 
	mulImage_32f(iplGx, iplGy, iplGxy);
	mulImage_32f(iplGx, iplGx, iplGx);
	mulImage_32f(iplGy, iplGy, iplGy);
	//extrSumMap5x5_32f(iplGxy); 	extrSumMap5x5_32f(iplGx); 	extrSumMap5x5_32f(iplGy); <-- not use integral image due to the numerical error!
	
	setZero(iplTen);
    setZero(iplCor);
	const int wnd_size = 5;
	const int start = wnd_size >> 1;
	const int end = wnd_size - start - 1;
	for (int y=start; y<iplTen->height-end; y++) {
		float *pTen = (float*)((char *)iplTen->imageData + y * iplTen->widthStep);
        //float *pCor = (float*)((char *)iplCor->imageData + y * iplCor->widthStep);
		float *pGxx0 = (float*)((char *)iplGx->imageData + (y-2) * iplGx->widthStep);
		float *pGyy0 = (float*)((char *)iplGy->imageData + (y-2) * iplGy->widthStep);
		float *pGxy0 = (float*)((char *)iplGxy->imageData + (y-2) * iplGxy->widthStep);
		float *pGxx1 = (float*)((char *)iplGx->imageData + (y-1) * iplGx->widthStep);
		float *pGyy1 = (float*)((char *)iplGy->imageData + (y-1) * iplGy->widthStep);
		float *pGxy1 = (float*)((char *)iplGxy->imageData + (y-1) * iplGxy->widthStep);
		float *pGxx2 = (float*)((char *)iplGx->imageData + y * iplGx->widthStep);
		float *pGyy2 = (float*)((char *)iplGy->imageData + y * iplGy->widthStep);
		float *pGxy2 = (float*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
		float *pGxx3 = (float*)((char *)iplGx->imageData + (y+1) * iplGx->widthStep);
		float *pGyy3 = (float*)((char *)iplGy->imageData + (y+1) * iplGy->widthStep);
		float *pGxy3 = (float*)((char *)iplGxy->imageData + (y+1) * iplGxy->widthStep);
		float *pGxx4 = (float*)((char *)iplGx->imageData + (y+2) * iplGx->widthStep);
		float *pGyy4 = (float*)((char *)iplGy->imageData + (y+2) * iplGy->widthStep);
		float *pGxy4 = (float*)((char *)iplGxy->imageData + (y+2) * iplGxy->widthStep);
		// initialize the first 4 columns
		for (int x=0; x<4; x++) {
			pGxxLine[x] = pGxx0[x] + pGxx1[x] + pGxx2[x] + pGxx3[x] + pGxx4[x];
			pGxyLine[x] = pGxy0[x] + pGxy1[x] + pGxy2[x] + pGxy3[x] + pGxy4[x];
			pGyyLine[x] = pGyy0[x] + pGyy1[x] + pGyy2[x] + pGyy3[x] + pGyy4[x];
		}
		// tensor calculation
		for (int x=start; x<iplTen->width-end; x++) {
			// calculate tensor matrix T = [pxx pxy; pxy pyy] in wnd_num * wnd_num window
			// calculate sum in right-most column
			int index = x+2;
			float pxx = pGxx0[index] + pGxx1[index] + pGxx2[index] + pGxx3[index] + pGxx4[index];
			float pxy = pGxy0[index] + pGxy1[index] + pGxy2[index] + pGxy3[index] + pGxy4[index];
			float pyy = pGyy0[index] + pGyy1[index] + pGyy2[index] + pGyy3[index] + pGyy4[index];
			// store in line buffers
			pGxxLine[index] = pxx;
			pGxyLine[index] = pxy;
			pGyyLine[index] = pyy;
			// sum to other columns
			pxx += pGxxLine[x-2] + pGxxLine[x-1] + pGxxLine[x] + pGxxLine[x+1];
			pxy += pGxyLine[x-2] + pGxyLine[x-1] + pGxyLine[x] + pGxyLine[x+1];
			pyy += pGyyLine[x-2] + pGyyLine[x-1] + pGyyLine[x] + pGyyLine[x+1];
			// calculate eigenvalues
			float k = (pxx+pyy) * (pxx+pyy) - 4 * (pxx * pyy - pxy * pxy);
			if ( k<=0.0f) continue;
			float temp1 = (float)sqrt(k);// * 0.5f;
			float temp2 = (pxx + pyy);// * 0.5f;
			float eg1 =  temp2 + temp1;		// since temp2 > 0 && temp1 > 0, eg1 must be larger than eg2
			float eg2 = temp2 - temp1;
			eg2 = eg2 < 0 ? -eg2 : eg2;	// abs
			// calculate the degree of anisotropy 
			float edge_regular;
			if (eg2 == 0.0f) {		// this equals to eg1 == eg2 == 0!
				edge_regular = 1.0;		// NOTE: we consider a constant window as "well-aligned" (i.e. regular region)
			} else {
				edge_regular = (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2));
			}
			// calculate corner
			float corner = eg2 / (1024.0f * 128.0f);
			corner = corner > 1.0f ? 1.0f : corner;
			// fusion
            //pCor[x] = corner;
			pTen[x] = edge_regular + corner;
		}
	}
	//saveImage("_Tensor.bmp", iplTen, 0, 255.0f);
    //saveImage("_Corner.bmp", iplCor, 0, 255.0f);

	// resize
	if (nWidth != iplStruct->width || nHeight != iplStruct->height) {
		resize(iplTen, iplStruct, SR_INTER_LINEAR);		// Sept.4, 2014: use bilinear instead of NN, since it has been proved that NN is ok in fixed-point (FPGA) implementation
	} else {
		copy(iplTen, iplStruct);
	}

	safeReleaseImage(&iplSrc0, &iplSrc, &iplGx, &iplGy, &iplGxy);
    safeReleaseImage(&iplCor, &iplTen);
	if (pGxxLine != NULL) delete [] pGxxLine;
	if (pGxyLine != NULL) delete [] pGxyLine;
	if (pGyyLine != NULL) delete [] pGyyLine;

	return true;
}

bool CImageUtility::extrStructMap5x5_o1_32f(IplImage *iplImage, IplImage *iplStruct, int ds_level)
// Calculate the tensor map of an image, using 5x5 window
// Supposing gx = Gradx(I) and gy = Grady(I), the tensor matrix is T = [ sum(gx*gx) sum(gx*gy); sum(gy*gx), sum(gy*gy) ]
// the tensor-based isotropy at a point is (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2)). Moreover, the corner
// point likelihood is alphs*eg2. The function map a sum of the isotropy and the corner likelihood to 0~1, where 1 denotes 
// the pixel in structure region. This function supports the tensor estimation on a downsampled image, where ds_level denotes 
// the level (1/2) of the pyramid image (0 denotes no downsample)
// Different from function extrStructMap5x5_32f(), this function (1) ;
// Argument:
//		iplImage -- [I] 1-channel input image, 32F or 8U datatype
//		iplStruct -- [O] 1-channel result image, 32F datatype
//		ds_level -- [I] downsample level, 0 for no downsample
// by Luhong Liang, IC-ASD, ASTRI, Aug. 28, 2013
{
	if (iplImage == NULL || iplStruct == NULL || ds_level < 0 ||
		iplImage->nChannels != 1 || iplStruct->nChannels != 1 || iplStruct->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type or argument in CImageUtility::extrStructMap5x5_o1_32f()!\n");
		return false;
	}

	int ds_factor = 1;
	if (ds_level > 0) {
		ds_factor = ds_factor << ds_level;
	} 
	int nWidth = iplImage->width >> ds_level;
	int nHeight = iplImage->height >> ds_level;
	if (nWidth * ds_factor != iplImage->width || nHeight * ds_factor != iplImage->height) {
		showErrMsg("Warning: non-integer multiplication in the pyramid in CImageUtility::extrStructMap5x5_o1_32f()!\n");
	}

	IplImage *iplSrc0 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplSrc = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplGx = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplGy = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplGxy = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	IplImage *iplTen = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
    IplImage *iplCor = createImage( nWidth, nHeight, SR_DEPTH_32F, 1 );
	float *pGxxLine = new float[iplImage->width];		// use line buffer instead of FIFO to simplify the management
	float *pGxyLine = new float[iplImage->width];
	float *pGyyLine = new float[iplImage->width];
	if (iplSrc0 == NULL ||iplSrc == NULL || iplGx == NULL || iplGy == NULL || iplGxy == NULL || iplTen == NULL ||
		iplCor == NULL || pGxxLine == NULL || pGxyLine == NULL || pGyyLine == NULL)  {
		safeReleaseImage(&iplSrc0, &iplSrc, &iplGx, &iplGy, &iplGxy);
        safeReleaseImage(&iplCor, &iplTen);
		if (pGxxLine != NULL) delete [] pGxxLine;
		if (pGxyLine != NULL) delete [] pGxyLine;
		if (pGyyLine != NULL) delete [] pGyyLine;
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap5x5_o1_32f()!\n");
		return false;
	}

	// data type conversion
	if (iplImage->depth == SR_DEPTH_32F) {
		copy(iplImage, iplSrc0);
	} else if (iplImage->depth == SR_DEPTH_8U) {
		cvtImage8Uto32F(iplImage, iplSrc0);
	} else {
		showErrMsg("Input image must be 8U or 32F in CImageUtility::extrStructMap5x5_o1_32f()!\n");
		safeReleaseImage(&iplSrc0, &iplSrc, &iplGx, &iplGy, &iplGxy);
        safeReleaseImage(&iplCor, &iplTen);
		return false;
	}

	// calculate pyramid image
	if (!meanPyrDown_32f(iplSrc0, iplSrc, ds_level)) {
		safeReleaseImage(&iplSrc0, &iplSrc, &iplGx, &iplGy, &iplGxy);
        safeReleaseImage(&iplCor, &iplTen);
	    if (pGxxLine != NULL) delete [] pGxxLine;
	    if (pGxyLine != NULL) delete [] pGxyLine;
	    if (pGyyLine != NULL) delete [] pGyyLine;
        return false;
	}

	// calculate gradient
	sobel_32f(iplSrc, iplGx, 0);			// do not use OpenCV function here
	sobel_32f(iplSrc, iplGy, 1);

	// calculate tensor 
	mulImage_32f(iplGx, iplGy, iplGxy);
	mulImage_32f(iplGx, iplGx, iplGx);
	mulImage_32f(iplGy, iplGy, iplGy);
	//extrSumMap5x5_32f(iplGxy); 	extrSumMap5x5_32f(iplGx); 	extrSumMap5x5_32f(iplGy); //<-- not use integral image due to the numerical error!

	setZero(iplTen);
    setZero(iplCor);
	const int wnd_size = 5;
	const int start = wnd_size >> 1;
	const int end = wnd_size - start - 1;
	for (int y=start; y<iplTen->height-end; y++) {
		float *pTen = (float*)((char *)iplTen->imageData + y * iplTen->widthStep);
        //float *pCor = (float*)((char *)iplCor->imageData + y * iplCor->widthStep);
		float *pGxx0 = (float*)((char *)iplGx->imageData + (y-2) * iplGx->widthStep);
		float *pGyy0 = (float*)((char *)iplGy->imageData + (y-2) * iplGy->widthStep);
		float *pGxy0 = (float*)((char *)iplGxy->imageData + (y-2) * iplGxy->widthStep);
		float *pGxx1 = (float*)((char *)iplGx->imageData + (y-1) * iplGx->widthStep);
		float *pGyy1 = (float*)((char *)iplGy->imageData + (y-1) * iplGy->widthStep);
		float *pGxy1 = (float*)((char *)iplGxy->imageData + (y-1) * iplGxy->widthStep);
		float *pGxx2 = (float*)((char *)iplGx->imageData + y * iplGx->widthStep);
		float *pGyy2 = (float*)((char *)iplGy->imageData + y * iplGy->widthStep);
		float *pGxy2 = (float*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
		float *pGxx3 = (float*)((char *)iplGx->imageData + (y+1) * iplGx->widthStep);
		float *pGyy3 = (float*)((char *)iplGy->imageData + (y+1) * iplGy->widthStep);
		float *pGxy3 = (float*)((char *)iplGxy->imageData + (y+1) * iplGxy->widthStep);
		float *pGxx4 = (float*)((char *)iplGx->imageData + (y+2) * iplGx->widthStep);
		float *pGyy4 = (float*)((char *)iplGy->imageData + (y+2) * iplGy->widthStep);
		float *pGxy4 = (float*)((char *)iplGxy->imageData + (y+2) * iplGxy->widthStep);
        //float *pGx = (float*)((char *)iplGx->imageData + y * iplGx->widthStep);
        //float *pGy = (float*)((char *)iplGy->imageData + y * iplGy->widthStep);
        //float *pGxy = (float*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
		// initialize the first 4 columns
		for (int x=0; x<4; x++) {
			pGxxLine[x] = pGxx0[x] + pGxx1[x] + pGxx2[x] + pGxx3[x] + pGxx4[x];
			pGxyLine[x] = pGxy0[x] + pGxy1[x] + pGxy2[x] + pGxy3[x] + pGxy4[x];
			pGyyLine[x] = pGyy0[x] + pGyy1[x] + pGyy2[x] + pGyy3[x] + pGyy4[x];
		}
		// tensor calculation
		for (int x=start; x<iplTen->width-end; x++) {
			// calculate tensor matrix T = [pxx pxy; pxy pyy] in wnd_num * wnd_num window
			// calculate sum in right-most column
			int index = x+2;
			float pxx = pGxx0[index] + pGxx1[index] + pGxx2[index] + pGxx3[index] + pGxx4[index];
			float pxy = pGxy0[index] + pGxy1[index] + pGxy2[index] + pGxy3[index] + pGxy4[index];
			float pyy = pGyy0[index] + pGyy1[index] + pGyy2[index] + pGyy3[index] + pGyy4[index];
			// store in line buffers
			pGxxLine[index] = pxx;
			pGxyLine[index] = pxy;
			pGyyLine[index] = pyy;
			// sum to other columns
			pxx += pGxxLine[x-2] + pGxxLine[x-1] + pGxxLine[x] + pGxxLine[x+1];
			pxy += pGxyLine[x-2] + pGxyLine[x-1] + pGxyLine[x] + pGxyLine[x+1];
			pyy += pGyyLine[x-2] + pGyyLine[x-1] + pGyyLine[x] + pGyyLine[x+1];
			// calculate eigenvalues
			float k = (pxx+pyy) * (pxx+pyy) - 4 * (pxx * pyy - pxy * pxy);
			if ( k<=0.0f) continue;
			float temp1 = (float)sqrt(k);// * 0.5f;
			float temp2 = (pxx + pyy);// * 0.5f;
			float eg1 =  temp2 + temp1;		// since temp2 > 0 && temp1 > 0, eg1 must be larger than eg2
			float eg2 = temp2 - temp1;
			eg2 = eg2 < 0 ? -eg2 : eg2;	// abs
			// calculate the degree of anisotropy 
			float edge_regular;
			if (eg2 == 0.0f) {		// this equals to eg1 == eg2 == 0!
				edge_regular = 1.0;		// NOTE: we consider a constant window as "well-aligned" (i.e. regular region)
			} else {
				edge_regular = (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2));
			}
			// calculate corner
			float corner = eg2 / (1024.0f * 128.0f);
			corner = corner > 1.0f ? 1.0f : corner;
			// fusion
            //pCor[x] = corner;
			pTen[x] = edge_regular + corner;
		}
	}
	//saveImage("_Tensor.bmp", iplTen, 0, 255.0f);
    //saveImage("_Corner.bmp", iplCor, 0, 255.0f);

	// resize
	if (nWidth != iplStruct->width || nHeight != iplStruct->height) {
		resize(iplTen, iplStruct, SR_INTER_NN);		// considering implemention in the loop, use NN
	} else {
		copy(iplTen, iplStruct);
	}

	safeReleaseImage(&iplSrc0, &iplSrc, &iplGx, &iplGy, &iplGxy);
    safeReleaseImage(&iplCor, &iplTen);
	if (pGxxLine != NULL) delete [] pGxxLine;
	if (pGxyLine != NULL) delete [] pGxyLine;
	if (pGyyLine != NULL) delete [] pGyyLine;

	return true;
}

bool CImageUtility::extrStructMap5x5_o2_32f(IplImage *iplImage, IplImage *iplStruct)
// Calculate the tensor map of an image, using 5x5 window
// Supposing gx = Gradx(I) and gy = Grady(I), the tensor matrix is T = [ sum(gx*gx) sum(gx*gy); sum(gy*gx), sum(gy*gy) ]
// the tensor-based isotropy at a point is (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2)). Moreover, the corner
// point likelihood is alphs*eg2. The function map a sum of the isotropy and the corner likelihood to 0~1, where 1 denotes 
// the pixel in structure region. This function supports the tensor estimation on a downsampled image, where ds_level denotes 
// the level (1/2) of the pyramid image (0 denotes no downsample)
// Different from function extrStructMap5x5_o1_32f(), this function
//      (1) abandoned the pyramid image
//      (2) reduced the memory consumption
//      (3) only supports the 32F input and output 
// Argument:
//		iplImage -- [I] 1-channel input image, 32F or 8U datatype
//		iplStruct -- [O] 1-channel result image, 32F datatype
// by Luhong Liang, IC-ASD, ASTRI, Sept. 6, 2013
{ 
	if (iplImage == NULL || iplStruct == NULL || iplImage->nChannels != 1 || 
        iplStruct->nChannels != 1 || iplImage->depth != SR_DEPTH_32F || iplStruct->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type or argument in CImageUtility::extrStructMap5x5_o2_32f()!\n");
		return false;
	}

	IplImage *iplGx = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGy = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGxy = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	float *pGxxLine = new float[iplImage->width];		// use line buffer instead of FIFO to simplify the management
	float *pGxyLine = new float[iplImage->width];
	float *pGyyLine = new float[iplImage->width];
	if (iplGx == NULL || iplGy == NULL || iplGxy == NULL ||
		pGxxLine == NULL || pGxyLine == NULL || pGyyLine == NULL)  {
		safeReleaseImage(&iplGx, &iplGy, &iplGxy);
		if (pGxxLine != NULL) delete [] pGxxLine;
		if (pGxyLine != NULL) delete [] pGxyLine;
		if (pGyyLine != NULL) delete [] pGyyLine;
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap5x5_o2_32f()!\n");
		return false;
	}

	// calculate gradient
	sobel_32f(iplImage, iplGx, 0);			// do not use OpenCV function here
	sobel_32f(iplImage, iplGy, 1);

	// calculate tensor 
	mulImage_32f(iplGx, iplGy, iplGxy);
	mulImage_32f(iplGx, iplGx, iplGx);
	mulImage_32f(iplGy, iplGy, iplGy);
	//extrSumMap5x5_32f(iplGxy); 	extrSumMap5x5_32f(iplGx); 	extrSumMap5x5_32f(iplGy); //<-- not use integral image due to the numerical error!

	setZero(iplStruct);
	const int wnd_size = 5;
	const int start = wnd_size >> 1;
	const int end = wnd_size - start - 1;
	for (int y=start; y<iplStruct->height-end; y++) {
		float *pTen = (float*)((char *)iplStruct->imageData + y * iplStruct->widthStep);
		float *pGxx0 = (float*)((char *)iplGx->imageData + (y-2) * iplGx->widthStep);
		float *pGyy0 = (float*)((char *)iplGy->imageData + (y-2) * iplGy->widthStep);
		float *pGxy0 = (float*)((char *)iplGxy->imageData + (y-2) * iplGxy->widthStep);
		float *pGxx1 = (float*)((char *)iplGx->imageData + (y-1) * iplGx->widthStep);
		float *pGyy1 = (float*)((char *)iplGy->imageData + (y-1) * iplGy->widthStep);
		float *pGxy1 = (float*)((char *)iplGxy->imageData + (y-1) * iplGxy->widthStep);
		float *pGxx2 = (float*)((char *)iplGx->imageData + y * iplGx->widthStep);
		float *pGyy2 = (float*)((char *)iplGy->imageData + y * iplGy->widthStep);
		float *pGxy2 = (float*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
		float *pGxx3 = (float*)((char *)iplGx->imageData + (y+1) * iplGx->widthStep);
		float *pGyy3 = (float*)((char *)iplGy->imageData + (y+1) * iplGy->widthStep);
		float *pGxy3 = (float*)((char *)iplGxy->imageData + (y+1) * iplGxy->widthStep);
		float *pGxx4 = (float*)((char *)iplGx->imageData + (y+2) * iplGx->widthStep);
		float *pGyy4 = (float*)((char *)iplGy->imageData + (y+2) * iplGy->widthStep);
		float *pGxy4 = (float*)((char *)iplGxy->imageData + (y+2) * iplGxy->widthStep);
        //float *pGx = (float*)((char *)iplGx->imageData + y * iplGx->widthStep);
        //float *pGy = (float*)((char *)iplGy->imageData + y * iplGy->widthStep);
        //float *pGxy = (float*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
		// initialize the first 4 columns
		for (int x=0; x<4; x++) {
			pGxxLine[x] = pGxx0[x] + pGxx1[x] + pGxx2[x] + pGxx3[x] + pGxx4[x];
			pGxyLine[x] = pGxy0[x] + pGxy1[x] + pGxy2[x] + pGxy3[x] + pGxy4[x];
			pGyyLine[x] = pGyy0[x] + pGyy1[x] + pGyy2[x] + pGyy3[x] + pGyy4[x];
		}
		// tensor calculation
		for (int x=start; x<iplStruct->width-end; x++) {
			// calculate tensor matrix T = [pxx pxy; pxy pyy] in wnd_num * wnd_num window
			// calculate sum in right-most column
			int index = x+2;
			float pxx = pGxx0[index] + pGxx1[index] + pGxx2[index] + pGxx3[index] + pGxx4[index];
			float pxy = pGxy0[index] + pGxy1[index] + pGxy2[index] + pGxy3[index] + pGxy4[index];
			float pyy = pGyy0[index] + pGyy1[index] + pGyy2[index] + pGyy3[index] + pGyy4[index];
			// store in line buffers
			pGxxLine[index] = pxx;
			pGxyLine[index] = pxy;
			pGyyLine[index] = pyy;
			// sum to other columns
			pxx += pGxxLine[x-2] + pGxxLine[x-1] + pGxxLine[x] + pGxxLine[x+1];
			pxy += pGxyLine[x-2] + pGxyLine[x-1] + pGxyLine[x] + pGxyLine[x+1];
			pyy += pGyyLine[x-2] + pGyyLine[x-1] + pGyyLine[x] + pGyyLine[x+1];
			// calculate eigenvalues
			float k = (pxx+pyy) * (pxx+pyy) - 4 * (pxx * pyy - pxy * pxy);
			if ( k<=0.0f) continue;
			float temp1 = (float)sqrt(k);// * 0.5f;
			float temp2 = (pxx + pyy);// * 0.5f;
			float eg1 =  temp2 + temp1;		// since temp2 > 0 && temp1 > 0, eg1 must be larger than eg2
			float eg2 = temp2 - temp1;
			eg2 = eg2 < 0 ? -eg2 : eg2;	// abs
			// calculate the degree of anisotropy 
			float edge_regular;
			if (eg2 == 0.0f) {		// this equals to eg1 == eg2 == 0!
				edge_regular = 1.0;		// NOTE: we consider a constant window as "well-aligned" (i.e. regular region)
			} else {
				edge_regular = (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2));
			}
			// calculate corner
			float corner = eg2 / (1024.0f * 128.0f);
			corner = corner > 1.0f ? 1.0f : corner;
			// fusion
			pTen[x] = edge_regular + corner;
            //pTen[x] = edge_regular;       // for debug only
		}
	}

	safeReleaseImage(&iplGx, &iplGy, &iplGxy);
	if (pGxxLine != NULL) delete [] pGxxLine;
	if (pGxyLine != NULL) delete [] pGxyLine;
	if (pGyyLine != NULL) delete [] pGyyLine;

	return true;
}

bool CImageUtility::extrStructMap5x5_o2_32f(IplImage *iplImage, IplImage *iplRegular, IplImage *iplCorner)
// Calculate the tensor map of an image, using 5x5 window
// Supposing gx = Gradx(I) and gy = Grady(I), the tensor matrix is T = [ sum(gx*gx) sum(gx*gy); sum(gy*gx), sum(gy*gy) ]
// the tensor-based isotropy at a point is (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2)). Moreover, the corner
// point likelihood is alphs*eg2. The function map a sum of the isotropy and the corner likelihood to 0~1, where 1 denotes 
// the pixel in structure region. This function supports the tensor estimation on a downsampled image, where ds_level denotes 
// the level (1/2) of the pyramid image (0 denotes no downsample)
// Different from function extrStructMap5x5_o1_32f(), this function
//      (1) abandoned the pyramid image
//      (2) reduced the memory consumption
//      (3) only supports the 32F input and output 
// Argument:
//		iplImage -- [I] 1-channel input image, 32F or 8U datatype
//		iplRegular -- [O] 1-channel regularity image (1 denotes random texture), 32F datatype
//     iplCorner -- [O] 1-channel corner image (1 denotes corner), 32F datatype
// by Luhong Liang, IC-ASD, ASTRI, April 15, 2014
{       
	if (iplImage == NULL || iplRegular == NULL || iplCorner == NULL || iplImage->nChannels != 1 ||      // TODO: complete check
        iplRegular->nChannels != 1 || iplImage->depth != SR_DEPTH_32F || iplRegular->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type or argument in CImageUtility::extrStructMap5x5_o2_32f()!\n");
		return false;
	}

	IplImage *iplGx = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGy = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGxy = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	float *pGxxLine = new float[iplImage->width];		// use line buffer instead of FIFO to simplify the management
	float *pGxyLine = new float[iplImage->width];
	float *pGyyLine = new float[iplImage->width];
	if (iplGx == NULL || iplGy == NULL || iplGxy == NULL ||
		pGxxLine == NULL || pGxyLine == NULL || pGyyLine == NULL)  {
		safeReleaseImage(&iplGx, &iplGy, &iplGxy);
		if (pGxxLine != NULL) delete [] pGxxLine;
		if (pGxyLine != NULL) delete [] pGxyLine;
		if (pGyyLine != NULL) delete [] pGyyLine;
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap5x5_o2_32f()!\n");
		return false;
	}

	// calculate gradient
	sobel_32f(iplImage, iplGx, 0);			// do not use OpenCV function here
	sobel_32f(iplImage, iplGy, 1);

	// calculate tensor 
	mulImage_32f(iplGx, iplGy, iplGxy);
	mulImage_32f(iplGx, iplGx, iplGx);
	mulImage_32f(iplGy, iplGy, iplGy);
	//extrSumMap5x5_32f(iplGxy); 	extrSumMap5x5_32f(iplGx); 	extrSumMap5x5_32f(iplGy); //<-- not use integral image due to the numerical error!

	setZero(iplRegular);
    setZero(iplCorner);
	const int wnd_size = 5;
	const int start = wnd_size >> 1;
	const int end = wnd_size - start - 1;
	for (int y=start; y<iplRegular->height-end; y++) {
		float *pTen = (float*)((char *)iplRegular->imageData + y * iplRegular->widthStep);
        float *pCor = (float*)((char *)iplCorner->imageData + y * iplCorner->widthStep);
		float *pGxx0 = (float*)((char *)iplGx->imageData + (y-2) * iplGx->widthStep);
		float *pGyy0 = (float*)((char *)iplGy->imageData + (y-2) * iplGy->widthStep);
		float *pGxy0 = (float*)((char *)iplGxy->imageData + (y-2) * iplGxy->widthStep);
		float *pGxx1 = (float*)((char *)iplGx->imageData + (y-1) * iplGx->widthStep);
		float *pGyy1 = (float*)((char *)iplGy->imageData + (y-1) * iplGy->widthStep);
		float *pGxy1 = (float*)((char *)iplGxy->imageData + (y-1) * iplGxy->widthStep);
		float *pGxx2 = (float*)((char *)iplGx->imageData + y * iplGx->widthStep);
		float *pGyy2 = (float*)((char *)iplGy->imageData + y * iplGy->widthStep);
		float *pGxy2 = (float*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
		float *pGxx3 = (float*)((char *)iplGx->imageData + (y+1) * iplGx->widthStep);
		float *pGyy3 = (float*)((char *)iplGy->imageData + (y+1) * iplGy->widthStep);
		float *pGxy3 = (float*)((char *)iplGxy->imageData + (y+1) * iplGxy->widthStep);
		float *pGxx4 = (float*)((char *)iplGx->imageData + (y+2) * iplGx->widthStep);
		float *pGyy4 = (float*)((char *)iplGy->imageData + (y+2) * iplGy->widthStep);
		float *pGxy4 = (float*)((char *)iplGxy->imageData + (y+2) * iplGxy->widthStep);
        //float *pGx = (float*)((char *)iplGx->imageData + y * iplGx->widthStep);
        //float *pGy = (float*)((char *)iplGy->imageData + y * iplGy->widthStep);
        //float *pGxy = (float*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
		// initialize the first 4 columns
		for (int x=0; x<4; x++) {
			pGxxLine[x] = pGxx0[x] + pGxx1[x] + pGxx2[x] + pGxx3[x] + pGxx4[x];
			pGxyLine[x] = pGxy0[x] + pGxy1[x] + pGxy2[x] + pGxy3[x] + pGxy4[x];
			pGyyLine[x] = pGyy0[x] + pGyy1[x] + pGyy2[x] + pGyy3[x] + pGyy4[x];
		}
		// tensor calculation
		for (int x=start; x<iplRegular->width-end; x++) {
			// calculate tensor matrix T = [pxx pxy; pxy pyy] in wnd_num * wnd_num window
			// calculate sum in right-most column
			int index = x+2;
			float pxx = pGxx0[index] + pGxx1[index] + pGxx2[index] + pGxx3[index] + pGxx4[index];
			float pxy = pGxy0[index] + pGxy1[index] + pGxy2[index] + pGxy3[index] + pGxy4[index];
			float pyy = pGyy0[index] + pGyy1[index] + pGyy2[index] + pGyy3[index] + pGyy4[index];
			// store in line buffers
			pGxxLine[index] = pxx;
			pGxyLine[index] = pxy;
			pGyyLine[index] = pyy;
			// sum to other columns
			pxx += pGxxLine[x-2] + pGxxLine[x-1] + pGxxLine[x] + pGxxLine[x+1];
			pxy += pGxyLine[x-2] + pGxyLine[x-1] + pGxyLine[x] + pGxyLine[x+1];
			pyy += pGyyLine[x-2] + pGyyLine[x-1] + pGyyLine[x] + pGyyLine[x+1];
			// calculate eigenvalues
			float k = (pxx+pyy) * (pxx+pyy) - 4 * (pxx * pyy - pxy * pxy);
			if ( k<=0.0f) continue;
			float temp1 = (float)sqrt(k);// * 0.5f;
			float temp2 = (pxx + pyy);// * 0.5f;
			float eg1 =  temp2 + temp1;		// since temp2 > 0 && temp1 > 0, eg1 must be larger than eg2
			float eg2 = temp2 - temp1;
			eg2 = eg2 < 0 ? -eg2 : eg2;	// abs
			// calculate the degree of anisotropy 
			float edge_regular;
			if (eg2 == 0.0f) {		// this equals to eg1 == eg2 == 0!
				edge_regular = 1.0;		// NOTE: we consider a constant window as "well-aligned" (i.e. regular region)
			} else {
				edge_regular = (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2));
			}
            pTen[x] = edge_regular;

			// calculate corner
            const float k_factor = 0.0625f;
            eg1 = eg1 / 65526.0f;
            eg2 = eg2 / 65526.0f;
            float corner = ((eg1 * eg2 - k_factor * (eg1 + eg2) * (eg1 + eg2))) * 0.25f;
            corner = corner < 0.0f ? 0.0f : corner;
            pCor[x] = corner > 1.0f ? 1.0f : corner;
            //float corner = eg2 / (1024.0f * 128.0f);
			//corner = corner > 1.0f ? 1.0f : corner;
            //pCor[x] = corner;
		}
	}

	safeReleaseImage(&iplGx, &iplGy, &iplGxy);
	if (pGxxLine != NULL) delete [] pGxxLine;
	if (pGxyLine != NULL) delete [] pGxyLine;
	if (pGyyLine != NULL) delete [] pGyyLine;

	return true;
}

bool CImageUtility::extrStructMap5x5_o3_32f(IplImage *iplImage, IplImage *iplStruct, IplImage *iplCorner)
// Calculate the tensor map of an image, using 5x5 window
// Supposing gx = Gradx(I) and gy = Grady(I), the tensor matrix is T = [ sum(gx*gx) sum(gx*gy); sum(gy*gx), sum(gy*gy) ]
// the tensor-based isotropy at a point is (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2)). Moreover, the corner
// point likelihood is alphs*eg2. The function map a sum of the isotropy and the corner likelihood to 0~1, where 1 denotes 
// the pixel in structure region. This function supports the tensor estimation on a downsampled image, where ds_level denotes 
// the level (1/2) of the pyramid image (0 denotes no downsample)
// Different from function extrStructMap5x5_o1_32f(), this function
//      (1) abandoned the pyramid image (feature of o2)
//      (2) reduced the memory consumption (feature of o2)
//      (3) only supports the 32F input and output (feature of o2)
//      (4) check the gradient and set low gradient region as "structure"
//      (5) Output corner detection result (optional)
// Argument:
//		iplImage -- [I] 1-channel input image, 32F or 8U datatype
//		iplStruct -- [O] 1-channel result image, 32F datatype, 
//                       where '1' represents 'structure' and '0' represents 'texture.
//     iplCorner -- [O] optional output of corner detection
// by Luhong Liang, IC-ASD, ASTRI, March 10, 2014
// March 18, 2014: Output corner detection result (optional)
{ 
	if (iplImage == NULL || iplStruct == NULL || iplImage->nChannels != 1 || 
        iplStruct->nChannels != 1 || iplImage->depth != SR_DEPTH_32F || iplStruct->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type or argument in CImageUtility::extrStructMap5x5_o3_32f()!\n");
		return false;
	}

	IplImage *iplGx = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGy = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGxy = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
    IplImage *iplGm = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	float *pGxxLine = new float[iplImage->width];		// use line buffer instead of FIFO to simplify the management
	float *pGxyLine = new float[iplImage->width];
	float *pGyyLine = new float[iplImage->width];
	if (iplGx == NULL || iplGy == NULL || iplGxy == NULL || iplGm == NULL ||
		pGxxLine == NULL || pGxyLine == NULL || pGyyLine == NULL)  {
		safeReleaseImage(&iplGx, &iplGy, &iplGxy, &iplGm);
		if (pGxxLine != NULL) delete [] pGxxLine;
		if (pGxyLine != NULL) delete [] pGxyLine;
		if (pGyyLine != NULL) delete [] pGyyLine;
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap5x5_o3_32f()!\n");
		return false;
	}

	// calculate gradient
    sobel_32f(iplImage, iplGm, 3);
    //saveImage("_Sobelx16.bmp", iplGm, 0, 16.0f);
	sobel_32f(iplImage, iplGx, 0);			// do not use OpenCV function here
	sobel_32f(iplImage, iplGy, 1);

	// calculate tensor 
	mulImage_32f(iplGx, iplGy, iplGxy);
	mulImage_32f(iplGx, iplGx, iplGx);
	mulImage_32f(iplGy, iplGy, iplGy);
	//extrSumMap5x5_32f(iplGxy); 	extrSumMap5x5_32f(iplGx); 	extrSumMap5x5_32f(iplGy); //<-- not use integral image due to the numerical error!
    //saveImage("_Gm.bmp", iplGm);    saveImage("_Gxx.bmp", iplGx);    saveImage("_Gyy.bmp", iplGy);    saveImage("_Gxy.bmp", iplGxy);

	setZero(iplStruct);
    if (iplCorner != NULL) {
        setZero(iplCorner);
    }
	const int wnd_size = 5;
	const int start = wnd_size >> 1;
	const int end = wnd_size - start - 1;
    float *pCor = NULL;
	for (int y=start; y<iplStruct->height-end; y++) {
		float *pTen = (float*)((char *)iplStruct->imageData + y * iplStruct->widthStep);
        float *pGabs = (float*)((char *)iplGm->imageData + y * iplGm->widthStep);
		float *pGxx0 = (float*)((char *)iplGx->imageData + (y-2) * iplGx->widthStep);
		float *pGyy0 = (float*)((char *)iplGy->imageData + (y-2) * iplGy->widthStep);
		float *pGxy0 = (float*)((char *)iplGxy->imageData + (y-2) * iplGxy->widthStep);
		float *pGxx1 = (float*)((char *)iplGx->imageData + (y-1) * iplGx->widthStep);
		float *pGyy1 = (float*)((char *)iplGy->imageData + (y-1) * iplGy->widthStep);
		float *pGxy1 = (float*)((char *)iplGxy->imageData + (y-1) * iplGxy->widthStep);
		float *pGxx2 = (float*)((char *)iplGx->imageData + y * iplGx->widthStep);
		float *pGyy2 = (float*)((char *)iplGy->imageData + y * iplGy->widthStep);
		float *pGxy2 = (float*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
		float *pGxx3 = (float*)((char *)iplGx->imageData + (y+1) * iplGx->widthStep);
		float *pGyy3 = (float*)((char *)iplGy->imageData + (y+1) * iplGy->widthStep);
		float *pGxy3 = (float*)((char *)iplGxy->imageData + (y+1) * iplGxy->widthStep);
		float *pGxx4 = (float*)((char *)iplGx->imageData + (y+2) * iplGx->widthStep);
		float *pGyy4 = (float*)((char *)iplGy->imageData + (y+2) * iplGy->widthStep);
		float *pGxy4 = (float*)((char *)iplGxy->imageData + (y+2) * iplGxy->widthStep);
        //float *pGx = (float*)((char *)iplGx->imageData + y * iplGx->widthStep);
        //float *pGy = (float*)((char *)iplGy->imageData + y * iplGy->widthStep);
        //float *pGxy = (float*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
        if (iplCorner != NULL) {
            pCor = (float*)((char *)iplCorner->imageData + y * iplCorner->widthStep);
        }
		// initialize the first 4 columns
		for (int x=0; x<4; x++) {
			pGxxLine[x] = pGxx0[x] + pGxx1[x] + pGxx2[x] + pGxx3[x] + pGxx4[x];
			pGxyLine[x] = pGxy0[x] + pGxy1[x] + pGxy2[x] + pGxy3[x] + pGxy4[x];
			pGyyLine[x] = pGyy0[x] + pGyy1[x] + pGyy2[x] + pGyy3[x] + pGyy4[x];
		}
		// tensor calculation
		for (int x=start; x<iplStruct->width-end; x++) {
            // calculate tensor matrix T = [pxx pxy; pxy pyy] in wnd_num * wnd_num window
            // calculate sum in right-most column
            int index = x+2;
            float pxx = pGxx0[index] + pGxx1[index] + pGxx2[index] + pGxx3[index] + pGxx4[index];
            float pxy = pGxy0[index] + pGxy1[index] + pGxy2[index] + pGxy3[index] + pGxy4[index];
            float pyy = pGyy0[index] + pGyy1[index] + pGyy2[index] + pGyy3[index] + pGyy4[index];
            // store in line buffers
            pGxxLine[index] = pxx;
            pGxyLine[index] = pxy;
            pGyyLine[index] = pyy;
            // check gradient
            //if (x == 803 && y==67)
            //    int p = 1;
            float gabs = pGabs[x];
            //float w_g = 0.0f;
            //if (gabs < 4.0f) {
            //    w_g = (4.0f - gabs) / 4.0f;
            //}
            //pTen[x] = w_g * 64;            continue;
            // sum to other columns
            pxx += pGxxLine[x-2] + pGxxLine[x-1] + pGxxLine[x] + pGxxLine[x+1];
            pxy += pGxyLine[x-2] + pGxyLine[x-1] + pGxyLine[x] + pGxyLine[x+1];
            pyy += pGyyLine[x-2] + pGyyLine[x-1] + pGyyLine[x] + pGyyLine[x+1];
            // calculate eigenvalues
            float k = (pxx+pyy) * (pxx+pyy) - 4 * (pxx * pyy - pxy * pxy);
            //pTen[x] = k / 256.0f; continue;
            if ( k<=0.0f) {
                // This means the isolated points, considered as structure!!!!!
                pTen[x] = 1.0f;
                if (pCor != NULL) {
                    pCor[x] = 0.0f;
                }
            } else {
			    float temp1 = (float)sqrt(k);// * 0.5f;
			    float temp2 = (pxx + pyy);// * 0.5f;
			    float eg1 =  temp2 + temp1;		// since temp2 > 0 && temp1 > 0, eg1 must be larger than eg2
			    float eg2 = temp2 - temp1;
			    eg2 = eg2 < 0 ? -eg2 : eg2;	// abs
			    // calculate the degree of anisotropy 
			    float edge_regular;
			    if (eg2 == 0.0f) {		// this equals to eg1 == eg2 == 0!
				    edge_regular = 1.0;		// NOTE: we consider a constant window as "well-aligned" (i.e. regular region)
			    } else {
				    edge_regular = (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2));
			    }
			    // calculate corner
			    float corner = eg2 / (1024.0f * 128.0f);
			    corner = corner > 1.0f ? 1.0f : corner;
                // weight for gradient
                float w_g = 0.0f;
                if (gabs < 4.0f) {
                    w_g = (4.0f - gabs) / 4.0f;
                }
			    // fusion
                float ten = (edge_regular + corner) * (1.0f - w_g) + w_g;
                //ten = ten < 0.0f ? 0.0f : ten;
                ten = ten > 1.0f ? 1.0f : ten;
			    pTen[x] = ten;
                //pTen[x] = w_g;       // for debug only
                if (pCor != NULL) {
                    //pCor[x] = eg2 / (1024.0f * 128.0f);
                    const float k_factor = 0.0625f;
                    eg1 = eg1 / 65526.0f;
                    eg2 = eg2 / 65526.0f;
                    float corner = ((eg1 * eg2 - k_factor * (eg1 + eg2) * (eg1 + eg2))) * 0.25f;
                    corner = corner < 0.0f ? 0.0f : corner;
                    pCor[x] = corner > 1.0f ? 1.0f : corner;
                }
            }
		}
	}
    //saveImage("_TensorCorner.bmp", iplStruct, 0, 255.0f);

	safeReleaseImage(&iplGx, &iplGy, &iplGxy, &iplGm);
	if (pGxxLine != NULL) delete [] pGxxLine;
	if (pGxyLine != NULL) delete [] pGxyLine;
	if (pGyyLine != NULL) delete [] pGyyLine;

	return true;
}

bool CImageUtility::extrStructMap5x5_o3a_32f(IplImage *iplImage, IplImage *iplStruct, IplImage *iplGrad, IplImage *iplCorner, bool downsample)
// Calculate the tensor map of an image, using 5x5 window
// Supposing gx = Gradx(I) and gy = Grady(I), the tensor matrix is T = [ sum(gx*gx) sum(gx*gy); sum(gy*gx), sum(gy*gy) ]
// the tensor-based isotropy at a point is (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2)). Moreover, the corner
// point likelihood is alphs*eg2. The function map a sum of the isotropy and the corner likelihood to 0~1, where 1 denotes 
// the pixel in structure region. This function supports the tensor estimation on a downsampled image, where ds_level denotes 
// the level (1/2) of the pyramid image (0 denotes no downsample)
// Different from function extrStructMap5x5_o1_32f(), this function
//      (1) abandoned the pyramid image (feature of o2)
//      (2) reduced the memory consumption (feature of o2)
//      (3) only supports the 32F input and output (feature of o2)
//      (4) check the gradient and set low gradient region as "structure"
//      (5) Output corner detection result (optional)
// Compared with extrStructMap5x5_o3_32f(), this function is a fast version with sobel gradient output:
//      (6) The input image iplImage has been padded 3 pixels in each direction
//      (7) move the Sobel + Max5x5 into this function and use boxing filter instead of max filter
//      (8) Added regularity and MAD calculation in downsampled source image
// Argument:
//		iplImage -- [I] 1-channel input image, 32F or 8U datatype, has been padded 3 pixels in each direction
//		iplStruct -- [O] 1-channel result image, 32F datatype
//     iplGrad -- [O] sobel gradient
//     iplCorner -- [O] optional output of corner detection
//     downsample -- [I] "true" to calculate the regularity, graident and corner in downsampled source image
// by Luhong Liang, IC-ASD, ASTRI, March 10, 2014
// July 18, 2014: Output corner detection result (optional)
// Setp 5, 2014: Added regularity and MAD calculation in downsampled source image
{ 
	if (iplImage == NULL || iplStruct == NULL || iplImage->nChannels != 1 || 
        iplStruct->nChannels != 1 || iplGrad->nChannels != 1 ||
        iplImage->depth != SR_DEPTH_32F || iplStruct->depth != SR_DEPTH_32F || iplGrad->depth != SR_DEPTH_32F ||
        iplImage->width != iplStruct->width+6 || iplImage->height != iplStruct->height+6 ||
        iplStruct->width != iplGrad->width || iplStruct->height != iplGrad->height) {
		showErrMsg("Invalid input image type or argument in CImageUtility::extrStructMap5x5_o3a_32f()!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    return extrStructMap5x5_o3a_32f_SIMD(iplImage, iplStruct, iplGrad, iplCorner);
#endif

    // use alias buffer to be compatible with non-downsample case (Sept. 2014)
    IplImage *iplImageBackup = iplImage;
    IplImage *iplStructBackup = iplStruct;
    IplImage *iplCornerBackup = iplCorner;
    if (downsample) {
        IplImage *iplImgOrg = unpadding(iplImage, 3, 3, 3, 3);
        IplImage *iplImgOrgDs = createImage(iplImgOrg->width/2, iplImgOrg->height/2, SR_DEPTH_32F, 1); 
        resize_2to1_bilinear_32f(iplImgOrg, iplImgOrgDs);
        iplImage = padding(iplImgOrgDs, 3, 3, 3, 3);        // alias
        safeReleaseImage(&iplImgOrg, &iplImgOrgDs);
        iplStruct = createImage(iplImage->width-6, iplImage->height-6, SR_DEPTH_32F, 1);      // alias
        iplCorner = createImage(iplImage->width-6, iplImage->height-6, SR_DEPTH_32F, 1);    // alias
        if (iplImage == NULL || iplStruct == NULL || iplCorner == NULL) {
            safeReleaseImage(&iplImage, &iplStruct, &iplCorner);
            return false;
        }
    }

	IplImage *iplGx = createImage( iplImage->width-2, iplImage->height-2, SR_DEPTH_32F, 1 );
	IplImage *iplGy = createImage( iplImage->width-2, iplImage->height-2, SR_DEPTH_32F, 1 );
	IplImage *iplGxy = createImage( iplImage->width-2, iplImage->height-2, SR_DEPTH_32F, 1 );
    IplImage *iplGm = createImage( iplImage->width-2, iplImage->height-2, SR_DEPTH_32F, 1 );
	float *pGxxLine = new float[iplImage->width];		// use line buffer instead of FIFO to simplify the management
	float *pGxyLine = new float[iplImage->width];
	float *pGyyLine = new float[iplImage->width];
	if (iplGx == NULL || iplGy == NULL || iplGxy == NULL || iplGm == NULL ||
		pGxxLine == NULL || pGxyLine == NULL || pGyyLine == NULL)  {
		safeReleaseImage(&iplGx, &iplGy, &iplGxy, &iplGm);
		if (pGxxLine != NULL) delete [] pGxxLine;
		if (pGxyLine != NULL) delete [] pGxyLine;
		if (pGyyLine != NULL) delete [] pGyyLine;
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap5x5_o3a_32f()!\n");
		return false;
	}

	// calculate gradient
    for (int y=0; y<iplGxy->height; y++) {
        float *pSrcN = (float *)((char *)iplImage->imageData + y * iplImage->widthStep);
        float *pSrc0 = (float *)((char *)iplImage->imageData + (y+1) * iplImage->widthStep);
        float *pSrc1 = (float *)((char *)iplImage->imageData + (y+2) * iplImage->widthStep);
        float *pGx = (float *)((char *)iplGx->imageData + y * iplGx->widthStep);
        float *pGy = (float *)((char *)iplGy->imageData + y * iplGy->widthStep);
        float *pGxy = (float *)((char *)iplGxy->imageData + y * iplGxy->widthStep);
        float *pGm = (float *)((char *)iplGm->imageData + y * iplGm->widthStep);
        for (int x=0; x<iplGxy->width; x++) {
            // -1 0 1
            // -2 0 2
            // -1 0 1
            float grad_x = ( - pSrcN[x]         + pSrcN[x+2]
                                    - pSrc0[x] * 2.0f + pSrc0[x+2] * 2.0f
                                    - pSrc1[x]          + pSrc1[x+2] );
            // -1  -2  -1
            //  0   0   0
            //  1   2   1
			float grad_y = ( - pSrcN[x] - pSrcN[x+1] * 2.0f - pSrcN[x+2]
			                       + pSrc1[x] + pSrc1[x+1] * 2.0f + pSrc1[x+2] );
            // Gxx
            pGx[x] = (grad_x * grad_x) * 0.0625f;
            // Gyy
            pGy[x] = (grad_y * grad_y) * 0.0625f;
            // Gxy 
            pGxy[x] = (grad_x * grad_y) * 0.0625f;
            // Gm
            grad_x = grad_x < 0.0f ? - grad_x : grad_x;
            grad_y = grad_y < 0.0f ? - grad_y : grad_y;
            pGm[x] = (grad_x + grad_y) * 0.125f;
        }
    }
    //saveImage("_Gm_o3a.bmp", iplGm);    saveImage("_Gxx_o3a.bmp", iplGx);    saveImage("_Gyy_o3a.bmp", iplGy);    saveImage("_Gxy_o3a.bmp", iplGxy);   

    // Tensor
    float *pCor = NULL;
	for (int y=0; y<iplStruct->height; y++) {
		float *pTen = (float*)((char *)iplStruct->imageData + y * iplStruct->widthStep);
        float *pGabs = (float*)((char *)iplGm->imageData + (y+2) * iplGm->widthStep);
		float *pGxx0 = (float*)((char *)iplGx->imageData + y * iplGx->widthStep);
		float *pGyy0 = (float*)((char *)iplGy->imageData + y * iplGy->widthStep);
		float *pGxy0 = (float*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
		float *pGxx1 = (float*)((char *)iplGx->imageData + (y+1) * iplGx->widthStep);
		float *pGyy1 = (float*)((char *)iplGy->imageData + (y+1) * iplGy->widthStep);
		float *pGxy1 = (float*)((char *)iplGxy->imageData + (y+1) * iplGxy->widthStep);
		float *pGxx2 = (float*)((char *)iplGx->imageData + (y+2) * iplGx->widthStep);
		float *pGyy2 = (float*)((char *)iplGy->imageData + (y+2) * iplGy->widthStep);
		float *pGxy2 = (float*)((char *)iplGxy->imageData + (y+2) * iplGxy->widthStep);
		float *pGxx3 = (float*)((char *)iplGx->imageData + (y+3) * iplGx->widthStep);
		float *pGyy3 = (float*)((char *)iplGy->imageData + (y+3) * iplGy->widthStep);
		float *pGxy3 = (float*)((char *)iplGxy->imageData + (y+3) * iplGxy->widthStep);
		float *pGxx4 = (float*)((char *)iplGx->imageData + (y+4) * iplGx->widthStep);
		float *pGyy4 = (float*)((char *)iplGy->imageData + (y+4) * iplGy->widthStep);
		float *pGxy4 = (float*)((char *)iplGxy->imageData + (y+4) * iplGxy->widthStep);
        //float *pGx = (float*)((char *)iplGx->imageData + y * iplGx->widthStep);
        //float *pGy = (float*)((char *)iplGy->imageData + y * iplGy->widthStep);
        //float *pGxy = (float*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
        if (iplCorner != NULL) {
            pCor = (float*)((char *)iplCorner->imageData + y * iplCorner->widthStep);
        }
		// initialize the first 4 columns
		for (int x=0; x<4; x++) {
			pGxxLine[x] = pGxx0[x] + pGxx1[x] + pGxx2[x] + pGxx3[x] + pGxx4[x];
			pGxyLine[x] = pGxy0[x] + pGxy1[x] + pGxy2[x] + pGxy3[x] + pGxy4[x];
			pGyyLine[x] = pGyy0[x] + pGyy1[x] + pGyy2[x] + pGyy3[x] + pGyy4[x];
		}
		// tensor calculation
		for (int x=0; x<iplStruct->width; x++) {
            // calculate tensor matrix T = [pxx pxy; pxy pyy] in wnd_num * wnd_num window
            // calculate sum in right-most column
            int index = x+4;
            float pxx = pGxx0[index] + pGxx1[index] + pGxx2[index] + pGxx3[index] + pGxx4[index];
            float pxy = pGxy0[index] + pGxy1[index] + pGxy2[index] + pGxy3[index] + pGxy4[index];
            float pyy = pGyy0[index] + pGyy1[index] + pGyy2[index] + pGyy3[index] + pGyy4[index];
            // store in line buffers
            pGxxLine[index] = pxx;
            pGxyLine[index] = pxy;
            pGyyLine[index] = pyy;
            // check gradient
            //if (x == 803 && y==67)
            //    int p = 1;
            float gabs = pGabs[x+2];        // +2 for alignment
            //float w_g = 0.0f;
            //if (gabs < 4.0f) {
            //    w_g = (4.0f - gabs) / 4.0f;
            //}
            //pTen[x] = w_g * 64;            continue;
            // sum to other columns
            pxx += pGxxLine[x] + pGxxLine[x+1] + pGxxLine[x+2] + pGxxLine[x+3];
            pxy += pGxyLine[x] + pGxyLine[x+1] + pGxyLine[x+2] + pGxyLine[x+3];
            pyy += pGyyLine[x] + pGyyLine[x+1] + pGyyLine[x+2] + pGyyLine[x+3];
            // calculate eigenvalues
            float k = (pxx+pyy) * (pxx+pyy) - 4 * (pxx * pyy - pxy * pxy);
            //pTen[x] = k / 256.0f; continue;
            if ( k<=0.0f) {
                // This means the isolated points, considered as structure!!!!!
                pTen[x] = 1.0f;
                if (pCor != NULL) {
                    pCor[x] = 0.0f;
                }
            } else {
			    float temp1 = (float)sqrt(k);// * 0.5f;
			    float temp2 = (pxx + pyy);// * 0.5f;
			    float eg1 =  temp2 + temp1;		// since temp2 > 0 && temp1 > 0, eg1 must be larger than eg2
			    float eg2 = temp2 - temp1;
			    eg2 = eg2 < 0 ? -eg2 : eg2;	// abs
			    // calculate the degree of anisotropy 
			    float edge_regular;
			    if (eg2 == 0.0f) {		// this equals to eg1 == eg2 == 0!
				    edge_regular = 1.0;		// NOTE: we consider a constant window as "well-aligned" (i.e. regular region)
			    } else {
				    edge_regular = (eg1 - eg2) * (eg1 - eg2) / ((eg1 + eg2) * (eg1 + eg2));
			    }
			    // calculate corner
			    float corner = eg2 / (1024.0f * 128.0f);
			    corner = corner > 1.0f ? 1.0f : corner;
                // weight for gradient
                float w_g = 0.0f;
                if (gabs < 4.0f) {
                    w_g = (4.0f - gabs) / 4.0f;
                }
			    // fusion
                float ten = (edge_regular + corner) * (1.0f - w_g) + w_g;
                //ten = ten < 0.0f ? 0.0f : ten;
                ten = ten > 1.0f ? 1.0f : ten;
			    pTen[x] = ten;
                //pTen[x] = w_g;       // for debug only
                if (pCor != NULL) {
                    //pCor[x] = eg2 / (1024.0f * 128.0f);
                    const float k_factor = 0.0625f;
                    eg1 = eg1 / 65526.0f;
                    eg2 = eg2 / 65526.0f;
                    float corner = ((eg1 * eg2 - k_factor * (eg1 + eg2) * (eg1 + eg2))) * 0.25f;
                    corner = corner < 0.0f ? 0.0f : corner;
                    pCor[x] = corner > 1.0f ? 1.0f : corner;
                }
            }
		}
	}
    //saveImage("_TensorCorner.bmp", iplStruct, 0, 255.0f);

	safeReleaseImage(&iplGx, &iplGy, &iplGxy);
	if (pGxxLine != NULL) delete [] pGxxLine;
	if (pGxyLine != NULL) delete [] pGxyLine;
	if (pGyyLine != NULL) delete [] pGyyLine;

    if (downsample) {       // Sept. 2014
        // resize regularity
        inter_1to2_bilinear_32f(iplStruct, iplStructBackup);
        if (iplCornerBackup != NULL) {
            inter_1to2_bilinear_32f(iplCorner, iplCornerBackup);
        }
        safeReleaseImage(&iplImage, &iplStruct, &iplCorner);       

        // re-calculate Gm
        safeReleaseImage(&iplGm);
        iplGm = createImage( iplImageBackup->width-2, iplImageBackup->height-2, SR_DEPTH_32F, 1 );
        if (iplGm == NULL) return false;
        for (int y=0; y<iplGm->height; y++) {
            float *pSrcN = (float *)((char *)iplImageBackup->imageData + y * iplImageBackup->widthStep);
            float *pSrc0 = (float *)((char *)iplImageBackup->imageData + (y+1) * iplImageBackup->widthStep);
            float *pSrc1 = (float *)((char *)iplImageBackup->imageData + (y+2) * iplImageBackup->widthStep);
            float *pGm = (float *)((char *)iplGm->imageData + y * iplGm->widthStep);
            for (int x=0; x<iplGm->width; x++) {
                // -1 0 1
                // -2 0 2
                // -1 0 1
                float grad_x = ( - pSrcN[x]         + pSrcN[x+2]
                                        - pSrc0[x] * 2.0f + pSrc0[x+2] * 2.0f
                                        - pSrc1[x]          + pSrc1[x+2] );
                // -1  -2  -1
                //  0   0   0
                //  1   2   1
			    float grad_y = ( - pSrcN[x] - pSrcN[x+1] * 2.0f - pSrcN[x+2]
					                   + pSrc1[x] + pSrc1[x+1] * 2.0f + pSrc1[x+2] );
                // Gm
                grad_x = grad_x < 0.0f ? - grad_x : grad_x;
                grad_y = grad_y < 0.0f ? - grad_y : grad_y;
                pGm[x] = (grad_x + grad_y) * 0.125f;
		    }
        }
    } 

    boxing5x5_o1_32f(iplGm, iplGrad);

    safeReleaseImage(&iplGm);

	return true;
}

bool CImageUtility::extrStructMap_int(IplImage *iplImage, IplImage *iplStruct, int wnd_size, int bit_depth)
// Calculate the tensor map of an image.
// This a fixed-point implementation of function extrStructMap_32f() (w/o piece-wise linear function!)
// Argument:
//		iplImage -- [I] input image, 32s data type
//		iplStruct -- [O] result tensor map, 8U data type
//		wnd_size -- [I] window size for tensor calculation
//		bit_depth -- [I] bit depth of iplImage, only support 8, 10 and 12
// by Luhong Liang, IC-ASD, ASTRI, Jan. 15, 2012
{
	if (iplImage == NULL || iplStruct == NULL || wnd_size < 3 || (bit_depth != 8 && bit_depth != 10 && bit_depth != 12) ||
		iplImage->nChannels != 1 || iplStruct->nChannels != 1 || iplImage->depth != SR_DEPTH_32S ||
		iplStruct->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type or argument in CImageUtility::extrStructMap_int()!\n");
		return false;
	}

	const int max_tensor = 255;

	int nWidth = iplImage->width;
	int nHeight = iplImage->height;
	IplImage *iplGx = createImage( nWidth, nHeight, SR_DEPTH_32S, 1 );
	IplImage *iplGy = createImage( nWidth, nHeight, SR_DEPTH_32S, 1 );
	IplImage *iplGxy = createImage( nWidth, nHeight, SR_DEPTH_32S, 1 );
	if (iplGx == NULL || iplGy == NULL || iplGxy == NULL)  {
		safeReleaseImage(&iplGx, &iplGy, &iplGxy);
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap_int()!\n");
		return false;
	}

	int clip_high_s = (1 << (bit_depth-1)) - 1;
	int clip_low_s = -clip_high_s;

	// calculate gradient
	sobel_int(iplImage, iplGx, 0, clip_low_s, clip_high_s);			// NOTE: the gradient is divided by 2 to keep the same bit-depth!
	//saveImage("_SobelX_Int12.bmp", iplGx, 128, 1.0f, bit_depth);
	sobel_int(iplImage, iplGy, 1, clip_low_s, clip_high_s);			// NOTE: the gradient is divided by 2 to keep the same bit-depth!
	//saveImage("_SobelY_Int12.bmp", iplGy, 128, 1.0f, bit_depth);

	// prepare tensor calculation (cross-correlation, 14-bit)
	int norm_shift = (bit_depth -8) * 2 + 2;		// normalize all bit-depth to 14 bits
	for (int y=0; y<iplGxy->height; y++) {
		int *pGx = (int*)((char *)iplGx->imageData + y * iplGx->widthStep);
		int *pGy = (int*)((char *)iplGy->imageData + y * iplGy->widthStep);
		int *pGxy = (int*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
		for (int x=0; x<iplGxy->width; x++) {
			pGxy[x] = (pGx[x] * pGy[x]) >> norm_shift;		// bug fixed: 2013.1.28
			pGx[x] = (pGx[x] * pGx[x]) >> norm_shift;
			pGy[x] = (pGy[x] * pGy[x]) >> norm_shift;
		}
	}

	// prepare tensor calculate (approximated sqrt and division)
	int pSqrtLUT[256];			// actually 4-bit
	for (int i=0; i<256; i++) {
		pSqrtLUT[i] = (int)(sqrt((float)i) + 0.5f);
	}

	int pDivLUT[256];			// actually 12-bit
	for (int i=1; i<256; i++) {
		pDivLUT[i] = 4095 / i;
	}
	pDivLUT[0] = 4095;

	// calculate structure measurement
	setZero(iplStruct);		// ignore boundary
	int start = wnd_size >> 1;
	int end = wnd_size - start - 1;
	//IplImage *iplTenOnly = createImage( nWidth, nHeight, SR_DEPTH_8U, 1 );	// for debug only
	//IplImage *iplCorOnly = createImage( nWidth, nHeight, SR_DEPTH_8U, 1 );	// for debug only
	//setZero(iplTenOnly);
	//setZero(iplCorOnly);
	for (int y=start; y<iplStruct->height-end; y++) {
		unsigned char *pTen = (unsigned char*)((char *)iplStruct->imageData + y * iplStruct->widthStep);
		//unsigned char *pTenOnly = (unsigned char*)((char *)iplTenOnly->imageData + y * iplTenOnly->widthStep);	// for debug only
		//unsigned char *pCorOnly = (unsigned char*)((char *)iplCorOnly->imageData + y * iplCorOnly->widthStep);	// for debug only
		for (int x=start; x<iplStruct->width-end; x++) {
			// calculate tensor matrix T = [pxx pxy; pxy pyy] in wnd_num * wnd_num window
			int pxx = 0, pxy = 0, pyy = 0;
			for (int v = y - start; v < y - start + wnd_size; v++) {
				int *pGxx = (int*)((char *)iplGx->imageData + v * iplGx->widthStep);
				int *pGyy = (int*)((char *)iplGy->imageData + v * iplGy->widthStep);
				int *pGxy = (int*)((char *)iplGxy->imageData + v * iplGxy->widthStep);
				for (int u = x - start; u < x - start + wnd_size; u++) {
					pxx += pGxx[u];
					pxy += pGxy[u];
					pyy += pGyy[u];
				}
			}
			// calculate eigenvalues
			int shift_count = 0;	// right shift --> add
			int edge_regular, corner;
			if (!(pxx < 4096 && pyy < 4096 && pxy < 2048 && pxy > -2048)) {
				// divided by 32 for large values to make sure the data is less than 14 bits
				pxx = pxx >> 5;		
				pxy = pxy >> 5;
				pyy = pyy >> 5;
				shift_count += 5;
			}
			unsigned int k = ((pxx+pyy) * (pxx+pyy) - ((pxx * pyy - pxy * pxy) << 2));		// 32-bit for k, so 14-bit for pxx, pyy, pxy, considering the div approximation, make them 12-bit
			if ( k <= 0) {
				edge_regular = 0;
				corner = 0;
			} else {
				// scaling k to avoid overflow in approximated sqrt
				if (k >=  64 * 64 * 256) {
					k = k >> 6;
					pxx = pxx >> 3;		
					pxy = pxy >> 3;
					pyy = pyy >> 3;				
					shift_count += 3;
				}
				// approximate sqrt(k)
				int sqrt_k;
				if (k < 256) {
					sqrt_k = pSqrtLUT[k];
				} else if (k < 64 * 256) {
					sqrt_k = (pSqrtLUT[k>>6]) << 3;
				} else if (k < 64 * 64 * 256) {
					sqrt_k = (pSqrtLUT[k>>12]) << 6;
				} else {
					// this should never happen
					sqrt_k = 64 * 16;
				}
				// calculate eigenvalues and then sort them (eg1 > eg2), eg1 and eg2 less than bit_depth
				int quad_b = pxx + pyy;		// 13-bit
				int eg1 = quad_b + sqrt_k;	// 14-bit
				int eg2 = quad_b - sqrt_k;
				eg2 = eg2 < 0 ? -eg2 : eg2;	// abs
				// calculate the degree of anisotropy 
				if (eg2 == 0) {		// this equals to eg1 == eg2 == 0!
					edge_regular = max_tensor;		// NOTE: we consider a constant window as "well-aligned" (i.e. regular region)
				} else {
					// scaling eg1 eg2 to avoid overflow in approximated division
					if (eg1 >= 4096) {		// exceeds 12 bits
						eg1 = eg1 >> 4;
						eg2 = eg2 >> 4;
						shift_count += 4;
					}
					// calculate numberator and denominator
					int num = (eg1 - eg2) * (eg1 - eg2);		// numerator, 32-bit
					int den = (eg1 + eg2) * (eg1 + eg2);		// denominator, 32-bit
					// apprpoxmiate the division
					if (den < 256) {
						// NOTE 1: num < den, impossible to overflow
						// NOTE 2: pDivLUT is 12-bit, to get 8-bit result, right-shift 4 bits
						edge_regular = (pDivLUT[den] * num) >> 4; 
					} else if (den < 64 * 255) {
						// NOTE: num < den, so num is less than 14 bits, no overflow for 32-bit
						edge_regular = (pDivLUT[(den+32)>>6] * num) >> 10; 
					} else if (den < 64 * 64 * 255) {
						// NOTE: num < den, so num is less than 20 bits
						edge_regular = (pDivLUT[(den+2048)>>12] * (num>>4)) >> 12; 
					} else if (den < 64 * 64 * 64 * 255) {
						// NOTE: num < den, so num is less than 26 bits
						edge_regular = (pDivLUT[(den+131072L)>>18] * (num>>10)) >> 12; 
					} else {
						// NOTE: when we cannot calculate the regularity, we assume it is the regular region
						edge_regular = max_tensor;	
					}
				}
				// calculate corner
				corner = (eg2 << shift_count) >> 5;
			}
			//pCorOnly[x] = corner > 255 ? 255 : corner;		// for debug only
			//pTenOnly[x] = edge_regular > 255 ? 255 : edge_regular;		// for debug only
			// fusion
			int tex = edge_regular + corner;
			pTen[x] = (unsigned char)(tex > 255 ? 255 : tex);		// clipping
		}
	}
	//saveImage("_TensorOrg_Int12.bmp", iplTenOnly, 0, 1.0f);
	//saveImage("_CornerOrg_Int12.bmp", iplCorOnly, 0, 1.0f);
	//saveImage("_TensorCornerOrg_Int12.bmp", iplStruct, 0, 1.0f);

	safeReleaseImage(&iplGx, &iplGy, &iplGxy);

	return true;
}

int CImageUtility::div_Int24_8U(unsigned int N, unsigned int D)
// Division using repeated subtraction
// The output quotient is 8U
// D must larger than zero!
{
	int q_bit = 0x80;
	int quotient = 0;
	D = D << 7;
	// bit 7
	if (N >= D) {
		quotient = quotient | q_bit;
		N = N - D;	
	}
	D = D >> 1;
	q_bit = q_bit >> 1;
	// bit 6
	if (N >= D) {
		quotient = quotient | q_bit;
		N = N - D;	
	}
	D = D >> 1;
	q_bit = q_bit >> 1;
	// bit 5
	if (N >= D) {
		quotient = quotient | q_bit;
		N = N - D;	
	}
	D = D >> 1;
	q_bit = q_bit >> 1;
	// bit 4
	if (N >= D) {
		quotient = quotient | q_bit;
		N = N - D;	
	}
	D = D >> 1;
	q_bit = q_bit >> 1;
	// bit 3
	if (N >= D) {
		quotient = quotient | q_bit;
		N = N - D;	
	}
	D = D >> 1;
	q_bit = q_bit >> 1;
	// bit 2
	if (N >= D) {
		quotient = quotient | q_bit;
		N = N - D;	
	}
	D = D >> 1;
	q_bit = q_bit >> 1;
	// bit 1
	if (N >= D) {
		quotient = quotient | q_bit;
		N = N - D;	
	}
	D = D >> 1;
	q_bit = q_bit >> 1;
	// bit 0
	if (N >= D) {
		quotient = quotient | q_bit;
	}

	return quotient;
}

int CImageUtility::div_Int12_5U(unsigned int N, unsigned int D)
// Division using repeated subtraction
// The output quotient is 5U
// D must larger than zero!
{
	int q_bit = 0x10;
	int quotient = 0;
	D = D << 4;		// D: /w 16-bit
	// bit 4
	if (N >= D) {
		quotient = quotient | q_bit;
		N = N - D;	
	}
	D = D >> 1;
	q_bit = q_bit >> 1;
	// bit 3
	if (N >= D) {
		quotient = quotient | q_bit;
		N = N - D;	
	}
	D = D >> 1;
	q_bit = q_bit >> 1;
	// bit 2
	if (N >= D) {
		quotient = quotient | q_bit;
		N = N - D;	
	}
	D = D >> 1;
	q_bit = q_bit >> 1;
	// bit 1
	if (N >= D) {
		quotient = quotient | q_bit;
		N = N - D;	
	}
	D = D >> 1;
	q_bit = q_bit >> 1;
	// bit 0
	if (N >= D) {
		quotient = quotient | q_bit;
	}

	return quotient;
}

bool CImageUtility::isValidYUV(IplImage *iplY, IplImage *iplU, IplImage *iplV)
// valid pointers, same depth and valid sizes
{
    if (iplY == NULL || iplU == NULL || iplV == NULL) return false;

    if (iplY->depth != iplU->depth || iplY->depth != iplV->depth) return false;

    if (iplU->width == iplY->width && iplU->height == iplY->height &&
        iplV->width == iplY->width && iplV->height == iplY->height) return true;        // 4:4:4

    if (iplU->width*2 == iplY->width && iplU->height == iplY->height &&
        iplV->width*2 == iplY->width && iplV->height == iplY->height) return true;      // 4:2:2

    if (iplU->width*2 == iplY->width && iplU->height*2 == iplY->height &&
        iplV->width*2 == iplY->width && iplV->height*2 == iplY->height) return true;    // 4:2:0

    return false;
}

bool CImageUtility::extrStructMap5x5_8U(IplImage *iplImage, IplImage *iplStruct)
// Calculate the tensor map of an image.
// This is a fixed-point implementation of function extrStructMap_32f() (w/o piece-wise linear function!)
// This is a specified version of function extrStructMap_int() for 8U I/O and 5x5 window!
// Argument:
//		iplImage -- [I] input image, 32s data type
//		iplStruct -- [O] result tensor map, 8U data type
// by Luhong Liang, IC-ASD, ASTRI, Feb. 21, 2012
{
	if (iplImage == NULL || iplStruct == NULL || iplImage->nChannels != 1 || iplStruct->nChannels != 1 || 
		iplImage->depth != SR_DEPTH_8U || iplStruct->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input image type or argument in CImageUtility::extrStructMap5x5_8U()!\n");
		return false;
	}

	const int max_tensor = 255;

	int nWidth = iplImage->width;
	int nHeight = iplImage->height;
	IplImage *iplGx = createImage( nWidth, nHeight, SR_DEPTH_32S, 1 );
	IplImage *iplGy = createImage( nWidth, nHeight, SR_DEPTH_32S, 1 );
	IplImage *iplGxy = createImage( nWidth, nHeight, SR_DEPTH_32S, 1 );
	if (iplGx == NULL || iplGy == NULL || iplGxy == NULL)  {
		safeReleaseImage(&iplGx, &iplGy, &iplGxy);
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap5x5_8U()!\n");
		return false;
	}

	// calculate gradient
	sobel_8U_int(iplImage, iplGx, 0);			// NOTE: the gradient is divided by 2 to keep the same bit-depth!
	//saveImage("_SobelX.bmp", iplGx, 128, 1.0f, 8); 
	sobel_8U_int(iplImage, iplGy, 1);			// NOTE: the gradient is divided by 2 to keep the same bit-depth!
	//saveImage("_SobelY.bmp", iplGy, 128, 1.0f, 8); 

	// prepare tensor calculation (cross-correlation, 14-bit)
	for (int y=0; y<iplGxy->height; y++) {
		int *pGx = (int*)((char *)iplGx->imageData + y * iplGx->widthStep);
		int *pGy = (int*)((char *)iplGy->imageData + y * iplGy->widthStep);
		int *pGxy = (int*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
		for (int x=0; x<iplGxy->width; x++) {
			int gxy = (pGx[x] * pGy[x]);
			pGxy[x] = (gxy >= 64*256) ? 0x3FFF : gxy;	// clip to 14-bit instead of right shift
			int gxx = (pGx[x] * pGx[x]);// >> 2;
			pGx[x] = (gxx >= 64*256) ? 0x3FFF : gxx;
			int gyy = (pGy[x] * pGy[x]);// >> 2;
			pGy[x] = (gyy >= 64*256) ? 0x3FFF : gyy;
		}
	}

	// prepare tensor calculate (approximated sqrt and division)
	//int pSqrtLUT[256];			// actually 6-bit
	//for (int i=0; i<256; i++) {
	//	pSqrtLUT[i] = (int)(sqrt((float)i)*4+0.5f);
	//	if (pSqrtLUT[i] > 63) pSqrtLUT[i] = 63;
	//}
	int pSqrtLUT[256] =			// LUT[x] = clip(round(sqrt(x) * 4));
	   { 0, 4, 6, 7, 8, 9, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 20, 21, 21, 22, 22, 22,
		 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 32,
		 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 38, 39, 39, 39,
		 39, 39, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 43, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45,
		 45, 45, 46, 46, 46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 48, 48, 48, 48, 48, 48, 49, 49, 49, 49, 49, 49, 50, 50, 50, 50, 50, 50,
		 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 53, 53, 53, 53, 53, 53, 54, 54, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55,
		 55, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60,
		 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63 };

 // calculate structure measurement
	setZero(iplStruct);		// ignore boundary
	const int wnd_size = 5;
	const int start = wnd_size >> 1;
	const int end = wnd_size - start - 1;
	for (int y=start; y<iplStruct->height-end; y++) {
		unsigned char *pTen = (unsigned char*)((char *)iplStruct->imageData + y * iplStruct->widthStep);
		for (int x=start; x<iplStruct->width-end; x++) {
			// calculate tensor matrix T = [pxx pxy; pxy pyy] in wnd_num * wnd_num window
			int pxx = 0, pxy = 0, pyy = 0;
			for (int v = y - start; v < y - start + wnd_size; v++) {
				int *pGxx = (int*)((char *)iplGx->imageData + v * iplGx->widthStep);
				int *pGyy = (int*)((char *)iplGy->imageData + v * iplGy->widthStep);
				int *pGxy = (int*)((char *)iplGxy->imageData + v * iplGxy->widthStep);
				for (int u = x - start; u < x - start + wnd_size; u++) {
					pxx += pGxx[u];			// pxx: 19-bit (14-bit + 5-bit (25))
					pxy += pGxy[u];
					pyy += pGyy[u];
				}
			}
			// calculate eigenvalues
			int shift_count = 0;	// right shift --> add
			int edge_regular, corner;
			// keep pxx, pxy, pyy 14-bit
			if (!(pxx < 16384 && pyy < 16384 && pxy < 8192 && pxy > -8192)) {
				pxx = pxx >> 5;
				pxy = pxy >> 5;
				pyy = pyy >> 5;
				shift_count += 5;
			}
			unsigned int k = ((pxx+pyy) * (pxx+pyy) - ((pxx * pyy - pxy * pxy) << 2));		// 31-bit for k
			if ( k <= 0) {
				edge_regular = 0;
				corner = 0;
			} else {
				// keep k 24-bit, i.e. keep sqrt(k) 12-bit
				if (k >=  256 * 256 * 256) {
					k = k >> 6;			// shift 6 bit rather than 7/8 bit to keep precision, although k may be 31-bit <--- AA
					pxx = pxx >> 3;		
					pxy = pxy >> 3;
					pyy = pyy >> 3;				
					shift_count += 3;
				}
				// approximate sqrt(k), keep sqrt_k 12-bit
				int sqrt_k;
				if (k < 256) {
					sqrt_k = (pSqrtLUT[k]) >> 2;
				} else if (k < 64 * 256) {
					sqrt_k = (pSqrtLUT[k>>6]) << 1;
				} else if (k < 16 * 256 * 256) {
					sqrt_k = (pSqrtLUT[k>>12]) << 4;
				} else if (k < 256 * 256 * 256) {
					sqrt_k = (pSqrtLUT[k>>16]) << 6;
				} else {
					// this should never happen in natural image, but need it to avoid overflow in extreme situation (see AA)
					sqrt_k = 4095;
				}
				//sqrt_k = (int)sqrt((float)k);
				// calculate eigenvalues and then sort them (eg1 > eg2), eg1 and eg2 less than bit_depth
				int quad_b = pxx + pyy;			// 15-bit
				int eg1 = quad_b + sqrt_k;		// 16-bit
				int eg2 = quad_b - sqrt_k;		// 15-bit
				eg2 = eg2 < 0 ? -eg2 : eg2;	// abs
				// calculate the degree of anisotropy 
				if (eg2 == 0) {		// this equals to eg1 == eg2 == 0!
					edge_regular = max_tensor;		// NOTE: we consider a constant window as "well-aligned" (i.e. regular region)
				} else {
					// calculate numberator and denominator
					unsigned int num = eg1 - eg2;		// numerator, 16-bit
					unsigned int den = eg1 + eg2;		// denominator, 17-bit!
					// division: firstly, left-shift the numerator, since 0<=num/den<=1
					if (den >= 8 * 256) {		// keep den 12-bit
						den = den >> 5;
						num = num;
					} else {
						num = num << 5;
					}
					// division: secondly, get 5-bit results
					edge_regular = div_Int12_5U(num, den);					// edge_regular: 5-bit
					// calculate the edge regularity, shift to 8-bit, i.e. 0~255 represents a regularity of 0~1
					edge_regular = (edge_regular * edge_regular) >> 2;		// edge_regular: 8-bit
					//edge_regular = div_Int24_8U((num<<8), den);
				}
				// calculate corner
				corner = (eg2 << shift_count) >> 7;
			}
			// fusion
			int tex = edge_regular + corner;
			pTen[x] = (unsigned char)(tex > 255 ? 255 : tex);		// clipping
		}
	}

	safeReleaseImage(&iplGx, &iplGy, &iplGxy);

	//saveImage("_TexMAP_8Ui_8Uo_opt_2.bmp", iplStruct, 0, 1.0f);

	return true;
}

bool CImageUtility::extrStructMap5x5_8U_s5(IplImage *iplImage, IplImage *iplStruct)
// Calculate the tensor map of an image.
// This is a fixed-point implementation of function extrStructMap_32f() (w/o piece-wise linear function!)
// This is a specified version of function extrStructMap_int() for 8U I/O and 5x5 window!
// Different from extrStructMap5x5_8U(), this function supposes the input image has been padded!
// Argument:
//		iplImage -- [I] input image, 32s data type
//		iplStruct -- [O] result tensor map, 8U data type
// by Luhong Liang, IC-ASD, ASTRI, May. 27, 2012
{
	if (iplImage == NULL || iplStruct == NULL || iplImage->nChannels != 1 || iplStruct->nChannels != 1 || 
		iplImage->depth != SR_DEPTH_8U || iplStruct->depth != SR_DEPTH_8U ||
		iplImage->width != iplStruct->width+6 || iplImage->height != iplStruct->height+6) {
		showErrMsg("Invalid input image type or argument in CImageUtility::extrStructMap5x5_8U_s5()!\n");
		return false;
	}

	const int max_tensor = 255;

	IplImage *iplGx = createImage( iplImage->width-2, iplImage->height-2, SR_DEPTH_32S, 1 );
	IplImage *iplGy = createImage( iplImage->width-2, iplImage->height-2, SR_DEPTH_32S, 1 );
	IplImage *iplGxy = createImage( iplImage->width-2, iplImage->height-2, SR_DEPTH_32S, 1 );
	if (iplGx == NULL || iplGy == NULL || iplGxy == NULL)  {
		safeReleaseImage(&iplGx, &iplGy, &iplGxy);
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap5x5_8U_s5()!\n");
		return false;
	}

	// calculate gradient
	sobel_8U_int_s5(iplImage, iplGx, 0);			// NOTE: the gradient is divided by 2 to keep the same bit-depth!
	//saveImage("_SobelX_s5.bmp", iplGx, 128, 1.0f, 8); 
	sobel_8U_int_s5(iplImage, iplGy, 1);			// NOTE: the gradient is divided by 2 to keep the same bit-depth!
	//saveImage("_SobelY_s5.bmp", iplGy, 128, 1.0f, 8); 

	// prepare tensor calculation (cross-correlation, 14-bit)
	for (int y=0; y<iplGxy->height; y++) {
		int *pGx = (int*)((char *)iplGx->imageData + y * iplGx->widthStep);
		int *pGy = (int*)((char *)iplGy->imageData + y * iplGy->widthStep);
		int *pGxy = (int*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
		for (int x=0; x<iplGxy->width; x++) {
			//pGxy[x] = (gxy >= 64*256) ? 0x3FFF : gxy;	// clip to 14-bit instead of right shift
            int gxy = (pGx[x] * pGy[x]);
			pGxy[x] = (gxy >= 64*256) ? 0x3FFF : ((gxy < -64*256) ? 0x4001 : gxy);
			int gxx = (pGx[x] * pGx[x]);// >> 2;
			//pGx[x] = (gxx >= 64*256) ? 0x3FFF : gxx;
			pGx[x] = (gxx >= 64*256) ? 0x3FFF : ((gxx < -64*256) ? 0x4001 : gxx);
			int gyy = (pGy[x] * pGy[x]);// >> 2;
			//pGy[x] = (gyy >= 64*256) ? 0x3FFF : gyy;
			pGy[x] = (gyy >= 64*256) ? 0x3FFF : ((gyy < -64*256) ? 0x4001 : gyy);
		}
	}

	// prepare tensor calculate (approximated sqrt and division)
	int pSqrtLUT[256] =			// LUT[x] = clip(round(sqrt(x) * 4));
	   { 0, 4, 6, 7, 8, 9, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 20, 21, 21, 22, 22, 22,
		 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 32,
		 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 38, 39, 39, 39,
		 39, 39, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 43, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45,
		 45, 45, 46, 46, 46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 48, 48, 48, 48, 48, 48, 49, 49, 49, 49, 49, 49, 50, 50, 50, 50, 50, 50,
		 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 53, 53, 53, 53, 53, 53, 54, 54, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55,
		 55, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60,
		 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63 };

	// calculate structure measurement
	for (int y=0; y<iplStruct->height; y++) {
		unsigned char *pTen = (unsigned char*)((char *)iplStruct->imageData + y * iplStruct->widthStep);
		for (int x=0; x<iplStruct->width; x++) {
			// calculate tensor matrix T = [pxx pxy; pxy pyy] in wnd_num * wnd_num window
			int pxx = 0, pxy = 0, pyy = 0;
			for (int v = y; v < y+5; v++) {
				int *pGxx = (int*)((char *)iplGx->imageData + v * iplGx->widthStep);
				int *pGyy = (int*)((char *)iplGy->imageData + v * iplGy->widthStep);
				int *pGxy = (int*)((char *)iplGxy->imageData + v * iplGxy->widthStep);
				for (int u = x; u < x+5; u++) {
					pxx += pGxx[u];			// pxx: 19-bit (14-bit + 5-bit (25))
					pxy += pGxy[u];
					pyy += pGyy[u];
				}
			}
			// calculate eigenvalues
			int shift_count = 0;	// right shift --> add
			int edge_regular, corner;
			// keep pxx, pxy, pyy 14-bit
			if (!(pxx < 16384 && pyy < 16384 && pxy < 8192 && pxy > -8192)) {
				pxx = pxx >> 5;
				pxy = pxy >> 5;
				pyy = pyy >> 5;
				shift_count += 5;
			}
			unsigned int k = ((pxx+pyy) * (pxx+pyy) - ((pxx * pyy - pxy * pxy) << 2));		// 31-bit for k
			if ( k <= 0) {
				edge_regular = 0;
				corner = 0;
			} else {
				// keep k 24-bit, i.e. keep sqrt(k) 12-bit
				if (k >=  256 * 256 * 256) {
					k = k >> 6;			// shift 6 bit rather than 7/8 bit to keep precision, although k may be 31-bit <--- AA
					pxx = pxx >> 3;		
					pxy = pxy >> 3;
					pyy = pyy >> 3;				
					shift_count += 3;
				}
				// approximate sqrt(k), keep sqrt_k 12-bit
				int sqrt_k;
				if (k < 256) {
					sqrt_k = (pSqrtLUT[k]) >> 2;
				} else if (k < 64 * 256) {
					sqrt_k = (pSqrtLUT[k>>6]) << 1;
				} else if (k < 16 * 256 * 256) {
					sqrt_k = (pSqrtLUT[k>>12]) << 4;
				} else if (k < 256 * 256 * 256) {
					sqrt_k = (pSqrtLUT[k>>16]) << 6;
				} else {
					// this should never happen in natural image, but need it to avoid overflow in extreme situation (see AA)
					sqrt_k = 4095;
				}
				//sqrt_k = (int)sqrt((float)k);
				// calculate eigenvalues and then sort them (eg1 > eg2), eg1 and eg2 less than bit_depth
				int quad_b = pxx + pyy;			// 15-bit
				int eg1 = quad_b + sqrt_k;		// 16-bit
				int eg2 = quad_b - sqrt_k;		// 15-bit
				eg2 = eg2 < 0 ? -eg2 : eg2;	// abs
				// calculate the degree of anisotropy 
				if (eg2 == 0) {		// this equals to eg1 == eg2 == 0!
					edge_regular = max_tensor;		// NOTE: we consider a constant window as "well-aligned" (i.e. regular region)
				} else {
					// calculate numberator and denominator
					unsigned int num = eg1 - eg2;		// numerator, 16-bit
					unsigned int den = eg1 + eg2;		// denominator, 17-bit!
					// division: firstly, left-shift the numerator, since 0<=num/den<=1
					if (den >= 8 * 256) {		// keep den 12-bit
						den = den >> 5;
						num = num;
					} else {
						num = num << 5;
					}
					// division: secondly, get 5-bit results
					edge_regular = div_Int12_5U(num, den);					// edge_regular: 5-bit
					// calculate the edge regularity, shift to 8-bit, i.e. 0~255 represents a regularity of 0~1
					edge_regular = (edge_regular * edge_regular) >> 2;		// edge_regular: 8-bit
					//edge_regular = div_Int24_8U((num<<8), den);
				}
				// calculate corner
				corner = (eg2 << shift_count) >> 7;
			}
			// fusion
			int tex = edge_regular + corner;
			pTen[x] = (unsigned char)(tex > 255 ? 255 : tex);		// clipping
		}
	}

	safeReleaseImage(&iplGx, &iplGy, &iplGxy);

	//saveImage("_TexMAP_8Ui_8Uo_opt_2.bmp", iplStruct, 0, 1.0f);

	return true;
}

bool CImageUtility::extrStructMap5x5_8U_v2(IplImage *iplImage, IplImage *iplStruct, IplImage *iplGM, int atten_opt)
// Calculate the tensor map of an image.
// This is a fixed-point implementation refering to function extrStructMap5x5_o3_32f(), while part of the code 
// is the same as the function extrStructMap5x5_8U_s5().
// The differences from extrStructMap5x5_8U_s5() are:
// (1). Consider the perfect isotropic (mostly isolated point_ as structure
// (2). Add attenuation factor associated with local variance meastured by a Sobel operator followed by a morphology operation.
// This function supposes the input image has been padded!
// Argument:
//		iplImage -- [I] input image, 32s data type
//		iplStruct -- [O] result tensor map, 8U data type, 0 means texture and 255 means structure
//     iplGM -- [O] intermediate result of gradient magnitude followed by max-min operation
//     atten_opt -- [I] ttenuation factor associated with local variance 
//                             0 -- No attenuation
//                             1~5 -- more and more attenuation in low contrast  region
//                             recommended value is 3 or 4.
// by Luhong Liang, IC-ASD, ASTRI, May. 27, 2012
// July 15: (1) add output of iplGM for testing vector generation; (2) adjust the padding of min and max operation
{
	if (iplImage == NULL || iplStruct == NULL || iplGM == NULL || 
        iplImage->nChannels != 1 || iplStruct->nChannels != 1 ||  iplGM->nChannels != 1 || 
		iplImage->depth != SR_DEPTH_8U || iplStruct->depth != SR_DEPTH_8U ||  iplGM->depth != SR_DEPTH_8U ||
		iplImage->width != iplStruct->width+6 || iplImage->height != iplStruct->height+6 || 
        iplImage->width != iplGM->width+6 || iplImage->height != iplGM->height+6 || 
        atten_opt < 0 || atten_opt > 5) {
		showErrMsg("Invalid input image type or argument in CImageUtility::extrStructMap5x5_8U_v2()!\n");
		return false;
	}

	const int max_tensor = 255;

	IplImage *iplGx = createImage( iplImage->width-2, iplImage->height-2, SR_DEPTH_32S, 1 );
	IplImage *iplGy = createImage( iplImage->width-2, iplImage->height-2, SR_DEPTH_32S, 1 );
    IplImage *iplGm = createImage( iplImage->width-2, iplImage->height-2, SR_DEPTH_8U, 1 );
	IplImage *iplGxy = createImage( iplImage->width-2, iplImage->height-2, SR_DEPTH_32S, 1 );
	if (iplGx == NULL || iplGy == NULL || iplGxy == NULL || iplGm == NULL)  {
		safeReleaseImage(&iplGx, &iplGy, &iplGxy, &iplGm);
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrStructMap5x5_8U_v2()!\n");
		return false;
	}

	// calculate gradient
	sobel_8U_int_s5(iplImage, iplGx, 0);			// NOTE: the gradient is divided by 2 to keep the same bit-depth!
	//saveImage("_SobelX_s5.bmp", iplGx, 128, 1.0f, 8); 
	sobel_8U_int_s5(iplImage, iplGy, 1);			// NOTE: the gradient is divided by 2 to keep the same bit-depth!
	//saveImage("_SobelY_s5.bmp", iplGy, 128, 1.0f, 8); 
    //sobel_8U_int_s5(iplImage, iplGm, 3);            // modified by Luhong, June 17, 2014
    //saveImage("_SobelAbs.bmp", iplGm, 0, 8.0f, 8);      // NOTE: the values in resultant gradient is half of that of sobel_32f()!

	// prepare tensor calculation (cross-correlation, 14-bit)
	for (int y=0; y<iplGxy->height; y++) {
		int *pGx = (int*)((char *)iplGx->imageData + y * iplGx->widthStep);
		int *pGy = (int*)((char *)iplGy->imageData + y * iplGy->widthStep);
		int *pGxy = (int*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
        unsigned char *pGm = (unsigned char*)((char *)iplGm->imageData + y * iplGm->widthStep);
		for (int x=0; x<iplGxy->width; x++) {
            // for magnitude
            int grad_x = pGx[x];
            int grad_y = pGy[x];
            grad_x = grad_x < 0 ? -grad_x : grad_x;
            grad_y = grad_y < 0 ? -grad_y : grad_y;
            int grad_xy = grad_x + grad_y;
            pGm[x] = (unsigned char)(grad_xy > 255 ? 255 : grad_xy);
            //pGm[x] = grad_m > 255 ? 255 : grad_m;
            // for tensor calculation
			//pGxy[x] = (gxy >= 64*256) ? 0x3FFF : gxy;	// clip to 14-bit instead of right shift
            int gxy = (pGx[x] * pGy[x]);
			pGxy[x] = (gxy >= 64*256) ? 0x3FFF : ((gxy < -64*256) ? 0x4001 : gxy);
			int gxx = (pGx[x] * pGx[x]);// >> 2;
			//pGx[x] = (gxx >= 64*256) ? 0x3FFF : gxx;
			pGx[x] = (gxx >= 64*256) ? 0x3FFF : ((gxx < -64*256) ? 0x4001 : gxx);
			int gyy = (pGy[x] * pGy[x]);// >> 2;
			//pGy[x] = (gyy >= 64*256) ? 0x3FFF : gyy;
			pGy[x] = (gyy >= 64*256) ? 0x3FFF : ((gyy < -64*256) ? 0x4001 : gyy);
		}
	}
    //saveImage("_SobelAbs1.bmp", iplGm, 0, 8.0f, 8);      // NOTE: the values in resultant gradient is half of that of sobel_32f()!

    max3x3_8U(iplGm, iplGm);
    //maxbox3x3_int(iplGm, iplGm, 3);
    min3x3_8U(iplGm, iplGm);
    //saveImage("_SobelAbs_Morph1.bmp", iplGm, 0, 16.0f, 8);      // NOTE: the values in resultant gradient is half of that of sobel_32f()!
    unpadding(iplGm, iplGM, 2, 2);

	// prepare tensor calculate (approximated sqrt and division)
	int pSqrtLUT[256] =			// LUT[x] = clip(round(sqrt(x) * 4));
	   { 0, 4, 6, 7, 8, 9, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 20, 21, 21, 22, 22, 22,
		 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 32,
		 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 38, 39, 39, 39,
		 39, 39, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 43, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45,
		 45, 45, 46, 46, 46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 48, 48, 48, 48, 48, 48, 49, 49, 49, 49, 49, 49, 50, 50, 50, 50, 50, 50,
		 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 53, 53, 53, 53, 53, 53, 54, 54, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55,
		 55, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60,
		 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63 };

    // temp testing point
    //IplImage *iplEg1 = createImage( iplStruct->width, iplStruct->height, SR_DEPTH_32S, 1 );
    //IplImage *iplEg2 = createImage( iplStruct->width, iplStruct->height, SR_DEPTH_32S, 1 );
    //cvSet(iplEg1, cvScalar(65535));
    //cvSet(iplEg2, cvScalar(65535));

	// calculate structure measurement
	for (int y=0; y<iplStruct->height; y++) {
		unsigned char *pTen = (unsigned char*)((char *)iplStruct->imageData + y * iplStruct->widthStep);
        unsigned char *pGm = (unsigned char*)((char *)iplGM->imageData + y * iplGM->widthStep);
        //int *pEg1 = (int *)(iplEg1->imageData + y * iplEg1->widthStep);
        //int *pEg2 = (int *)(iplEg2->imageData + y * iplEg2->widthStep);
		for (int x=0; x<iplStruct->width; x++) {
			// calculate tensor matrix T = [pxx pxy; pxy pyy] in wnd_num * wnd_num window
            //if (x==136 && y==0) 
            //    int p=0;
			int pxx = 0, pxy = 0, pyy = 0;
			for (int v = y; v < y+5; v++) {
				int *pGxx = (int*)((char *)iplGx->imageData + v * iplGx->widthStep);
				int *pGyy = (int*)((char *)iplGy->imageData + v * iplGy->widthStep);
				int *pGxy = (int*)((char *)iplGxy->imageData + v * iplGxy->widthStep);
				for (int u = x; u < x+5; u++) {
					pxx += pGxx[u];			// pxx: 19-bit (14-bit + 5-bit (25))
					pxy += pGxy[u];
					pyy += pGyy[u];
				}
			}
			// calculate eigenvalues
			int shift_count = 0;	// right shift --> add
			int edge_regular, corner;
            int structure;
			// keep pxx, pxy, pyy 14-bit
			if (!(pxx < 16384 && pyy < 16384 && pxy < 8192 && pxy > -8192)) {
				pxx = pxx >> 5;
				pxy = pxy >> 5;
				pyy = pyy >> 5;
				shift_count += 5;
			}
			unsigned int k = ((pxx+pyy) * (pxx+pyy) - ((pxx * pyy - pxy * pxy) << 2));		// 31-bit for k
			if ( k <= 16) {                        // modified by Luhong, June 17, 2014
                // If it is perfect isotropic, consider it as isolated point (do not enhance)
				structure = max_tensor;            // modified by Luhong, June 17, 2014
			} else {
				// keep k 24-bit, i.e. keep sqrt(k) 12-bit
				if (k >=  256 * 256 * 256) {
					k = k >> 6;			// shift 6 bit rather than 7/8 bit to keep precision, although k may be 31-bit <--- AA
					pxx = pxx >> 3;		
					pxy = pxy >> 3;
					pyy = pyy >> 3;				
					shift_count += 3;
				}
				// approximate sqrt(k), keep sqrt_k 12-bit
				int sqrt_k;
				if (k < 256) {
					sqrt_k = (pSqrtLUT[k]) >> 2;
				} else if (k < 64 * 256) {
					sqrt_k = (pSqrtLUT[k>>6]) << 1;
				} else if (k < 16 * 256 * 256) {
					sqrt_k = (pSqrtLUT[k>>12]) << 4;
				} else if (k < 256 * 256 * 256) {
					sqrt_k = (pSqrtLUT[k>>16]) << 6;
				} else {
					// this should never happen in natural image, but need it to avoid overflow in extreme situation (see AA)
					sqrt_k = 4095;
				}
				//sqrt_k = (int)sqrt((float)k);
				// calculate eigenvalues and then sort them (eg1 > eg2), eg1 and eg2 less than bit_depth
				int quad_b = pxx + pyy;			// 15-bit
				int eg1 = quad_b + sqrt_k;		// 16-bit
				int eg2 = quad_b - sqrt_k;		// 15-bit
				eg2 = eg2 < 0 ? -eg2 : eg2;	// abs
                //pEg1[x] = eg1;
                //pEg2[x] = eg2;

				// calculate the degree of anisotropy 
				if (eg2 == 0) {		// this equals to eg1 == eg2 == 0!
					edge_regular = max_tensor;		// modified by Luhong, June 17, 2014
				} else {
					// calculate numberator and denominator
					unsigned int num = eg1 - eg2;		// numerator, 16-bit
					unsigned int den = eg1 + eg2;		// denominator, 17-bit!
					// division: firstly, left-shift the numerator, since 0<=num/den<=1
					if (den >= 8 * 256) {		// keep den 12-bit
						den = den >> 5;
						num = num;
					} else {
						num = num << 5;
					}
					// division: secondly, get 5-bit results
					edge_regular = div_Int12_5U(num, den);					// edge_regular: 5-bit
					// calculate the edge regularity, shift to 8-bit, i.e. 0~255 represents a regularity of 0~1
					edge_regular = (edge_regular * edge_regular) >> 2;		// edge_regular: 8-bit
					//edge_regular = div_Int24_8U((num<<8), den);
				}

                // calculate corner
                corner = (eg2 << shift_count) >> 7;
                
                // weight for gradient and fusion (modified by Luhong, June 17, 2014)
                int grad = pGm[x]; 
                int struct1 = edge_regular + corner;
                if (atten_opt == 0) {
                    structure = struct1;
                } else {
                    int atten_th = 1 << atten_opt;
                    grad = grad > atten_th ? atten_th : grad;
                    structure = ( struct1 * grad + (atten_th - grad) * 255) >> atten_opt;
                } 
                //else {        // July 7, 2014
                //    grad = grad > 16 ? 16 : grad;
                //    grad = grad < 8 ? 8 : grad;
                //    grad = grad - 8;
                //    structure = ( struct1 * grad + (8 - grad) * 255) >> 3;
                //}
			}
            // clipping
			pTen[x] = (unsigned char)(structure > 255 ? 255 : structure);
		}
	}

    //saveImage("_CA_eg1.bmp", iplEg1, 0, 1.0f, 16);
    //writeImageVector("_CA_eg1.txt", iplEg1, false, 16);
    //saveImage("_CA_eg2.bmp", iplEg2, 0, 1.0f, 16);
    //writeImageVector("_CA_eg2.txt", iplEg2, false, 16);
    //safeReleaseImage(&iplEg1, &iplEg2);

	safeReleaseImage(&iplGx, &iplGy, &iplGxy, &iplGm);
    //saveImage("_CA_SqrtSobel.bmp", iplStruct, 0, 1, 8);
	//saveImage("_TexMAP_8Ui_8Uo_opt_2.bmp", iplStruct, 0, 1.0f);

	return true;
}

 bool CImageUtility::extrCornerMap_32f(IplImage *iplImage, IplImage *iplCorner, int method)
// Calculate the coner map of an image using structure tensor in 5x5 window
// Supposing gx = Gradx(I) and gy = Grady(I), the tensor matrix is T = [ sum(gx*gx) sum(gx*gy); sum(gy*gx), sum(gy*gy) ]
// the corner point likelihood is alphs*eg2. The function map the corner likelihood to 0~1, where 1 denotes 
// the pixel in a corner.
// This function is based on extrStructMap5x5_o2_32f().
// Argument:
//		iplImage -- [I] 1-channel input image, 32F or 8U datatype
//		iplStruct -- [O] 1-channel result image, 32F datatype
//     method -- [O] method to calculate likelihood of corner. 1 (default) -- using the smaller eigenvalue; 
//                            2 -- using both two eigenvalues (more robust in corner detection)
// by Luhong Liang, IC-ASD, ASTRI, Feb. 6, 2014
// Modified on May 15, 2014
{ 
	if (iplImage == NULL || iplCorner == NULL || iplImage->nChannels != 1 || 
        iplCorner->nChannels != 1 || iplImage->depth != SR_DEPTH_32F || iplCorner->depth != SR_DEPTH_32F ||
        (method != 1 && method !=2)) {
		showErrMsg("Invalid input image type or argument in CImageUtility::extrCornerMap_32f()!\n");
		return false;
	}

	IplImage *iplGx = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGy = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGxy = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	float *pGxxLine = new float[iplImage->width];		// use line buffer instead of FIFO to simplify the management
	float *pGxyLine = new float[iplImage->width];
	float *pGyyLine = new float[iplImage->width];
	if (iplGx == NULL || iplGy == NULL || iplGxy == NULL ||
		pGxxLine == NULL || pGxyLine == NULL || pGyyLine == NULL)  {
		safeReleaseImage(&iplGx, &iplGy, &iplGxy);
		if (pGxxLine != NULL) delete [] pGxxLine;
		if (pGxyLine != NULL) delete [] pGxyLine;
		if (pGyyLine != NULL) delete [] pGyyLine;
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrCornerMap_32f()!\n");
		return false;
	}

	// calculate gradient
	sobel_32f(iplImage, iplGx, 0);			// do not use OpenCV function here
	sobel_32f(iplImage, iplGy, 1);

	// calculate tensor 
	mulImage_32f(iplGx, iplGy, iplGxy);
	mulImage_32f(iplGx, iplGx, iplGx);
	mulImage_32f(iplGy, iplGy, iplGy);
	//extrSumMap5x5_32f(iplGxy); 	extrSumMap5x5_32f(iplGx); 	extrSumMap5x5_32f(iplGy); //<-- not use integral image due to the numerical error!

	setZero(iplCorner);
	const int wnd_size = 5;
	const int start = wnd_size >> 1;
	const int end = wnd_size - start - 1;
	for (int y=start; y<iplCorner->height-end; y++) {
		float *pTen = (float*)((char *)iplCorner->imageData + y * iplCorner->widthStep);
		float *pGxx0 = (float*)((char *)iplGx->imageData + (y-2) * iplGx->widthStep);
		float *pGyy0 = (float*)((char *)iplGy->imageData + (y-2) * iplGy->widthStep);
		float *pGxy0 = (float*)((char *)iplGxy->imageData + (y-2) * iplGxy->widthStep);
		float *pGxx1 = (float*)((char *)iplGx->imageData + (y-1) * iplGx->widthStep);
		float *pGyy1 = (float*)((char *)iplGy->imageData + (y-1) * iplGy->widthStep);
		float *pGxy1 = (float*)((char *)iplGxy->imageData + (y-1) * iplGxy->widthStep);
		float *pGxx2 = (float*)((char *)iplGx->imageData + y * iplGx->widthStep);
		float *pGyy2 = (float*)((char *)iplGy->imageData + y * iplGy->widthStep);
		float *pGxy2 = (float*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
		float *pGxx3 = (float*)((char *)iplGx->imageData + (y+1) * iplGx->widthStep);
		float *pGyy3 = (float*)((char *)iplGy->imageData + (y+1) * iplGy->widthStep);
		float *pGxy3 = (float*)((char *)iplGxy->imageData + (y+1) * iplGxy->widthStep);
		float *pGxx4 = (float*)((char *)iplGx->imageData + (y+2) * iplGx->widthStep);
		float *pGyy4 = (float*)((char *)iplGy->imageData + (y+2) * iplGy->widthStep);
		float *pGxy4 = (float*)((char *)iplGxy->imageData + (y+2) * iplGxy->widthStep);
        //float *pGx = (float*)((char *)iplGx->imageData + y * iplGx->widthStep);
        //float *pGy = (float*)((char *)iplGy->imageData + y * iplGy->widthStep);
        //float *pGxy = (float*)((char *)iplGxy->imageData + y * iplGxy->widthStep);
		// initialize the first 4 columns
		for (int x=0; x<4; x++) {
			pGxxLine[x] = pGxx0[x] + pGxx1[x] + pGxx2[x] + pGxx3[x] + pGxx4[x];
			pGxyLine[x] = pGxy0[x] + pGxy1[x] + pGxy2[x] + pGxy3[x] + pGxy4[x];
			pGyyLine[x] = pGyy0[x] + pGyy1[x] + pGyy2[x] + pGyy3[x] + pGyy4[x];
		}
		// tensor calculation
		for (int x=start; x<iplCorner->width-end; x++) {
			// calculate tensor matrix T = [pxx pxy; pxy pyy] in wnd_num * wnd_num window
			// calculate sum in right-most column
			int index = x+2;
			float pxx = pGxx0[index] + pGxx1[index] + pGxx2[index] + pGxx3[index] + pGxx4[index];
			float pxy = pGxy0[index] + pGxy1[index] + pGxy2[index] + pGxy3[index] + pGxy4[index];
			float pyy = pGyy0[index] + pGyy1[index] + pGyy2[index] + pGyy3[index] + pGyy4[index];
			// store in line buffers
			pGxxLine[index] = pxx;
			pGxyLine[index] = pxy;
			pGyyLine[index] = pyy;
			// sum to other columns
			pxx += pGxxLine[x-2] + pGxxLine[x-1] + pGxxLine[x] + pGxxLine[x+1];
			pxy += pGxyLine[x-2] + pGxyLine[x-1] + pGxyLine[x] + pGxyLine[x+1];
			pyy += pGyyLine[x-2] + pGyyLine[x-1] + pGyyLine[x] + pGyyLine[x+1];
			// calculate eigenvalues
			float k = (pxx+pyy) * (pxx+pyy) - 4 * (pxx * pyy - pxy * pxy);
			if ( k<=0.0f) continue;
			float temp1 = (float)sqrt(k);// * 0.5f;
			float temp2 = (pxx + pyy);// * 0.5f;
			float eg1 =  temp2 + temp1;		// since temp2 > 0 && temp1 > 0, eg1 must be larger than eg2
			float eg2 = temp2 - temp1;
			eg2 = eg2 < 0 ? -eg2 : eg2;	// abs
			
            // calculate corner
            float corner=0.0f;
            if (method == 1) {
                corner = eg2 / (1024.0f * 64.0f);
                corner = corner > 1.0f ? 1.0f : corner;
            } else if (method == 2) {   // May 15, 2014
                const float k_factor = 0.0625f;
                eg1 = eg1 / 65526.0f;
                eg2 = eg2 / 65526.0f;
                corner = ((eg1 * eg2 - k_factor * (eg1 + eg2) * (eg1 + eg2))) * 0.25f;
                corner = corner < 0.0f ? 0.0f : corner;
                corner = corner > 1.0f ? 1.0f : corner;
            }
			
            // write
			pTen[x] = corner;
		}
	}

	safeReleaseImage(&iplGx, &iplGy, &iplGxy);
	if (pGxxLine != NULL) delete [] pGxxLine;
	if (pGxyLine != NULL) delete [] pGxyLine;
	if (pGyyLine != NULL) delete [] pGyyLine;

	return true;
}

bool CImageUtility::extrMADLowMap_32f(IplImage *iplImage, IplImage *iplMAD, int wnd_size)
// calculate the map of local MAD of an image
// NOTE: (1) the local MAD is normalized to 0~1 using a piece-wise linear function!
//       (2) the result map will be resized to the target image size using NN interpolation
// by Luhong Liang, IC-ASD, ASTRI, Nov. 15, 2012
{
	if (iplImage == NULL || iplMAD == NULL || 
		iplImage->nChannels != 1 || iplMAD->nChannels != 1 || iplMAD->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::extrMADLowMap_32f()!\n");
		return false;
	}

	// data type conversion
	IplImage *iplTemp = extrMADMap_32f(iplImage, wnd_size);
	if (iplTemp == NULL) return false;
	//saveImage("_MADMap.bmp", iplTemp, 0, 4);

	
	for (int y=0; y<iplTemp->height; y++) {
		float *pMAD = (float*)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		for (int x=0; x<iplTemp->width; x++) {
			// piece-wise linear function for MAD
			float mae = pMAD[x];
			float w2;
			if (mae < 4.0f) {
				w2 = 0.0f;
			} else if (mae > 8.0f) {
				w2 = 1.0f;
			} else {
				w2 = (mae - 4.0f) / 4.0f;
			}
			pMAD[x] = w2;
		}
	}

	// resize
	if (iplImage->width != iplMAD->width || iplImage->height != iplMAD->height) {
		resize(iplTemp, iplMAD, SR_INTER_NN);		// considering implemention in the loop, use NN
	} else {
		copy(iplTemp, iplMAD);
	}

	safeReleaseImage(&iplTemp);

	return true;
}

bool CImageUtility::extrMeanMap5x5_32f(IplImage *iplImage)
// Calculate local mean (sliding window)
// NOTE: The "boundary" pixels (2 pixels in each direction) will keep undefined!
// by Luhong Liang, IC-ASD, ASTRI, Feb. 19, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::extrMeanMap5x5_32f()!\n");
		return NULL;
	}

	// allocate integral image
	IplImage *iplInt = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	if (iplInt == NULL)  {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrMeanMap5x5_32f()!\n");
		return false;
	}

	// calculate integral map of the original image
	const float div = 1.0f / 25.0f;
	float *pSrc0 = (float *)((char*)iplImage->imageData);
	float *pDst0 = (float *)((char*)iplInt->imageData);
	pDst0[0] = pSrc0[0];
	for (int x=1; x<iplInt->width; x++) {
		pDst0[x] = pDst0[x-1] + pSrc0[x];
	}
	for (int y=1; y<iplInt->height; y++) {
		float *pSrc = (float *)((char*)iplImage->imageData + y*iplImage->widthStep);
		float *pDstN = (float *)((char*)iplInt->imageData + (y-1)*iplInt->widthStep);
		float *pDst = (float *)((char*)iplInt->imageData + y*iplInt->widthStep);
		pDst[0] = pDstN[0] + pSrc[0];
		for (int x=1; x<iplInt->width; x++) {
			pDst[x] = pSrc[x] + pDst[x-1] + pDstN[x] - pDstN[x-1];
		}
	}

	// calculate sum (valid region only)
	float *pInt = (float *)((char*)iplInt->imageData + 4*iplInt->widthStep);
	float *pMean = (float *)((char*)iplImage->imageData + 2*iplImage->widthStep);
	pMean[2] = pInt[4] * div;
	for (int x=3; x<iplImage->width-2; x++) {
		pMean[x] = (pInt[x+2] - pInt[x-3]) * div;
	}
	for (int y=3; y<iplImage->height-2; y++) {
		float *pInt0 = (float *)((char*)iplInt->imageData + (y-3)*iplInt->widthStep);
		float *pInt1 = (float *)((char*)iplInt->imageData + (y+2)*iplInt->widthStep);
		float *pMean = (float *)((char*)iplImage->imageData + y*iplImage->widthStep);
		pMean[2] = (pInt1[4] - pInt0[4]) * div;
		for (int x=3; x<iplImage->width-2; x++) {
			pMean[x] = (pInt1[x+2] - pInt1[x-3] - pInt0[x+2] + pInt0[x-3]) * div;
		}
	}

	safeReleaseImage(&iplInt);

	return true;
}

bool CImageUtility::extrSumMap5x5_32f(IplImage *iplImage)
// Calculate local sum (sliding window)
// NOTE: The "boundary" pixels (2 pixels in each direction) will keep undefined!
// by Luhong Liang, IC-ASD, ASTRI, Feb. 19, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::extrSumMap5x5_32f()!\n");
		return NULL;
	}

	// allocate integral image
	IplImage *iplInt = createImage( iplImage->width, iplImage->height, SR_DEPTH_64F, 1 );
	if (iplInt == NULL)  {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrSumMap5x5_32f()!\n");
		return false;
	}

	// calculate integral map of the original image
	//const float div = 1.0f / 25.0f;
	float *pSrc0 = (float *)((char*)iplImage->imageData);
	double *pDst0 = (double *)((char*)iplInt->imageData);
	pDst0[0] = pSrc0[0];
	for (int x=1; x<iplInt->width; x++) {
		pDst0[x] = pDst0[x-1] + pSrc0[x];
	}
	for (int y=1; y<iplInt->height; y++) {
		float *pSrc = (float *)((char*)iplImage->imageData + y*iplImage->widthStep);
		double *pDstN = (double *)((char*)iplInt->imageData + (y-1)*iplInt->widthStep);
		double *pDst = (double *)((char*)iplInt->imageData + y*iplInt->widthStep);
		pDst[0] = pDstN[0] + pSrc[0];
		for (int x=1; x<iplInt->width; x++) {
			pDst[x] = pSrc[x] + pDst[x-1] + pDstN[x] - pDstN[x-1];
		}
	}

	// calculate sum (valid region only)
	double *pInt = (double *)((char*)iplInt->imageData + 4*iplInt->widthStep);
	float *pSum = (float *)((char*)iplImage->imageData + 2*iplImage->widthStep);
	pSum[2] = (float)pInt[4];
	for (int x=3; x<iplImage->width-2; x++) {
		pSum[x] = (float)(pInt[x+2] - pInt[x-3]);
	}
	for (int y=3; y<iplImage->height-2; y++) {
		double *pInt0 = (double *)((char*)iplInt->imageData + (y-3)*iplInt->widthStep);
		double *pInt1 = (double *)((char*)iplInt->imageData + (y+2)*iplInt->widthStep);
		float *pSum = (float *)((char*)iplImage->imageData + y*iplImage->widthStep);
		pSum[2] = (float)(pInt1[4] - pInt0[4]);
		for (int x=3; x<iplImage->width-2; x++) {
			pSum[x] = (float)(pInt1[x+2] - pInt1[x-3] - pInt0[x+2] + pInt0[x-3]);
		}
	}

	safeReleaseImage(&iplInt);

	return true;
}

IplImage *CImageUtility::extrLocVarMap5x5_32f(IplImage *iplImage)
// Calculate the map of local variance of an image
// The local variance is: Lv = sum(f(x,y)), (x,y)(=R
// where f(x,y) = sq(I(x,y) - I(x,y-1)) + sq(I(x,y) - I(x,y+1)) + sq(I(x,y) - I(x-1,y)) + sq(I(x,y) - I(x+1,y))
// by Luhong Liang, IC-ASD, ASTRI, Aug. 27, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1) {
		showErrMsg("Invalid input image type in CImageUtility::extrLocVarMap5x5_32f()!\n");
		return NULL;
	}

	// allocate buffers
	IplImage *iplDiff = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplInt = createImage( iplImage->width, iplImage->height, SR_DEPTH_64F, 1 );  // must be double to support 4K format!, Luhong, Aug. 12, 2013
	if (iplDiff == NULL || iplInt == NULL)  {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrLocVarMap5x5_32f()!\n");
		safeReleaseImage(&iplDiff, &iplInt);
		return NULL;
	}
	const float div = 3.0f / (25.0f * 4.0f);        // * 4.0f to normalize to the data range similar to MAD
	setZero(iplDiff);	// to guarantee the correct integral map

	if (iplImage->depth == SR_DEPTH_32F) {
        // calculate 3x3 variance
        for (int y=1; y<iplDiff->height-1; y++) {
            float *pSrcN = (float *)((char*)iplImage->imageData + (y-1)*iplImage->widthStep);
            float *pSrc0 = (float *)((char*)iplImage->imageData + y*iplImage->widthStep);
            float *pSrc1 = (float *)((char*)iplImage->imageData + (y+1)*iplImage->widthStep);
            float *pDiff = (float *)((char*)iplDiff->imageData + y*iplDiff->widthStep);
            for (int x=1; x<iplDiff->width; x++) {
                float diff = 0.0f;
                float center = pSrc0[x];
                float delta;
                delta = center - pSrcN[x]; diff += delta * delta;//> 0 ? delta : -delta;
                delta = center - pSrc1[x]; diff += delta * delta;// > 0 ? delta : -delta;
                delta = center - pSrc0[x-1]; diff += delta * delta;// > 0 ? delta : -delta;
                delta = center - pSrc0[x+1]; diff += delta * delta;// > 0 ? delta : -delta;
                pDiff[x] = sqrt(diff);
            }
        }
		// calculate integral map of the original image
		float *pSrc0 = (float *)((char*)iplDiff->imageData);
		double *pDst0 = (double *)((char*)iplInt->imageData);
		pDst0[0] = pSrc0[0];
		for (int x=1; x<iplInt->width; x++) {
			pDst0[x] = pDst0[x-1] + pSrc0[x];
		}
		for (int y=1; y<iplInt->height; y++) {
			float *pSrc = (float *)((char*)iplDiff->imageData + y*iplDiff->widthStep);
			double *pDstN = (double *)((char*)iplInt->imageData + (y-1)*iplInt->widthStep);
			double *pDst = (double *)((char*)iplInt->imageData + y*iplInt->widthStep);
			pDst[0] = pDstN[0] + pSrc[0];
			for (int x=1; x<iplInt->width; x++) {
				pDst[x] = pSrc[x] + pDst[x-1] + pDstN[x] - pDstN[x-1];
			}
		}
		// calculate mean (valid region only)
		double *pInt = (double *)((char*)iplInt->imageData + 4*iplInt->widthStep);
		float *pLocVar = (float *)((char*)iplDiff->imageData + 2*iplDiff->widthStep);
		pLocVar[2] = (float)(pInt[4] * div);
		for (int x=3; x<iplDiff->width-2; x++) {
			pLocVar[x] = (float)(pInt[x+2] - pInt[x-3]) * div;
		}
		for (int y=3; y<iplDiff->height-2; y++) {
			double *pInt0 = (double *)((char*)iplInt->imageData + (y-3)*iplInt->widthStep);
			double *pInt1 = (double *)((char*)iplInt->imageData + (y+2)*iplInt->widthStep);
			float *pLocVar = (float *)((char*)iplDiff->imageData + y*iplDiff->widthStep);
			pLocVar[2] = (float)(pInt1[4] - pInt0[4]) * div;
			for (int x=3; x<iplDiff->width-2; x++) {
				pLocVar[x] = (float)(pInt1[x+2] - pInt1[x-3] - pInt0[x+2] + pInt0[x-3]) * div;
			}
		}
        //float fRunTime = (float)clock() / (float)CLOCKS_PER_SEC;
        //fRunTime = fRunTime - fStartTime;
        //showMessage1("%f s used in calculating mean.\n", fRunTime);
	} else {
		showErrMsg("Input image must be 32F in CImageUtility::extrMADMap5x5_o1_32f()!\n");
		safeReleaseImage(&iplInt, &iplDiff);
		return NULL;
	}

	safeReleaseImage(&iplInt);

	return iplDiff;
}

bool CImageUtility::extrLocVarMap5x5_32f(IplImage *iplImage, IplImage *iplLocVar)
// Calculate the map of local variance of an image
// The local variance is: Lv = sum(f(x,y)), (x,y)(=R
// where f(x,y) = sq(I(x,y) - I(x,y-1)) + sq(I(x,y) - I(x,y+1)) + sq(I(x,y) - I(x-1,y)) + sq(I(x,y) - I(x+1,y))
// by Luhong Liang, IC-ASD, ASTRI, Sept. 6, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplLocVar == NULL || iplLocVar->nChannels != 1 ||
        iplImage->width != iplLocVar->width || iplImage->height != iplLocVar->height ||
        iplImage->depth != SR_DEPTH_32F || iplLocVar->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::extrLocVarMap5x5_32f()!\n");
		return false;
	}

	// allocate buffers
	//IplImage *iplInt = createImage( iplImage->width, iplImage->height, SR_DEPTH_64F, 1 );  // must be double to support 4K format!, Luhong, Aug. 12, 2013
	//if (iplInt == NULL)  {
	//	showErrMsg("Fail to allocate buffer in CImageUtility::extrLocVarMap5x5_32f()!\n");
	//	safeReleaseImage(&iplInt);
	//	return false;
	//}
	//const float div = 3.0f / (25.0f * 4.0f);        // * 4.0f to normalize to the data range similar to MAD
	setZero(iplLocVar);	// to guarantee the correct integral map

	if (iplImage->depth == SR_DEPTH_32F) {
        // calculate 3x3 variance
        for (int y=1; y<iplLocVar->height-1; y++) {
            float *pSrcN = (float *)((char*)iplImage->imageData + (y-1)*iplImage->widthStep);
            float *pSrc0 = (float *)((char*)iplImage->imageData + y*iplImage->widthStep);
            float *pSrc1 = (float *)((char*)iplImage->imageData + (y+1)*iplImage->widthStep);
            float *pDiff = (float *)((char*)iplLocVar->imageData + y*iplLocVar->widthStep);
            for (int x=1; x<iplLocVar->width; x++) {
                float diff = 0.0f;
                float center = pSrc0[x];
                float delta;
                delta = center - pSrcN[x]; diff += delta * delta;//> 0 ? delta : -delta;
                delta = center - pSrc1[x]; diff += delta * delta;// > 0 ? delta : -delta;
                delta = center - pSrc0[x-1]; diff += delta * delta;// > 0 ? delta : -delta;
                delta = center - pSrc0[x+1]; diff += delta * delta;// > 0 ? delta : -delta;
                pDiff[x] = sqrt(diff);
            }
        }
		// calculate integral map of the original image
        /*
		float *pSrc0 = (float *)((char*)iplLocVar->imageData);
		double *pDst0 = (double *)((char*)iplInt->imageData);
		pDst0[0] = pSrc0[0];
		for (int x=1; x<iplInt->width; x++) {
			pDst0[x] = pDst0[x-1] + pSrc0[x];
		}
		for (int y=1; y<iplInt->height; y++) {
			float *pSrc = (float *)((char*)iplLocVar->imageData + y*iplLocVar->widthStep);
			double *pDstN = (double *)((char*)iplInt->imageData + (y-1)*iplInt->widthStep);
			double *pDst = (double *)((char*)iplInt->imageData + y*iplInt->widthStep);
			pDst[0] = pDstN[0] + pSrc[0];
			for (int x=1; x<iplInt->width; x++) {
				pDst[x] = pSrc[x] + pDst[x-1] + pDstN[x] - pDstN[x-1];
			}
		}
		// calculate mean (valid region only)
		double *pInt = (double *)((char*)iplInt->imageData + 4*iplInt->widthStep);
		float *pLocVar = (float *)((char*)iplLocVar->imageData + 2*iplLocVar->widthStep);
		pLocVar[2] = (float)(pInt[4] * div);
		for (int x=3; x<iplLocVar->width-2; x++) {
			pLocVar[x] = (float)(pInt[x+2] - pInt[x-3]) * div;
		}
		for (int y=3; y<iplLocVar->height-2; y++) {
			double *pInt0 = (double *)((char*)iplInt->imageData + (y-3)*iplInt->widthStep);
			double *pInt1 = (double *)((char*)iplInt->imageData + (y+2)*iplInt->widthStep);
			float *pLocVar = (float *)((char*)iplLocVar->imageData + y*iplLocVar->widthStep);
			pLocVar[2] = (float)(pInt1[4] - pInt0[4]) * div;
			for (int x=3; x<iplLocVar->width-2; x++) {
				pLocVar[x] = (float)(pInt1[x+2] - pInt1[x-3] - pInt0[x+2] + pInt0[x-3]) * div;
			}
		}*/
        //float fRunTime = (float)clock() / (float)CLOCKS_PER_SEC;
        //fRunTime = fRunTime - fStartTime;
        //showMessage1("%f s used in calculating mean.\n", fRunTime);
	} else {
		showErrMsg("Input image must be 32F in CImageUtility::extrLocVarMap5x5_32f()!\n");
		//safeReleaseImage(&iplInt);
		return false;
	}

	//safeReleaseImage(&iplInt);

	return true;
}

bool CImageUtility::extrLocVarMap5x5min_32f(IplImage *iplImage, IplImage *iplLocVar)
// Calculate the map of local variance of an image
// The local variance is: Lv = sum(f(x,y)), (x,y)(=R
// where f(x,y) = min(I(x,y) - I(x+m,y+n)), where -1<= m, n <= 1 && m|n != 0
// by Luhong Liang, IC-ASD, ASTRI, Sept. 6, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplLocVar == NULL || iplLocVar->nChannels != 1 ||
        iplImage->width != iplLocVar->width || iplImage->height != iplLocVar->height ||
        iplImage->depth != SR_DEPTH_32F || iplLocVar->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::extrLocVarMap5x5_32f()!\n");
		return false;
	}

	// allocate buffers
	IplImage *iplInt = createImage( iplImage->width, iplImage->height, SR_DEPTH_64F, 1 );  // must be double to support 4K format!, Luhong, Aug. 12, 2013
	if (iplInt == NULL)  {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrLocVarMap5x5_32f()!\n");
		safeReleaseImage(&iplInt);
		return false;
	}
	const float div = 3.0f / (25.0f * 4.0f);        // * 4.0f to normalize to the data range similar to MAD
	setZero(iplLocVar);	// to guarantee the correct integral map

	if (iplImage->depth == SR_DEPTH_32F) {
        // calculate 3x3 variance
        for (int y=1; y<iplLocVar->height-1; y++) {
            float *pSrcN = (float *)((char*)iplImage->imageData + (y-1)*iplImage->widthStep);
            float *pSrc0 = (float *)((char*)iplImage->imageData + y*iplImage->widthStep);
            float *pSrc1 = (float *)((char*)iplImage->imageData + (y+1)*iplImage->widthStep);
            float *pDiff = (float *)((char*)iplLocVar->imageData + y*iplLocVar->widthStep);
            for (int x=1; x<iplLocVar->width; x++) {
                //float diff = 0.0f;
                float center = pSrc0[x];
                float min_diff = 255.0f;
                float delta = center - pSrcN[x];    delta = delta < 0.0f ? -delta : delta;    min_diff = delta < min_diff ? delta : min_diff;
                delta = center - pSrcN[x-1];    delta = delta < 0.0f ? -delta : delta;    min_diff = delta < min_diff ? delta : min_diff;
                delta = center - pSrcN[x+1];    delta = delta < 0.0f ? -delta : delta;    min_diff = delta < min_diff ? delta : min_diff;
                delta = center - pSrc1[x];    delta = delta < 0.0f ? -delta : delta;    min_diff = delta < min_diff ? delta : min_diff;
                delta = center - pSrc1[x-1];    delta = delta < 0.0f ? -delta : delta;    min_diff = delta < min_diff ? delta : min_diff;
                delta = center - pSrc1[x+1];    delta = delta < 0.0f ? -delta : delta;    min_diff = delta < min_diff ? delta : min_diff;
                delta = center - pSrc0[x-1];    delta = delta < 0.0f ? -delta : delta;    min_diff = delta < min_diff ? delta : min_diff;
                delta = center - pSrc0[x+1];    delta = delta < 0.0f ? -delta : delta;    min_diff = delta < min_diff ? delta : min_diff;
                pDiff[x] = min_diff;
            }
        }
		// calculate integral map of the original image
		float *pSrc0 = (float *)((char*)iplLocVar->imageData);
		double *pDst0 = (double *)((char*)iplInt->imageData);
		pDst0[0] = pSrc0[0];
		for (int x=1; x<iplInt->width; x++) {
			pDst0[x] = pDst0[x-1] + pSrc0[x];
		}
		for (int y=1; y<iplInt->height; y++) {
			float *pSrc = (float *)((char*)iplLocVar->imageData + y*iplLocVar->widthStep);
			double *pDstN = (double *)((char*)iplInt->imageData + (y-1)*iplInt->widthStep);
			double *pDst = (double *)((char*)iplInt->imageData + y*iplInt->widthStep);
			pDst[0] = pDstN[0] + pSrc[0];
			for (int x=1; x<iplInt->width; x++) {
				pDst[x] = pSrc[x] + pDst[x-1] + pDstN[x] - pDstN[x-1];
			}
		}
		// calculate mean (valid region only)
		double *pInt = (double *)((char*)iplInt->imageData + 4*iplInt->widthStep);
		float *pLocVar = (float *)((char*)iplLocVar->imageData + 2*iplLocVar->widthStep);
		pLocVar[2] = (float)(pInt[4] * div);
		for (int x=3; x<iplLocVar->width-2; x++) {
			pLocVar[x] = (float)(pInt[x+2] - pInt[x-3]) * div;
		}
		for (int y=3; y<iplLocVar->height-2; y++) {
			double *pInt0 = (double *)((char*)iplInt->imageData + (y-3)*iplInt->widthStep);
			double *pInt1 = (double *)((char*)iplInt->imageData + (y+2)*iplInt->widthStep);
			float *pLocVar = (float *)((char*)iplLocVar->imageData + y*iplLocVar->widthStep);
			pLocVar[2] = (float)(pInt1[4] - pInt0[4]) * div;
			for (int x=3; x<iplLocVar->width-2; x++) {
				pLocVar[x] = (float)(pInt1[x+2] - pInt1[x-3] - pInt0[x+2] + pInt0[x-3]) * div;
			}
		}
        //float fRunTime = (float)clock() / (float)CLOCKS_PER_SEC;
        //fRunTime = fRunTime - fStartTime;
        //showMessage1("%f s used in calculating mean.\n", fRunTime);
	} else {
		showErrMsg("Input image must be 32F in CImageUtility::extrLocVarMap5x5_32f()!\n");
		safeReleaseImage(&iplInt);
		return false;
	}

	safeReleaseImage(&iplInt);

	return true;
}

IplImage *CImageUtility::extrLocVarMap3x3_32f(IplImage *iplImage)
// Calculate the map of local variance of an image
// The local variance is: Lv = sum(f(x,y)), (x,y)(=R
// where f(x,y) = sq(I(x,y) - I(x,y-1)) + sq(I(x,y) - I(x,y+1)) + sq(I(x,y) - I(x-1,y)) + sq(I(x,y) - I(x+1,y))
// by Luhong Liang, IC-ASD, ASTRI, Sept. 10, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1) {
		showErrMsg("Invalid input image type in CImageUtility::extrLocVarMap3x3_32f()!\n");
		return NULL;
	}

	// allocate buffers
	IplImage *iplVar = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	if (iplVar == NULL)  {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrLocVarMap3x3_32f()!\n");
		return NULL;
	}

    if (!extrLocVarMap3x3_32f(iplImage, iplVar)) {
        safeReleaseImage(&iplVar);
        return NULL;
    }

    return iplVar;
}

bool CImageUtility::extrLocVarMap3x3_32f(IplImage *iplImage, IplImage *iplLocVar)
// Calculate the map of local variance of an image
// The local variance is: Lv = sum(f(x,y)), (x,y)(=R
// where f(x,y) = sq(I(x,y) - I(x,y-1)) + sq(I(x,y) - I(x,y+1)) + sq(I(x,y) - I(x-1,y)) + sq(I(x,y) - I(x+1,y))
// by Luhong Liang, IC-ASD, ASTRI, Sept. 10, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplLocVar == NULL || iplLocVar->nChannels != 1 ||
        iplImage->width != iplLocVar->width || iplImage->height != iplLocVar->height ||
        iplImage->depth != SR_DEPTH_32F || iplLocVar->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::extrLocVarMap3x3_32f()!\n");
		return false;
	}

	// allocate buffers
	IplImage *iplTemp = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );  // must be double to support 4K format!, Luhong, Aug. 12, 2013
    float *pLine = new float[iplImage->width];
	if (iplTemp == NULL || pLine == NULL)  {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrLocVarMap3x3_32f()!\n");
		safeReleaseImage(&iplTemp);
        if (pLine != NULL) delete pLine;
		return false;
	}
	const float div = 3.0f / (9.0f * 8.0f);        // * 3.0f to normalize to the data range similar to MAD
	setZero(iplLocVar);	// to guarantee the correct integral map
    setZero(iplTemp);
    for (int i=0; i<iplLocVar->width; i++) {
        pLine[i] = 0.0f;
    }

	if (iplImage->depth == SR_DEPTH_32F) {
        // calculate 3x3 variance
        for (int y=1; y<iplTemp->height-1; y++) {
            float *pSrcN = (float *)((char*)iplImage->imageData + (y-1)*iplImage->widthStep);
            float *pSrc0 = (float *)((char*)iplImage->imageData + y*iplImage->widthStep);
            float *pSrc1 = (float *)((char*)iplImage->imageData + (y+1)*iplImage->widthStep);
            float *pDiff = (float *)((char*)iplTemp->imageData + y*iplTemp->widthStep);
            for (int x=1; x<iplTemp->width; x++) {
                float diff = 0.0f;
                float center = pSrc0[x];
                float delta;
                delta = center - pSrcN[x-1]; diff += delta * delta;//> 0 ? delta : -delta;
                delta = center - pSrcN[x]; diff += delta * delta;//> 0 ? delta : -delta;
                delta = center - pSrcN[x+1]; diff += delta * delta;//> 0 ? delta : -delta;
                delta = center - pSrc1[x-1]; diff += delta * delta;// > 0 ? delta : -delta;
                delta = center - pSrc1[x]; diff += delta * delta;// > 0 ? delta : -delta;
                delta = center - pSrc1[x+1]; diff += delta * delta;// > 0 ? delta : -delta;
                delta = center - pSrc0[x-1]; diff += delta * delta;// > 0 ? delta : -delta;
                delta = center - pSrc0[x+1]; diff += delta * delta;// > 0 ? delta : -delta;
                pDiff[x] = sqrt(diff);
            }
        }
		// calculate mean local variance
		for (int y=1; y<iplLocVar->height-1; y++) {
            float *pSrcN = (float *)((char*)iplTemp->imageData + (y-1)*iplTemp->widthStep);
            float *pSrc0 = (float *)((char*)iplTemp->imageData + y*iplTemp->widthStep);
            float *pSrc1 = (float *)((char*)iplTemp->imageData + (y+1)*iplTemp->widthStep);
			float *pDst = (float *)((char*)iplLocVar->imageData + y*iplLocVar->widthStep);
			for (int x=1; x<iplLocVar->width-1; x++) {
				pLine[x] = pSrcN[x] + pSrc0[x] + pSrc1[x];
			}
            for (int x=1; x<iplLocVar->width-1; x++) {
                pDst[x] = (pLine[x-1] + pLine[x] + pLine[x+1]) * div;
            }
		}
	} else {
		showErrMsg("Input image must be 32F in CImageUtility::extrLocVarMap3x3_32f()!\n");
		safeReleaseImage(&iplTemp);
		return false;
	}

	safeReleaseImage(&iplTemp);

	return true;
}

bool CImageUtility::extrLocVar3x3_32f(IplImage *iplImage, IplImage *iplLocVar)
// Calculate the local variance of an image
// The local variance is: Lv(x,y) = sq(I(x,y) - I(x,y-1)) + sq(I(x,y) - I(x,y+1)) + sq(I(x,y) - I(x-1,y)) + sq(I(x,y) - I(x+1,y))
// NOTE: there is no sqrt() in this function compared with functions like extrLocVarMap3x3_32f()!
// by Luhong Liang, IC-ASD, ASTRI, Nov. 1, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplLocVar == NULL || iplLocVar->nChannels != 1 ||
        iplImage->width != iplLocVar->width || iplImage->height != iplLocVar->height ||
        iplImage->depth != SR_DEPTH_32F || iplLocVar->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::extrLocVar3x3_32f()!\n");
		return false;
	}

	// allocate buffers
	IplImage *iplPadded = padding(iplImage, 1, 1, 1, 1);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrLocVar3x3_32f()!\n");
		return false;
	}


	if (iplImage->depth == SR_DEPTH_32F) {
        // calculate 3x3 variance
        for (int y=1; y<iplLocVar->height-1; y++) {
            float *pSrcN = (float *)((char*)iplImage->imageData + (y-1)*iplImage->widthStep);
            float *pSrc0 = (float *)((char*)iplImage->imageData + y*iplImage->widthStep);
            float *pSrc1 = (float *)((char*)iplImage->imageData + (y+1)*iplImage->widthStep);
            float *pVar = (float *)((char*)iplLocVar->imageData + y*iplLocVar->widthStep);
            for (int x=1; x<iplLocVar->width; x++) {
                float diff = 0.0f;
                float center = pSrc0[x];
                float delta;
                delta = center - pSrcN[x]; diff += delta * delta;//> 0 ? delta : -delta;
                delta = center - pSrc1[x]; diff += delta * delta;// > 0 ? delta : -delta;
                delta = center - pSrc0[x-1]; diff += delta * delta;// > 0 ? delta : -delta;
                delta = center - pSrc0[x+1]; diff += delta * delta;// > 0 ? delta : -delta;
                pVar[x] = diff;
            }
        }
	} else {
		showErrMsg("Input image must be 32F in CImageUtility::extrLocVarMap3x3_32f()!\n");
		safeReleaseImage(&iplPadded);
		return false;
	}

	safeReleaseImage(&iplPadded);

	return true;
}

IplImage *CImageUtility::extrMADMap_32f(IplImage *iplImage, int wnd_size)
// calculate the map of local MAD of an image
// by Luhong Liang, IC-ASD, ASTRI, Dec. 4, 2012
{
	if (iplImage == NULL || iplImage->nChannels != 1) {
		showErrMsg("Invalid input image type in CImageUtility::extrMADMap_32f()!\n");
		return NULL;
	}

	// data type conversion
	IplImage *iplSrc = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplTemp = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	if (iplSrc == NULL || iplTemp == NULL)  {
		safeReleaseImage(&iplSrc, &iplTemp);
		showErrMsg("Fail to allocate buffer in CImageUtility::extrMADMap_32f()!\n");
		return NULL;
	}

	if (iplImage->depth == SR_DEPTH_32F) {
		copy(iplImage, iplSrc);
	} else if (iplImage->depth == SR_DEPTH_8U) {
		cvtImage8Uto32F(iplImage, iplSrc);
	} else {
		showErrMsg("Input image must be 8U or 32F in CImageUtility::extrMADMap_32f()!\n");
		safeReleaseImage(&iplSrc, &iplTemp);
		return NULL;
	}

	// check local MAD
	setZero(iplTemp);
	float div = 1.0f / (wnd_size * wnd_size);
	int start = wnd_size >> 1;
	int end = wnd_size - start - 1;
	for (int y=start; y<iplTemp->height-end; y++) {
		float *pMAD = (float*)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		for (int x=start; x<iplTemp->width-end; x++) {
			// calculate mean
			float mean = 0.0f;
			for (int v = y - start; v < y - start + wnd_size; v++) {
				float *pSrc = (float*)((char *)iplSrc->imageData + v * iplSrc->widthStep);
				for (int u = x - start; u < x - start + wnd_size; u++) {
					mean += pSrc[u];
				}
			}
			mean = mean * div;
			// calculate MAD
			float mae = 0.0f;
			for (int v = y - start; v < y - start + wnd_size; v++) {
				float *pSrc = (float*)((char *)iplSrc->imageData + v * iplSrc->widthStep);
				for (int u = x - start; u < x - start + wnd_size; u++) {
					float diff = pSrc[u] - mean;
					diff = diff < 0.0f ? -diff : diff;
					mae += diff;
				}
			}
			mae = mae * div;
			pMAD[x] = mae;
		}
	}

	safeReleaseImage(&iplSrc);

	return iplTemp;
}

IplImage *CImageUtility::extrMADMap5x5_32f(IplImage *iplImage)
// Calculate the map of local MAD of an image
// This function is a faster version of function extrMADMap_32f().
// by Luhong Liang, IC-ASD, ASTRI, Feb. 18, 2013
// Memory leak check, June 27, 2013
// Intergal image overflow bug fixed, Aug. 10, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1) {
		showErrMsg("Invalid input image type in CImageUtility::extrMADMap5x5_32f()!\n");
		return NULL;
	}

	// allocate buffers
	IplImage *iplMAD = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplInt = createImage( iplImage->width, iplImage->height, SR_DEPTH_64F, 1 );  // must be double to support 4K format!, Luhong, Aug. 12, 2013
	if (iplMAD == NULL || iplInt == NULL)  {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrMADMap5x5_32f()!\n");
		safeReleaseImage(&iplMAD, &iplInt);
		return NULL;
	}
	const float div = 1.0f / 25.0f;
	setZero(iplMAD);	// to guarantee the correct integral map

	if (iplImage->depth == SR_DEPTH_32F) {
        //float fStartTime = (float)clock() / (float)CLOCKS_PER_SEC;
		// calculate integral map of the original image
		float *pSrc0 = (float *)((char*)iplImage->imageData);
		double *pDst0 = (double *)((char*)iplInt->imageData);
		pDst0[0] = pSrc0[0];
		for (int x=1; x<iplInt->width; x++) {
			pDst0[x] = pDst0[x-1] + pSrc0[x];
		}
		for (int y=1; y<iplInt->height; y++) {
			float *pSrc = (float *)((char*)iplImage->imageData + y*iplImage->widthStep);
			double *pDstN = (double *)((char*)iplInt->imageData + (y-1)*iplInt->widthStep);
			double *pDst = (double *)((char*)iplInt->imageData + y*iplInt->widthStep);
			pDst[0] = pDstN[0] + pSrc[0];
			for (int x=1; x<iplInt->width; x++) {
				pDst[x] = pSrc[x] + pDst[x-1] + pDstN[x] - pDstN[x-1];
			}
		}
		// calculate mean (valid region only)
		double *pInt = (double *)((char*)iplInt->imageData + 4*iplInt->widthStep);
		float *pMean = (float *)((char*)iplMAD->imageData + 2*iplMAD->widthStep);
		pMean[2] = (float)(pInt[4] * div);
		for (int x=3; x<iplMAD->width-2; x++) {
			pMean[x] = (float)(pInt[x+2] - pInt[x-3]) * div;
		}
		for (int y=3; y<iplMAD->height-2; y++) {
			double *pInt0 = (double *)((char*)iplInt->imageData + (y-3)*iplInt->widthStep);
			double *pInt1 = (double *)((char*)iplInt->imageData + (y+2)*iplInt->widthStep);
			float *pMean = (float *)((char*)iplMAD->imageData + y*iplMAD->widthStep);
			pMean[2] = (float)(pInt1[4] - pInt0[4]) * div;
			for (int x=3; x<iplMAD->width-2; x++) {
				pMean[x] = (float)(pInt1[x+2] - pInt1[x-3] - pInt0[x+2] + pInt0[x-3]) * div;
			}
		}
        //float fRunTime = (float)clock() / (float)CLOCKS_PER_SEC;
        //fRunTime = fRunTime - fStartTime;
        //showMessage1("%f s used in calculating mean.\n", fRunTime);

        //saveImage("_MAD_Mean.bmp", iplMAD);
        //fStartTime = (float)clock() / (float)CLOCKS_PER_SEC;
		// calculate MAD
		for (int y=2; y<iplMAD->height-2; y++) {
			float *pMAD = (float*)((char *)iplMAD->imageData + y * iplMAD->widthStep);
			for (int x=2; x<iplMAD->width-2; x++) {
				// calculate mean
				float mean = pMAD[x];
				// calculate MAD
				float mad = 0.0f;
				for (int v = y-2; v < y+3; v++) {
					float *pSrc = (float*)((char *)iplImage->imageData + v * iplImage->widthStep);
					for (int u = x-2; u < x+3; u++) {
						float diff = pSrc[u] - mean;
						diff = diff < 0.0f ? -diff : diff;
						mad += diff;
					}
				}
				mad = mad * div;
				pMAD[x] = mad;
			}
		}
        //fRunTime = (float)clock() / (float)CLOCKS_PER_SEC;
        //fRunTime = fRunTime - fStartTime;
        //showMessage1("%f s used in MAD calculation.\n", fRunTime);

    } else if (iplImage->depth == SR_DEPTH_8U) {
		// calculate integral map
		unsigned char *pSrc0 = (unsigned char *)((char*)iplImage->imageData);
		double *pDst0 = (double *)((char*)iplInt->imageData);
		pDst0[0] = pSrc0[0];
		for (int x=1; x<iplInt->width; x++) {
			pDst0[x] = pDst0[x-1] + pSrc0[x];
		}
		for (int y=1; y<iplInt->height; y++) {
			unsigned char *pSrc = (unsigned char *)((char*)iplImage->imageData + y*iplImage->widthStep);
			double *pDstN = (double *)((char*)iplInt->imageData + (y-1)*iplInt->widthStep);
			double *pDst = (double *)((char*)iplInt->imageData + y*iplInt->widthStep);
			pDst[0] = pDstN[0] + pSrc[0];
			for (int x=1; x<iplInt->width; x++) {
				pDst[x] = pSrc[x] + pDst[x-1] + pDstN[x] - pDstN[x-1];
			}
		}
		// calculate mean (valid region only)
		double *pInt = (double *)((char*)iplInt->imageData + 4*iplInt->widthStep);
		float *pMean = (float *)((char*)iplMAD->imageData + 2*iplMAD->widthStep);
		pMean[2] = (float)(pInt[4] * div);
		for (int x=3; x<iplMAD->width-2; x++) {
			pMean[x] = (float)(pInt[x+2] - pInt[x-3]) * div;
		}
		for (int y=3; y<iplMAD->height-2; y++) {
			double *pInt0 = (double *)((char*)iplInt->imageData + (y-3)*iplInt->widthStep);
			double *pInt1 = (double *)((char*)iplInt->imageData + (y+2)*iplInt->widthStep);
			float *pMean = (float *)((char*)iplMAD->imageData + y*iplMAD->widthStep);
			pMean[2] = (float)(pInt1[4] - pInt0[4]) * div;
			for (int x=3; x<iplMAD->width-2; x++) {
				pMean[x] = (float)(pInt1[x+2] - pInt1[x-3] - pInt0[x+2] + pInt0[x-3]) * div;
			}
		}
		// calculate MAD
		for (int y=2; y<iplMAD->height-2; y++) {
			float *pMAD = (float*)((char *)iplMAD->imageData + y * iplMAD->widthStep);
			for (int x=2; x<iplMAD->width-2; x++) {
				// calculate mean
				float mean = pMAD[x];
				// calculate MAD
				float mad = 0.0f;
				for (int v = y-2; v < y+3; v++) {
					unsigned char *pSrc = (unsigned char*)((char *)iplImage->imageData + v * iplImage->widthStep);
					for (int u = x-2; u < x+3; u++) {
						float diff = (float)(pSrc[u]) - mean;
						diff = diff < 0.0f ? -diff : diff;
						mad += diff;
					}
				}
				mad = mad * div;
				pMAD[x] = mad;
			}
		}
	} else {
		showErrMsg("Input image must be 8U or 32F in CImageUtility::extrMADMap5x5_32f()!\n");
		safeReleaseImage(&iplInt, &iplMAD);
		return NULL;
	}

	safeReleaseImage(&iplInt);

	return iplMAD;
}

bool CImageUtility::extrSingularBinMap5x5_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// Detect the singular point region (like speckle) and binary pattern structure region to output a
// likelihood map
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image; should be the same size as iplSrcImage
{
	if (iplSrcImage == NULL || iplDstImage == NULL) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::extrSingularBinMap5x5_32f()!\n");
		return false;
	}

	const int padded = 2;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrSingularBinMap5x5_32f()!\n");
		return false;
	}

    float pBlock[25];
    const float delta_factor_mean = 0.0625f;       // for speckle detection
    const float delta_factor_span = 0.25f;       // for speckle detection
    const float min_delta = 4.0f;               // for speckle detection
    const float min_diff_th = 16.0f;             // for binary structure detection

    for (int y=0; y<iplDstImage->height; y++) {
        //float *pSrc = (float *)((char *)iplPadded->imageData + y * iplPadded->widthStep);
        float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            //if (x == 49 && y == 107 || x==764&&y==49)
            //    int p = 1;
            // get 5x5 data and calculate mean, max and min
            int i=0;
            float sumval = 0;
            float maxval = 0.0f;
            float minval = 255.0f;
            for (int v = y; v < y+5; v++) {
                float *pSrc = (float*)((char *)iplPadded->imageData + v * iplPadded->widthStep);
                for (int u = x; u < x+5; u++) {
                    float val = pSrc[u];
                    pBlock[i] = val;
                    sumval += val;
                    maxval = val > maxval ? val : maxval;
                    minval = val < minval ? val : minval;
                    i++;
				}
            }
            float meanval = sumval / 25.0f;
            
            // calculate the "sigular point" indicator and accumulated binary likelihood
            int bnum = 0;
            int dnum = 0;
            float acc_diff = 0.0f;
            float span = (maxval-meanval) < (meanval-minval) ? (maxval-meanval) : (meanval-minval);
            float init_delta = (delta_factor_mean*meanval < delta_factor_span*span) ? delta_factor_mean*meanval : delta_factor_span*span;
            float delta = (init_delta > min_delta) ? init_delta : min_delta;
            for (int n=0; n<25; n++) {
                // sigular point
                float val = pBlock[n];
                if (val > (meanval+delta)) {
                    //bmean += pBlock[n];
                    bnum ++;
                } else if (val < (meanval-delta)) {
                    //dmean += pBlock[n];
                    dnum ++;
                }
                // binary likelihood
                float diff_max = maxval - val;
                float diff_min = val - minval; 
                if (diff_max < diff_min) { 
                    acc_diff += diff_max; 
                } else {
                    acc_diff += diff_min; 
                }
            }
            int sigularnum;
            if (bnum == 0) {
                sigularnum = dnum;
            } else if (dnum == 0) {
                sigularnum = bnum;
            } else {
                sigularnum = bnum < dnum ? bnum : dnum;     // it is possibly the speckle, if very few pixels with most max/min intensity
            }
            // consider flat region as singular point!!!
            //pDst[x] = sigularnum; continue;     // for debug only

            // calculate the "sigular point" indicator
            float diff_max_min = maxval - minval;
            //pDst[x] = diff_max_min; continue; // for debug only
            //pDst[x] = diff_max_min; continue;   // for debug only
            //float w_maxmin;
            //if (diff_max_min < 16.0f) {
            //    w_maxmin = 0.0f;
            //} else if (diff_max_min < 32.0f) {
            //    w_maxmin = (diff_max_min - 16.0f) / 16.0f;
            //} else {
            //    w_maxmin = 1.0f;
            //}
            //float singular_like1 = (16.0f - sigularnum) * w_maxmin;
            //pDst[x] = singular_like1*16; continue;   // for debug only
            //if (x==706 && y==139)
            //    int p =1;
            float w1;
            if (diff_max_min <= 0.0f) {
                w1 = 0.0f;
            } else {
                float sig_div = diff_max_min < 8.0f ? 8.0f : diff_max_min;
                w1 = sigularnum / sqrt(sig_div);
            }

            // measure binary structure
            float diffmaxmin = maxval - minval;
            diffmaxmin = diffmaxmin < min_diff_th ? min_diff_th : diffmaxmin;
            float binstruct = acc_diff / diffmaxmin;
            binstruct = binstruct < 4.0f ? 4.0f : binstruct;
            binstruct = binstruct > 6.0f ? 6.0f : binstruct;
            float w2 = (binstruct - 4.0f) * 0.5f;       // smaller, more like binary pattern

            // fusion
            float wf = (w1 + 0.125f) * (w2 + 0.03125f) - 0.125f * 0.03125f;
            wf = wf > 1.0f ? 1.0f : wf;

            // write back
            pDst[x] = wf;
        }
    }
    //saveImage("__MaxMin__v5.bmp", iplDstImage, 0, 1.0f);
    //saveImage("__W6__v5.bmp", iplDstImage, 64, 255.0f);
    
    safeReleaseImage(&iplPadded);
	
	return true;
}

 bool CImageUtility::extrSingularBinMap5x5_32f(IplImage *iplSrcImage, IplImage *iplSin, IplImage *iplBin, IplImage *iplMaxMin, IplImage *iplMAD)
// Detect the singular point region (like speckle), binary pattern structure region and the local difference of max-min
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//		iplSin -- [O] singular num, 0~16, 0 represents the most singular  region (more like speckle)
//     iplBin -- [O] binary pattern measurement, 0 represents the pixel most like binary pattern
//     iplMaxMin -- [O] difference of maximum and minimun value in the window
//     iplMAD -- [O] MAD of the window
{
	if (iplSrcImage == NULL || iplSin == NULL || iplBin == NULL || iplMaxMin == NULL) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::extrSingularBinMap5x5_32f()!\n");
		return false;
	}

	const int padded = 2;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrSingularBinMap5x5_32f()!\n");
		return false;
	}

    float pBlock[25];
    const float delta_factor_mean = 0.0625f;       // for speckle detection
    const float delta_factor_span = 0.25f;       // for speckle detection
    const float min_delta = 4.0f;               // for speckle detection
    const float min_diff_th = 16.0f;             // for binary structure detection

    for (int y=0; y<iplSin->height; y++) {
        //float *pSrc = (float *)((char *)iplPadded->imageData + y * iplPadded->widthStep);
        float *pSin = (float *)((char *)iplSin->imageData + y * iplSin->widthStep);
        float *pBin = (float *)((char *)iplBin->imageData + y * iplBin->widthStep);
        float *pDif = (float *)((char *)iplMaxMin->imageData + y * iplMaxMin->widthStep);
        float *pMAD = (float *)((char *)iplMAD->imageData + y * iplMAD->widthStep);
        for (int x=0; x<iplSin->width; x++) {
            //if (x == 49 && y == 107 || x==764&&y==49)
            //    int p = 1;
            // get 5x5 data and calculate mean, max and min
            float sumval = 0;
            float maxval = 0.0f;
            float minval = 255.0f;
            int i=0;
            for (int v = y; v < y+5; v++) {
                float *pSrc = (float*)((char *)iplPadded->imageData + v * iplPadded->widthStep);
                for (int u = x; u < x+5; u++) {
                    float val = pSrc[u];
                    pBlock[i] = val;
                    sumval += val;
                    maxval = val > maxval ? val : maxval;
                    minval = val < minval ? val : minval;
                    i++;
				}
            }
            float meanval = sumval / 25.0f;
            float diff_max_min = maxval - minval;
            //float div_mean = meanval < 32.0f ? 1.0f : meanval/32.0f;
            //pDif[x] = diff_max_min / div_mean;
            pDif[x] = diff_max_min;

            // MAD
            i=0;
            float mad = 0.0f;
            for (int v = y; v < y+5; v++) {
                float *pSrc = (float*)((char *)iplPadded->imageData + v * iplPadded->widthStep);
                for (int u = x; u < x+5; u++) {
                    float val = pSrc[u];
                    float dif = val - meanval;
                    dif = dif < 0.0f ? -dif : dif;
                    mad += dif;
                }
            }
            mad = mad / 25.0f;
            pMAD[x] = mad;
            
            // calculate the "sigular point" indicator and accumulated binary likelihood
            int bnum = 0;
            int dnum = 0;
            float acc_diff = 0.0f;
            float span = (maxval-meanval) < (meanval-minval) ? (maxval-meanval) : (meanval-minval);
            float init_delta = (delta_factor_mean*meanval < delta_factor_span*span) ? delta_factor_mean*meanval : delta_factor_span*span;
            float delta = (init_delta > min_delta) ? init_delta : min_delta;
            for (int n=0; n<25; n++) {
                // sigular point
                float val = pBlock[n];
                if (val > (meanval+delta)) {
                    //bmean += pBlock[n];
                    bnum ++;
                } else if (val < (meanval-delta)) {
                    //dmean += pBlock[n];
                    dnum ++;
                }
                // binary likelihood
                float diff_max = maxval - val;
                float diff_min = val - minval; 
                if (diff_max < diff_min) { 
                    acc_diff += diff_max; 
                } else {
                    acc_diff += diff_min; 
                }
            }
            int sigularnum;
            if (bnum == 0) {
                sigularnum = dnum;
            } else if (dnum == 0) {
                sigularnum = bnum;
            } else {
                sigularnum = bnum < dnum ? bnum : dnum;     // it is possibly the speckle, if very few pixels with most max/min intensity
            }
            // consider flat region as singular point!!!
            pSin[x] = (float)sigularnum;

            // measure binary structure
            float bin_div = diff_max_min < min_diff_th ? min_diff_th : diff_max_min;
            float binstruct = acc_diff / bin_div;
            pBin[x] = binstruct;
        }
    }
    
    safeReleaseImage(&iplPadded);
	
	return true;
}

bool CImageUtility::extrSingularBinMap5x5_8U_v2(IplImage *iplSrcImage, IplImage *iplBin, IplImage *iplMaxMin)
// Detect the singular point region (like speckle), binary pattern structure region and the local difference of max-min
// This function is a fixed-point implementatin of function extrSingularBinMap5x5_32f().
// This function supposes the input image iplSrcImage has been padded 2 pixels in each direction!
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//     iplBin -- [O] binary pattern measurement, 0 represents the pixel most like binary pattern
//     iplMaxMin -- [O] difference of maximum and minimun value in the window
// by Luhong Liang, IC-ASD, ASTRI
// June 13, 2014
{
	if (iplSrcImage == NULL || iplBin == NULL || iplMaxMin == NULL ||
        iplSrcImage->depth != SR_DEPTH_8U || iplBin->depth != SR_DEPTH_8U || iplMaxMin->depth != SR_DEPTH_8U ||
        iplSrcImage->width != iplBin->width+4 || iplSrcImage->height != iplBin->height+4 ||
        iplSrcImage->width != iplMaxMin->width+4 || iplSrcImage->height != iplMaxMin->height+4) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::extrSingularBinMap5x5_8U_v2()!\n");
		return false;
	}

    unsigned char pBlock[25];
    const int min_diff_th = 16;                       // for binary structure detection

    for (int y=0; y<iplBin->height; y++) {
        //unsigned char *pSrc = (unsigned char *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        unsigned char *pBin = (unsigned char *)((char *)iplBin->imageData + y * iplBin->widthStep);
        unsigned char *pDif = (unsigned char *)((char *)iplMaxMin->imageData + y * iplMaxMin->widthStep);
        for (int x=0; x<iplBin->width; x++) {
            //if (x == 49 && y == 107 || x==764&&y==49)
            //    int p = 1;
            // get 5x5 data and calculate mean, max and min
            int sumval = 0;
            unsigned char maxval = 0;
            unsigned char minval = 255;
            int i=0;
            for (int v = y; v < y+5; v++) {
                unsigned char *pSrc = (unsigned char*)((char *)iplSrcImage->imageData + v * iplSrcImage->widthStep);
                for (int u = x; u < x+5; u++) {
                    unsigned char val = pSrc[u];
                    pBlock[i] = val;
                    sumval += val;
                    maxval = val > maxval ? val : maxval;
                    minval = val < minval ? val : minval;
                    i++;
				}
            }
            int diff_max_min = maxval - minval;
            pDif[x] = (unsigned char)diff_max_min;
           
            // calculate the "sigular point" indicator and accumulated binary likelihood
            int acc_diff = 0;
            for (int n=0; n<25; n++) {
                // binary likelihood
                unsigned char val = pBlock[n];
                unsigned char diff_max = maxval - val;
                unsigned char diff_min = val - minval; 
                if (diff_max < diff_min) { 
                    acc_diff += diff_max; 
                } else {
                    acc_diff += diff_min; 
                }
            }

            // measure binary structure
            int bin_div = diff_max_min < min_diff_th ? min_diff_th : diff_max_min;
            int binstruct = (acc_diff << 4) / bin_div;
            binstruct = binstruct > 255 ? 255 : binstruct;
            pBin[x] = (unsigned char)binstruct;
        }
    }

	return true;
}

bool CImageUtility::extrSingularBinMap5x5_8U_v2a(IplImage *iplSrcImage, IplImage *iplBin, IplImage *iplMaxMin)
// Detect the singular point region (like speckle), binary pattern structure region and the local difference of max-min
// This function is a hardware-friendly version of  function extrSingularBinMap5x5_8U_v2(). The new function uses a LUT
// instead of division. This function supposes the input image iplSrcImage has been padded 2 pixels in each direction!
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//     iplBin -- [O] binary pattern measurement, 0 represents the pixel most like binary pattern
//     iplMaxMin -- [O] difference of maximum and minimun value in the window
// by Luhong Liang, IC-ASD, ASTRI
// June 20, 2014
{
	if (iplSrcImage == NULL || iplBin == NULL || iplMaxMin == NULL ||
        iplSrcImage->depth != SR_DEPTH_8U || iplBin->depth != SR_DEPTH_8U || iplMaxMin->depth != SR_DEPTH_8U ||
        iplSrcImage->width != iplBin->width+4 || iplSrcImage->height != iplBin->height+4 ||
        iplSrcImage->width != iplMaxMin->width+4 || iplSrcImage->height != iplMaxMin->height+4) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::extrSingularBinMap5x5_8U_v2a()!\n");
		return false;
	}

    unsigned char pBlock[25];
    const unsigned char pLUT[] = { 64, 60, 57, 54, 51, 49, 47, 45, 43, 41, 39, 38, 37, 35, 34, 33, 32, 31, 30, 29, 28, 28, 27, 26,      // 48-entry, 7-bit
                                                    26, 25, 24, 24, 23, 23, 22, 22, 21, 21, 20, 20, 20, 19, 19, 19, 18, 18, 18, 17, 17, 17, 17, 16 };

    for (int y=0; y<iplBin->height; y++) {
        //unsigned char *pSrc = (unsigned char *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        unsigned char *pBin = (unsigned char *)((char *)iplBin->imageData + y * iplBin->widthStep);
        unsigned char *pDif = (unsigned char *)((char *)iplMaxMin->imageData + y * iplMaxMin->widthStep);
        for (int x=0; x<iplBin->width; x++) {
            //if (x == 49 && y == 107 || x==764&&y==49)
            //    int p = 1;
            // get 5x5 data and calculate mean, max and min
            int sumval = 0;
            unsigned char maxval = 0;
            unsigned char minval = 255;
            int i=0;
            for (int v = y; v < y+5; v++) {
                unsigned char *pSrc = (unsigned char*)((char *)iplSrcImage->imageData + v * iplSrcImage->widthStep);
                for (int u = x; u < x+5; u++) {
                    unsigned char val = pSrc[u];
                    pBlock[i] = val;
                    sumval += val;
                    maxval = val > maxval ? val : maxval;
                    minval = val < minval ? val : minval;
                    i++;
				}
            }
            int diff_max_min = maxval - minval;
            pDif[x] = (unsigned char)diff_max_min;
           
            // calculate the "sigular point" indicator and accumulated binary likelihood
            int acc_diff = 0;
            for (int n=0; n<25; n++) {
                // binary likelihood
                unsigned char val = pBlock[n];
                unsigned char diff_max = maxval - val;
                unsigned char diff_min = val - minval; 
                if (diff_max < diff_min) { 
                    acc_diff += diff_max; 
                } else {
                    acc_diff += diff_min; 
                }
            }

            // measure binary structure
            int bin_div = diff_max_min < 16 ? 16 : diff_max_min;
            unsigned char binstruct;
            if (bin_div < 64) {
                int index = bin_div - 16;       // 0~47
                binstruct = (unsigned char)((acc_diff * pLUT[index]) >> 6);      //  acc_diff: 12-bit, LUT: 7-bit
            } else {
                int index = (bin_div >> 2) - 16;       // 0~47
                binstruct = (unsigned char)((acc_diff * pLUT[index]) >> 8);      //  acc_diff: 12-bit, LUT: 7-bit
            }
            binstruct = binstruct > 255 ? 255 : binstruct;
            pBin[x] = binstruct;
        }
    }

	return true;
}

#define __acc_bin_likelihood(val, maxval, minval, diff_max, diff_min, acc)  \
{ \
    diff_max = (maxval) - (val); \
    diff_min = (val) - (minval);  \
    if (diff_max < diff_min) {  \
        acc += diff_max;  \
    } else { \
        acc += diff_min;  \
    } \
}

bool CImageUtility::extrSingularBinMap5x5_32f_v3(IplImage *iplSrcImage, IplImage *iplBin, IplImage *iplMaxMin)
// Detect the singular point region (like speckle), binary pattern structure region and the local difference of max-min
// This function is an optimized version of function extrSingularBinMap5x5_32f(), where the singluar number calculation
// part is removed.
// This function supposes the input image iplSrcImage has been padded 2 pixels in each direction!
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image, 2-pixel padded in boundaries
//     iplBin -- [O] binary pattern measurement, 0 represents the pixel most like binary pattern
//     iplMaxMin -- [O] difference of maximum and minimun value in the window
// by Luhong Liang, IC-ASD, ASTRI
// June 14, 2014
{
	if (iplSrcImage == NULL || iplBin == NULL || iplMaxMin == NULL ||
        iplSrcImage->depth != SR_DEPTH_32F || iplBin->depth != SR_DEPTH_32F || iplMaxMin->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplBin->width+4 || iplSrcImage->height != iplBin->height+4 ||
        iplSrcImage->width != iplMaxMin->width+4 || iplSrcImage->height != iplMaxMin->height+4) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::extrSingularBinMap5x5_32f_v3()!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    return extrSingularBinMap5x5_v3_32f_SIMD(iplSrcImage, iplBin, iplMaxMin);
#endif // #ifdef __SR_USE_SIMD

    //float pBlock[25];
    const float min_diff_th = 16.0f;                       // for binary structure detection
    float *pLineBuf = new float [iplSrcImage->width * 3];
    if (pLineBuf == NULL) {
        showErrMsg("Fail to allocate buffer in CImageUtility::extrSingularBinMap5x5_32f_v3()!\n");
        return false;
    }
    //float *pSum = pLineBuf;
    float *pMax = pLineBuf + 1;
    float *pMin = pLineBuf + 2;

    for (int y=0; y<iplBin->height; y++) {
        float *pSrc0 = (float *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        float *pSrc1 = (float *)((char *)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
        float *pSrc2 = (float *)((char *)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
        float *pSrc3 = (float *)((char *)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
        float *pSrc4 = (float *)((char *)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
        float *pBin = (float *)((char *)iplBin->imageData + y * iplBin->widthStep);
        float *pDif = (float *)((char *)iplMaxMin->imageData + y * iplMaxMin->widthStep);
        // calculate in Y direction
        for (int x=0, xx=0; x<iplSrcImage->width; x++, xx+=3) {
            //pSum[xx] = pSrc0[x] + pSrc1[x] + pSrc2[x] + pSrc3[x] + pSrc4[x];
            float b01 = pSrc0[x] < pSrc1[x] ? pSrc0[x] : pSrc1[x];
            float b23 = pSrc2[x] < pSrc3[x] ? pSrc2[x] : pSrc3[x];
            float b1234 = b01 < b23 ? b01 : b23;
            pMin[xx] = b1234 < pSrc4[x] ? b1234 : pSrc4[x];
            float t01 = pSrc0[x] > pSrc1[x] ? pSrc0[x] : pSrc1[x];
            float t23 = pSrc2[x] > pSrc3[x] ? pSrc2[x] : pSrc3[x];
            float t1234 = t01 > t23 ? t01 : t23;
            pMax[xx] = t1234 > pSrc4[x] ? t1234 : pSrc4[x];
        }
        for (int x=0, xx=0; x<iplBin->width; x++, xx+=3) {
            // calculate max and min
            //float sumval = pSum[xx] + pSum[xx+3] + pSum[xx+6] + pSum[xx+9] + pSum[xx+12];
            float b01 = pMin[xx] < pMin[xx+3] ? pMin[xx] : pMin[xx+3];
            float b23 = pMin[xx+6] < pMin[xx+9] ? pMin[xx+6] : pMin[xx+9];
            float b1234 = b01 < b23 ? b01 : b23;
            float minval = b1234 < pMin[xx+12] ? b1234 : pMin[xx+12];
            float t01 = pMax[xx] > pMax[xx+3] ? pMax[xx] : pMax[xx+3];
            float t23 = pMax[xx+6] > pMax[xx+9] ? pMax[xx+6] : pMax[xx+9];
            float t1234 = t01 > t23 ? t01 : t23;
            float maxval = t1234 > pMax[xx+12] ? t1234 : pMax[xx+12];
            float diff_max_min = maxval - minval;
            pDif[x] = diff_max_min;

            // binary likelihood
            float acc_diff = 0.0f;
            float diff_max, diff_min;
            __acc_bin_likelihood(pSrc0[x], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc0[x+1], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc0[x+2], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc0[x+3], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc0[x+4], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc1[x], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc1[x+1], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc1[x+2], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc1[x+3], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc1[x+4], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc2[x], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc2[x+1], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc2[x+2], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc2[x+3], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc2[x+4], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc3[x], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc3[x+1], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc3[x+2], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc3[x+3], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc3[x+4], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc4[x], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc4[x+1], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc4[x+2], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc4[x+3], maxval, minval, diff_max, diff_min, acc_diff);
            __acc_bin_likelihood(pSrc4[x+4], maxval, minval, diff_max, diff_min, acc_diff);

            // measure binary structure
            float bin_div = diff_max_min < min_diff_th ? min_diff_th : diff_max_min;
            float binstruct = acc_diff / bin_div;
            pBin[x] = binstruct;
        }
    }

    delete [] pLineBuf;

	return true;
}

IplImage *CImageUtility::extrMADMap5x5_o1_32f(IplImage *iplImage)
// Calculate the map of local MAD of an image
// This function is a faster version of function extrMADMap_32f().
{
	if (iplImage == NULL || iplImage->nChannels != 1) {
		showErrMsg("Invalid input image type in CImageUtility::extrMADMap5x5_o1_32f()!\n");
		return NULL;
	}

	// allocate buffers
	IplImage *iplMAD = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	if (iplMAD == NULL)  {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrMADMap5x5_o1_32f()!\n");
		return NULL;
	}

    if (extrMADMap5x5_o1_32f(iplImage, iplMAD)) {
        return iplMAD;
    } else {
        safeReleaseImage(&iplMAD);
        return NULL;
    }
}

bool CImageUtility::extrMADMap5x5_o1_32f(IplImage *iplImage, IplImage *iplMAD)
// Calculate the map of local MAD of an image
// This function is a faster version of function extrMADMap_32f().
// by Luhong Liang, IC-ASD, ASTRI, Feb. 18, 2013
// Memory leak check, June 27, 2013
// Intergal image overflow bug fixed, Aug. 10, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplMAD == NULL || iplMAD->nChannels != 1 ||
        iplImage->depth != SR_DEPTH_32F || iplMAD->depth != SR_DEPTH_32F || 
        iplImage->width != iplMAD->width || iplImage->height != iplMAD->height) {
		showErrMsg("Invalid input image type in CImageUtility::extrMADMap5x5_o1_32f()!\n");
		return NULL;
	}

	// allocate buffers
	IplImage *iplInt = createImage( iplImage->width, iplImage->height, SR_DEPTH_64F, 1 );  // must be double to support 4K format!, Luhong, Aug. 12, 2013
	if (iplInt == NULL)  {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrMADMap5x5_o1_32f()!\n");
		return NULL;
	}
	const float div = 1.0f / 25.0f;
	setZero(iplMAD);	// to guarantee the correct integral map

	if (iplImage->depth == SR_DEPTH_32F) {
        //float fStartTime = (float)clock() / (float)CLOCKS_PER_SEC;
		// calculate integral map of the original image
		float *pSrc0 = (float *)((char*)iplImage->imageData);
		double *pDst0 = (double *)((char*)iplInt->imageData);
		pDst0[0] = pSrc0[0];
		for (int x=1; x<iplInt->width; x++) {
			pDst0[x] = pDst0[x-1] + pSrc0[x];
		}
		for (int y=1; y<iplInt->height; y++) {
			float *pSrc = (float *)((char*)iplImage->imageData + y*iplImage->widthStep);
			double *pDstN = (double *)((char*)iplInt->imageData + (y-1)*iplInt->widthStep);
			double *pDst = (double *)((char*)iplInt->imageData + y*iplInt->widthStep);
			pDst[0] = pDstN[0] + pSrc[0];
			for (int x=1; x<iplInt->width; x++) {
				pDst[x] = pSrc[x] + pDst[x-1] + pDstN[x] - pDstN[x-1];
			}
		}
		// calculate mean (valid region only)
		double *pInt = (double *)((char*)iplInt->imageData + 4*iplInt->widthStep);
		float *pMean = (float *)((char*)iplMAD->imageData + 2*iplMAD->widthStep);
		pMean[2] = (float)(pInt[4] * div);
		for (int x=3; x<iplMAD->width-2; x++) {
			pMean[x] = (float)(pInt[x+2] - pInt[x-3]) * div;
		}
		for (int y=3; y<iplMAD->height-2; y++) {
			double *pInt0 = (double *)((char*)iplInt->imageData + (y-3)*iplInt->widthStep);
			double *pInt1 = (double *)((char*)iplInt->imageData + (y+2)*iplInt->widthStep);
			float *pMean = (float *)((char*)iplMAD->imageData + y*iplMAD->widthStep);
			pMean[2] = (float)(pInt1[4] - pInt0[4]) * div;
			for (int x=3; x<iplMAD->width-2; x++) {
				pMean[x] = (float)(pInt1[x+2] - pInt1[x-3] - pInt0[x+2] + pInt0[x-3]) * div;
			}
		}
        //float fRunTime = (float)clock() / (float)CLOCKS_PER_SEC;
        //fRunTime = fRunTime - fStartTime;
        //showMessage1("%f s used in calculating mean.\n", fRunTime);

        //saveImage("_MAD_Mean.bmp", iplMAD);
        //fStartTime = (float)clock() / (float)CLOCKS_PER_SEC;
		// calculate MAD
		for (int y=2; y<iplMAD->height-2; y++) {
			float *pMAD = (float*)((char *)iplMAD->imageData + y * iplMAD->widthStep);
			for (int x=2; x<iplMAD->width-2; x++) {
				// calculate mean
				float mean = pMAD[x];
				// calculate MAD
				float mad = 0.0f;
                float diff;
                float *pSrc0 = (float*)((char *)iplImage->imageData + (y-2) * iplImage->widthStep) + x - 2;
                float *pSrc1 = pSrc0 + iplImage->width;
                float *pSrc2 = pSrc1 + iplImage->width;
                float *pSrc3 = pSrc2 + iplImage->width;
                float *pSrc4 = pSrc3 + iplImage->width;

                diff = pSrc0[0] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc0[1] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc0[2] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc0[3] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc0[4] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;

                diff = pSrc1[0] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc1[1] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc1[2] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc1[3] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc1[4] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;

                diff = pSrc2[0] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc2[1] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc2[2] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc2[3] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc2[4] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;

                diff = pSrc3[0] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc3[1] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc3[2] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc3[3] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc3[4] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;

                diff = pSrc4[0] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc4[1] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc4[2] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc4[3] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc4[4] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;

                mad = mad * div;
				pMAD[x] = mad;
			}
		}
        //fRunTime = (float)clock() / (float)CLOCKS_PER_SEC;
        //fRunTime = fRunTime - fStartTime;
        //showMessage1("%f s used in MAD calculation.\n", fRunTime);
	} else {
		showErrMsg("Input image must be 32F in CImageUtility::extrMADMap5x5_o1_32f()!\n");
		safeReleaseImage(&iplInt, &iplMAD);
		return NULL;
	}

	safeReleaseImage(&iplInt);

	return true;
}

bool CImageUtility::extrMADMap5x5_o1_32f(IplImage *iplImage, IplImage *iplMAD, IplImage *iplMean)
// Calculate the map of local MAD of an image
// This function is a faster version of function extrMADMap_32f().
// by Luhong Liang, IC-ASD, ASTRI, Feb. 18, 2013
// Memory leak check, June 27, 2013
// Intergal image overflow bug fixed, Aug. 10, 2013
// July 15, 2014: Add output of mean
{
    // TODO: complete check
	if (iplImage == NULL || iplImage->nChannels != 1 || iplMAD == NULL || iplMAD->nChannels != 1 ||
        iplMean == NULL || iplMean->nChannels != 1 || iplMean->depth != SR_DEPTH_32F ||
        iplImage->depth != SR_DEPTH_32F || iplMAD->depth != SR_DEPTH_32F || 
        iplImage->width != iplMAD->width || iplImage->height != iplMAD->height) {
		showErrMsg("Invalid input image type in CImageUtility::extrMADMap5x5_o1_32f()!\n");
		return NULL;
	}

	// allocate buffers
	IplImage *iplInt = createImage( iplImage->width, iplImage->height, SR_DEPTH_64F, 1 );  // must be double to support 4K format!, Luhong, Aug. 12, 2013
	if (iplInt == NULL)  {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrMADMap5x5_o1_32f()!\n");
		return NULL;
	}
	const float div = 1.0f / 25.0f;
	setZero(iplMean);	// to guarantee the correct integral map
    setZero(iplMAD);

	if (iplImage->depth == SR_DEPTH_32F) {
        //float fStartTime = (float)clock() / (float)CLOCKS_PER_SEC;
		// calculate integral map of the original image
		float *pSrc0 = (float *)((char*)iplImage->imageData);
		double *pDst0 = (double *)((char*)iplInt->imageData);
		pDst0[0] = pSrc0[0];
		for (int x=1; x<iplInt->width; x++) {
			pDst0[x] = pDst0[x-1] + pSrc0[x];
		}
		for (int y=1; y<iplInt->height; y++) {
			float *pSrc = (float *)((char*)iplImage->imageData + y*iplImage->widthStep);
			double *pDstN = (double *)((char*)iplInt->imageData + (y-1)*iplInt->widthStep);
			double *pDst = (double *)((char*)iplInt->imageData + y*iplInt->widthStep);
			pDst[0] = pDstN[0] + pSrc[0];
			for (int x=1; x<iplInt->width; x++) {
				pDst[x] = pSrc[x] + pDst[x-1] + pDstN[x] - pDstN[x-1];
			}
		}
		// calculate mean (valid region only)
		double *pInt = (double *)((char*)iplInt->imageData + 4*iplInt->widthStep);
		float *pMean = (float *)((char*)iplMean->imageData + 2*iplMean->widthStep);
		pMean[2] = (float)(pInt[4] * div);
		for (int x=3; x<iplMean->width-2; x++) {
			pMean[x] = (float)(pInt[x+2] - pInt[x-3]) * div;
		}
		for (int y=3; y<iplMean->height-2; y++) {
			double *pInt0 = (double *)((char*)iplInt->imageData + (y-3)*iplInt->widthStep);
			double *pInt1 = (double *)((char*)iplInt->imageData + (y+2)*iplInt->widthStep);
			float *pMean = (float *)((char*)iplMean->imageData + y*iplMean->widthStep);
			pMean[2] = (float)(pInt1[4] - pInt0[4]) * div;
			for (int x=3; x<iplMean->width-2; x++) {
				pMean[x] = (float)(pInt1[x+2] - pInt1[x-3] - pInt0[x+2] + pInt0[x-3]) * div;
			}
		}
        //float fRunTime = (float)clock() / (float)CLOCKS_PER_SEC;
        //fRunTime = fRunTime - fStartTime;
        //showMessage1("%f s used in calculating mean.\n", fRunTime);

        //saveImage("_MAD_Mean.bmp", iplMAD);
        //fStartTime = (float)clock() / (float)CLOCKS_PER_SEC;
		// calculate MAD
		for (int y=2; y<iplMAD->height-2; y++) {
			float *pMAD = (float*)((char *)iplMAD->imageData + y * iplMAD->widthStep);
            float *pMean = (float*)((char *)iplMean->imageData + y * iplMean->widthStep);
			for (int x=2; x<iplMAD->width-2; x++) {
				// calculate mean
				float mean = pMean[x];
				// calculate MAD
				float mad = 0.0f;
                float diff;
                float *pSrc0 = (float*)((char *)iplImage->imageData + (y-2) * iplImage->widthStep) + x - 2;
                float *pSrc1 = pSrc0 + iplImage->width;
                float *pSrc2 = pSrc1 + iplImage->width;
                float *pSrc3 = pSrc2 + iplImage->width;
                float *pSrc4 = pSrc3 + iplImage->width;

                diff = pSrc0[0] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc0[1] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc0[2] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc0[3] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc0[4] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;

                diff = pSrc1[0] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc1[1] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc1[2] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc1[3] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc1[4] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;

                diff = pSrc2[0] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc2[1] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc2[2] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc2[3] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc2[4] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;

                diff = pSrc3[0] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc3[1] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc3[2] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc3[3] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc3[4] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;

                diff = pSrc4[0] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc4[1] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc4[2] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc4[3] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;
                diff = pSrc4[4] - mean; diff = diff < 0.0f ? -diff : diff; mad += diff;

                mad = mad * div;
				pMAD[x] = mad;
			}
		}
        //fRunTime = (float)clock() / (float)CLOCKS_PER_SEC;
        //fRunTime = fRunTime - fStartTime;
        //showMessage1("%f s used in MAD calculation.\n", fRunTime);
	} else {
		showErrMsg("Input image must be 32F in CImageUtility::extrMADMap5x5_o1_32f()!\n");
		safeReleaseImage(&iplInt, &iplMAD);
		return NULL;
	}

	safeReleaseImage(&iplInt);

	return true;
}

IplImage *CImageUtility::extrMADMap_int(IplImage *iplImage, int wnd_size, int bit_depth)
// Calculate the map of local MAD of an image
// This function will normalize the bit depth to 8 bits!
// The result image is 8U!
// Arguments:
//      iplImage -- [I] input integer image, 1-channel, 32S data type
//		wnd_size == [I] window size, 1<=wnd_size<=64
//		bit_depth -- [I] bit depth of the input image, 8 <= bit_depth < 20
// by Luhong Liang, IC-ASD, ASTRI, Jan. 9, 2013; Major modification: Jan. 16, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || bit_depth < 8 ) {
		showErrMsg("Invalid input image type in CImageUtility::extrMADMap_int()!\n");
		return NULL;
	}

	// data type conversion
	IplImage *iplMap = createImage( iplImage->width, iplImage->height, SR_DEPTH_8U, 1 );
	if (iplMap == NULL)  {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrMADMap_int()!\n");
		return NULL;
	}

	if (extrMADMap_int(iplImage, iplMap, wnd_size, bit_depth)) {
		return iplMap;
	} else {
		safeReleaseImage(&iplMap);
		return NULL;
	}
}

bool CImageUtility::extrMADMap_int(IplImage *iplImage, IplImage *iplMADMap, int wnd_size, int bit_depth)
// Calculate the map of local MAD of an image
// This function will normalize the bit depth to 8 bits!
// The result image is 8U!
// Arguments:
//      iplImage -- [I] input integer image, 1-channel, 32S data type
//      iplMADMap -- [O] input integer image, 1-channel, 8U data type
//		wnd_size == [I] window size, 1<=wnd_size<=64
//		bit_depth -- [I] bit depth of the input image, 8 <= bit_depth < 20
// by Luhong Liang, IC-ASD, ASTRI, Jan. 16, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S ||
		iplMADMap == NULL || iplMADMap->nChannels != 1 || iplMADMap->depth != SR_DEPTH_8U ||
		iplImage->width != iplMADMap->width || iplImage->height != iplMADMap->height || bit_depth < 8 ) {
		showErrMsg("Invalid input/output image type or bit depth in CImageUtility::extrMADMap_int()!\n");
		return NULL;
	}

	setZero(iplMADMap);

	// check local MAD
	// This is the implementation with the best readability, but has very high overhead!
	int div = wnd_size * wnd_size;
	int start = wnd_size >> 1;
	int end = wnd_size - start - 1;
	for (int y=start; y<iplMADMap->height-end; y++) {
		unsigned char *pMAD = (unsigned char*)(iplMADMap->imageData + y * iplMADMap->widthStep);
		for (int x=start; x<iplMADMap->width-end; x++) {
			// calculate mean
			int mean = 0;
			for (int v = y - start; v < y - start + wnd_size; v++) {
				int *pSrc = (int*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u = x - start; u < x - start + wnd_size; u++) {
					mean += pSrc[u];
				}
			}
			mean = mean / div;
			// calculate MAD
			int mae = 0;
			for (int v = y - start; v < y - start + wnd_size; v++) {
				int *pSrc = (int*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u = x - start; u < x - start + wnd_size; u++) {
					int diff = pSrc[u] - mean;
					diff = diff < 0.0f ? -diff : diff;
					mae += diff;
				}
			}
			mae = mae / div;
			pMAD[x] = (unsigned char)(mae >> (bit_depth - 8));
		}
	}

	return true;
}

IplImage *CImageUtility::extrMADMap5x5_int(IplImage *iplImage, int src_depth, int dst_depth)
// Calculate the map of local MAD of an image. 
// NOTE: This function is a simplified version of extrMADMap_int(), which supports:
//       (1) 32S input and 8U output
//		 (2) 32S input and 8U output with compressed 6-bit data range
//       (1) 8U input and 8U output
//		 (2) 8U input and 8U output with compressed 6-bit data range
// When the output is 6-bit, the compression scheme is: [0,32]-->[0, 32] & (32-->95]-->(32-->63] & others-->63.
// Arguments:
//      iplImage -- [I] input integer image, 1-channel, 32S data type
//		src_depth -- [I] bit depth of the input image, 8 <= bit_depth < 20
//		dst_depth --[I] bit depth of the MAD map, should be 8 or 6
// by Luhong Liang, IC-ASD, ASTRI
// Jan. 31, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || src_depth >= 20 || src_depth < 8 || 
		(iplImage->depth != SR_DEPTH_32S && iplImage->depth != SR_DEPTH_8U)) {
		showErrMsg("Invalid input image type or bit depth in CImageUtility::extrMADMap5x5_int()!\n");
		return NULL;
	}
	if (dst_depth != 6 && dst_depth != 8) {
		showErrMsg("Only supports 6-bit and 8-bit MAD map in CImageUtility::extrMADMap5x5_int()!\n");
		return NULL;
	}

	// allocate MAD map
	IplImage *iplMap = createImage( iplImage->width, iplImage->height, SR_DEPTH_8U, 1 );
	if (iplMap == NULL)  {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrMADMap5x5_int()!\n");
		return NULL;
	}

	bool rlt;
	if (iplImage->depth == SR_DEPTH_32S) {
		if (dst_depth == 8) {
			rlt = extrMADMap5x5_Intto8U(iplImage, iplMap, src_depth);
		} else {
			rlt = extrMADMap5x5_Ito6U(iplImage, iplMap, src_depth);
		}
	} else {
		if (dst_depth == 8) {
			rlt = extrMADMap5x5_8Uto8U(iplImage, iplMap);
		} else {
			rlt = extrMADMap5x5_8Uto6U(iplImage, iplMap);
		}
	}

	if (rlt) {
		return iplMap;
	} else {
		safeReleaseImage(&iplMap);
		return NULL;
	}
}

bool CImageUtility::extrMADMap5x5_Ito6U(IplImage *iplImage, IplImage *iplMADMap, int bit_depth)
// Calculate the map of local MAD of an image. 
// NOTE: This function is a simplified version of extrMADMap_int(5x5), where the division is approximated and the output.
//       is compressed to 6 bits! The compression scheme is: [0,32]-->[0, 32] & (32-->95]-->(32-->63] & others-->63.
// Arguments:
//      iplImage -- [I] input integer image, 1-channel, 32S data type
//      iplMADMap -- [O] input integer image, 1-channel, 8U data type
//		bit_depth -- [I] bit depth of the input image, 8 <= bit_depth < 20
// by Luhong Liang, IC-ASD, ASTRI, Jan. 16, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S ||
		iplMADMap == NULL || iplMADMap->nChannels != 1 || iplMADMap->depth != SR_DEPTH_8U ||
		iplImage->width != iplMADMap->width || iplImage->height != iplMADMap->height || bit_depth < 8 ) {
		showErrMsg("Invalid input/output image type or bit depth in CImageUtility::extrMADMap5x5_Ito6U()!\n");
		return NULL;
	}

	setZero(iplMADMap);

	// check local MAD
	// This is the implementation with the best readability, but has very high overhead!
	for (int y=2; y<iplMADMap->height-2; y++) {
		unsigned char *pMAD = (unsigned char*)(iplMADMap->imageData + y * iplMADMap->widthStep);
		for (int x=2; x<iplMADMap->width-2; x++) {
			// calculate mean
			int mean = 0;
			for (int v=y-2; v<y+3; v++) {
				int *pSrc = (int*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x-2; u<x+3; u++) {
					mean += pSrc[u];
				}
			}
			mean = (mean * 41) >> 10;			// 41 can be implementated by (mean>>5)+(mean>>3)+mean
			// calculate MAD
			int mae = 0;
			for (int v=y-2; v<y+3; v++) {
				int *pSrc = (int*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x-2; u<x+3; u++) {
					int diff = pSrc[u] - mean;
					diff = diff < 0.0f ? -diff : diff;
					mae += diff;
				}
			}
			mae = mae >> 5;						// 1/32 instead of 1/25
			mae = mae >> (bit_depth - 8);		// normalize to 8-bit
			// linear piece wise
			if (mae <= 32) {
				pMAD[x] = (unsigned char)mae;
			} else if (mae < 96) {
				pMAD[x] = (unsigned char)((mae - 32) >> 1);
			} else {
				pMAD[x] = 63;
			}
		}
	}

	return true;
}

bool CImageUtility::extrMADMap5x5_Intto8U(IplImage *iplImage, IplImage *iplMADMap, int bit_depth)
// Calculate the map of local MAD of an image. The output is normalzied to 8-bit
// Arguments:
//      iplImage -- [I] input integer image, 1-channel, 32S data type
//      iplMADMap -- [O] input integer image, 1-channel, 8U data type
//		bit_depth -- [I] bit depth of the input image, 8 <= bit_depth < 20
// by Luhong Liang, IC-ASD, ASTRI, Jan. 16, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S ||
		iplMADMap == NULL || iplMADMap->nChannels != 1 || iplMADMap->depth != SR_DEPTH_8U ||
		iplImage->width != iplMADMap->width || iplImage->height != iplMADMap->height || bit_depth < 8 ) {
		showErrMsg("Invalid input/output image type or bit depth in CImageUtility::extrMADMap5x5_Ito6U()!\n");
		return NULL;
	}

	setZero(iplMADMap);

	// check local MAD
	// This is the implementation with the best readability, but has very high overhead!
	for (int y=2; y<iplMADMap->height-2; y++) {
		unsigned char *pMAD = (unsigned char*)(iplMADMap->imageData + y * iplMADMap->widthStep);
		for (int x=2; x<iplMADMap->width-2; x++) {
			// calculate mean
			int mean = 0;
			for (int v=y-2; v<y+3; v++) {
				int *pSrc = (int*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x-2; u<x+3; u++) {
					mean += pSrc[u];
				}
			}
			mean = (mean * 41) >> 10;			// 41 can be implementated by (mean>>5)+(mean>>3)+mean
			// calculate MAD
			int mae = 0;
			for (int v=y-2; v<y+3; v++) {
				int *pSrc = (int*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x-2; u<x+3; u++) {
					int diff = pSrc[u] - mean;
					diff = diff < 0.0f ? -diff : diff;
					mae += diff;
				}
			}
			mae = mae >> 5;						// 1/32 instead of 1/25
			pMAD[x] = (unsigned char)(mae >> (bit_depth - 8));		// normalize to 8-bit
		}
	}

	return true;
}

bool CImageUtility::extrMADMap5x5_8Uto8U(IplImage *iplImage, IplImage *iplMADMap)
// Calculate the map of local MAD of an image. This function will normalize the bit depth to 8 bits! The result image is 8U!
// NOTE: This function is a simplified version of extrMADMap_int5x5(), where both the IO images are 8U type
// Arguments:
//      iplImage -- [I] input integer image, 1-channel, 8U data type
//      iplMADMap -- [O] input integer image, 1-channel, 8U data type
// by Luhong Liang, IC-ASD, ASTRI, Jan. 31, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_8U ||
		iplMADMap == NULL || iplMADMap->nChannels != 1 || iplMADMap->depth != SR_DEPTH_8U ||
		iplImage->width != iplMADMap->width || iplImage->height != iplMADMap->height) {
		showErrMsg("Invalid input/output image type or bit depth in CImageUtility::extrMADMap5x5_8Uto8U()!\n");
		return NULL;
	}

	setZero(iplMADMap);

	// check local MAD
	// This is the implementation with the best readability, but has very high overhead!
	for (int y=2; y<iplMADMap->height-2; y++) {
		unsigned char *pMAD = (unsigned char*)(iplMADMap->imageData + y * iplMADMap->widthStep);
		for (int x=2; x<iplMADMap->width-2; x++) {
			// calculate mean
			int mean = 0;
			for (int v=y-2; v<y+3; v++) {
				unsigned char *pSrc = (unsigned char*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x-2; u<x+3; u++) {
					mean += pSrc[u];
				}
			}
			mean = (mean * 41) >> 10;			// 41 can be implementated by (mean>>5)+(mean>>3)+mean
			// calculate MAD
			int mae = 0;
			for (int v=y-2; v<y+3; v++) {
				unsigned char *pSrc = (unsigned char*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x-2; u<x+3; u++) {
					int diff = pSrc[u] - mean;
					diff = diff < 0.0f ? -diff : diff;
					mae += diff;
				}
			}
			pMAD[x] = (unsigned char)(mae >> 5);						// 1/32 instead of 1/25
		}
	}

	return true;
}

bool CImageUtility::extrMADMap5x5_8Uto8U_s5(IplImage *iplImage, IplImage *iplMADMap)
// Calculate the map of local MAD of an image. This function will normalize the bit depth to 8 bits! The result image is 8U!
// NOTE: This function is a simplified version of extrMADMap_int5x5(), where both the IO images are 8U type
// NOTE: Different from extrMADMap5x5_8Uto8U(), this function suppose the input image has been padded, i.e.
//       the output image will be 4x4 lines/columns smaller than the input image
// Arguments:
//      iplImage -- [I] input integer image, 1-channel, 8U data type
//      iplMADMap -- [O] input integer image, 1-channel, 8U data type
// by Luhong Liang, IC-ASD, ASTRI, May 16, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_8U ||
		iplMADMap == NULL || iplMADMap->nChannels != 1 || iplMADMap->depth != SR_DEPTH_8U ||
		iplImage->width != iplMADMap->width+4 || iplImage->height != iplMADMap->height+4) {
		showErrMsg("Invalid input/output image type or bit depth in CImageUtility::extrMADMap5x5_8Uto8U_s5()!\n");
		return NULL;
	}
	
	// check local MAD
	// This is the implementation with the best readability, but has very high overhead!
	for (int y=0; y<iplMADMap->height; y++) {
		unsigned char *pMAD = (unsigned char*)(iplMADMap->imageData + y * iplMADMap->widthStep);
		for (int x=0; x<iplMADMap->width; x++) {
			// calculate mean
			int mean = 0;
			for (int v=y; v<y+5; v++) {
				unsigned char *pSrc = (unsigned char*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x; u<x+5; u++) {
					mean += pSrc[u];
				}
			}
			mean = (mean * 41) >> 10;			// 41 can be implementated by (mean>>5)+(mean>>3)+mean
			// calculate MAD
			int mae = 0;
			for (int v=y; v<y+5; v++) {
				unsigned char *pSrc = (unsigned char*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x; u<x+5; u++) {
					int diff = pSrc[u] - mean;
					diff = diff < 0.0f ? -diff : diff;
					mae += diff;
				}
			}
			pMAD[x] = (unsigned char)(mae >> 5);						// 1/32 instead of 1/25
		}
	}

	return true;
}

bool CImageUtility::extrMADMap5x5_10Uto8U_s5(IplImage *iplImage, IplImage *iplMADMap)
// Calculate the map of local MAD of an image. This function will normalize the bit depth to 8 bits! The result image is 8U!
// NOTE: This function is a simplified version of extrMADMap_int5x5(), where both the IO images are 8U type
// NOTE: Different from extrMADMap5x5_8Uto8U(), this function suppose the input image has been padded, i.e.
//       the output image will be 4x4 lines/columns smaller than the input image
// Arguments:
//      iplImage -- [I] input integer image, 1-channel, 8U data type
//      iplMADMap -- [O] input integer image, 1-channel, 8U data type
// by Luhong Liang, IC-ASD, ASTRI, May 16, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S ||
		iplMADMap == NULL || iplMADMap->nChannels != 1 || iplMADMap->depth != SR_DEPTH_8U ||
		iplImage->width != iplMADMap->width+4 || iplImage->height != iplMADMap->height+4) {
		showErrMsg("Invalid input/output image type or bit depth in CImageUtility::extrMADMap5x5_10Uto8U_s5()!\n");
		return NULL;
	}
	
	// check local MAD
	// This is the implementation with the best readability, but has very high overhead!
	for (int y=0; y<iplMADMap->height; y++) {
		unsigned char *pMAD = (unsigned char*)(iplMADMap->imageData + y * iplMADMap->widthStep);
		for (int x=0; x<iplMADMap->width; x++) {
			// calculate mean
			int mean = 0;
			for (int v=y; v<y+5; v++) {
				int *pSrc = (int*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x; u<x+5; u++) {
					mean += pSrc[u];
				}
			}
			mean = (mean * 41) >> 10;			// 41 can be implementated by (mean>>5)+(mean>>3)+mean
			// calculate MAD
			int mae = 0;
			for (int v=y; v<y+5; v++) {
				int *pSrc = (int*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x; u<x+5; u++) {
					int diff = pSrc[u] - mean;
					diff = diff < 0.0f ? -diff : diff;
					mae += diff;
				}
			}
			int dst = mae >> 6;						// 1/32 instead of 1/25, and then shift one more bit to convert result to 9-bit
			pMAD[x] = (unsigned char)(((dst&0x00000001)==0) ? (dst>>1) : ((dst>>1)+1));		// rounding, do not need clipping (impossible to overflow)
		}
	}

	return true;
}

IplImage *CImageUtility::extrMADMap5x5_8Uto8U_s5(IplImage *iplImage)
// Calculate the map of local MAD of an image. This function will normalize the bit depth to 8 bits! The result image is 8U!
// NOTE: This function is a simplified version of extrMADMap_int5x5(), where both the IO images are 8U type
// NOTE: Different from extrMADMap5x5_8Uto8U(), this function suppose the input image has been padded, i.e.
//       the output image will be 4x4 lines/columns smaller than the input image
// Arguments:
//      iplImage -- [I] input integer image, 1-channel, 8U data type
// by Luhong Liang, IC-ASD, ASTRI, May 16, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_8U) {
		showErrMsg("Invalid input/output image type or bit depth in CImageUtility::extrMADMap5x5_8Uto8U_s5()!\n");
		return NULL;
	}

	// allocate buffer
	IplImage *iplMAD = createImage(iplImage->width-4, iplImage->height-4, SR_DEPTH_8U, 1);
	if (iplMAD == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrMADMap5x5_8Uto8U_s5()!\n");
		return NULL;
	}

	// calculate MAD
	if (extrMADMap5x5_8Uto8U_s5(iplImage, iplMAD)) {
		return iplMAD;
	} else {
		safeReleaseImage(&iplMAD);
		return NULL;
	}
}

IplImage *CImageUtility::extrMADMap5x5_10Uto8U_s5(IplImage *iplImage)
// Calculate the map of local MAD of an image. This function will normalize the bit depth to 8 bits! The result image is 8U!
// NOTE: This function is a simplified version of extrMADMap_int5x5(), where both the IO images are 8U type
// NOTE: Different from extrMADMap5x5_8Uto8U(), this function suppose the input image has been padded, i.e.
//       the output image will be 4x4 lines/columns smaller than the input image
// Arguments:
//      iplImage -- [I] input integer image, 1-channel, 8U data type
// by Luhong Liang, IC-ASD, ASTRI, May 27, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input/output image type or bit depth in CImageUtility::extrMADMap5x5_10Uto8U_s5()!\n");
		return NULL;
	}

	// allocate buffer
	IplImage *iplMAD = createImage(iplImage->width-4, iplImage->height-4, SR_DEPTH_8U, 1);
	if (iplMAD == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::extrMADMap5x5_10Uto8U_s5()!\n");
		return NULL;
	}

	// calculate MAD
	if (extrMADMap5x5_10Uto8U_s5(iplImage, iplMAD)) {
		return iplMAD;
	} else {
		safeReleaseImage(&iplMAD);
		return NULL;
	}
}

bool CImageUtility::extrMADMap5x5_8Uto6U(IplImage *iplImage, IplImage *iplMADMap)
// Calculate the map of local MAD of an image. Both the source and destination images are 8U.
// NOTE: This function is a simplified version of extrMADMap_int(5x5), where the division is approximated and the output.
//       is compressed to 6 bits! The compression scheme is: [0,32]-->[0, 32] & (32-->95]-->(32-->63] & others-->63.
// Arguments:
//      iplImage -- [I] input integer image, 1-channel, 8U data type
//      iplMADMap -- [O] input integer image, 1-channel, 8U data type
// by Luhong Liang, IC-ASD, ASTRI, Jan. 28, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_8U ||
		iplMADMap == NULL || iplMADMap->nChannels != 1 || iplMADMap->depth != SR_DEPTH_8U ||
		iplImage->width != iplMADMap->width || iplImage->height != iplMADMap->height) {
		showErrMsg("Invalid input/output image type or bit depth in CImageUtility::extrMADMap5x5_8Uto6U()!\n");
		return NULL;
	}

	setZero(iplMADMap);

	// check local MAD
	// This is the implementation with the best readability, but has very high overhead!
	for (int y=2; y<iplMADMap->height-2; y++) {
		unsigned char *pMAD = (unsigned char*)(iplMADMap->imageData + y * iplMADMap->widthStep);
		for (int x=2; x<iplMADMap->width-2; x++) {
			// calculate mean
			int mean = 0;
			for (int v=y-2; v<y+3; v++) {
				unsigned char *pSrc = (unsigned char*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x-2; u<x+3; u++) {
					mean += pSrc[u];
				}
			}
			mean = (mean * 41) >> 10;			// 41 can be implementated by (mean>>5)+(mean>>3)+mean
			// calculate MAD
			int mad = 0;
			for (int v=y-2; v<y+3; v++) {
				unsigned char *pSrc = (unsigned char*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x-2; u<x+3; u++) {
					int diff = pSrc[u] - mean;
					diff = diff < 0.0f ? -diff : diff;
					mad += diff;
				}
			}
			mad = mad >> 5;						// 1/32 instead of 1/25
			// piece-wise linear function
			// [0, 32] --> [0, 32], [33, 95] --> [32, 63] 
			if (mad <= 32) {
				pMAD[x] = (unsigned char)mad;
			} else if (mad < 96) {
				pMAD[x] = (unsigned char)((mad>>1) + 16);		// equals to ((mad-32)>>1)+32
			} else {
				pMAD[x] = 63;
			}
		}
	}

	return true;
}

bool CImageUtility::extrMADMap5x5_8Uto3U(IplImage *iplImage, IplImage *iplMADMap)
// Calculate the map of local MAD of an image. Both the source and destination images are 8U.
// NOTE: This function is a simplified version of extrMADMap_int(5x5), where the division is approximated and the output.
//       is clipped to 3 bits! This function is specailly used for content analysis.
// Arguments:
//      iplImage -- [I] input integer image, 1-channel, 8U data type
//      iplMADMap -- [O] input integer image, 1-channel, 3U data type
// by Luhong Liang, IC-ASD, ASTRI, Feb. 22, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_8U ||
		iplMADMap == NULL || iplMADMap->nChannels != 1 || iplMADMap->depth != SR_DEPTH_8U ||
		iplImage->width != iplMADMap->width || iplImage->height != iplMADMap->height) {
		showErrMsg("Invalid input/output image type or bit depth in CImageUtility::extrMADMap5x5_8Uto6U()!\n");
		return NULL;
	}

	setZero(iplMADMap);

	// check local MAD
	// This is the implementation with the best readability, but has very high overhead!
	for (int y=2; y<iplMADMap->height-2; y++) {
		unsigned char *pMAD = (unsigned char*)(iplMADMap->imageData + y * iplMADMap->widthStep);
		for (int x=2; x<iplMADMap->width-2; x++) {
			// calculate mean
			int mean = 0;
			for (int v=y-2; v<y+3; v++) {
				unsigned char *pSrc = (unsigned char*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x-2; u<x+3; u++) {
					mean += pSrc[u];
				}
			}
			mean = (mean * 41) >> 10;			// 41 can be implementated by (mean>>5)+(mean>>3)+mean
			// calculate MAD
			int mad = 0;
			for (int v=y-2; v<y+3; v++) {
				unsigned char *pSrc = (unsigned char*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x-2; u<x+3; u++) {
					int diff = pSrc[u] - mean;
					diff = diff < 0.0f ? -diff : diff;
					mad += diff;
				}
			}
			mad = mad >> 5;						// 1/32 instead of 1/25
			// clipping to 3-bit
			if (mad <= 7) {
				pMAD[x] = (unsigned char)mad;
			} else {
				pMAD[x] = 7;
			} 
		}
	}

	return true;
}

bool CImageUtility::extrMADMap5x5_8Uto3U_s5(IplImage *iplImage, IplImage *iplMADMap)
// Calculate the map of local MAD of an image. Both the source and destination images are 8U.
// NOTE: This function is a simplified version of extrMADMap_int(5x5), where the division is approximated and the output.
//       is clipped to 3 bits! This function is specailly used for content analysis.
// Different from extrMADMap5x5_8Uto3U(), this function supposes the input image has been padded by 2 pixels in each directions.
// Arguments:
//      iplImage -- [I] input integer image, 1-channel, 8U data type
//      iplMADMap -- [O] input integer image, 1-channel, 3U data type
// by Luhong Liang, IC-ASD, ASTRI, May. 27, 2013
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_8U ||
		iplMADMap == NULL || iplMADMap->nChannels != 1 || iplMADMap->depth != SR_DEPTH_8U ||
		iplImage->width != iplMADMap->width+4 || iplImage->height != iplMADMap->height+4) {
		showErrMsg("Invalid input/output image type or bit depth in CImageUtility::extrMADMap5x5_8Uto3U_s5()!\n");
		return NULL;
	}

	// check local MAD
	// This is the implementation with the best readability, but has very high overhead!
	for (int y=0; y<iplMADMap->height; y++) {
		unsigned char *pMAD = (unsigned char*)(iplMADMap->imageData + y * iplMADMap->widthStep);
		for (int x=0; x<iplMADMap->width; x++) {
			// calculate mean
			int mean = 0;
			for (int v=y; v<y+5; v++) {
				unsigned char *pSrc = (unsigned char*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x; u<x+5; u++) {
					mean += pSrc[u];
				}
			}
			mean = (mean * 41) >> 10;			// 41 can be implementated by (mean>>5)+(mean>>3)+mean
			// calculate MAD
			int mad = 0;
			for (int v=y; v<y+5; v++) {
				unsigned char *pSrc = (unsigned char*)((char *)iplImage->imageData + v * iplImage->widthStep);
				for (int u=x; u<x+5; u++) {
					int diff = pSrc[u] - mean;
					diff = diff < 0.0f ? -diff : diff;
					mad += diff;
				}
			}
			mad = mad >> 5;						// 1/32 instead of 1/25
			// clipping to 3-bit
			if (mad <= 7) {
				pMAD[x] = (unsigned char)mad;
			} else {
				pMAD[x] = 7;
			} 
		}
	}

	return true;
}

bool CImageUtility::extrStrongGradPrior_32f(IplImage *iplImage, IplImage *iplEdge, float threshold)
// extract strong gradient as prior
{
	if (iplImage == NULL || iplEdge == NULL || iplEdge->nChannels !=1 || iplEdge->depth != SR_DEPTH_32F ||
		iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::extrGradPriorMap_32f()!\n");
		return false;
	}
    if (threshold <= 0.0f) {
		showErrMsg("Invalid input threshold in CImageUtility::extrGradPriorMap_32f()!\n");
		return false;
	}

#ifdef __OPENCV_OLD_CV_H__
	IplImage *iplSrc = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplTempLR = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplTempLR1 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	if (iplSrc == NULL || iplTempLR == NULL || iplTempLR1 == NULL)  {
		safeReleaseImage(&iplSrc, &iplTempLR, &iplTempLR1);
		showErrMsg("Fail to allocate buffer in CImageUtility::extrGradPriorMap_32f()!\n");
		return false;
	}

	// data type conversion
	if (iplImage->depth == SR_DEPTH_32F) {
		copy(iplImage, iplSrc);
	} else if (iplImage->depth == SR_DEPTH_8U) {
		cvtImage8Uto32F(iplImage, iplSrc);
	} else {
		showErrMsg("Input image must be 8U or 32F in CImageUtility::extrGradPriorMap_32f()!\n");
		safeReleaseImage(&iplSrc, &iplTempLR, &iplTempLR1);
		return false;
	}

	// get gradient
	sobel_32f(iplSrc, iplTempLR, 3);
	//saveImage("_SobelLR.bmp", iplTempLR, 0.0f, 1.0f);

	// smooth
	smooth(iplTempLR, iplTempLR1, CV_GAUSSIAN, 5, 5, 1.0f);	
	//saveImage("_SobelLRSmooth.bmp", iplTempLR1, 0.0f, 1.0f);

	// gradient difference
	for (int y=0; y<iplTempLR1->height; y++) {	// have to write a customized substraction fuction, since different data types in I/O
		float *pRec = (float *)((char*)iplTempLR1->imageData + y * iplTempLR1->widthStep);
		for (int x=0; x<iplTempLR1->width; x++) {
			float grad = pRec[x];
			if (grad > threshold) {
				pRec[x] = 255.0f;
			} else {
				pRec[x] = 255.0f * grad / threshold;
			}
		}
	} 
	//saveImage("_StrongEdgeMap.bmp", iplTempLR1, 0.0f, 2.0f);
	
	// resize
	if (iplImage->width != iplEdge->width || iplImage->height != iplEdge->height) {
		resize(iplTempLR1, iplEdge, SR_INTER_NN);		// considering implemention in the loop, use NN
	} else {
		copy(iplTempLR1, iplEdge);
	}

	// release buffer
	safeReleaseImage(&iplSrc, &iplTempLR, &iplTempLR1);

	return true;
#else			//#ifdef __OPENCV_OLD_CV_H__
	showErrMsg("OpenCV is necessary in  CImageUtility::extrGradPriorMap_32f()!\n");
	return false;
#endif			//#ifdef __OPENCV_OLD_CV_H__
}

bool CImageUtility::extrBlurMap_32f(IplImage *iplImage, IplImage *iplBlur, int wnd_size)
// Extract a blurry map of the input image 
// The idea is from "The Blur Effect: Perception and Estimation with a New No-Reference Perceptual Blur Metric"
// Crt-Roffet F., Dolmiere T., Ladret P., Nicolas M. - GRENOBLE - 2007
// In SPIE proceedings - SPIE Electronic Imaging Symposium Conf Human Vision and Electronic Imaging, tats-Unis d'Amrique (2007) 
{
	if (iplImage == NULL || iplBlur == NULL) {		// TODO: complete check of the arguments
		showErrMsg("Invalid input image in CImageUtility::extrBlurMap_32f()!\n");
		return false;
	}

	// blur input image
	IplImage *iplSmoothed = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplBlurMetric = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	if (iplSmoothed == NULL|| iplBlurMetric == NULL) {
		showErrMsg("Fail to allocate image buffer in CImageUtility::extrBlurMap_32f()!\n");
		safeReleaseImage(&iplSmoothed, &iplBlurMetric);
		return false;
	}
	smooth(iplImage, iplSmoothed, SR_BLUR, wnd_size, wnd_size);		// boxing filter
	//saveImage("_Blur.bmp", iplSmoothed, 0.0f, 1.0f);

	// difference of variantions
	setZero(iplBlurMetric);
	int wnd_pad = wnd_size >> 1;
	int point_num = wnd_size * wnd_size;
	for (int y=wnd_pad; y<iplBlurMetric->height-wnd_size+1;y++) {
		float *pBlur = (float *)((char*)iplBlurMetric->imageData + y * iplBlurMetric->widthStep);
		for (int x=wnd_pad; x<iplBlurMetric->width-wnd_size+1; x++) {
			// mean
			float mean_org = 0.0f;
			float mean_smth = 0.0f;
			for (int yy=y-wnd_pad; yy<y+wnd_size-wnd_pad; yy++) {
				float *pOrg = (float *)((char*)iplImage->imageData + yy * iplImage->widthStep);
				float *pSmth = (float *)((char*)iplSmoothed->imageData + yy * iplSmoothed->widthStep);
				for (int xx=x-wnd_pad; xx<x+wnd_size-wnd_pad; xx++) {
					mean_org += pOrg[xx];
					mean_smth += pSmth[xx];
				}
			} 
			mean_org = mean_org / point_num;
			mean_smth = mean_smth / point_num;
			// mae
			float mae_org = 0.0f;
			float mae_smth = 0.0f;
			for (int yy=y-wnd_pad; yy<y+wnd_size-wnd_pad; yy++) {
				float *pOrg = (float *)((char*)iplImage->imageData + yy * iplImage->widthStep);
				float *pSmth = (float *)((char*)iplSmoothed->imageData + yy * iplSmoothed->widthStep);
				for (int xx=x-wnd_pad; xx<x+wnd_size-wnd_pad; xx++) {
					float diff = pOrg[xx] - mean_org;
					diff = diff < 0 ? -diff : diff;
					mae_org += diff;
					diff = pSmth[xx] - mean_smth;
					diff = diff < 0 ? -diff : diff;
					mae_smth += diff;
				}
			} 
			mae_org = mae_org / point_num;
			mae_smth = mae_smth / point_num;
			// blur
			pBlur[x] = mae_org - mae_smth;
		}
	}

	//saveImage("_BlurMapx4.bmp", iplBlurMetric, 0.0f, 4.0f);

	// resize
	resize(iplBlurMetric, iplBlur, SR_INTER_LINEAR);

	// release buffer
	safeReleaseImage(&iplSmoothed, &iplBlurMetric);

	return true;
}

bool CImageUtility::extrGradPriorMap_32f(IplImage *iplImage, IplImage *iplRecImage, IplImage *iplMap, float threshold)
// Extract a map of gradient prior. To make it smooth and cover the halo region, a Gaussian filter is applied to the gradent map.
// A threshold is used to saturate the gradient map.
{
	if (iplImage == NULL || iplMap == NULL || iplMap->nChannels !=1 || iplMap->depth != SR_DEPTH_32F ||
		iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::extrGradPriorMap_32f()!\n");
		return false;
	}

	IplImage *iplSrc = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplTempLR = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplTempLR1 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	if (iplSrc == NULL || iplTempLR == NULL || iplTempLR1 == NULL)  {
		safeReleaseImage(&iplSrc, &iplTempLR, &iplTempLR1);
		showErrMsg("Fail to allocate buffer in CImageUtility::extrGradPriorMap_32f()!\n");
		return false;
	}

	// data type conversion
	if (iplImage->depth == SR_DEPTH_32F) {
		copy(iplImage, iplSrc);
	} else if (iplImage->depth == SR_DEPTH_8U) {
		cvtImage8Uto32F(iplImage, iplSrc);
	} else {
		showErrMsg("Input image must be 8U or 32F in CImageUtility::extrGradPriorMap_32f()!\n");
		safeReleaseImage(&iplSrc, &iplTempLR, &iplTempLR1);
		return false;
	}

	// get gradient
	sobel_32f(iplSrc, iplTempLR, 3);
	saveImage("_SobelLR.bmp", iplTempLR, 0, 1.0f);
	sobel_32f(iplRecImage, iplTempLR1, 3);
	saveImage("_SobelRec.bmp", iplTempLR1, 0, 1.0f);

	// gradient difference
	for (int y=0; y<iplTempLR1->height; y++) {	// have to write a customized substraction fuction, since different data types in I/O
		float *pSrc = (float *)((char*)iplTempLR->imageData + y * iplTempLR->widthStep);
		float *pRec = (float *)((char*)iplTempLR1->imageData + y * iplTempLR1->widthStep);
		for (int x=0; x<iplTempLR1->width; x++) {
			float src = pSrc[x];
			float rec = pRec[x];
			float diff = src - rec;
			if (diff < 0.0f || src <= 0.0f) {
				diff = 0.0f;
			} else {
				diff = diff / src;
			}
			if (diff > threshold) {
				pRec[x] = 1.0f;
			} else {
				pRec[x] = diff / threshold;
			}
		}
	} 
	saveImage("_SobelDiffMap.bmp", iplTempLR1, 0, 255.0f);
	
	// resize
	if (iplImage->width != iplMap->width || iplImage->height != iplMap->height) {
		resize(iplTempLR1, iplMap, SR_INTER_NN);		// considering implemention in the loop, use NN
	} else {
		copy(iplTempLR1, iplMap);
	}

	// release buffer
	safeReleaseImage(&iplSrc, &iplTempLR, &iplTempLR1);

	return true;
}

bool CImageUtility::extrGradSharpMap_32f(IplImage *iplImage, IplImage *iplMap, int d)
// Calculate a map of gradient profile sharpness of an image
// The method is from:
// L. Liang, et. al. A no-reference perceptual blur metric using histogram of gradient profile sharpness, ICIP 2009
{
	if (iplImage == NULL || iplMap == NULL || iplMap->nChannels !=1 || iplMap->depth != SR_DEPTH_32F ||
		iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::extrGradPriorMap_32f()!\n");
		return false;
	}
	if (d < 1 || d > 16) {
		showErrMsg("Gradient profile length (on one side) must be 1~16 in CImageUtility::extrGradPriorMap_32f()!\n");
		return false;
	}

	IplImage *iplSrc = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGradH = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGradV = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	if (iplSrc == NULL || iplGradH == NULL || iplGradV == NULL)  {
		safeReleaseImage(&iplSrc, &iplGradH, &iplGradV);
		showErrMsg("Fail to allocate buffer in CImageUtility::extrGradPriorMap_32f()!\n");
		return false;
	}

	// data type conversion
	if (iplImage->depth == SR_DEPTH_32F) {
		copy(iplImage, iplSrc);
	} else if (iplImage->depth == SR_DEPTH_8U) {
		cvtImage8Uto32F(iplImage, iplSrc);
	} else {
		showErrMsg("Input image must be 8U or 32F in CImageUtility::extrGradPriorMap_32f()!\n");
		safeReleaseImage(&iplSrc, &iplGradH, &iplGradV);
		return false;
	}

	// calculate gradient
	sobel_32f(iplSrc, iplGradH, 0);
	//saveImage("_GradH.bmp", iplGradH, 0.0f, 1.0f);
	sobel_32f(iplSrc, iplGradV, 3);
	//saveImage("_GradV.bmp", iplGradV, 0.0f, 1.0f);

	// gradient profile sharpness
	const float grad_th = 32.0f;
	setZero(iplSrc);
	for (int y=d; y<iplSrc->height-d; y++) {	// have to write a customized substraction fuction, since different data types in I/O
		float *pGradH = (float *)((char*)iplGradH->imageData + y * iplGradH->widthStep);
		float *pGradV = (float *)((char*)iplGradV->imageData + y * iplGradV->widthStep);
		float *pDst = (float *)((char*)iplSrc->imageData + y * iplSrc->widthStep);
		for (int x=d; x<iplSrc->width-d; x++) {
			// calculate gradient profile sharpness along x or y direction
			float gx = pGradH[x];
			gx = gx < 0 ? -gx : gx;
			float gy = pGradV[x];
			gy = gy < 0 ? -gy : gy;
			if (gx < grad_th && gy < grad_th) continue;
			float sigma = 0.0f;
			if (gx > gy) {
				float *pGx = pGradH + x;
				// calculate ms and sigma square
				float ms = 0.0f;
				for (int xx=-d; xx<d; xx++) {
					float gxx = pGx[xx];
					gxx = gxx < 0? -gxx : gxx;
					ms += gxx;
					sigma += gxx * xx * xx;
				}
				if (ms > 0.0f) {
					sigma = sigma / ms;
					// calculate sigma
					float gx2 = gx * gx;
					sigma = sqrt(sigma * gx2 / (gx2 + gy * gy));
				} else {
					sigma = (float)d;
				}
			} else {
				float *pGy = pGradV + x;
				// calculate ms and sigma square
				float ms = 0.0f;			
				for (int yy=-d; yy<d; yy++) {
					float gyy = pGy[yy*iplSrc->width];
					gyy = gyy < 0 ? -gyy : gyy;
					ms += gyy;
					sigma += gyy * yy * yy;
				}
				if (ms > 0.0f) {
					sigma = sigma / ms;
					// calculate sigma
					float gy2 = gy * gy;
					sigma = sqrt(sigma * gy2 / (gy2 + gx * gx));
				} else {
					sigma = (float)d;
				}
			}
			pDst[x] = 1.0f - sigma / d;		// normalize
		}
	} 
	//saveImage("_GradProfileSharp.bmp", iplSrc, 0.0f, 255.0f);
	
	// resize
	if (iplImage->width != iplMap->width || iplImage->height != iplMap->height) {
		resize(iplSrc, iplMap, SR_INTER_CUBIC);		// considering implemention in the loop, use NN
	} else {
		copy(iplSrc, iplMap);
	}

	// release buffer
	safeReleaseImage(&iplSrc, &iplGradH, &iplGradV);

	return true;
}

bool CImageUtility::filtHolo5x5_int(IplImage *iplImage, IplImage *iplHolo)
// A filter to evaluate the differences in local windows. The 5x5 filter is
//     o  x  x  x  o
//     x  o  o  o  x
//     x  o  @  o  x
//     x  o  o  o  x
//     o  x  x  x  o
// The filter response (is abs( @ * 12 - mean(X)) >> 4)
// This function supports "in-place" operation.
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S ||
		iplHolo == NULL || iplHolo->nChannels != 1 || iplHolo->depth != SR_DEPTH_32S ||
		iplImage->width != iplHolo->width || iplImage->height != iplHolo->height) {
		showErrMsg("Invalid input/output image type or bit depth in CImageUtility::filtHolo5x5_int()!\n");
		return false;
	}

    // padding
	const int padded = 2;
	IplImage *iplPadded = padding(iplImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::filtHolo5x5_int()!\n");
		return false;
	}

    // filtering
    for (int y=0; y<iplHolo->height; y++) {
        int *pSrc0 = (int *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
        int *pSrc1 = (int *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
        int *pSrc2 = (int *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
        int *pSrc3 = (int *)((char*)iplPadded->imageData + (y+3) * iplPadded->widthStep);
        //int *pSrc4 = (int *)((char*)iplPadded->imageData + (y+4) * iplPadded->widthStep);
        int *pDst = (int *)((char*)iplHolo->imageData + y * iplHolo->widthStep);
        for (int x=0; x<iplHolo->width; x++) {
            int mean2 = pSrc0[x+1] + pSrc0[x+2] + pSrc0[x+3] + pSrc1[x] + pSrc1[x+4]  + pSrc2[x] + pSrc2[x+4] +
                        pSrc3[x] + pSrc3[x+4] + pSrc0[x+1] + pSrc0[x+2] + pSrc0[x+3];
            int fil = (pSrc2[x+2] * 12 - mean2);
            fil = fil < 0 ? -fil : fil;     // abs
            pDst[x] = fil >> 4;
        }
    }

    return true;
}

IplImage *CImageUtility::filtHolo5x5_int(IplImage *iplImage)
// A filter to evaluate the differences in local windows. The 5x5 filter is
//     o  x  x  x  o
//     x  o  o  o  x
//     x  o  @  o  x
//     x  o  o  o  x
//     o  x  x  x  o
// The filter response is abs( @ - mean(X))
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S) {
		showErrMsg("Invalid input/output image type or bit depth in CImageUtility::filtHolo5x5_int()!\n");
		return NULL;
	}

    IplImage *iplHolo = createImage(iplImage->width, iplImage->height, iplImage->depth, iplImage->nChannels);
    if (iplHolo == NULL) {
		showErrMsg("Fail to allocate image buffer in CImageUtility::filtHolo5x5_int()!\n");
		return NULL;
	}

    if (!filtHolo5x5_int(iplImage, iplHolo)) {
        safeReleaseImage(&iplHolo);
        return NULL;
    }

    return iplHolo;
}

bool CImageUtility::rmIsoBulb9x9_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float thw, int con_num)
// Remove isolated bulbs in the image. This function consider pixel which value is larger or equal to 'thw'
// as 'white' points. And then check every 9x9 windows. If the number of white points on the boundary is smaller 
// than 'con_num' and the centeral 3x3 window has 'white' points, the conent in the winodw will be considered as 
// a 'bulb' and all pixel will be set to 'thw'
// by Luhong Liang, IC-ASD, ASTRI, June. 25, 2013
{
    if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
        iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F || thw < 0.0f || con_num < 0 ||
        iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height) {
        showErrMsg("Invalid argument in CImageUtility::rmIsoBulb9x9_32f()!\n");
        return false;
    }

    //saveImage("_Org.bmp", iplSrcImage, 0, 255.0f);

    // padding zeros
    IplImage *iplPadded = padding_0_0(iplSrcImage, 4, 4, 4, 4);
    if (iplPadded == NULL) return false;

    // binarize (for acceleration)
    for (int y=4; y<iplDstImage->height-4; y++) {
        float *pSrc = (float *)((char *)iplPadded->imageData + y * iplPadded->widthStep);
        for (int x=4; x<iplDstImage->width-4; x++) {
            if (pSrc[x] >= thw) {
                pSrc[x] = 1.0f;
            } else {
                pSrc[x] = 0.0f;
            }
        }
    }

    //saveImage("_Bin.bmp", iplPadded, 0, 255.0f);

    // detect and remove bulb in binarized image
    for (int y=0; y<iplPadded->height-8; y++) {
        float *pSrc0 = (float *)((char *)iplPadded->imageData + y * iplPadded->widthStep);
        float *pSrc1 = (float *)((char *)iplPadded->imageData + (y+1) * iplPadded->widthStep);
        float *pSrc2 = (float *)((char *)iplPadded->imageData + (y+2) * iplPadded->widthStep);
        float *pSrc3 = (float *)((char *)iplPadded->imageData + (y+3) * iplPadded->widthStep);
        float *pSrc4 = (float *)((char *)iplPadded->imageData + (y+4) * iplPadded->widthStep);
        float *pSrc5 = (float *)((char *)iplPadded->imageData + (y+5) * iplPadded->widthStep);
        float *pSrc6 = (float *)((char *)iplPadded->imageData + (y+6) * iplPadded->widthStep);
        float *pSrc7 = (float *)((char *)iplPadded->imageData + (y+7) * iplPadded->widthStep);
        float *pSrc8 = (float *)((char *)iplPadded->imageData + (y+8) * iplPadded->widthStep);
        for (int x=0; ;) {
            if (x>=iplPadded->width-8) break;
            // check centre 3x3
            float centrewhite = pSrc3[x+3] + pSrc3[x+4] + pSrc3[x+5] +
                                pSrc4[x+3] + pSrc4[x+4] + pSrc4[x+5] + 
                                pSrc5[x+3] + pSrc5[x+4] + pSrc5[x+5];
            if (centrewhite < 1.0f) {
                x++;
                continue;
            }
            // check boundary
            float connected = pSrc0[x] + pSrc0[x+1] + pSrc0[x+2] + pSrc0[x+3] + pSrc0[x+4] + pSrc0[x+5] + pSrc0[x+6] + pSrc0[x+7] + pSrc0[x+8] + 
                              pSrc8[x] + pSrc8[x+1] + pSrc8[x+2] + pSrc8[x+3] + pSrc8[x+4] + pSrc8[x+5] + pSrc8[x+6] + pSrc8[x+7] + pSrc8[x+8] + 
                              pSrc1[x] + pSrc1[x+8] + pSrc2[x] + pSrc2[x+8] + pSrc3[x] + pSrc3[x+8] + pSrc4[x] + pSrc4[x+8] + pSrc5[x] + pSrc5[x+8] + 
                              pSrc6[x] + pSrc6[x+8] + pSrc7[x] + pSrc7[x+8];
            if ((int)connected >= con_num) {
                x++;
                continue;
            }
            // isolated bulb detected (remove)
            float *pLine0 = pSrc0 + x; 
            float *pLine1 = pSrc1 + x;
            float *pLine2 = pSrc2 + x; 
            float *pLine3 = pSrc3 + x; 
            float *pLine4 = pSrc4 + x; 
            float *pLine5 = pSrc5 + x; 
            float *pLine6 = pSrc6 + x; 
            float *pLine7 = pSrc7 + x; 
            float *pLine8 = pSrc8 + x;
            pLine0[0]=0.0f; pLine0[1]=0.0f; pLine0[2]=0.0f; pLine0[3]=0.0f; pLine0[4]=0.0f; pLine0[5]=0.0f; pLine0[6]=0.0f; pLine0[7]=0.0f; pLine0[8]=0.0f;
            pLine1[0]=0.0f; pLine1[1]=0.0f; pLine1[2]=0.0f; pLine1[3]=0.0f; pLine1[4]=0.0f; pLine1[5]=0.0f; pLine1[6]=0.0f; pLine1[7]=0.0f; pLine1[8]=0.0f;
            pLine2[0]=0.0f; pLine2[1]=0.0f; pLine2[2]=0.0f; pLine2[3]=0.0f; pLine2[4]=0.0f; pLine2[5]=0.0f; pLine2[6]=0.0f; pLine2[7]=0.0f; pLine2[8]=0.0f;
            pLine3[0]=0.0f; pLine3[1]=0.0f; pLine3[2]=0.0f; pLine3[3]=0.0f; pLine3[4]=0.0f; pLine3[5]=0.0f; pLine3[6]=0.0f; pLine3[7]=0.0f; pLine3[8]=0.0f;
            pLine4[0]=0.0f; pLine4[1]=0.0f; pLine4[2]=0.0f; pLine4[3]=0.0f; pLine4[4]=0.0f; pLine4[5]=0.0f; pLine4[6]=0.0f; pLine4[7]=0.0f; pLine4[8]=0.0f;
            pLine5[0]=0.0f; pLine5[1]=0.0f; pLine5[2]=0.0f; pLine5[3]=0.0f; pLine5[4]=0.0f; pLine5[5]=0.0f; pLine5[6]=0.0f; pLine5[7]=0.0f; pLine5[8]=0.0f;
            pLine6[0]=0.0f; pLine6[1]=0.0f; pLine6[2]=0.0f; pLine6[3]=0.0f; pLine6[4]=0.0f; pLine6[5]=0.0f; pLine6[6]=0.0f; pLine6[7]=0.0f; pLine6[8]=0.0f;
            pLine7[0]=0.0f; pLine7[1]=0.0f; pLine7[2]=0.0f; pLine7[3]=0.0f; pLine7[4]=0.0f; pLine7[5]=0.0f; pLine7[6]=0.0f; pLine7[7]=0.0f; pLine7[8]=0.0f;
            pLine8[0]=0.0f; pLine8[1]=0.0f; pLine8[2]=0.0f; pLine8[3]=0.0f; pLine8[4]=0.0f; pLine8[5]=0.0f; pLine8[6]=0.0f; pLine8[7]=0.0f; pLine8[8]=0.0f;
            x+=8;
        }
    }

    //saveImage("_RmBin.bmp", iplPadded, 0, 255.0f);

    // map to dst image
    for (int y=0; y<iplDstImage->height; y++) {
        float *pSrc = (float *)((char *)iplPadded->imageData + (y+4) * iplPadded->widthStep);
        float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pOrg = (float *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        for (int x=0, xx=4; x<iplDstImage->width; x++, xx++) {
            if (pSrc[xx] == 0.0f && pOrg[x] >= thw) {
                pDst[x] = thw;
            } else {
                pDst[x] = pOrg[x];
            }
        }
    }

    //saveImage("_RmIso.bmp", iplDstImage, 0, 255.0f);

    safeReleaseImage(&iplPadded);

    return false;
}

bool CImageUtility::rmIsoBulb11x11_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float thw, int con_num)
// Remove isolated bulbs in the image. This function consider pixel which value is larger or equal to 'thw'
// as 'white' points. And then check every 11x11 windows. If the number of white points on the boundary is smaller 
// than 'con_num' and the centeral 3x3 window has 'white' points, the conent in the winodw will be considered as 
// a 'bulb' and all pixel will be set to 'thw'
// by Luhong Liang, IC-ASD, ASTRI, June. 25, 2013
{
    if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
        iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F || thw < 0.0f || con_num < 0 ||
        iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height) {
        showErrMsg("Invalid argument in CImageUtility::rmIsoBulb11x11_32f()!\n");
        return false;
    }

    //saveImage("_Org.bmp", iplSrcImage, 0, 255.0f);

    // padding zeros
    IplImage *iplPadded = padding_0_0(iplSrcImage, 5, 5, 5, 5);
    if (iplPadded == NULL) return false;

    // binarize (for acceleration)
    for (int y=5; y<iplDstImage->height-5; y++) {
        float *pSrc = (float *)((char *)iplPadded->imageData + y * iplPadded->widthStep);
        for (int x=5; x<iplDstImage->width-5; x++) {
            if (pSrc[x] >= thw) {
                pSrc[x] = 1.0f;
            } else {
                pSrc[x] = 0.0f;
            }
        }
    }

    //saveImage("_Bin.bmp", iplPadded, 0, 255.0f);

    // detect and remove bulb in binarized image
    for (int y=0; y<iplPadded->height-10; y++) {
        float *pSrc0 = (float *)((char *)iplPadded->imageData + y * iplPadded->widthStep);
        float *pSrc1 = (float *)((char *)iplPadded->imageData + (y+1) * iplPadded->widthStep);
        float *pSrc2 = (float *)((char *)iplPadded->imageData + (y+2) * iplPadded->widthStep);
        float *pSrc3 = (float *)((char *)iplPadded->imageData + (y+3) * iplPadded->widthStep);
        float *pSrc4 = (float *)((char *)iplPadded->imageData + (y+4) * iplPadded->widthStep);
        float *pSrc5 = (float *)((char *)iplPadded->imageData + (y+5) * iplPadded->widthStep);
        float *pSrc6 = (float *)((char *)iplPadded->imageData + (y+6) * iplPadded->widthStep);
        float *pSrc7 = (float *)((char *)iplPadded->imageData + (y+7) * iplPadded->widthStep);
        float *pSrc8 = (float *)((char *)iplPadded->imageData + (y+8) * iplPadded->widthStep);
        float *pSrc9 = (float *)((char *)iplPadded->imageData + (y+9) * iplPadded->widthStep);
        float *pSrc10 = (float *)((char *)iplPadded->imageData + (y+10) * iplPadded->widthStep);
        for (int x=0; ;) {
            if (x>=iplPadded->width-10) break;
            // check centre 3x3
            float centrewhite = pSrc4[x+4] + pSrc4[x+5] + pSrc4[x+6] +
                                pSrc5[x+4] + pSrc5[x+5] + pSrc5[x+6] + 
                                pSrc6[x+4] + pSrc6[x+5] + pSrc6[x+6];
            if (centrewhite < 1.0f) {
                x++;
                continue;
            }
            // check boundary
            float connected = pSrc0[x] + pSrc0[x+1] + pSrc0[x+2] + pSrc0[x+3] + pSrc0[x+4] + pSrc0[x+5] + pSrc0[x+6] + pSrc0[x+7] + pSrc0[x+8] + pSrc0[x+9] + pSrc0[x+10] +
                              pSrc10[x] + pSrc10[x+1] + pSrc10[x+2] + pSrc10[x+3] + pSrc10[x+4] + pSrc10[x+5] + pSrc10[x+6] + pSrc10[x+7] + pSrc10[x+8] + pSrc10[x+9] + pSrc10[x+10] +
                              pSrc1[x] + pSrc1[x+10] + pSrc2[x] + pSrc2[x+10] + pSrc3[x] + pSrc3[x+10] + pSrc4[x] + pSrc4[x+10] + pSrc5[x] + pSrc5[x+10] + 
                              pSrc6[x] + pSrc6[x+10] + pSrc7[x] + pSrc7[x+10] + pSrc8[x] + pSrc8[x+10] + pSrc9[x] + pSrc9[x+10];
            if ((int)connected >= con_num) {
                x++;
                continue;
            }
            // isolated bulb detected (remove)
            float *pLine0 = pSrc0 + x; 
            float *pLine1 = pSrc1 + x;
            float *pLine2 = pSrc2 + x; 
            float *pLine3 = pSrc3 + x; 
            float *pLine4 = pSrc4 + x; 
            float *pLine5 = pSrc5 + x; 
            float *pLine6 = pSrc6 + x; 
            float *pLine7 = pSrc7 + x; 
            float *pLine8 = pSrc8 + x;
            float *pLine9 = pSrc9 + x; 
            float *pLine10 = pSrc10 + x;
            pLine0[0]=0.0f; pLine0[1]=0.0f; pLine0[2]=0.0f; pLine0[3]=0.0f; pLine0[4]=0.0f; pLine0[5]=0.0f; pLine0[6]=0.0f; pLine0[7]=0.0f; pLine0[8]=0.0f; pLine0[9]=0.0f; pLine0[10]=0.0f;
            pLine1[0]=0.0f; pLine1[1]=0.0f; pLine1[2]=0.0f; pLine1[3]=0.0f; pLine1[4]=0.0f; pLine1[5]=0.0f; pLine1[6]=0.0f; pLine1[7]=0.0f; pLine1[8]=0.0f; pLine1[9]=0.0f; pLine1[10]=0.0f;
            pLine2[0]=0.0f; pLine2[1]=0.0f; pLine2[2]=0.0f; pLine2[3]=0.0f; pLine2[4]=0.0f; pLine2[5]=0.0f; pLine2[6]=0.0f; pLine2[7]=0.0f; pLine2[8]=0.0f; pLine2[9]=0.0f; pLine2[10]=0.0f;
            pLine3[0]=0.0f; pLine3[1]=0.0f; pLine3[2]=0.0f; pLine3[3]=0.0f; pLine3[4]=0.0f; pLine3[5]=0.0f; pLine3[6]=0.0f; pLine3[7]=0.0f; pLine3[8]=0.0f; pLine3[9]=0.0f; pLine3[10]=0.0f;
            pLine4[0]=0.0f; pLine4[1]=0.0f; pLine4[2]=0.0f; pLine4[3]=0.0f; pLine4[4]=0.0f; pLine4[5]=0.0f; pLine4[6]=0.0f; pLine4[7]=0.0f; pLine4[8]=0.0f; pLine4[9]=0.0f; pLine4[10]=0.0f;
            pLine5[0]=0.0f; pLine5[1]=0.0f; pLine5[2]=0.0f; pLine5[3]=0.0f; pLine5[4]=0.0f; pLine5[5]=0.0f; pLine5[6]=0.0f; pLine5[7]=0.0f; pLine5[8]=0.0f; pLine5[9]=0.0f; pLine5[10]=0.0f;
            pLine6[0]=0.0f; pLine6[1]=0.0f; pLine6[2]=0.0f; pLine6[3]=0.0f; pLine6[4]=0.0f; pLine6[5]=0.0f; pLine6[6]=0.0f; pLine6[7]=0.0f; pLine6[8]=0.0f; pLine6[9]=0.0f; pLine6[10]=0.0f;
            pLine7[0]=0.0f; pLine7[1]=0.0f; pLine7[2]=0.0f; pLine7[3]=0.0f; pLine7[4]=0.0f; pLine7[5]=0.0f; pLine7[6]=0.0f; pLine7[7]=0.0f; pLine7[8]=0.0f; pLine7[9]=0.0f; pLine7[10]=0.0f;
            pLine8[0]=0.0f; pLine8[1]=0.0f; pLine8[2]=0.0f; pLine8[3]=0.0f; pLine8[4]=0.0f; pLine8[5]=0.0f; pLine8[6]=0.0f; pLine8[7]=0.0f; pLine8[8]=0.0f; pLine8[9]=0.0f; pLine8[10]=0.0f;
            pLine9[0]=0.0f; pLine9[1]=0.0f; pLine9[2]=0.0f; pLine9[3]=0.0f; pLine9[4]=0.0f; pLine9[5]=0.0f; pLine9[6]=0.0f; pLine9[7]=0.0f; pLine9[8]=0.0f; pLine9[9]=0.0f; pLine9[10]=0.0f;
            pLine10[0]=0.0f; pLine10[1]=0.0f; pLine10[2]=0.0f; pLine10[3]=0.0f; pLine10[4]=0.0f; pLine10[5]=0.0f; pLine10[6]=0.0f; pLine10[7]=0.0f; pLine10[8]=0.0f; pLine10[9]=0.0f; pLine10[10]=0.0f;
            x+=10;
        }
    }

    //saveImage("_RmBin.bmp", iplPadded, 0, 255.0f);

    // map to dst image
    for (int y=0; y<iplDstImage->height; y++) {
        float *pSrc = (float *)((char *)iplPadded->imageData + (y+5) * iplPadded->widthStep);
        float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pOrg = (float *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        for (int x=0, xx=5; x<iplDstImage->width; x++, xx++) {
            if (pSrc[xx] == 0.0f && pOrg[x] >= thw) {
                pDst[x] = thw;
            } else {
                pDst[x] = pOrg[x];
            }
        }
    }

    //saveImage("_RmIso.bmp", iplDstImage, 0, 255.0f);

    safeReleaseImage(&iplPadded);

    return false;
}

bool CImageUtility::rmIsoBulb13x13_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float thw, int con_num)
// Remove isolated bulbs in the image. This function consider pixel which value is larger or equal to 'thw'
// as 'white' points. And then check every 13x13 windows. If the number of white points on the boundary is smaller 
// than 'con_num' and the centeral 3x3 window has 'white' points, the conent in the winodw will be considered as 
// a 'bulb' and all pixel will be set to 'thw'
// by Luhong Liang, IC-ASD, ASTRI, June. 25, 2013
{
    if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
        iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F || thw < 0.0f || con_num < 0 ||
        iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height) {
        showErrMsg("Invalid argument in CImageUtility::rmIsoBulb13x13_32f()!\n");
        return false;
    }

    //saveImage("_Org.bmp", iplSrcImage, 0, 255.0f);

    // padding zeros
    IplImage *iplPadded = padding_0_0(iplSrcImage, 6, 6, 6, 6);
    if (iplPadded == NULL) return false;

    // binarize (for acceleration)
    for (int y=6; y<iplDstImage->height-6; y++) {
        float *pSrc = (float *)((char *)iplPadded->imageData + y * iplPadded->widthStep);
        for (int x=6; x<iplDstImage->width-6; x++) {
            if (pSrc[x] >= thw) {
                pSrc[x] = 1.0f;
            } else {
                pSrc[x] = 0.0f;
            }
        }
    }
    //saveImage("_Bin.bmp", iplPadded, 0, 255.0f);

    // detect and remove bulb in binarized image
    for (int y=0; y<iplPadded->height-12; y++) {
        float *pSrc0 = (float *)((char *)iplPadded->imageData + y * iplPadded->widthStep);
        float *pSrc1 = (float *)((char *)iplPadded->imageData + (y+1) * iplPadded->widthStep);
        float *pSrc2 = (float *)((char *)iplPadded->imageData + (y+2) * iplPadded->widthStep);
        float *pSrc3 = (float *)((char *)iplPadded->imageData + (y+3) * iplPadded->widthStep);
        float *pSrc4 = (float *)((char *)iplPadded->imageData + (y+4) * iplPadded->widthStep);
        float *pSrc5 = (float *)((char *)iplPadded->imageData + (y+5) * iplPadded->widthStep);
        float *pSrc6 = (float *)((char *)iplPadded->imageData + (y+6) * iplPadded->widthStep);
        float *pSrc7 = (float *)((char *)iplPadded->imageData + (y+7) * iplPadded->widthStep);
        float *pSrc8 = (float *)((char *)iplPadded->imageData + (y+8) * iplPadded->widthStep);
        float *pSrc9 = (float *)((char *)iplPadded->imageData + (y+9) * iplPadded->widthStep);
        float *pSrc10 = (float *)((char *)iplPadded->imageData + (y+10) * iplPadded->widthStep);
        float *pSrc11 = (float *)((char *)iplPadded->imageData + (y+11) * iplPadded->widthStep);
        float *pSrc12 = (float *)((char *)iplPadded->imageData + (y+12) * iplPadded->widthStep);
        for (int x=0; ;) {
            if (x>=iplPadded->width-12) break;
            // check centre 3x3
            float centrewhite = pSrc5[x+5] + pSrc5[x+6] + pSrc5[x+7] +
                                pSrc6[x+5] + pSrc6[x+6] + pSrc6[x+7] + 
                                pSrc7[x+5] + pSrc7[x+6] + pSrc7[x+7];
            if (centrewhite < 1.0f) {
                x++;
                continue;
            }
            // check boundary
            float connected = pSrc0[x] + pSrc0[x+1] + pSrc0[x+2] + pSrc0[x+3] + pSrc0[x+4] + pSrc0[x+5] + pSrc0[x+6] + pSrc0[x+7] + pSrc0[x+8] + pSrc0[x+9] + pSrc0[x+10] + pSrc0[x+11] + pSrc0[x+12] +
                              pSrc12[x] + pSrc12[x+1] + pSrc12[x+2] + pSrc12[x+3] + pSrc12[x+4] + pSrc12[x+5] + pSrc12[x+6] + pSrc12[x+7] + pSrc12[x+8] + pSrc12[x+9] + pSrc12[x+10] + pSrc12[x+11] + pSrc12[x+12] +
                              pSrc1[x] + pSrc1[x+12] + pSrc2[x] + pSrc2[x+12] + pSrc3[x] + pSrc3[x+12] + pSrc4[x] + pSrc4[x+12] + pSrc5[x] + pSrc5[x+12] + pSrc6[x] + pSrc6[x+12] + 
                              pSrc7[x] + pSrc7[x+12] + pSrc8[x] + pSrc8[x+12] + pSrc9[x] + pSrc9[x+12] + pSrc10[x] + pSrc10[x+12] + pSrc11[x] + pSrc11[x+12];
            if ((int)connected >= con_num) {
                x++;
                continue;
            }
            // isolated bulb detected (remove)
            float *pLine0 = pSrc0 + x; 
            float *pLine1 = pSrc1 + x;
            float *pLine2 = pSrc2 + x; 
            float *pLine3 = pSrc3 + x; 
            float *pLine4 = pSrc4 + x; 
            float *pLine5 = pSrc5 + x; 
            float *pLine6 = pSrc6 + x; 
            float *pLine7 = pSrc7 + x; 
            float *pLine8 = pSrc8 + x;
            float *pLine9 = pSrc9 + x; 
            float *pLine10 = pSrc10 + x;
            float *pLine11 = pSrc11 + x;
            float *pLine12 = pSrc12 + x;
            pLine0[0]=0.0f; pLine0[1]=0.0f; pLine0[2]=0.0f; pLine0[3]=0.0f; pLine0[4]=0.0f; pLine0[5]=0.0f; pLine0[6]=0.0f; pLine0[7]=0.0f; pLine0[8]=0.0f; pLine0[9]=0.0f; pLine0[10]=0.0f; pLine0[11]=0.0f; pLine0[12]=0.0f;
            pLine1[0]=0.0f; pLine1[1]=0.0f; pLine1[2]=0.0f; pLine1[3]=0.0f; pLine1[4]=0.0f; pLine1[5]=0.0f; pLine1[6]=0.0f; pLine1[7]=0.0f; pLine1[8]=0.0f; pLine1[9]=0.0f; pLine1[10]=0.0f; pLine1[11]=0.0f; pLine1[12]=0.0f;
            pLine2[0]=0.0f; pLine2[1]=0.0f; pLine2[2]=0.0f; pLine2[3]=0.0f; pLine2[4]=0.0f; pLine2[5]=0.0f; pLine2[6]=0.0f; pLine2[7]=0.0f; pLine2[8]=0.0f; pLine2[9]=0.0f; pLine2[10]=0.0f; pLine2[11]=0.0f; pLine2[12]=0.0f;
            pLine3[0]=0.0f; pLine3[1]=0.0f; pLine3[2]=0.0f; pLine3[3]=0.0f; pLine3[4]=0.0f; pLine3[5]=0.0f; pLine3[6]=0.0f; pLine3[7]=0.0f; pLine3[8]=0.0f; pLine3[9]=0.0f; pLine3[10]=0.0f; pLine3[11]=0.0f; pLine3[12]=0.0f;
            pLine4[0]=0.0f; pLine4[1]=0.0f; pLine4[2]=0.0f; pLine4[3]=0.0f; pLine4[4]=0.0f; pLine4[5]=0.0f; pLine4[6]=0.0f; pLine4[7]=0.0f; pLine4[8]=0.0f; pLine4[9]=0.0f; pLine4[10]=0.0f; pLine4[11]=0.0f; pLine4[12]=0.0f;
            pLine5[0]=0.0f; pLine5[1]=0.0f; pLine5[2]=0.0f; pLine5[3]=0.0f; pLine5[4]=0.0f; pLine5[5]=0.0f; pLine5[6]=0.0f; pLine5[7]=0.0f; pLine5[8]=0.0f; pLine5[9]=0.0f; pLine5[10]=0.0f; pLine5[11]=0.0f; pLine5[12]=0.0f;
            pLine6[0]=0.0f; pLine6[1]=0.0f; pLine6[2]=0.0f; pLine6[3]=0.0f; pLine6[4]=0.0f; pLine6[5]=0.0f; pLine6[6]=0.0f; pLine6[7]=0.0f; pLine6[8]=0.0f; pLine6[9]=0.0f; pLine6[10]=0.0f; pLine6[11]=0.0f; pLine6[12]=0.0f;
            pLine7[0]=0.0f; pLine7[1]=0.0f; pLine7[2]=0.0f; pLine7[3]=0.0f; pLine7[4]=0.0f; pLine7[5]=0.0f; pLine7[6]=0.0f; pLine7[7]=0.0f; pLine7[8]=0.0f; pLine7[9]=0.0f; pLine7[10]=0.0f; pLine7[11]=0.0f; pLine7[12]=0.0f;
            pLine8[0]=0.0f; pLine8[1]=0.0f; pLine8[2]=0.0f; pLine8[3]=0.0f; pLine8[4]=0.0f; pLine8[5]=0.0f; pLine8[6]=0.0f; pLine8[7]=0.0f; pLine8[8]=0.0f; pLine8[9]=0.0f; pLine8[10]=0.0f; pLine8[11]=0.0f; pLine8[12]=0.0f;
            pLine9[0]=0.0f; pLine9[1]=0.0f; pLine9[2]=0.0f; pLine9[3]=0.0f; pLine9[4]=0.0f; pLine9[5]=0.0f; pLine9[6]=0.0f; pLine9[7]=0.0f; pLine9[8]=0.0f; pLine9[9]=0.0f; pLine9[10]=0.0f; pLine9[11]=0.0f; pLine9[12]=0.0f;
            pLine10[0]=0.0f; pLine10[1]=0.0f; pLine10[2]=0.0f; pLine10[3]=0.0f; pLine10[4]=0.0f; pLine10[5]=0.0f; pLine10[6]=0.0f; pLine10[7]=0.0f; pLine10[8]=0.0f; pLine10[9]=0.0f; pLine10[10]=0.0f;  pLine10[11]=0.0f; pLine10[12]=0.0f;
            pLine11[0]=0.0f; pLine11[1]=0.0f; pLine11[2]=0.0f; pLine11[3]=0.0f; pLine11[4]=0.0f; pLine11[5]=0.0f; pLine11[6]=0.0f; pLine11[7]=0.0f; pLine11[8]=0.0f; pLine11[9]=0.0f; pLine11[10]=0.0f;  pLine11[11]=0.0f; pLine11[12]=0.0f;
            pLine12[0]=0.0f; pLine12[1]=0.0f; pLine12[2]=0.0f; pLine12[3]=0.0f; pLine12[4]=0.0f; pLine12[5]=0.0f; pLine12[6]=0.0f; pLine12[7]=0.0f; pLine12[8]=0.0f; pLine12[9]=0.0f; pLine12[10]=0.0f;  pLine12[11]=0.0f; pLine12[12]=0.0f;
            x+=12;
        }
    }

    //saveImage("_RmBin.bmp", iplPadded, 0, 255.0f);
    //saveImage("_Org.bmp", iplSrcImage, 0, 255.0f);

    // map to dst image
    for (int y=0; y<iplDstImage->height; y++) {
        float *pSrc = (float *)((char *)iplPadded->imageData + (y+6) * iplPadded->widthStep);
        float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pOrg = (float *)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        for (int x=0, xx=5; x<iplDstImage->width; x++, xx++) {
            //if (pSrc[xx] == 0.0f && pOrg[x] >= thw) {
            if ((pSrc[xx] < 0.001f) && (pSrc[xx] > -0.001f) && pOrg[x] >= thw) {
                pDst[x] = thw;
            } else {
                pDst[x] = pOrg[x];
            }
        }
    }

    //saveImage("_RmIso.bmp", iplDstImage, 0, 255.0f);

    safeReleaseImage(&iplPadded);

    return false;
}

bool CImageUtility::rmIsoBulb13x13_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage, IplImage *iplBulb, float thw, int con_num)
// Remove isolated bulbs in the image. This function consider pixel which value is larger or equal to 'thw'
// as 'white' points. And then check every 13x13 windows. If the number of white points on the boundary is smaller 
// than 'con_num' and the centeral 3x3 window has 'white' points, the conent in the winodw will be considered as 
// a 'bulb' and all pixel will be set to 'thw'
// NOTE: iplBulb is changed in this function!
// by Luhong Liang, IC-ASD, ASTRI, June. 25, 2013
// Fast version on July 15, 2014
{
    if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
        iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F || thw < 0.0f || con_num < 0 ||
        iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height) {
        showErrMsg("Invalid argument in CImageUtility::rmIsoBulb13x13_32f()!\n");
        return false;
    }

    IplImage *iplBin = createImage(iplSrcImage->width, iplSrcImage->height, SR_DEPTH_8U, 1);
    if (iplBin == NULL) return false;

    // binarize (for acceleration)
    for (int y=0; y<iplDstImage->height; y++) {
        float *pSrc = (float *)(iplSrcImage->imageData + y * iplSrcImage->widthStep);
        float *pBulb = (float *)(iplBulb->imageData + y * iplBulb->widthStep);
        unsigned char *pDst = (unsigned char *)(iplBin->imageData + y * iplBin->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
                float tex = pSrc[x];
                float bulb = pBulb[x];
                tex = tex - bulb * 4.0f;
                pBulb[x] = tex;
                if (tex >= thw) {
                    pDst[x] = 1;
                } else {
                    pDst[x] = 0;
            }
        }
    }

    // padding zeros
    IplImage *iplPadded = padding_0_0(iplBin, 6, 6, 6, 6);
    if (iplPadded == NULL) return false;
    //saveImage("_Bin_o1.bmp", iplPadded, 0, 255.0f);

    // detect and remove bulb in binarized image
    for (int y=0; y<iplPadded->height-12; y++) {
        unsigned char *pSrc0 = (unsigned char *)((char *)iplPadded->imageData + y * iplPadded->widthStep);
        unsigned char *pSrc1 = (unsigned char *)((char *)iplPadded->imageData + (y+1) * iplPadded->widthStep);
        unsigned char *pSrc2 = (unsigned char *)((char *)iplPadded->imageData + (y+2) * iplPadded->widthStep);
        unsigned char *pSrc3 = (unsigned char *)((char *)iplPadded->imageData + (y+3) * iplPadded->widthStep);
        unsigned char *pSrc4 = (unsigned char *)((char *)iplPadded->imageData + (y+4) * iplPadded->widthStep);
        unsigned char *pSrc5 = (unsigned char *)((char *)iplPadded->imageData + (y+5) * iplPadded->widthStep);
        unsigned char *pSrc6 = (unsigned char *)((char *)iplPadded->imageData + (y+6) * iplPadded->widthStep);
        unsigned char *pSrc7 = (unsigned char *)((char *)iplPadded->imageData + (y+7) * iplPadded->widthStep);
        unsigned char *pSrc8 = (unsigned char *)((char *)iplPadded->imageData + (y+8) * iplPadded->widthStep);
        unsigned char *pSrc9 = (unsigned char *)((char *)iplPadded->imageData + (y+9) * iplPadded->widthStep);
        unsigned char *pSrc10 = (unsigned char *)((char *)iplPadded->imageData + (y+10) * iplPadded->widthStep);
        unsigned char *pSrc11 = (unsigned char *)((char *)iplPadded->imageData + (y+11) * iplPadded->widthStep);
        unsigned char *pSrc12 = (unsigned char *)((char *)iplPadded->imageData + (y+12) * iplPadded->widthStep);
        for (int x=0; ;) {
            if (x>=iplPadded->width-12) break;
            // check centre 3x3
            int centrewhite = pSrc5[x+5] + pSrc5[x+6] + pSrc5[x+7] +
                                       pSrc6[x+5] + pSrc6[x+6] + pSrc6[x+7] + 
                                       pSrc7[x+5] + pSrc7[x+6] + pSrc7[x+7];
            if (centrewhite < 1) {
                x++;
                continue;
            }
            // check boundary
            int connected = pSrc0[x] + pSrc0[x+1] + pSrc0[x+2] + pSrc0[x+3] + pSrc0[x+4] + pSrc0[x+5] + pSrc0[x+6] + pSrc0[x+7] + pSrc0[x+8] + pSrc0[x+9] + pSrc0[x+10] + pSrc0[x+11] + pSrc0[x+12] +
                              pSrc12[x] + pSrc12[x+1] + pSrc12[x+2] + pSrc12[x+3] + pSrc12[x+4] + pSrc12[x+5] + pSrc12[x+6] + pSrc12[x+7] + pSrc12[x+8] + pSrc12[x+9] + pSrc12[x+10] + pSrc12[x+11] + pSrc12[x+12] +
                              pSrc1[x] + pSrc1[x+12] + pSrc2[x] + pSrc2[x+12] + pSrc3[x] + pSrc3[x+12] + pSrc4[x] + pSrc4[x+12] + pSrc5[x] + pSrc5[x+12] + pSrc6[x] + pSrc6[x+12] + 
                              pSrc7[x] + pSrc7[x+12] + pSrc8[x] + pSrc8[x+12] + pSrc9[x] + pSrc9[x+12] + pSrc10[x] + pSrc10[x+12] + pSrc11[x] + pSrc11[x+12];
            if (connected >= con_num) {
                x++;
                continue;
            }
            // isolated bulb detected (remove)
            unsigned char *pLine0 = pSrc0 + x; 
            unsigned char *pLine1 = pSrc1 + x;
            unsigned char *pLine2 = pSrc2 + x; 
            unsigned char *pLine3 = pSrc3 + x; 
            unsigned char *pLine4 = pSrc4 + x; 
            unsigned char *pLine5 = pSrc5 + x; 
            unsigned char *pLine6 = pSrc6 + x; 
            unsigned char *pLine7 = pSrc7 + x; 
            unsigned char *pLine8 = pSrc8 + x;
            unsigned char *pLine9 = pSrc9 + x; 
            unsigned char *pLine10 = pSrc10 + x;
            unsigned char *pLine11 = pSrc11 + x;
            unsigned char *pLine12 = pSrc12 + x;
            pLine0[0]=0; pLine0[1]=0; pLine0[2]=0; pLine0[3]=0; pLine0[4]=0; pLine0[5]=0; pLine0[6]=0; pLine0[7]=0; pLine0[8]=0; pLine0[9]=0; pLine0[10]=0; pLine0[11]=0; pLine0[12]=0;
            pLine1[0]=0; pLine1[1]=0; pLine1[2]=0; pLine1[3]=0; pLine1[4]=0; pLine1[5]=0; pLine1[6]=0; pLine1[7]=0; pLine1[8]=0; pLine1[9]=0; pLine1[10]=0; pLine1[11]=0; pLine1[12]=0;
            pLine2[0]=0; pLine2[1]=0; pLine2[2]=0; pLine2[3]=0; pLine2[4]=0; pLine2[5]=0; pLine2[6]=0; pLine2[7]=0; pLine2[8]=0; pLine2[9]=0; pLine2[10]=0; pLine2[11]=0; pLine2[12]=0;
            pLine3[0]=0; pLine3[1]=0; pLine3[2]=0; pLine3[3]=0; pLine3[4]=0; pLine3[5]=0; pLine3[6]=0; pLine3[7]=0; pLine3[8]=0; pLine3[9]=0; pLine3[10]=0; pLine3[11]=0; pLine3[12]=0;
            pLine4[0]=0; pLine4[1]=0; pLine4[2]=0; pLine4[3]=0; pLine4[4]=0; pLine4[5]=0; pLine4[6]=0; pLine4[7]=0; pLine4[8]=0; pLine4[9]=0; pLine4[10]=0; pLine4[11]=0; pLine4[12]=0;
            pLine5[0]=0; pLine5[1]=0; pLine5[2]=0; pLine5[3]=0; pLine5[4]=0; pLine5[5]=0; pLine5[6]=0; pLine5[7]=0; pLine5[8]=0; pLine5[9]=0; pLine5[10]=0; pLine5[11]=0; pLine5[12]=0;
            pLine6[0]=0; pLine6[1]=0; pLine6[2]=0; pLine6[3]=0; pLine6[4]=0; pLine6[5]=0; pLine6[6]=0; pLine6[7]=0; pLine6[8]=0; pLine6[9]=0; pLine6[10]=0; pLine6[11]=0; pLine6[12]=0;
            pLine7[0]=0; pLine7[1]=0; pLine7[2]=0; pLine7[3]=0; pLine7[4]=0; pLine7[5]=0; pLine7[6]=0; pLine7[7]=0; pLine7[8]=0; pLine7[9]=0; pLine7[10]=0; pLine7[11]=0; pLine7[12]=0;
            pLine8[0]=0; pLine8[1]=0; pLine8[2]=0; pLine8[3]=0; pLine8[4]=0; pLine8[5]=0; pLine8[6]=0; pLine8[7]=0; pLine8[8]=0; pLine8[9]=0; pLine8[10]=0; pLine8[11]=0; pLine8[12]=0;
            pLine9[0]=0; pLine9[1]=0; pLine9[2]=0; pLine9[3]=0; pLine9[4]=0; pLine9[5]=0; pLine9[6]=0; pLine9[7]=0; pLine9[8]=0; pLine9[9]=0; pLine9[10]=0; pLine9[11]=0; pLine9[12]=0;
            pLine10[0]=0; pLine10[1]=0; pLine10[2]=0; pLine10[3]=0; pLine10[4]=0; pLine10[5]=0; pLine10[6]=0; pLine10[7]=0; pLine10[8]=0; pLine10[9]=0; pLine10[10]=0;  pLine10[11]=0; pLine10[12]=0;
            pLine11[0]=0; pLine11[1]=0; pLine11[2]=0; pLine11[3]=0; pLine11[4]=0; pLine11[5]=0; pLine11[6]=0; pLine11[7]=0; pLine11[8]=0; pLine11[9]=0; pLine11[10]=0;  pLine11[11]=0; pLine11[12]=0;
            pLine12[0]=0; pLine12[1]=0; pLine12[2]=0; pLine12[3]=0; pLine12[4]=0; pLine12[5]=0; pLine12[6]=0; pLine12[7]=0; pLine12[8]=0; pLine12[9]=0; pLine12[10]=0;  pLine12[11]=0; pLine12[12]=0;
            x+=12;
        }
    }

    //saveImage("_RmBin_o1.bmp", iplPadded, 0, 255.0f);

    // map to dst image
    for (int y=0; y<iplDstImage->height; y++) {
        unsigned char *pSrc = (unsigned char *)((char *)iplPadded->imageData + (y+6) * iplPadded->widthStep);
        float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pOrg = (float *)((char *)iplBulb->imageData + y * iplBulb->widthStep);
        for (int x=0, xx=5; x<iplDstImage->width; x++, xx++) {
            if (pSrc[xx] == 0 && pOrg[x] >= thw) {
                pDst[x] = thw;
            } else {
                pDst[x] = pOrg[x];
            }
        }
    }

    //saveImage("_RmIso_o1.bmp", iplDstImage, 0, 255.0f);

    safeReleaseImage(&iplPadded);

    return false;
}

bool CImageUtility::rmIsoBulbFillHole3x3_8U(IplImage *iplSrcImage, IplImage *iplDstImage, int min_th)
// 3x3 selectively min and max filter to remove isolated WHITE bulb and fill the BLACK hole
// min_th -- a threhold in hole detection
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U)  {
		showErrMsg("Invalid input argument in CImageUtility::rmIsoBulbFillHole3x3_8U()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::rmIsoBulbFillHole3x3_8U()!\n");
		return false;
	}
    unsigned char pBlock[9];

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		unsigned char *pSrc0 = (unsigned char *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		unsigned char *pSrc1 = (unsigned char *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		unsigned char *pSrc2 = (unsigned char *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
		unsigned char *pDst = (unsigned char *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            // get data block
            pBlock[0] = pSrc0[x]; pBlock[1] = pSrc0[x+1]; pBlock[2] = pSrc0[x+2];
            pBlock[3] = pSrc1[x]; pBlock[4] = pSrc1[x+1]; pBlock[5] = pSrc1[x+2];
            pBlock[6] = pSrc2[x]; pBlock[7] = pSrc2[x+1]; pBlock[8] = pSrc2[x+2];
            // detect black hole
            int centrev = pBlock[4] + min_th;
            bool is_hole = (centrev<pBlock[0]) && (centrev<pBlock[1]) && (centrev<pBlock[2]) && 
                                  (centrev<pBlock[3])                                      && (centrev<pBlock[5]) && 
                                  (centrev<pBlock[6]) && (centrev<pBlock[7]) && (centrev<pBlock[8]);
            // calculate the minimum and mean
            unsigned char minv = pBlock[0];
            int meanv = pBlock[0];
            for (int i=1; i<9; i++) {
                if (pBlock[i] < minv) {
                    minv = pBlock[i];
                }
                meanv += pBlock[i];
            }
            // selective remove or fill
            if (is_hole) {
                meanv = (meanv - pBlock[4]) >> 3;
                pDst[x] = (unsigned char)meanv;
            } else {
                pDst[x] = (unsigned char)minv;
            }
		}
	}

	safeReleaseImage(&iplPadded);

	return true;
}


bool CImageUtility::filter2D3x3_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float *pFilt)
// Convolute using a 3x3 2D filter
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image, same size as input image
//      pFilt -- [I] 2D filter in raster scanning order with 9 elements
// by Cao Shuang, ICDD, ASTRI
// Dec. 8, 2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
        pFilt == NULL)  {
		showErrMsg("Invalid input argument in CImageUtility::filter2D3x3_32f()!\n");
		return false;
	}

    IplImage *iplPadded = padding(iplSrcImage, 1, 1, 1, 1);
    bool rlt = filter2D3x3_o1_32f(iplPadded, iplDstImage, pFilt);
    safeReleaseImage(&iplPadded);

    return rlt;
}

bool CImageUtility::filter2D3x3_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float *pFilt)
// Convolute using a 3x3 2D filter
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image, has been padded 2 pixels in each direction
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image
//      pFilt -- [I] 2D filter in raster scanning order with 9 elements
// by Cao Shuang, ICDD, ASTRI
// Dec. 8, 2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width+2 || iplSrcImage->height != iplDstImage->height+2 ||
        pFilt == NULL)  {
		showErrMsg("Invalid input argument in CImageUtility::filter2D3x3_o1_32f()!\n");
		return false;
	}

    // line filters
    float *pF0 = pFilt;
    float *pF1 = pFilt + 3;
    float *pF2 = pFilt + 6;

    // convolution
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pSrc0 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
        float *pSrc2 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            float val = 0.0f;
			// convolution
            val+=pSrc0[x]*pF0[0]; val+=pSrc0[x+1]*pF0[1]; val+=pSrc0[x+2]*pF0[2];  // line 1
            val+=pSrc1[x]*pF1[0]; val+=pSrc1[x+1]*pF1[1]; val+=pSrc1[x+2]*pF1[2];  // line 2
            val+=pSrc2[x]*pF2[0]; val+=pSrc2[x+1]*pF2[1]; val+=pSrc2[x+2]*pF2[2];  // line 3
            // set result
            pDst[x] = val;
		}
	}

    return true;
}

bool CImageUtility::filter2D5x5_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float *pFilt)
// Convolute using a 5x5 2D filter
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image, same size as input image
//      pFilt -- [I] 2D filter in raster scanning order with 25 elements
// by Luhong Liang, ICDD, ASTRI
// Nov. 30, 2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
        pFilt == NULL)  {
		showErrMsg("Invalid input argument in CImageUtility::filter2D5x5_32f()!\n");
		return false;
	}

    IplImage *iplPadded = padding(iplSrcImage, 2, 2, 2, 2);
    bool rlt = filter2D5x5_o1_32f(iplPadded, iplDstImage, pFilt);
    safeReleaseImage(&iplPadded);

    return rlt;
}

bool CImageUtility::filter2D5x5_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float *pFilt)
// Convolute using a 5x5 2D filter
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image, has been padded 2 pixels in each direction
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image
//      pFilt -- [I] 2D filter in raster scanning order with 25 elements
// by Luhong Liang, ICDD, ASTRI
// Oct. 25, 2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width+4 || iplSrcImage->height != iplDstImage->height+4 ||
        pFilt == NULL)  {
		showErrMsg("Invalid input argument in CImageUtility::filter2D5x5_o1_32f()!\n");
		return false;
	}

    // line filters
    float *pF0 = pFilt;
    float *pF1 = pFilt + 5;
    float *pF2 = pFilt + 10;
    float *pF3 = pFilt + 15;
    float *pF4 = pFilt + 20;

    // convolution
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pSrc0 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
        float *pSrc2 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
        float *pSrc3 = (float *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
        float *pSrc4 = (float *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            float val = 0.0f;
			// convolution
            val+=pSrc0[x]*pF0[0]; val+=pSrc0[x+1]*pF0[1]; val+=pSrc0[x+2]*pF0[2];  val+=pSrc0[x+3]*pF0[3];  val+=pSrc0[x+4]*pF0[4];
            val+=pSrc1[x]*pF1[0]; val+=pSrc1[x+1]*pF1[1]; val+=pSrc1[x+2]*pF1[2];  val+=pSrc1[x+3]*pF1[3];  val+=pSrc1[x+4]*pF1[4];
            val+=pSrc2[x]*pF2[0]; val+=pSrc2[x+1]*pF2[1]; val+=pSrc2[x+2]*pF2[2];  val+=pSrc2[x+3]*pF2[3];  val+=pSrc2[x+4]*pF2[4];
            val+=pSrc3[x]*pF3[0]; val+=pSrc3[x+1]*pF3[1]; val+=pSrc3[x+2]*pF3[2];  val+=pSrc3[x+3]*pF3[3];  val+=pSrc3[x+4]*pF3[4];
            val+=pSrc4[x]*pF4[0]; val+=pSrc4[x+1]*pF4[1]; val+=pSrc4[x+2]*pF4[2];  val+=pSrc4[x+3]*pF4[3];  val+=pSrc4[x+4]*pF4[4];
            // set result
            pDst[x] = val;
		}
	}

    return true;
}

bool CImageUtility::filter2D5x5_acc1_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float *pFilt)
// Convolute using a 5x5 2D filter and then, accumulate to the previous output image
// This function is special designed for CNN
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image, has been padded 2 pixels in each direction
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image
//      pFilt -- [I] 2D filter in raster scanning order with 25 elements
// by Luhong Liang, ICDD, ASTRI
// Nov. 25, 2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width+4 || iplSrcImage->height != iplDstImage->height+4 ||
        pFilt == NULL)  {
		showErrMsg("Invalid input argument in CImageUtility::filter2D5x5_acc1_32f()!\n");
		return false;
	}

    // line filters
    float *pF0 = pFilt;
    float *pF1 = pFilt + 5;
    float *pF2 = pFilt + 10;
    float *pF3 = pFilt + 15;
    float *pF4 = pFilt + 20;

    // convolution
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pSrc0 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
        float *pSrc2 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
        float *pSrc3 = (float *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
        float *pSrc4 = (float *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            // acc
            float val = pDst[x];
			// convolution
            val+=pSrc0[x]*pF0[0]; val+=pSrc0[x+1]*pF0[1]; val+=pSrc0[x+2]*pF0[2];  val+=pSrc0[x+3]*pF0[3];  val+=pSrc0[x+4]*pF0[4];
            val+=pSrc1[x]*pF1[0]; val+=pSrc1[x+1]*pF1[1]; val+=pSrc1[x+2]*pF1[2];  val+=pSrc1[x+3]*pF1[3];  val+=pSrc1[x+4]*pF1[4];
            val+=pSrc2[x]*pF2[0]; val+=pSrc2[x+1]*pF2[1]; val+=pSrc2[x+2]*pF2[2];  val+=pSrc2[x+3]*pF2[3];  val+=pSrc2[x+4]*pF2[4];
            val+=pSrc3[x]*pF3[0]; val+=pSrc3[x+1]*pF3[1]; val+=pSrc3[x+2]*pF3[2];  val+=pSrc3[x+3]*pF3[3];  val+=pSrc3[x+4]*pF3[4];
            val+=pSrc4[x]*pF4[0]; val+=pSrc4[x+1]*pF4[1]; val+=pSrc4[x+2]*pF4[2];  val+=pSrc4[x+3]*pF4[3];  val+=pSrc4[x+4]*pF4[4];
            // set result
            pDst[x] = val;
		}
	}

    return true;
}

bool CImageUtility::filter2D7x7_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float *pFilt)
// Convolute using a 7x7 2D filter
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image, same size as input image
//      pFilt -- [I] 2D filter in raster scanning order with 49 elements
// by Cao Shuang, ICDD, ASTRI
// Dec. 8, 2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
        pFilt == NULL)  {
		showErrMsg("Invalid input argument in CImageUtility::filter2D7x7_32f()!\n");
		return false;
	}

    IplImage *iplPadded = padding(iplSrcImage, 3, 3, 3, 3);
    bool rlt = filter2D7x7_o1_32f(iplPadded, iplDstImage, pFilt);
    safeReleaseImage(&iplPadded);

    return rlt;
}

bool CImageUtility::filter2D7x7_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float *pFilt)
// Convolute using a 7x7 2D filter
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image, has been padded 4 pixels in each direction
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image
//      pFilt -- [I] 2D filter in raster scanning order with 49 elements
// by Cao Shuang, ICDD, ASTRI
// Dec. 8, 2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width+6 || iplSrcImage->height != iplDstImage->height+6 ||
        pFilt == NULL)  {
		showErrMsg("Invalid input argument in CImageUtility::filter2D7x7_o1_32f()!\n");
		return false;
	}

    // line filters
    float *pF0 = pFilt;
    float *pF1 = pFilt + 7;
    float *pF2 = pFilt + 14;
    float *pF3 = pFilt + 21;
    float *pF4 = pFilt + 28;
    float *pF5 = pFilt + 35;
    float *pF6 = pFilt + 42;

    // convolution
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pSrc0 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
        float *pSrc2 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
        float *pSrc3 = (float *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
        float *pSrc4 = (float *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
        float *pSrc5 = (float *)((char*)iplSrcImage->imageData + (y+5) * iplSrcImage->widthStep);
        float *pSrc6 = (float *)((char*)iplSrcImage->imageData + (y+6) * iplSrcImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            float val = 0.0f;
			// line 0
            val+=pSrc0[x]*pF0[0];   val+=pSrc0[x+1]*pF0[1]; val+=pSrc0[x+2]*pF0[2];  val+=pSrc0[x+3]*pF0[3];  val+=pSrc0[x+4]*pF0[4];
            val+=pSrc0[x+5]*pF0[5]; val+=pSrc0[x+6]*pF0[6]; 
			// line 1
            val+=pSrc1[x]*pF1[0];   val+=pSrc1[x+1]*pF1[1]; val+=pSrc1[x+2]*pF1[2];  val+=pSrc1[x+3]*pF1[3];  val+=pSrc1[x+4]*pF1[4];
            val+=pSrc1[x+5]*pF1[5]; val+=pSrc1[x+6]*pF1[6]; 
			// line 2
            val+=pSrc2[x]*pF2[0];   val+=pSrc2[x+1]*pF2[1]; val+=pSrc2[x+2]*pF2[2];  val+=pSrc2[x+3]*pF2[3];  val+=pSrc2[x+4]*pF2[4];
            val+=pSrc2[x+5]*pF2[5]; val+=pSrc2[x+6]*pF2[6]; 
			// line 3
            val+=pSrc3[x]*pF3[0];   val+=pSrc3[x+1]*pF3[1]; val+=pSrc3[x+2]*pF3[2];  val+=pSrc3[x+3]*pF3[3];  val+=pSrc3[x+4]*pF3[4];
            val+=pSrc3[x+5]*pF3[5]; val+=pSrc3[x+6]*pF3[6]; 
			// line 4
            val+=pSrc4[x]*pF4[0];   val+=pSrc4[x+1]*pF4[1]; val+=pSrc4[x+2]*pF4[2];  val+=pSrc4[x+3]*pF4[3];  val+=pSrc4[x+4]*pF4[4];
            val+=pSrc4[x+5]*pF4[5]; val+=pSrc4[x+6]*pF4[6]; 
			// line 5
            val+=pSrc5[x]*pF5[0];   val+=pSrc5[x+1]*pF5[1]; val+=pSrc5[x+2]*pF5[2];  val+=pSrc5[x+3]*pF5[3];  val+=pSrc5[x+4]*pF5[4];
            val+=pSrc5[x+5]*pF5[5]; val+=pSrc5[x+6]*pF5[6]; 
			// line 6
            val+=pSrc6[x]*pF6[0];   val+=pSrc6[x+1]*pF6[1]; val+=pSrc6[x+2]*pF6[2];  val+=pSrc6[x+3]*pF6[3];  val+=pSrc6[x+4]*pF6[4];
            val+=pSrc6[x+5]*pF6[5]; val+=pSrc6[x+6]*pF6[6]; 
            // set result
            pDst[x] = val;
		}
	}

    return true;
}

bool CImageUtility::filter2D9x9_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float *pFilt)
// Convolute using a 9x9 2D filter
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image, same size as input image
//      pFilt -- [I] 2D filter in raster scanning order with 25 elements
// by Luhong Liang, ICDD, ASTRI
// Nov. 30, 2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
        pFilt == NULL)  {
		showErrMsg("Invalid input argument in CImageUtility::filter2D9x9_32f()!\n");
		return false;
	}

    IplImage *iplPadded = padding(iplSrcImage, 4, 4, 4, 4);
    bool rlt = filter2D9x9_o1_32f(iplPadded, iplDstImage, pFilt);
    safeReleaseImage(&iplPadded);

    return rlt;
}

bool CImageUtility::filter2D9x9_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float *pFilt)
// Convolute using a 9x9 2D filter
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image, has been padded 4 pixels in each direction
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image
//      pFilt -- [I] 2D filter in raster scanning order with 81 elements
// by Luhong Liang, ICDD, ASTRI
// Oct. 25, 2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width+8 || iplSrcImage->height != iplDstImage->height+8 ||
        pFilt == NULL)  {
		showErrMsg("Invalid input argument in CImageUtility::filter2D9x9_o1_32f()!\n");
		return false;
	}

    // line filters
    float *pF0 = pFilt;
    float *pF1 = pFilt + 9;
    float *pF2 = pFilt + 18;
    float *pF3 = pFilt + 27;
    float *pF4 = pFilt + 36;
    float *pF5 = pFilt + 45;
    float *pF6 = pFilt + 54;
    float *pF7 = pFilt + 63;
    float *pF8 = pFilt + 72;

    // convolution
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pSrc0 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
        float *pSrc2 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
        float *pSrc3 = (float *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
        float *pSrc4 = (float *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
        float *pSrc5 = (float *)((char*)iplSrcImage->imageData + (y+5) * iplSrcImage->widthStep);
        float *pSrc6 = (float *)((char*)iplSrcImage->imageData + (y+6) * iplSrcImage->widthStep);
        float *pSrc7 = (float *)((char*)iplSrcImage->imageData + (y+7) * iplSrcImage->widthStep);
        float *pSrc8 = (float *)((char*)iplSrcImage->imageData + (y+8) * iplSrcImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            float val = 0.0f;
			// line 0
            val+=pSrc0[x]*pF0[0];   val+=pSrc0[x+1]*pF0[1]; val+=pSrc0[x+2]*pF0[2];  val+=pSrc0[x+3]*pF0[3];  val+=pSrc0[x+4]*pF0[4];
            val+=pSrc0[x+5]*pF0[5]; val+=pSrc0[x+6]*pF0[6]; val+=pSrc0[x+7]*pF0[7];  val+=pSrc0[x+8]*pF0[8];
			// line 1
            val+=pSrc1[x]*pF1[0];   val+=pSrc1[x+1]*pF1[1]; val+=pSrc1[x+2]*pF1[2];  val+=pSrc1[x+3]*pF1[3];  val+=pSrc1[x+4]*pF1[4];
            val+=pSrc1[x+5]*pF1[5]; val+=pSrc1[x+6]*pF1[6]; val+=pSrc1[x+7]*pF1[7];  val+=pSrc1[x+8]*pF1[8];
			// line 2
            val+=pSrc2[x]*pF2[0];   val+=pSrc2[x+1]*pF2[1]; val+=pSrc2[x+2]*pF2[2];  val+=pSrc2[x+3]*pF2[3];  val+=pSrc2[x+4]*pF2[4];
            val+=pSrc2[x+5]*pF2[5]; val+=pSrc2[x+6]*pF2[6]; val+=pSrc2[x+7]*pF2[7];  val+=pSrc2[x+8]*pF2[8];
			// line 3
            val+=pSrc3[x]*pF3[0];   val+=pSrc3[x+1]*pF3[1]; val+=pSrc3[x+2]*pF3[2];  val+=pSrc3[x+3]*pF3[3];  val+=pSrc3[x+4]*pF3[4];
            val+=pSrc3[x+5]*pF3[5]; val+=pSrc3[x+6]*pF3[6]; val+=pSrc3[x+7]*pF3[7];  val+=pSrc3[x+8]*pF3[8];
			// line 4
            val+=pSrc4[x]*pF4[0];   val+=pSrc4[x+1]*pF4[1]; val+=pSrc4[x+2]*pF4[2];  val+=pSrc4[x+3]*pF4[3];  val+=pSrc4[x+4]*pF4[4];
            val+=pSrc4[x+5]*pF4[5]; val+=pSrc4[x+6]*pF4[6]; val+=pSrc4[x+7]*pF4[7];  val+=pSrc4[x+8]*pF4[8];
			// line 5
            val+=pSrc5[x]*pF5[0];   val+=pSrc5[x+1]*pF5[1]; val+=pSrc5[x+2]*pF5[2];  val+=pSrc5[x+3]*pF5[3];  val+=pSrc5[x+4]*pF5[4];
            val+=pSrc5[x+5]*pF5[5]; val+=pSrc5[x+6]*pF5[6]; val+=pSrc5[x+7]*pF5[7];  val+=pSrc5[x+8]*pF5[8];
			// line 6
            val+=pSrc6[x]*pF6[0];   val+=pSrc6[x+1]*pF6[1]; val+=pSrc6[x+2]*pF6[2];  val+=pSrc6[x+3]*pF6[3];  val+=pSrc6[x+4]*pF6[4];
            val+=pSrc6[x+5]*pF6[5]; val+=pSrc6[x+6]*pF6[6]; val+=pSrc6[x+7]*pF6[7];  val+=pSrc6[x+8]*pF6[8];
			// line 7
            val+=pSrc7[x]*pF7[0];   val+=pSrc7[x+1]*pF7[1]; val+=pSrc7[x+2]*pF7[2];  val+=pSrc7[x+3]*pF7[3];  val+=pSrc7[x+4]*pF7[4];
            val+=pSrc7[x+5]*pF7[5]; val+=pSrc7[x+6]*pF7[6]; val+=pSrc7[x+7]*pF7[7];  val+=pSrc7[x+8]*pF7[8];
			// line 8
            val+=pSrc8[x]*pF8[0];   val+=pSrc8[x+1]*pF8[1]; val+=pSrc8[x+2]*pF8[2];  val+=pSrc8[x+3]*pF8[3];  val+=pSrc8[x+4]*pF8[4];
            val+=pSrc8[x+5]*pF8[5]; val+=pSrc8[x+6]*pF8[6]; val+=pSrc8[x+7]*pF8[7];  val+=pSrc8[x+8]*pF8[8];
            // set result
            pDst[x] = val;
		}
	}

    return true;
}

bool CImageUtility::filter2D9x9_ReLU_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float *pFilt, float bias)
// Convolute using a 9x9 2D filter and a bias, then followed by ReLU ( f= max(x,0) )
// This function is special designed for CNN
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image, has been padded 4 pixels in each direction
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image
//      pFilt -- [I] 2D filter in raster scanning order with 81 elements
//      bias -- [I] bias
// by Luhong Liang, ICDD, ASTRI
// Nov. 25, 2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width+8 || iplSrcImage->height != iplDstImage->height+8 ||
        pFilt == NULL)  {
		showErrMsg("Invalid input argument in CImageUtility::filter2D9x9_ReLU_32f()!\n");
		return false;
	}

    // line filters
    float *pF0 = pFilt;
    float *pF1 = pFilt + 9;
    float *pF2 = pFilt + 18;
    float *pF3 = pFilt + 27;
    float *pF4 = pFilt + 36;
    float *pF5 = pFilt + 45;
    float *pF6 = pFilt + 54;
    float *pF7 = pFilt + 63;
    float *pF8 = pFilt + 72;

    // convolution
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pSrc0 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
        float *pSrc2 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
        float *pSrc3 = (float *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
        float *pSrc4 = (float *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
        float *pSrc5 = (float *)((char*)iplSrcImage->imageData + (y+5) * iplSrcImage->widthStep);
        float *pSrc6 = (float *)((char*)iplSrcImage->imageData + (y+6) * iplSrcImage->widthStep);
        float *pSrc7 = (float *)((char*)iplSrcImage->imageData + (y+7) * iplSrcImage->widthStep);
        float *pSrc8 = (float *)((char*)iplSrcImage->imageData + (y+8) * iplSrcImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            // bias
            float val = bias;
			// line 0
            val+=pSrc0[x]*pF0[0];   val+=pSrc0[x+1]*pF0[1]; val+=pSrc0[x+2]*pF0[2];  val+=pSrc0[x+3]*pF0[3];  val+=pSrc0[x+4]*pF0[4];
            val+=pSrc0[x+5]*pF0[5]; val+=pSrc0[x+6]*pF0[6]; val+=pSrc0[x+7]*pF0[7];  val+=pSrc0[x+8]*pF0[8];
			// line 1
            val+=pSrc1[x]*pF1[0];   val+=pSrc1[x+1]*pF1[1]; val+=pSrc1[x+2]*pF1[2];  val+=pSrc1[x+3]*pF1[3];  val+=pSrc1[x+4]*pF1[4];
            val+=pSrc1[x+5]*pF1[5]; val+=pSrc1[x+6]*pF1[6]; val+=pSrc1[x+7]*pF1[7];  val+=pSrc1[x+8]*pF1[8];
			// line 2
            val+=pSrc2[x]*pF2[0];   val+=pSrc2[x+1]*pF2[1]; val+=pSrc2[x+2]*pF2[2];  val+=pSrc2[x+3]*pF2[3];  val+=pSrc2[x+4]*pF2[4];
            val+=pSrc2[x+5]*pF2[5]; val+=pSrc2[x+6]*pF2[6]; val+=pSrc2[x+7]*pF2[7];  val+=pSrc2[x+8]*pF2[8];
			// line 3
            val+=pSrc3[x]*pF3[0];   val+=pSrc3[x+1]*pF3[1]; val+=pSrc3[x+2]*pF3[2];  val+=pSrc3[x+3]*pF3[3];  val+=pSrc3[x+4]*pF3[4];
            val+=pSrc3[x+5]*pF3[5]; val+=pSrc3[x+6]*pF3[6]; val+=pSrc3[x+7]*pF3[7];  val+=pSrc3[x+8]*pF3[8];
			// line 4
            val+=pSrc4[x]*pF4[0];   val+=pSrc4[x+1]*pF4[1]; val+=pSrc4[x+2]*pF4[2];  val+=pSrc4[x+3]*pF4[3];  val+=pSrc4[x+4]*pF4[4];
            val+=pSrc4[x+5]*pF4[5]; val+=pSrc4[x+6]*pF4[6]; val+=pSrc4[x+7]*pF4[7];  val+=pSrc4[x+8]*pF4[8];
			// line 5
            val+=pSrc5[x]*pF5[0];   val+=pSrc5[x+1]*pF5[1]; val+=pSrc5[x+2]*pF5[2];  val+=pSrc5[x+3]*pF5[3];  val+=pSrc5[x+4]*pF5[4];
            val+=pSrc5[x+5]*pF5[5]; val+=pSrc5[x+6]*pF5[6]; val+=pSrc5[x+7]*pF5[7];  val+=pSrc5[x+8]*pF5[8];
			// line 6
            val+=pSrc6[x]*pF6[0];   val+=pSrc6[x+1]*pF6[1]; val+=pSrc6[x+2]*pF6[2];  val+=pSrc6[x+3]*pF6[3];  val+=pSrc6[x+4]*pF6[4];
            val+=pSrc6[x+5]*pF6[5]; val+=pSrc6[x+6]*pF6[6]; val+=pSrc6[x+7]*pF6[7];  val+=pSrc6[x+8]*pF6[8];
			// line 7
            val+=pSrc7[x]*pF7[0];   val+=pSrc7[x+1]*pF7[1]; val+=pSrc7[x+2]*pF7[2];  val+=pSrc7[x+3]*pF7[3];  val+=pSrc7[x+4]*pF7[4];
            val+=pSrc7[x+5]*pF7[5]; val+=pSrc7[x+6]*pF7[6]; val+=pSrc7[x+7]*pF7[7];  val+=pSrc7[x+8]*pF7[8];
			// line 8
            val+=pSrc8[x]*pF8[0];   val+=pSrc8[x+1]*pF8[1]; val+=pSrc8[x+2]*pF8[2];  val+=pSrc8[x+3]*pF8[3];  val+=pSrc8[x+4]*pF8[4];
            val+=pSrc8[x+5]*pF8[5]; val+=pSrc8[x+6]*pF8[6]; val+=pSrc8[x+7]*pF8[7];  val+=pSrc8[x+8]*pF8[8];
            // clipping
            val = val < 0.0f ? 0.0f : val;
            // set result
            pDst[x] = val ;
		}
	}

    return true;
}

bool CImageUtility::filter2Doddxodd_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float *pFilt, int size)
// Convolute using a oddxodd 2D filter
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image, same size as input image
//      pFilt -- [I] 2D filter in raster scanning order with oddxodd elements
// by Cao Shuang, ICDD, ASTRI
// Dec, 9, 2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
        pFilt == NULL || size < 2 || (size%2) != 1 || size > 128)  {
		showErrMsg("Invalid input argument in CImageUtility::filter2Doddxodd_32f()!\n");
		return false;
	}

    int a = size/2;
    IplImage *iplPadded = padding(iplSrcImage, a, a, a, a);
    bool rlt = filter2Doddxodd_o1_32f(iplPadded, iplDstImage, pFilt, size);
    safeReleaseImage(&iplPadded);

    return rlt;
}

bool CImageUtility::filter2Doddxodd_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float *pFilt, int size)
// Convolute using a oddxodd 2D filter
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image, same size as input image
//      pFilt -- [I] 2D filter in raster scanning order with oddxodd elements
// by Cao Shuang, ICDD, ASTRI
// Dec, 9, 2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width+size-1 || iplSrcImage->height != iplDstImage->height+size-1 ||
        pFilt == NULL)  {
		showErrMsg("Invalid input argument in CImageUtility::filter2Doddxodd_o1_32f()!\n");
		return false;
	}

    int buf_size = size * size;
    float *pBuffer = new float [buf_size];
    //convolution
    for (int y=0; y<iplDstImage->height; y++) {
        float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            // get a convolution query
            for (int yy=y; yy<y+size; yy++) {
                int yy1 = (yy - y) * size;
                float *pLine = (float *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);                
                for (int xx=x; x<xx+size; xx++) {
                    int index = yy1 + xx;
                    pBuffer[index] = pLine[xx];
                }
            }
            float val = 0.0f;
            for (int i=0; i<buf_size; i++) {
                val += pBuffer[i] * pFilt[i];
            }
            // set result
            pDst[x] = val;
        }
    }

    return true;
}

bool CImageUtility::filter2Devenxeven_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float *pFilt, int size)
// Convolute using a evenxeven 2D filter
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image, same size as input image
//      pFilt -- [I] 2D filter in raster scanning order with evenxeven elements
// by Cao Shuang, ICDD, ASTRI
// Dec, 9, 2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
        pFilt == NULL || size < 2 || (size%2) == 1 || size > 128)  {
		showErrMsg("Invalid input argument in CImageUtility::filter2Devenxeven_32f()!\n");
		return false;
	}
                                                            
    int a = size - 1;
    IplImage *iplPadded = padding(iplSrcImage, a, 0, a, 0);
    bool rlt = filter2Devenxeven_o1_32f(iplPadded, iplDstImage, pFilt, size);
    safeReleaseImage(&iplPadded);

    return rlt;
}

bool CImageUtility::filter2Devenxeven_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float *pFilt, int size)
// Convolute using a evenxeven 2D filter
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image, same size as input image
//      pFilt -- [I] 2D filter in raster scanning order with evenxeven elements
// by Cao Shuang, ICDD, ASTRI
// Dec, 9, 2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width+size-1 || iplSrcImage->height != iplDstImage->height+size-1 ||
        pFilt == NULL)  {
		showErrMsg("Invalid input argument in CImageUtility::filter2Devenxeven_o1_32f()!\n");
		return false;
	}

    int buf_size = size * size;
    float *pBuffer = new float [buf_size];
    //convolution
    for (int y=0; y<iplDstImage->height; y++) {
        float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            // get a convolution query
            for (int yy=y; yy<y+size; yy++) {
                int yy1 = (yy - y) * size;
                float *pLine = (float *)(iplSrcImage->imageData + yy * iplSrcImage->widthStep);                
                for (int xx=x; x<xx+size; xx++) {
                    int index = yy1 + xx;
                    pBuffer[index] = pLine[xx];
                }
            }
            float val = 0.0f;
            for (int i=0; i<buf_size; i++) {
                val += pBuffer[i] * pFilt[i];
            }
            // set result
            pDst[x] = val;
        }
    }

    return true;
}

bool CImageUtility::getMonoEdgePointList(IplImage *iplLabel, CvRect roi, int label, CvPoint pt_start, unsigned char pMark[], 
                                         CvPoint pPoints[], int &point_num, int &start_index)
// Get the points in a labeled edge and put the coordinates into a point list.
// This function tries to search an (at least local) monotonic line/curve and order the point from top left to bottom right.
// Arguments:
//      iplLabel -- [I] 32S label image (for example, created by function markEdges_32f()), 
//                      where the label is 1 ~ edge_num (when edge_num > 0).
//      roi -- [I] ROI for the search.
//      label -- [I] label of the edge pixel to search.
//      start -- [I] start point of the search. For a successful search, this point must be marked as the label ID of 'label'.
//      pMark -- [O] an image buffer of size (roi.width x roi.height) to marked the point in the list, where '0' represents 
//                   'empty' and '255' represents edge point searched.
//      pPoints -- [O] resultant point list, which stores the relative coordinates in the ROI. 
//                     NOTE: The element number MUST BE LARGER THAN (3*roi.width*roi.height)
//      point_num -- [O] number of points searched. It is also the length of the resultant point list.
//      start_index -- [O] index of the start point 'start' in the resultant point list 'pPoints'
// NOTE: This function will not check the input arguments for an efficient implementation. If any input and output buffer/value
//       is inappropriate, the function may CRASH.
// by Luhong Liang, ICDD, ASTRI
// March 6, 2015
{
    if (pt_start.x < roi.x || pt_start.x >= roi.x+roi.width ||
        pt_start.y < roi.y || pt_start.y >= roi.y+roi.height) {
        point_num = 0;
        start_index = -1;
        return false;   // possible incorrect input
    }
    // check start point
    int *pLabelStart = (int *)(iplLabel->imageData + pt_start.y*iplLabel->widthStep);
    int lab = pLabelStart[pt_start.x];
    if (lab != label) {
        point_num = 0;
        start_index = -1;
        return false;   // possible incorrect input
    }

    // Direction table
    // Line Direction Code:     0   1   2
    //                          7   C   3
    //                          6   5   4
    static const CvPoint pCLut[8] = { {-1,-1}, { 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0} };
    static const int pDLut[8][5]  = { { 0, 1, 7, 2, 6 },       // direction 0: search 0, 1, 7, 2, 6 in order
                                      { 1, 2, 0, 3, 7 },       // direction 1: search 1, 2, 0, 3, 7 in order
                                      { 2, 3, 1, 4, 0 },       // direction 2: search 2, 3, 1, 4, 0 in order
                                      { 3, 4, 2, 5, 1 },       // direction 3: search 3, 4, 2, 5, 1 in order
                                      { 4, 5, 3, 6, 2 },       // direction 4: search 4, 5, 3, 6, 2 in order
                                      { 5, 6, 4, 7, 3 },       // direction 5: search 5, 6, 4, 7, 3 in order
                                      { 6, 7, 5, 0, 4 },       // direction 6: search 6, 7, 5, 0, 4 in order
                                      { 7, 0, 6, 1, 5 } };     // direction 7: search 7, 0, 6, 1, 5 in order
    
    // Search an connected line that is almost monotonic.
    // To get an "monotonic" line/curve, we contrain the search direction in each step (see pDLut[][] above).
    // This step is must-have to avoid "dual-line" problem (two lines with the same label in the window) 
    int run_length = (roi.width + roi.height) / 2 - 1;

    // initialize mark
    for (int i=0; i<roi.width*roi.height; i++) {
        pMark[i] = 0;
    }

    // mark the "start" point
    int cx = pt_start.x - roi.x;
    int cy = pt_start.y - roi.y;
    pMark[cy*roi.width+cx] = 255;

    // search to top left (direction 2)
    // Line Direction Code:     0   1   2
    //                          7   C   3
    //                          6   5   4
    int pix_num_tl = 0;
    CvPoint *pPointTL = pPoints + roi.width * roi.height;
    int pre_dir = 2;
    bool hit = true;
    while (pix_num_tl < run_length && hit) {
        // next point
        int xx=0, yy=0;
        bool not_hit = true;
        for (int i=0; i<5 && not_hit; i++) {
            // try a next step position
            int cur_dir = pDLut[pre_dir][i];
            CvPoint shift_next = pCLut[cur_dir];
            xx = cx + shift_next.x;
            yy = cy + shift_next.y;
            if (xx >= 0 && xx < roi.width && yy >= 0 && yy < roi.height) {
                lab = *((int *)(iplLabel->imageData + (yy+roi.y)*iplLabel->widthStep) + xx + roi.x);
                int mark_idx = yy * roi.width + xx;
                if (lab == label && pMark[mark_idx] == 0) {
                    pPointTL[pix_num_tl].x = xx;
                    pPointTL[pix_num_tl].y = yy;
                    pix_num_tl ++;
                    pMark[mark_idx] = 255;
                    pre_dir = cur_dir;
                    not_hit = false;
                }
            }
        }
        if (not_hit) {
            hit = false;
        } else {
            cx = xx;    // move to next pixel
            cy = yy;
        }
    }

    // search to bottom right (direction 6)
    // Line Direction Code:     0   1   2
    //                          7   C   3
    //                          6   5   4
    cx = pt_start.x - roi.x;        // return to the start point
    cy = pt_start.y - roi.y;

    int pix_num_br = 0;
    CvPoint *pPointBR = pPoints + roi.width * roi.height *2;
    pre_dir = 6;
    hit = true;
    while (pix_num_br < run_length && hit) {
        // next point
        int xx=0, yy=0;
        bool not_hit = true;
        for (int i=0; i<5 && not_hit; i++) {
            // try a next step position
            int cur_dir = pDLut[pre_dir][i];
            CvPoint shift_next = pCLut[cur_dir];
            xx = cx + shift_next.x;
            yy = cy + shift_next.y;
            if (xx >= 0 && xx < roi.width && yy >= 0 && yy < roi.height) {
                lab = *((int *)(iplLabel->imageData + (yy+roi.y)*iplLabel->widthStep) + xx + roi.x);
                int mark_idx = yy * roi.width + xx;
                if (lab == label && pMark[mark_idx] == 0) {
                    pPointBR[pix_num_br].x = xx;
                    pPointBR[pix_num_br].y = yy;
                    pix_num_br ++;
                    pMark[mark_idx] = 255;
                    pre_dir = cur_dir;
                    not_hit = false;
                }
            }
        }
        if (not_hit) {
            hit = false;
        } else {
            cx = xx;    // move to next pixel
            cy = yy;
        }
    }

    // merge the two point lists
    if (pPointTL[pix_num_tl-1].x < pPointBR[pix_num_br-1].x || 
        (pPointTL[pix_num_tl-1].x == pPointBR[pix_num_br-1].x && pPointTL[pix_num_tl-1].y < pPointBR[pix_num_br-1].y)) {
        // left part
        for (int i=0; i<pix_num_tl; i++) {
            pPoints[i] = pPointTL[pix_num_tl-i-1];
        }
        // center point
        pPoints[pix_num_tl].x = pt_start.x - roi.x;
        pPoints[pix_num_tl].y = pt_start.y - roi.y;
        start_index = pix_num_tl;
        // right part
        for (int i=0; i<pix_num_br; i++) {
            pPoints[i+pix_num_tl+1] = pPointBR[i];
        }
        
    } else {
        // left part
        for (int i=0; i<pix_num_br; i++) {
            pPoints[i] = pPointBR[pix_num_br-i-1];
        }
        // center point
        pPoints[pix_num_br].x = pt_start.x - roi.x;
        pPoints[pix_num_br].y = pt_start.y - roi.y;
        start_index = pix_num_br;
        // right part
        for (int i=0; i<pix_num_tl; i++) {
            pPoints[i+pix_num_br+1] = pPointTL[i];
        }
    }
    point_num = pix_num_tl + pix_num_br + 1;

    return true;
}

IplImage *CImageUtility::markEdges_32f(IplImage *iplEdge, float edge_th, int &edge_num, int connectivity, int min_pix_num)
// Assign labels to the 4- or 8-connected edges
// Argument:
//      iplEdge -- [I] input edge likelihood map
//      edge_th -- [I] edge should be with likelhood larger than or equal to the threshold
//      edge_num -- [I/] input the maximal number of the edges to be labelled and output the actual number of edges labelled
//      connectivity -- [I] 4 or 8 to determine the 4-connected or 8-connected rule used
//      min_pix_num -- [I] if it is larger than 0, only label the edges with pixel numbers larger than or equal to the threshold
// Return:
//      An 32-bit interger image where each pixel represents the label of the edge. If there is edge_num lines labelled, the label 
//      is from 1 to edge_num.
// by Luhong Liang
// March 4, 2015
{
    if (iplEdge == NULL || iplEdge->nChannels != 1 || iplEdge->depth != SR_DEPTH_32F ||
        (connectivity != 4 && connectivity != 8) || edge_num < 0 || min_pix_num < 0)  {
        showErrMsg("Invalid input image(s) and/or argument(s) in CImageUtility::markEdges_32f()!\n");
        return NULL;
    }

    IplImage *iplLabel = createImage(iplEdge->width, iplEdge->height, SR_DEPTH_32S, 1);
    IplImage *iplEdgePad = padding_0_0(iplEdge, 1, 1, 1, 0);
    int *pNewLabel = new int[(edge_num+1)*2*4];
    if (iplLabel == NULL || pNewLabel == NULL || iplEdgePad == NULL) {
        showErrMsg("Fail to allocate image and/or buffer in CImageUtility::markEdges_32f()!\n");
        delete [] pNewLabel;
        safeReleaseImage(&iplLabel, &iplEdgePad);
        return NULL;
    }
    int *pPixelNum = pNewLabel + 4*(edge_num+1);

    //
    // Pass 1: labeling in raster scan order, check top and left (label > 0)
    //         check      x   x   x
    //                    x   O
    //
    setZero(iplLabel);      // for debug
    int cur_edge_id = 1;
    int max_edge_id = iplEdge->width * iplEdge->height;
    if (connectivity == 8) {
        // first line
        float *pEdg = (float *)(iplEdge->imageData);
        int *pLab = (int *)(iplLabel->imageData);
        if (pEdg[0] >= edge_th) {
            // new edge entry
            pLab[0] = cur_edge_id;
            pNewLabel[cur_edge_id] = cur_edge_id;
            cur_edge_id ++;
        } else {
            pLab[0] = 0;
        }
        for(int x=1; x<iplLabel->width; x++) {
            if (pEdg[x] >= edge_th) {
                if (pEdg[x-1] >= edge_th) {
                    // connect
                    pLab[x] = pLab[x-1];
                } else {
                    // add new entry
                    pLab[x] = cur_edge_id;
                    pNewLabel[cur_edge_id] = cur_edge_id;
                    cur_edge_id ++;
                }
            } else {
                pLab[x] = 0;
            }
        }
        // other lines
        int p0N, p00, p01, p1N, lab;
        for (int y=1; y<iplLabel->height; y++) {
            int *pLab0 = (int *)(iplLabel->imageData + (y-1) * iplLabel->widthStep);
            int *pLab1 = (int *)(iplLabel->imageData + y * iplLabel->widthStep);
            float *pEdg1 = (float *)(iplEdge->imageData + y * iplEdge->widthStep);
            // first pixel
            if (pEdg1[0] >= edge_th) {
                p00 = pLab0[0];
                p01 = pLab0[1];
                // check upper pixels
                if (p00 > 0 || p01 > 0) {
                    // find minimal label
                    lab = max_edge_id;
                    if (p00 > 0 && p00 < lab) lab = p00;
                    if (p01 > 0 && p01 < lab) lab = p01;
                    // update label table (no matter if the label is 0, since entry 0 is not used)
                    pNewLabel[p00] = lab;
                    pNewLabel[p01] = lab;
                    // connect
                    pLab1[0] = lab;
                } else {
                    // new entry
                    pLab1[0] = cur_edge_id;
                    pNewLabel[cur_edge_id] = cur_edge_id;
                    cur_edge_id ++;
                }
            } else {
                pLab1[0] = 0;
            }
            // middle pixels
            for(int x=1; x<iplLabel->width-1; x++) {        // to fix!!!
                //if (x==225 && y==482 || x==1920 && y==460 || x==1883 && y==535)
                //    int p = 1;
                if (pEdg1[x] >= edge_th) {
                    p0N = pLab0[x-1];
                    p00 = pLab0[x];
                    p01 = pLab0[x+1];
                    p1N = pLab1[x-1]; 
                    // check upper pixels
                    if (p0N > 0 || p00 > 0 || p01 > 0 || p1N > 0) {
                        // find minimal label
                        lab = max_edge_id;
                        if (p0N > 0 && p0N < lab) lab = p0N;
                        if (p00 > 0 && p00 < lab) lab = p00;
                        if (p01 > 0 && p01 < lab) lab = p01;
                        if (p1N > 0 && p1N < lab) lab = p1N;
                        // update label table (no matter if the label is 0, since entry 0 is not used)
                        pNewLabel[p0N] = lab;
                        pNewLabel[p00] = lab;
                        pNewLabel[p01] = lab;
                        pNewLabel[p1N] = lab;
                        //if (lab == 1740 || lab == 1371)
                        //    int p4 = 1;
                        // connect
                        pLab1[x] = lab;
                    } else {
                        // new entry
                        pLab1[x] = cur_edge_id;
                        pNewLabel[cur_edge_id] = cur_edge_id;
                        //if (cur_edge_id == 1740 || cur_edge_id == 1371)
                        //    int p5 = 1;
                        //if (cur_edge_id > 1212 && cur_edge_id < 1402) {
                        //    IplImage *iplVis = visMarkedEdges(iplLabel, edge_num);
                        //    saveImage("__Labeling.bmp", iplVis);
                        //    safeReleaseImage(&iplVis);
                        //}
                        cur_edge_id ++;
                    }
                } else {
                    pLab1[x] = 0;
                }
            }   // for x

            // right most pixels
            int x = iplLabel->width-1;
            if (pEdg1[x] >= edge_th) {
                p0N = pLab0[x-1];
                p00 = pLab0[x];
                p1N = pLab1[x-1]; 
                // check upper pixels
                if (p0N > 0 || p00 > 0 || p1N > 0) {
                    // find minimal label
                    lab = max_edge_id;
                    if (p0N > 0 && p0N < lab) lab = p0N;
                    if (p00 > 0 && p00 < lab) lab = p00;
                    if (p1N > 0 && p1N < lab) lab = p1N;
                    // update label table (no matter if the label is 0, since entry 0 is not used)
                    pNewLabel[p0N] = lab;
                    pNewLabel[p00] = lab;
                    pNewLabel[p1N] = lab;
                    // connect
                    pLab1[x] = lab;
                } else {
                    // new entry
                    pLab1[x] = cur_edge_id;
                    pNewLabel[cur_edge_id] = cur_edge_id;
                    cur_edge_id ++;
                }
            } else {
                pLab1[x] = 0;
            }   
        } // for y
    } else {
    }
    edge_num = cur_edge_id - 1;
    //showMessage1("%d edge lines initially labelled.\n", edge_num);
    //IplImage *iplVis = visMarkedEdges(iplLabel, edge_num);
    //saveImage("__Labeling0.bmp", iplVis);
    //safeReleaseImage(&iplVis);
                        //}
    //
    // Pass 2: Merge in raster scan order, check right (label > 0)
    //         check     O   x
    //
    for (int y=0; y<iplLabel->height; y++) {
        int *pLab = (int *)(iplLabel->imageData + y * iplLabel->widthStep);
        for(int x=1; x<iplLabel->width; x++) {
            //if (x==225 && y==482 || x==1920 && y==460 || x==1884 && y==535)
            //    int p = 1;
            int lab0 = pLab[x];
            int labn = pLab[x-1];
            if (lab0 > 0 && labn > 0 && lab0 != labn) {
                int lab0t = lab0;
                while (lab0t != pNewLabel[lab0t]) {// search the "original" label id
                    lab0t = pNewLabel[lab0t];
                }
                int labnt = labn;
                while (labnt != pNewLabel[labnt]) {// search the "original" label id
                    labnt = pNewLabel[labnt];
                }
                int min_lab = labnt < lab0t ? labnt : lab0t;
                pNewLabel[lab0] = min_lab;
                pNewLabel[labn] = min_lab;
            }
            //if (pNewLabel[1371] == 1215 || pNewLabel[1740] == 1371)
            //    int p2 = 0;
        }   // for x
    } // for y

    // search the "original" label id of each changed label
	pNewLabel[0] = 0;			// dumb element, May 11, 2015
    for (int i=1; i<=edge_num; i++) {       
        int lab = pNewLabel[i];
        if (lab != pNewLabel[lab]) {
            while (lab != pNewLabel[lab]) { // search the "original" label id
                lab = pNewLabel[lab];
            }
            pNewLabel[i] = lab;
        }
    }

    // "condense" the label ids
    for (int i=0; i<=edge_num; i++) {
        pPixelNum[i] = 0;
    }
    for (int i=1; i<=edge_num; i++) {		// i=0 --> i=1, May 11, 2015
        int lab = pNewLabel[i];
        pPixelNum[lab] = 1;
    }
    int new_id = 1;
    for (int i=1; i<=edge_num; i++) {		// i=0 --> i=1, May 11, 2015
        if (pPixelNum[i] > 0) {
            pPixelNum[i] = new_id;
            new_id ++;
        }
    }
    for (int i=1; i<=edge_num; i++) {		// i=0 --> i=1, May 11, 2015
        pNewLabel[i] = pPixelNum[pNewLabel[i]];
    }    
    edge_num = new_id - 1;

    //
    // Pass 3: merge edge lines   
    //
    for (int i=0; i<=edge_num; i++) {
        pPixelNum[i] = 0;
    }
    pNewLabel[0] = 0;       // to remove a branch below
    for (int y=0; y<iplLabel->height; y++) {
        int *pLab = (int *)(iplLabel->imageData + y * iplLabel->widthStep);
        for(int x=0; x<iplLabel->width; x++) {
            //if (x==225 && y==482 || x==1920 && y==460)
            //    int p = 1;
            int lab = pLab[x];
            int newlab = pNewLabel[lab];
            pLab[x] = newlab;
            pPixelNum[newlab]++;
        }
    }
    //showMessage1("%d edge lines labelled after merge.\n", edge_num);
    
    //
    // delete lines with little pixels
    //
    pNewLabel[0] = 0;
    int new_edge_id = 1;
    for (int i=1; i<=edge_num; i++) {
        //if (i==692)
        //    int p = 1;
        if (pPixelNum[i] < min_pix_num) {
            //pPixelNum[i] = 0;
            pNewLabel[i] = 0;
        } else {
            pNewLabel[i] = new_edge_id;
            new_edge_id ++;
        }
    }
    edge_num = new_edge_id - 1;
    for (int y=0; y<iplLabel->height; y++) {
        int *pLab = (int *)(iplLabel->imageData + y * iplLabel->widthStep);
        for(int x=0; x<iplLabel->width; x++) {
            //if (x==1774 && y==976)
            //    int p = 1;
            int lab = pLab[x];
            pLab[x] = pNewLabel[lab];
        }
    }
    //showMessage1("%d edge lines after short line removal.\n", edge_num);

    delete [] pNewLabel;
    safeReleaseImage(&iplEdgePad);
    
    return iplLabel;
}

IplImage *CImageUtility::visMarkedEdges(IplImage *iplLabel, int edge_num)
// Visualize a label map to an RGB 8U image
// Argument:
//      iplLabel -- [I] 32S label image (for example, created by function markEdges_32f()), 
//                      where the label is 1 ~ edge_num (when edge_num > 0)
//      edge_num -- [I] number of the edge lines in the label image, 
//                      which equals to the maximal label value in the label image.
//                      If edge_num = -1, re-count the edge number in this function.
// Return:
//      RGB 8U image, where each color represents a line.
// by Luhong Liang
// March 4, 2015
{
    if (iplLabel == NULL || iplLabel->nChannels != 1 || iplLabel->depth != SR_DEPTH_32S)  {
        showErrMsg("Invalid input image(s) and/or argument(s) in CImageUtility::visMarkedEdges()!\n");
        return NULL;
    }

    // get edge number
    if (edge_num < 0) {
        edge_num = 0;
        for (int y=0; y<iplLabel->height; y++) {
            int *pLab = (int *)(iplLabel->imageData + y * iplLabel->widthStep);
            for(int x=0; x<iplLabel->width; x++) {
                int lab = pLab[x];
                if (lab > edge_num) {
                    edge_num = lab;
                }
            }
        }
    }

    // allocate color table
    unsigned char *pColor = new unsigned char[(edge_num+1)*3];
    IplImage *iplRGB = createImage(iplLabel->width, iplLabel->height, SR_DEPTH_8U, 3);
    if (pColor == NULL || iplRGB == NULL) {
        showErrMsg("Fail to allocate color table in CImageUtility::visMarkedEdges()!\n");
        safeReleaseImage(&iplRGB);
        if (pColor != NULL) delete [] pColor;
        return NULL;
    }
    unsigned char *pR = pColor;
    unsigned char *pG = pR + edge_num + 1;
    unsigned char *pB = pG + edge_num + 1;

    // create the color scheme
    int a = (int)ceil(exp(log((double)edge_num)/3.0)) + 1;
    int interv = 255 / a;
    pR[0] = 0;
    pG[0] = 0;
    pB[0] = 0;
    int i = 1;
    for (int r=255; r>=interv && i<=edge_num; r-=interv) {
        for (int g=0; g<255 && i<=edge_num; g+=interv) {
            for (int b=0; b<255 && i<=edge_num; b+=interv) {
                pR[i] = (unsigned char)r;
                pG[i] = (unsigned char)g;
                pB[i] = (unsigned char)b;
                i ++;
            }
        }
    }
    srand(917);
    for (int i=1; i<=edge_num; i++) {
        int xch = rand() % edge_num + 1;
        int rt = pR[i]; int gt = pG[i]; int bt = pB[i];
        pR[i] = pR[xch]; pG[i] = pG[xch]; pB[i] = pB[xch];
        pR[xch] = (unsigned char)rt; 
        pG[xch] = (unsigned char)gt; 
        pB[xch] = (unsigned char)bt;
    }

    // create colorful image
    for (int y=0; y<iplRGB->height; y++) {
        int *pLab = (int *)(iplLabel->imageData + y * iplLabel->widthStep);
        unsigned char *pRGB = (unsigned char *)(iplRGB->imageData + y * iplRGB->widthStep);
        for(int x=0, xx=0; x<iplRGB->width; x++, xx+=3) {
            int lab = pLab[x];
            pRGB[xx] = pB[lab];
            pRGB[xx+1] = pG[lab];
            pRGB[xx+2] = pR[lab];
        }
    }

    delete [] pColor;

    return iplRGB;
}

IplImage *CImageUtility::extrEdge_32f(IplImage *iplLabel, int edge_id0, int edge_id1, int &pixel_num)
// Extract edges with label ID from 'edge_id0' to 'edge_id1' in the label map.
// Argument:
//      iplLabel -- [I] 32S label map created by markEdges_32f().
//      edge_id -- [I] the label of the edge to be extracted.
//      pixel_num -- [O] number of pixels in the extracted edge
// Return:
//      An 8U image where '255' represents the edge and '0' represents others
// by Luhong Liang
// March 4, 2015
{
    if (iplLabel == NULL || iplLabel->nChannels != 1 || iplLabel->depth != SR_DEPTH_32S)  {
        showErrMsg("Invalid input image(s) and/or argument(s) in CImageUtility::extrEdge_32f()!\n");
        return NULL;
    }

    IplImage *iplEdge = createImage(iplLabel->width, iplLabel->height, SR_DEPTH_8U, 1);
    if (iplEdge == NULL) {
        showErrMsg("Fail to allocate color table in CImageUtility::extrEdge_32f()!\n");
        safeReleaseImage(&iplEdge);
        return NULL;
    }

    pixel_num = 0;
    for (int y=0; y<iplEdge->height; y++) {
        int *pLab = (int *)(iplLabel->imageData + y * iplLabel->widthStep);
        unsigned char *pEdg = (unsigned char *)(iplEdge->imageData + y * iplEdge->widthStep);
        for(int x=0, xx=0; x<iplEdge->width; x++, xx+=3) {
            int lab = pLab[x];
            if (lab >= edge_id0 && lab <= edge_id1) {
                pEdg[x] = 255;
                pixel_num ++;
            } else {
                pEdg[x] = 0;
            }
        }
    }

    return iplEdge;
}

bool CImageUtility::inflatLabel3x3_32f(IplImage *iplLabel, IplImage *iplInfLabel)
// Inflate labels by 3x3 max filter (boxing shape) while trying to keep each edge seperated
//      iplLabel -- [I] 32S label image (for example, created by function markEdges_32f()), 
//                      where the label is 1 ~ edge_num (when edge_num > 0)
//      iplInfLabel -- [O] resultant label map, 32S
// This function supports "in-place" operation.
// by Luhong Liang
// March 4, 2015
{
    if (iplLabel == NULL || iplLabel->nChannels != 1 || iplLabel->depth != SR_DEPTH_32S ||
        iplInfLabel == NULL || iplInfLabel->nChannels != 1 || iplInfLabel->depth != SR_DEPTH_32S ||
        iplLabel->width != iplInfLabel->width || iplLabel->height != iplInfLabel->height)  {
        showErrMsg("Invalid input image(s) and/or argument(s) in CImageUtility::inflatLabel3x3_32f()!\n");
        return false;
    }

    IplImage *iplMark = createImage(iplLabel->width+2, iplLabel->height+2, SR_DEPTH_8U, 1);
    IplImage *iplPadded = padding(iplLabel, 1, 1, 1, 1);
    if (iplMark == NULL || iplPadded == NULL) {
        showErrMsg("Fail to allocate color table in CImageUtility::inflatLabel3x3_32f()!\n");
        safeReleaseImage(&iplMark, &iplPadded);
        return false;
    }

    const unsigned char empty = 0;
    const unsigned char inflated = 255;
    setValue3(iplMark, empty);

    for (int y=0; y<iplInfLabel->height; y++) {
        int *pOrg = (int *)(iplLabel->imageData + y * iplLabel->widthStep);
        int *pLab0 = (int *)(iplPadded->imageData + y * iplPadded->widthStep);
        int *pLab1 = (int *)(iplPadded->imageData + (y+1) * iplPadded->widthStep);
        int *pLab2 = (int *)(iplPadded->imageData + (y+2) * iplPadded->widthStep);
        unsigned char *pMark0 = (unsigned char *)(iplMark->imageData + y * iplMark->widthStep);
        unsigned char *pMark1 = (unsigned char *)(iplMark->imageData + (y+1) * iplMark->widthStep);
        unsigned char *pMark2 = (unsigned char *)(iplMark->imageData + (y+2) * iplMark->widthStep);
        for(int x=0; x<iplInfLabel->width; x++) {
            //if (x==120 && y==1)
            //    int p = 1;

            int lab = pOrg[x];
            if (lab > 0) {
                // mark
                pLab1[x+1] = lab;

                // neighbouring 00
                if (pLab0[x-1] <= 0 && pMark0[x-1] == empty) {
                    // "empty" --> inflate
                    pLab0[x-1] = lab;
                    pMark0[x-1] = inflated;
                    // do nothing for cleared one
                } else if (pMark0[x-1] == inflated && pLab0[x-1] != lab) {   
                    // "occupied" --> clear to seperate two edges
                    pLab0[x-1] = 0;
                }
                // do nothing for originally labelled one

                // neighbouring 01
                if (pLab0[x] <= 0 && pMark0[x] == empty) {
                    pLab0[x] = lab;
                    pMark0[x] = inflated;
                } else if (pMark0[x] == inflated && pLab0[x] != lab) {   
                    pLab0[x] = 0;
                }

                // neighbouring 02
                if (pLab0[x+1] <= 0 && pMark0[x+1] == empty) {
                    pLab0[x+1] = lab;
                    pMark0[x+1] = inflated;
                } else if (pMark0[x+1] == inflated && pLab0[x+1] != lab) {   
                    pLab0[x+1] = 0;
                }

                // neighbouring 10
                if (pLab1[x-1] <= 0 && pMark1[x-1] == empty) {
                    pLab1[x-1] = lab;
                    pMark1[x-1] = inflated;
                } else if (pMark1[x-1] == inflated && pLab1[x-1] != lab) {   
                    pLab1[x-1] = 0;
                }

                // neighbouring 12
                if (pLab1[x+1] <= 0 && pMark1[x+1] == empty) {
                    pLab1[x+1] = lab;
                    pMark1[x+1] = inflated;
                } else if (pMark1[x+1] == inflated && pLab1[x+1] != lab) {   
                    pLab1[x+1] = 0;
                }

                // neighbouring 20
                if (pLab2[x-1] <= 0 && pMark2[x-1] == empty) {
                    pLab2[x-1] = lab;
                    pMark2[x-1] = inflated;
                } else if (pMark2[x-1] == inflated && pLab2[x-1] != lab) {   
                    pLab2[x-1] = 0;
                }

                // neighbouring 21
                if (pLab2[x] <= 0 && pMark2[x] == empty) {
                    pLab2[x] = lab;
                    pMark2[x] = inflated;
                } else if (pMark2[x] == inflated && pLab2[x] != lab) {   
                    pLab2[x] = 0;
                }

                // neighbouring 22
                if (pLab2[x+1] <= 0 && pMark2[x+1] == empty) {
                    pLab2[x+1] = lab;
                    pMark2[x+1] = inflated;
                } else if (pMark2[x+1] == inflated && pLab2[x+1] != lab) {   
                    pLab2[x+1] = 0;
                }
            }
        } // for x
    } // for y

    unpadding(iplPadded, iplInfLabel, 1, 1);

    safeReleaseImage(&iplMark, &iplPadded);

    return true;
}

bool CImageUtility::rmGrateLines_32f(IplImage *iplLabel, int wnd_rad, int threshold)
// Remove the lines in the "grate" region
// Arguments:
//      iplLabel -- [I] 32S label image (for example, created by function markEdges_32f()), 
//                      where the label is 1 ~ edge_num (when edge_num > 0)
//      wnd_rad -- [I] radius of the window to detect the "grate"
//      threshold -- [I] if the number of lines larger than the threshold, the line pixel will
//                       be considered in "grate" lines (0 ~ 21, 2 by default)
// by Luhong Liang
// March 6, 2015
{
    const int max_wnd_size = 21;
    //const int pix_num_vs_width = 2;     // maximum pixel number of an "valid" line/curve vs. window size

    //const float eps = 1e-5f;
    //const float fit_th = 0.1f;

    if (iplLabel == NULL || iplLabel->nChannels != 1 || iplLabel->depth != SR_DEPTH_32S) {
        showErrMsg("Invalid input image(s) and/or argument(s) in CImageUtility::rmGrateLines_32f()!\n");
        return false;
    }
    
    int wnd_size = wnd_rad * 2 + 1;
    if (wnd_size > max_wnd_size || wnd_rad < 2)  {
        showErrMsg("Invalid window radius (must be 2~10) in CImageUtility::rmGrateLines_32f()!\n");
        return false;
    }

    if (wnd_size > max_wnd_size || wnd_rad < 2)  {
        showErrMsg("Invalid window radius (must be 2~10) in CImageUtility::rmGrateLines_32f()!\n");
        return false;
    }
    if (threshold > max_wnd_size || threshold < 0)  {
        showErrMsg("Invalid threshold (must be 0~21) in CImageUtility::rmGrateLines_32f()!\n");
        return false;
    }

    IplImage *iplLabPad = CImageUtility::padding_0_0(iplLabel, wnd_rad, wnd_rad, wnd_rad, wnd_rad);
    IplImage *iplBlock = createImage(wnd_size, wnd_size, iplLabel->depth, 1);
    if (iplLabPad == NULL || iplBlock == NULL) {
        showErrMsg("Fail to allocate image buffer in CImageUtility::getEdgeOrient()!\n");
        safeReleaseImage(&iplLabPad, &iplBlock);
        return false;
    }

    unsigned char pMark[max_wnd_size * max_wnd_size];
    CvPoint pPoints[max_wnd_size * max_wnd_size * 2];
    //int pix_in_line_th = wnd_size * pix_num_vs_width;
    //int win_center_idx = (wnd_size * wnd_size) / 2;
    CvRect roi = { 0, 0, wnd_size, wnd_size };
    int pLabelCount[max_wnd_size + 2];
    //CvPoint pStartPoints[max_wnd_size + 2];
    for (int y=0; y<iplLabel->height; y++) {
        int *pLab0 = (int *)(iplLabel->imageData + y * iplLabel->widthStep);
        //int *pLabel = (int *)(iplLabPad->imageData + y * iplLabPad->widthStep);
        for (int x=0; x<iplLabel->width; x++) {
            //if (x==918 && y==488)
            //    int p = 1;

            // edge guided
            int lab = pLab0[x];
            if (lab <= 0) {
                continue;
            }

            // copy a block & count the label number
            int label_num = 0;
            int max_label_num = threshold + 2;
            for (int yy=0; yy<iplBlock->height; yy++) {
                int *pSrc = (int *)(iplLabPad->imageData + (yy+y) * iplLabPad->widthStep) + x;
                int *pDst = (int *)(iplBlock->imageData + yy * iplBlock->widthStep);
                for (int xx=0; xx<iplBlock->width; xx++) {
                    int label = pSrc[xx];
                    // copy
                    pDst[xx] = label;
                    // count label
                    if (label > 0 && label_num < max_label_num) {
                        bool hit = false;
                        for (int j=0; j<label_num && !hit; j++) {
                            if (pLabelCount[j] == label) {
                                hit = true;
                            }
                        }
                        if (!hit) {
                            pLabelCount[label_num] = label;
                            //pStartPoints[label_num].x = xx;
                            //pStartPoints[label_num].y = yy;
                            label_num ++;
                        }
                    }
                } // xx
            } // yy

            // do not check label number here, since there may be two or mulitple lines sharing one label

            // get a "monotonic" curve in a point list form
            int line_num_marked = 0;
            bool has_line = true;
            while (line_num_marked <= max_label_num && has_line) {
                // find a new line
                bool new_line = false;
                CvPoint pt_start = {0, 0};
                int label_c = 0;
                for (int yy=0; yy<iplBlock->height && !new_line; yy++) {
                    int *pBlock = (int *)(iplBlock->imageData + yy * iplBlock->widthStep);
                    for (int xx=0; xx<iplBlock->width && !new_line; xx++) {
                        if (pBlock[xx] > 0) {
                            new_line = true;
                            pt_start.x = xx;
                            pt_start.y = yy;
                            label_c = pBlock[xx];
                        }
                    }
                }
                // mark a line
                if (new_line) {
                    int point_num=0, start_idx=0;
                    if (getMonoEdgePointList(iplBlock, roi, label_c, pt_start, pMark, pPoints, point_num, start_idx)) {
                        // update labels
                        for (int jj=0; jj<point_num; jj++) {
                            int *pBlock = (int *)(iplBlock->imageData + pPoints[jj].y  * iplBlock->widthStep);
                            pBlock[pPoints[jj].x] = 0;
                        }
                        if (point_num > 5) {
                            line_num_marked ++;
                        }
                    } else {
                        has_line = false;
                    }
                } else {
                    has_line = false;
                }
            } // while

            if (line_num_marked > threshold) {
                pLab0[x] = 0;
            }
        }
    }

    safeReleaseImage(&iplLabPad, &iplBlock);

    return true;
}

bool CImageUtility::getEdgeOrient(IplImage *iplLabel, IplImage *iplOrientMap, IplImage *iplLikelihood, int wnd_rad)
// Calculate the edge orientation at each labeled edge point. 
// Arguments:
//      iplLabel -- [I] 32S label image (for example, created by function markEdges_32f()), 
//                      where the label is 1 ~ edge_num (when edge_num > 0)
//      iplDirMap -- [O] resultant orientation map, where each pixel is an angle ranging [0, 180).
//                       0 represents the horizontal line and 90 represents the veritical line. 
//                       Some examples are:
//                          0        45        90        135     
//                         ___       \         |           /   
//                                    \        |          /
//      iplLikelihood -- [O] likelihood of the orientation estimation
//      wnd_rad -- [I] window radius to conduct the orientation estimation
// by Luhong Liang
// March 6, 2015
{
    const int max_wnd_size = 21;
    const int pix_num_vs_width = 2;     // maximum pixel number of an "valid" line/curve vs. window size

    const float eps = 1e-5f;
    const float fit_th = 0.1f;

    if (iplLabel == NULL || iplLabel->nChannels != 1 || iplLabel->depth != SR_DEPTH_32S ||
        iplOrientMap == NULL || iplOrientMap->nChannels != 1 || iplOrientMap->depth != SR_DEPTH_32F ||
        iplLikelihood == NULL || iplLikelihood->nChannels != 1 || iplLikelihood->depth != SR_DEPTH_32F ||
        iplLabel->width != iplOrientMap->width || iplLabel->height != iplOrientMap->height ||
        iplLabel->width != iplLikelihood->width || iplLabel->height != iplLikelihood->height) {
        showErrMsg("Invalid input image(s) and/or argument(s) in CImageUtility::getEdgeOrient()!\n");
        return false;
    }
    
    int wnd_size = wnd_rad * 2 + 1;
    if (wnd_size > max_wnd_size || wnd_rad < 2)  {
        showErrMsg("Invalid window radius (must be 2~10) in CImageUtility::getEdgeOrient()!\n");
        return false;
    }

    IplImage *iplLabPad = CImageUtility::padding_0_0(iplLabel, wnd_rad, wnd_rad, wnd_rad, wnd_rad);
    if (iplLabPad == NULL) {
        showErrMsg("Fail to allocate image buffer in CImageUtility::getEdgeOrient()!\n");
        return false;
    }

    unsigned char pMark[max_wnd_size * max_wnd_size];
    CvPoint pPoints[max_wnd_size * max_wnd_size * 2];
    int pix_in_line_th = wnd_size * pix_num_vs_width;
    //int win_center_idx = (wnd_size * wnd_size) / 2;
    for (int y=0; y<iplOrientMap->height; y++) {
        int *pLab0 = (int *)(iplLabel->imageData + y * iplLabel->widthStep);
        //int *pLabel = (int *)(iplLabPad->imageData + y * iplLabPad->widthStep);
        float *pOrient = (float *)(iplOrientMap->imageData + y * iplOrientMap->widthStep);
        float *pLike = (float *)(iplLikelihood->imageData + y * iplLikelihood->widthStep);
        for (int x=0; x<iplOrientMap->width; x++) {
            //if (x==1202 && y==375)
            //    int p = 1;

            // edge guided
            int lab = pLab0[x];
            if (lab <= 0) {
                pOrient[x] = -1.0f;
                pLike[x] = 0.0f;
                continue;
            }

            // get a "monotonic" curve in a point list form
            CvRect roi = { x, y, wnd_size, wnd_size };
            CvPoint pt_start = {x+wnd_rad, y+wnd_rad};      // considering padding
            int point_num, start_idx;
            if (!getMonoEdgePointList(iplLabPad, roi, lab, pt_start, pMark, pPoints, point_num, start_idx)) continue;
          

            // Check the number of pixels in the window.
            // If the pixel number is too large, it is not a simple line or curve.
            // In this case, the template matching for direction detection is meaningless
            if (point_num < 3 || point_num > pix_in_line_th) {
                pOrient[x] = -1.0f;
                pLike[x] = 0.0f;
                continue;
            }

            int sxx = 0, syy = 0, sxy = 0;
            int x_mean = 0, y_mean = 0;
            for (int i=0; i<point_num; i++) {
                int xi = pPoints[i].x;
                int yi = pPoints[i].y;
                sxx += xi * xi;
                syy += yi * yi;
                sxy += xi * yi;
                x_mean += xi;
                y_mean += yi;
            }
            float ssxx = (float)sxx - (float)x_mean * (float)x_mean / (float)point_num;
            float ssyy = (float)syy - (float)y_mean * (float)y_mean / (float)point_num;
            float ssxy = (float)sxy - (float)x_mean * (float)y_mean / (float)point_num;
            float sigma_x = ssxx / (float)point_num;
            float sigma_y = ssyy / (float)point_num;
            float cov_xy = ssxy / (float)point_num;


            float likelihood, angle;
            if (sigma_x < eps) {
                angle = PI * 0.5f;
                likelihood = 1.0f;      // vertical lines
            } else if (sigma_y < eps) {
                angle = 0.0f;
                likelihood = 1.0f;      // horizontal lines
            } else {
                angle = atan2 (cov_xy,sigma_x);
                angle = angle < 0.0f ? angle + PI : angle;
                likelihood = cov_xy * cov_xy / (sigma_x * sigma_y);
            }

            if (likelihood > fit_th) {
                pOrient[x] = angle * 180.0f / PI; 
                pLike[x] = likelihood;
            } else {
                pOrient[x] = -1.0f;     // < 0.0 for "empty"
                pLike[x] = 0.0f;
            }

        } // for x
    } // for y

	safeReleaseImage(&iplLabPad);

    return true;
}

bool CImageUtility::smoothEdgeOrient(IplImage *iplDirMap, IplImage *iplDstMap, IplImage *iplLabel, 
                                     int wnd_rad, float sigma)
// Smooth the edge orientation map.
// This function supports "in-place" operation.
// Arguments:
//      iplDirMap -- [I] Input orientation map, where each pixel is an angle ranging [0, 180).
//                       0 represents the horizontal line and 90 represents the veritical line. 
//                       Some examples are:
//                          0        45        90        135     
//                         ___       \         |           /   
//                                    \        |          /
//                       This map may be obtianed by function getEdgeOrient();
//      DstMap -- [O] resultant edge direction map.
//      iplLabel -- [I] 32S label image (for example, created by function markEdges_32f()), 
//                      where the label is 1 ~ edge_num (when edge_num > 0)
//      wnd_rad -- [I] window radius of the smooth filter
//      sigma -- [I] sigma of the Gaussian filter
// by Luhong Liang
// March 9, 2015
{
    const int max_wnd_size = 21;
    const int pix_num_vs_width = 2;     // maximum pixel number of an "valid" line/curve vs. window size

    //const float eps = 1e-5f;
    //const float fit_th = 0.1f;

    if (iplLabel == NULL || iplLabel->nChannels != 1 || iplLabel->depth != SR_DEPTH_32S ||
        iplDstMap == NULL || iplDstMap->nChannels != 1 || iplDstMap->depth != SR_DEPTH_32F ||
        iplDirMap == NULL || iplDirMap->nChannels != 1 || iplDirMap->depth != SR_DEPTH_32F ||
        iplLabel->width != iplDstMap->width || iplLabel->height != iplDstMap->height ||
        iplLabel->width != iplDirMap->width || iplLabel->height != iplDirMap->height) {
        showErrMsg("Invalid input image(s) and/or argument(s) in CImageUtility::smoothEdgeOrient()!\n");
        return false;
    }
    
    int wnd_size = wnd_rad * 2 + 1;
    if (wnd_size > max_wnd_size || wnd_rad < 2)  {
        showErrMsg("Invalid window radius (must be 2~10) in CImageUtility::smoothEdgeOrient()!\n");
        return false;
    }

	// prepare spatial fitler, TODO: can reduce the table to almost 1/4!
	float *pGs = new float[wnd_size * wnd_size];
	if (pGs == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::smoothEdgeOrient()!\n");
		return false;
	}
	float fDiv = 1.0f /( 2.0f * sigma * sigma);
	int nGsIdx = 0;
	for (int y=-wnd_rad; y<=wnd_rad; y++) {
		for (int x=-wnd_rad; x<=wnd_rad; x++) {
			float value = (float)exp(-(x*x + y*y) * fDiv);
            value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
            pGs[nGsIdx] = value;
			nGsIdx ++;
		}
	}

    IplImage *iplLabPad = CImageUtility::padding_0_0(iplLabel, wnd_rad, wnd_rad, wnd_rad, wnd_rad);
    IplImage *iplDirPad = CImageUtility::padding_0_0(iplDirMap, wnd_rad, wnd_rad, wnd_rad, wnd_rad);
    if (iplLabPad == NULL || iplDirMap == NULL) {
        showErrMsg("Fail to allocate image buffer in CImageUtility::smoothEdgeOrient()!\n");
        safeReleaseImage(&iplLabPad, &iplDirPad);
        if (pGs != NULL) delete [] pGs;
        return false;
    }

    unsigned char pMark[max_wnd_size * max_wnd_size];
    CvPoint pPoints[max_wnd_size * max_wnd_size * 2];
    int pix_in_line_th = wnd_size * pix_num_vs_width;
    //int win_center_idx = (wnd_size * wnd_size) / 2;
    for (int y=0; y<iplDstMap->height; y++) {
        float *pDir0 = (float *)(iplDirMap->imageData + y * iplDirMap->widthStep);
        //float *pDir = (float *)(iplDirPad->imageData + y * iplDirPad->widthStep);
        int *pLab0 = (int *)(iplLabel->imageData + y * iplLabel->widthStep);
        //int *pLab = (int *)(iplLabPad->imageData + y * iplLabPad->widthStep);
        float *pDst = (float *)(iplDstMap->imageData + y * iplDstMap->widthStep);
        for (int x=0; x<iplDstMap->width; x++) {
            //if (x==1202 && y==375)
            //    int p = 1;
            int lab0 = pLab0[x];        // do not check direction map here
            if (lab0 < 1) {             // if a labeled pixel does not have direction, try to "fill" it in smoothing
                pDst[x] = -1.0f;
                continue;
            }

            // get a "monotonic" curve in a point list form
            CvRect roi = { x, y, wnd_size, wnd_size };
            CvPoint pt_start = {x+wnd_rad, y+wnd_rad};      // considering padding
            int point_num, start_idx;
            if (!getMonoEdgePointList(iplLabPad, roi, lab0, pt_start, pMark, pPoints, point_num, start_idx)) continue;

            // Check the number of pixels in the window.
            // If the pixel number is too large, it is not a simple line or curve.
            // In this case, the template matching for direction detection is meaningless
            if (point_num < 3 || point_num > pix_in_line_th) {
                pDst[x] = -1.0f;
                continue;
            }

            // check the "start point"
            float dir0 = pDir0[x];
            if (dir0 < 0.0f) {
                // check "previous" and "next" point
                bool not_hit = false;
                int xx, yy;
                float angle;
                if (start_idx > 1) {
                    xx = pPoints[start_idx-1].x;
                    yy = pPoints[start_idx-1].y;
                    angle = *((float *)(iplDirPad->imageData + (yy+roi.y) * iplDirPad->widthStep) + roi.x + xx);
                    if (angle < 0.0f) {
                        not_hit = true;
                    }
                }
                if (start_idx < point_num - 1) {
                    xx = pPoints[start_idx+1].x;
                    yy = pPoints[start_idx+1].y;
                    angle = *((float *)(iplDirPad->imageData + (yy+roi.y) * iplDirPad->widthStep) + roi.x + xx);
                    if (angle < 0.0f) {
                        not_hit = true;
                    }
                }
                if (not_hit) {
                    pDst[x] = -1.0f;   // if the "previous" or "next" point does not have direction, this point doesn't either
                    continue;
                }
            }

            // smoothing
            int smth_pt_num = 0;
            float apx = 0, apy = 0;
            for (int i=0; i<point_num; i++) {
                int xx = pPoints[i].x;
                int yy = pPoints[i].y;
                float angle = *((float *)(iplDirPad->imageData + (yy+roi.y) * iplDirPad->widthStep) + roi.x + xx);
                if (angle >= 0.0f) {
                    float px = cos(angle*PI/180.0f);
                    float py = sin(angle*PI/180.0f);
                    int idx = wnd_size * yy + xx;
                    float w = pGs[idx];
                    apx += px * w;
                    apy += py * w;
                    smth_pt_num ++;
                }
            }
            if (smth_pt_num < 3) {
                pDst[x] = -1.0f;
                continue;
            }
            apx = apx / smth_pt_num;
            apy = apy / smth_pt_num;
            float angle_smth = atan2 (apy, apx);
            angle_smth = angle_smth < 0.0f ? angle_smth + PI : angle_smth;
            pDst[x] = angle_smth * 180.0f / PI;
        }  // for x
    } // for y
    
    safeReleaseImage(&iplLabPad, &iplDirPad);
    if (pGs != NULL) delete [] pGs;

    return true;
}

bool CImageUtility::dilateMax15x15_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// dilate the grayscale image using a 15x15 maximum kernel
{
    if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
        iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height) {
        showErrMsg("Invalid argument in CImageUtility::dilateMax15x15_32f()!\n");
        return false;
    }

    // padding zeros
    IplImage *iplPadded = padding_0_0(iplSrcImage, 7, 7, 7, 7);
    if (iplPadded == NULL) return false;
    float *pLine = new float[iplPadded->width];
    if (pLine == NULL) {
        showErrMsg("Fail to allocate buffer in CImageUtility::dilateMax15x15_32f()!\n");
        safeReleaseImage(&iplPadded);
        return false;
    }

    // filtering
    for (int y=0; y<iplDstImage->height; y++) {
        float *pSrc0 = (float *)((char *)iplPadded->imageData + y * iplPadded->widthStep);
        float *pSrc1 = (float *)((char *)iplPadded->imageData + (y+1) * iplPadded->widthStep);
        float *pSrc2 = (float *)((char *)iplPadded->imageData + (y+2) * iplPadded->widthStep);
        float *pSrc3 = (float *)((char *)iplPadded->imageData + (y+3) * iplPadded->widthStep);
        float *pSrc4 = (float *)((char *)iplPadded->imageData + (y+4) * iplPadded->widthStep);
        float *pSrc5 = (float *)((char *)iplPadded->imageData + (y+5) * iplPadded->widthStep);
        float *pSrc6 = (float *)((char *)iplPadded->imageData + (y+6) * iplPadded->widthStep);
        float *pSrc7 = (float *)((char *)iplPadded->imageData + (y+7) * iplPadded->widthStep);
        float *pSrc8 = (float *)((char *)iplPadded->imageData + (y+8) * iplPadded->widthStep);
        float *pSrc9 = (float *)((char *)iplPadded->imageData + (y+9) * iplPadded->widthStep);
        float *pSrc10 = (float *)((char *)iplPadded->imageData + (y+10) * iplPadded->widthStep);
        float *pSrc11 = (float *)((char *)iplPadded->imageData + (y+11) * iplPadded->widthStep);
        float *pSrc12 = (float *)((char *)iplPadded->imageData + (y+12) * iplPadded->widthStep);
        float *pSrc13 = (float *)((char *)iplPadded->imageData + (y+13) * iplPadded->widthStep);
        float *pSrc14 = (float *)((char *)iplPadded->imageData + (y+14) * iplPadded->widthStep);
        float *pDst = (float *)((char *)iplDstImage->imageData + y * iplDstImage->widthStep);
        // filtering in Y direction
        for (int x=0; x<iplPadded->width; x++) {
            float max_val = pSrc0[x];
            max_val = pSrc1[x] > max_val ? pSrc1[x] : max_val;
            max_val = pSrc2[x] > max_val ? pSrc2[x] : max_val;
            max_val = pSrc3[x] > max_val ? pSrc3[x] : max_val;
            max_val = pSrc4[x] > max_val ? pSrc4[x] : max_val;
            max_val = pSrc5[x] > max_val ? pSrc5[x] : max_val;
            max_val = pSrc6[x] > max_val ? pSrc6[x] : max_val;
            max_val = pSrc7[x] > max_val ? pSrc7[x] : max_val;
            max_val = pSrc8[x] > max_val ? pSrc8[x] : max_val;
            max_val = pSrc9[x] > max_val ? pSrc9[x] : max_val;
            max_val = pSrc10[x] > max_val ? pSrc10[x] : max_val;
            max_val = pSrc11[x] > max_val ? pSrc11[x] : max_val;
            max_val = pSrc12[x] > max_val ? pSrc12[x] : max_val;
            max_val = pSrc13[x] > max_val ? pSrc13[x] : max_val;
            max_val = pSrc14[x] > max_val ? pSrc14[x] : max_val;
            pLine[x] = max_val;
        }
        // filtering in X direction
        for (int x=0; x<iplDstImage->width; x++) {
            float max_val = pLine[x];
            max_val = pLine[x+1] > max_val ? pLine[x+1] : max_val;
            max_val = pLine[x+2] > max_val ? pLine[x+2] : max_val;
            max_val = pLine[x+3] > max_val ? pLine[x+3] : max_val;
            max_val = pLine[x+4] > max_val ? pLine[x+4] : max_val;
            max_val = pLine[x+5] > max_val ? pLine[x+5] : max_val;
            max_val = pLine[x+6] > max_val ? pLine[x+6] : max_val;
            max_val = pLine[x+7] > max_val ? pLine[x+7] : max_val;
            max_val = pLine[x+8] > max_val ? pLine[x+8] : max_val;
            max_val = pLine[x+9] > max_val ? pLine[x+9] : max_val;
            max_val = pLine[x+10] > max_val ? pLine[x+10] : max_val;
            max_val = pLine[x+11] > max_val ? pLine[x+11] : max_val;
            max_val = pLine[x+12] > max_val ? pLine[x+12] : max_val;
            max_val = pLine[x+13] > max_val ? pLine[x+13] : max_val;
            max_val = pLine[x+14] > max_val ? pLine[x+14] : max_val;
            pDst[x] = max_val;
        }
    }

    delete [] pLine;
    safeReleaseImage(&iplPadded);

    return false;
}

bool CImageUtility::min3x3_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// 3x3 min filter
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::min3x3_32f()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::min3x3_32f()!\n");
		return false;
	}

    bool rlt = min3x3_o1_32f(iplPadded, iplDstImage);

    safeReleaseImage(&iplPadded);

    return rlt;
}

bool CImageUtility::min3x3_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// 3x3 min filter
// compared with min3x3_32f, this function suppose the input image has been padded 1 pixel in each direction
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width+2 || iplSrcImage->height != iplDstImage->height+2)  {
		showErrMsg("Invalid input argument in CImageUtility::min3x3_o1_32f()!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    return min3x3_o1_32f_SIMD(iplSrcImage, iplDstImage);
#endif      // #ifdef __SR_USE_SIMD

	// line buffer
	float *pLineBuf = new float[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::min3x3_o1_32f()!\n");
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		float *pSrc0 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		float *pSrc2 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
            float minv = pSrc0[x] < pSrc1[x] ? pSrc0[x] : pSrc1[x];
            minv = minv < pSrc2[x] ? minv : pSrc2[x];
			pLineBuf[x] = minv;
		}
		// convolution in X direction
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            float minv = pLineBuf[x] < pLineBuf[x+1] ? pLineBuf[x] : pLineBuf[x+1];
            minv = minv < pLineBuf[x+2] ? minv : pLineBuf[x+2];
			pDst[x] = minv;

		}
	}

	delete [] pLineBuf;

	return true;
}

bool CImageUtility::min3x3_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// 3x3 min filter
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U)  {
		showErrMsg("Invalid input argument in CImageUtility::min3x3_8U()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::min3x3_8U()!\n");
		return false;
	}

	// line buffer
	unsigned char *pLineBuf = new unsigned char[iplPadded->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::min3x3_8U()!\n");
		safeReleaseImage(&iplPadded);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		unsigned char *pSrc0 = (unsigned char *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		unsigned char *pSrc1 = (unsigned char *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		unsigned char *pSrc2 = (unsigned char *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
		for (int x=0; x<iplPadded->width; x++) {
            unsigned char minv = pSrc0[x] < pSrc1[x] ? pSrc0[x] : pSrc1[x];
            minv = minv < pSrc2[x] ? minv : pSrc2[x];
			pLineBuf[x] = minv;
		}
		// convolution in X direction
		unsigned char *pDst = (unsigned char *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            unsigned char minv = pLineBuf[x] < pLineBuf[x+1] ? pLineBuf[x] : pLineBuf[x+1];
            minv = minv < pLineBuf[x+2] ? minv : pLineBuf[x+2];
			pDst[x] = minv;
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplPadded);

	return true;
}

bool CImageUtility::min3x3_int(IplImage *iplSrcImage, IplImage *iplDstImage)
// 3x3 min filter
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::min3x3_int()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::min3x3_int()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplPadded->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::min3x3_int()!\n");
		safeReleaseImage(&iplPadded);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		int *pSrc1 = (int *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		int *pSrc2 = (int *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
		for (int x=0; x<iplPadded->width; x++) {
            int minv = pSrc0[x] < pSrc1[x] ? pSrc0[x] : pSrc1[x];
            minv = minv < pSrc2[x] ? minv : pSrc2[x];
			pLineBuf[x] = minv;
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            int minv = pLineBuf[x] < pLineBuf[x+1] ? pLineBuf[x] : pLineBuf[x+1];
            minv = minv < pLineBuf[x+2] ? minv : pLineBuf[x+2];
			pDst[x] = minv;

		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplPadded);

	return true;
}

bool CImageUtility::mean3x3_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// 3x3 mean filter
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::mean3x3_32f()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::mean3x3_32f()!\n");
		return false;
	}

	// line buffer
	float *pLineBuf = new float[iplPadded->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::mean3x3_32f()!\n");
		safeReleaseImage(&iplPadded);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		float *pSrc0 = (float *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		float *pSrc1 = (float *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		float *pSrc2 = (float *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
		for (int x=0; x<iplPadded->width; x++) {
			pLineBuf[x] = (pSrc0[x] + pSrc1[x] + pSrc2[x]) / 3.0f;
		}
		// convolution in X direction
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x] + pLineBuf[x+1] + pLineBuf[x+2]) / 3.0f;

		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplPadded);

	return true;
}

bool CImageUtility::max3x3_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// 3x3 max filter
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::max3x3_32f()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::max3x3_32f()!\n");
		return false;
	}

    bool rlt = max3x3_o1_32f(iplPadded, iplDstImage);

	safeReleaseImage(&iplPadded);

	return rlt;
}

bool CImageUtility::max3x3_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// 3x3 max filter
// different from max3x3_32f, this function supposes the input image has been padded 1 pixel in each direction
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width+2 || iplSrcImage->height != iplDstImage->height+2)  {
		showErrMsg("Invalid input argument in CImageUtility::max3x3_o1_32f()!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    return max3x3_o1_32f_SIMD(iplSrcImage, iplDstImage);
#endif      // #ifdef __SR_USE_SIMD

	// line buffer
	float *pLineBuf = new float[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::max3x3_32f()!\n");
		return false;
	}
	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		float *pSrc0 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		float *pSrc2 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
            float maxv = pSrc0[x] > pSrc1[x] ? pSrc0[x] : pSrc1[x];
            maxv = maxv > pSrc2[x] ? maxv : pSrc2[x];
			pLineBuf[x] = maxv;//max(max(max(pSrc0[x], pSrc1[x]), max(pSrc2[x], pSrc3[x])), pSrc4[x]);
		}
		// convolution in X direction
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            float maxv = pLineBuf[x] > pLineBuf[x+1] ? pLineBuf[x] : pLineBuf[x+1];
            maxv = maxv > pLineBuf[x+2] ? maxv : pLineBuf[x+2];
			pDst[x] = maxv; //max(max(max(pLineBuf[x], pLineBuf[x+1]), max(pLineBuf[x+2], pLineBuf[x+3])), pLineBuf[x+4]);

		}
	}

	delete [] pLineBuf;

	return true;
}

bool CImageUtility::max3x3_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// 3x3 max filter
// Arguments:
//		iplSrcImage -- [I] input image; must be 8U, 1-channel image
//		iplDstImage -- [O] input image; must be 8U, 1-channel image; should be the same size as iplSrcImage
//		direction -- [I] direction: 0 -- horizontal (absolute value);  1 -- vertical (absolute value);  3 -- ABS (1-norm)
//	Luhong Liang, IC-ASD, ASTRI
//	Sept. 25, 2014
{
	if (iplSrcImage == NULL || iplDstImage == NULL || 
        iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U ||
        iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::max3x3_8U()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::max3x3_8U()!\n");
		return false;
	}

    // process
    bool rlt = max3x3_o1_8U(iplPadded, iplDstImage);
    safeReleaseImage(&iplPadded);

    return rlt;
}

bool CImageUtility::max3x3_o1_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// 3x3 max filter
//		iplSrcImage -- [I] input image; must be 8U, 1-channel image, has been padded 1 pixel in each direction
//		iplDstImage -- [O] input image; must be 8U, 1-channel image 
//		direction -- [I] direction: 0 -- horizontal (absolute value);  1 -- vertical (absolute value);  3 -- ABS (1-norm)
//	Luhong Liang, IC-ASD, ASTRI
//	Sept. 25, 2014
{
	if (iplSrcImage == NULL || iplDstImage == NULL || 
        iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U ||
        iplSrcImage->width != iplDstImage->width+2 || iplSrcImage->height != iplDstImage->height+2) {		// TODO: complete check needed
		showErrMsg("Invalid input/output image in CImageUtility::max3x3_o1_8U()!\n");
		return false;
	}

	// line buffer
	unsigned char *pLineBuf = new unsigned char[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::max3x3_o1_8U()!\n");
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		unsigned char *pSrc0 = (unsigned char *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		unsigned char *pSrc1 = (unsigned char *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		unsigned char *pSrc2 = (unsigned char *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
            unsigned char maxv = pSrc0[x] > pSrc1[x] ? pSrc0[x] : pSrc1[x];
            maxv = maxv > pSrc2[x] ? maxv : pSrc2[x];
			pLineBuf[x] = maxv;//max(max(max(pSrc0[x], pSrc1[x]), max(pSrc2[x], pSrc3[x])), pSrc4[x]);
		}
		// convolution in X direction
		unsigned char *pDst = (unsigned char *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            unsigned char maxv = pLineBuf[x] > pLineBuf[x+1] ? pLineBuf[x] : pLineBuf[x+1];
            maxv = maxv > pLineBuf[x+2] ? maxv : pLineBuf[x+2];
			pDst[x] = maxv; //max(max(max(pLineBuf[x], pLineBuf[x+1]), max(pLineBuf[x+2], pLineBuf[x+3])), pLineBuf[x+4]);

		}
	}

	delete [] pLineBuf;

	return true;
}

bool CImageUtility::max3x3_int(IplImage *iplSrcImage, IplImage *iplDstImage)
// 3x3 max filter
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::max3x3_int()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::max3x3_int()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplPadded->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::max3x3_int()!\n");
		safeReleaseImage(&iplPadded);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		int *pSrc1 = (int *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		int *pSrc2 = (int *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
		for (int x=0; x<iplPadded->width; x++) {
            int maxv = pSrc0[x] > pSrc1[x] ? pSrc0[x] : pSrc1[x];
            maxv = maxv > pSrc2[x] ? maxv : pSrc2[x];
			pLineBuf[x] = maxv;//max(max(max(pSrc0[x], pSrc1[x]), max(pSrc2[x], pSrc3[x])), pSrc4[x]);
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            int maxv = pLineBuf[x] > pLineBuf[x+1] ? pLineBuf[x] : pLineBuf[x+1];
            maxv = maxv > pLineBuf[x+2] ? maxv : pLineBuf[x+2];
			pDst[x] = maxv; //max(max(max(pLineBuf[x], pLineBuf[x+1]), max(pLineBuf[x+2], pLineBuf[x+3])), pLineBuf[x+4]);

		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplPadded);

	return true;
}

bool CImageUtility::max5x5_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// 5x5 max filter
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::max5x5_32f()!\n");
		return false;
	}

	// padding
	const int padded = 2;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::max5x5_32f()!\n");
		return false;
	}

	// line buffer
	float *pLineBuf = new float[iplPadded->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::max5x5_32f()!\n");
		safeReleaseImage(&iplPadded);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		float *pSrc0 = (float *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		float *pSrc1 = (float *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		float *pSrc2 = (float *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
		float *pSrc3 = (float *)((char*)iplPadded->imageData + (y+3) * iplPadded->widthStep);
		float *pSrc4 = (float *)((char*)iplPadded->imageData + (y+4) * iplPadded->widthStep);
		for (int x=0; x<iplPadded->width; x++) {
            float maxv = pSrc0[x] > pSrc1[x] ? pSrc0[x] : pSrc1[x];
            maxv = maxv > pSrc2[x] ? maxv : pSrc2[x];
            maxv = maxv > pSrc3[x] ? maxv : pSrc3[x];
            maxv = maxv > pSrc4[x] ? maxv : pSrc4[x];
			pLineBuf[x] = maxv;//max(max(max(pSrc0[x], pSrc1[x]), max(pSrc2[x], pSrc3[x])), pSrc4[x]);
		}
		// convolution in X direction
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            float maxv = pLineBuf[x] > pLineBuf[x+1] ? pLineBuf[x] : pLineBuf[x+1];
            maxv = maxv > pLineBuf[x+2] ? maxv : pLineBuf[x+2];
            maxv = maxv > pLineBuf[x+3] ? maxv : pLineBuf[x+3];
            maxv = maxv > pLineBuf[x+4] ? maxv : pLineBuf[x+4];
			pDst[x] = maxv; //max(max(max(pLineBuf[x], pLineBuf[x+1]), max(pLineBuf[x+2], pLineBuf[x+3])), pLineBuf[x+4]);
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplPadded);

	return true;
}

bool CImageUtility::min5x5_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// 5x5 min filter
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::min5x5_32f()!\n");
		return false;
	}

	// padding
	const int padded = 2;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::min5x5_32f()!\n");
		return false;
	}

	// line buffer
	float *pLineBuf = new float[iplPadded->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::min5x5_32f()!\n");
		safeReleaseImage(&iplPadded);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		float *pSrc0 = (float *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		float *pSrc1 = (float *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		float *pSrc2 = (float *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
		float *pSrc3 = (float *)((char*)iplPadded->imageData + (y+3) * iplPadded->widthStep);
		float *pSrc4 = (float *)((char*)iplPadded->imageData + (y+4) * iplPadded->widthStep);
		for (int x=0; x<iplPadded->width; x++) {
            float minv = pSrc0[x] < pSrc1[x] ? pSrc0[x] : pSrc1[x];
            minv = minv < pSrc2[x] ? minv : pSrc2[x];
            minv = minv < pSrc3[x] ? minv : pSrc3[x];
            minv = minv < pSrc4[x] ? minv : pSrc4[x];
			pLineBuf[x] = minv;//max(max(max(pSrc0[x], pSrc1[x]), max(pSrc2[x], pSrc3[x])), pSrc4[x]);
		}
		// convolution in X direction
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            float minv = pLineBuf[x] < pLineBuf[x+1] ? pLineBuf[x] : pLineBuf[x+1];
            minv = minv < pLineBuf[x+2] ? minv : pLineBuf[x+2];
            minv = minv < pLineBuf[x+3] ? minv : pLineBuf[x+3];
            minv = minv < pLineBuf[x+4] ? minv : pLineBuf[x+4];
			pDst[x] = minv; //max(max(max(pLineBuf[x], pLineBuf[x+1]), max(pLineBuf[x+2], pLineBuf[x+3])), pLineBuf[x+4]);
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplPadded);

	return true;
}

bool CImageUtility::maxbox3x3_8U(IplImage *iplSrcImage, IplImage *iplDstImage, int max_weight_quarters)
//mixture of 3x3 max filter and boxing filter
// max_weight_quarters:  1 -- 1/4 max, 3/4 boxing, etc.
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U ||
        max_weight_quarters < 0 || max_weight_quarters > 4)  {
		showErrMsg("Invalid input argument in CImageUtility::maxbox3x3_8U()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::maxbox3x3_8U()!\n");
		return false;
	}
    unsigned char pBlock[9];

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		unsigned char *pSrc0 = (unsigned char *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		unsigned char *pSrc1 = (unsigned char *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		unsigned char *pSrc2 = (unsigned char *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
		unsigned char *pDst = (unsigned char *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            // get data block
            pBlock[0] = pSrc0[x]; pBlock[1] = pSrc0[x+1]; pBlock[2] = pSrc0[x+2];
            pBlock[3] = pSrc1[x]; pBlock[4] = pSrc1[x+1]; pBlock[5] = pSrc1[x+2];
            pBlock[6] = pSrc2[x]; pBlock[7] = pSrc2[x+1]; pBlock[8] = pSrc2[x+2];
            // calculate the maximum and mean
            unsigned char maxv = pBlock[0];
            int meanv = pBlock[0];
            for (int i=1; i<9; i++) {
                if (pBlock[i] > maxv) {
                    maxv = pBlock[i];
                }
                meanv += pBlock[i];
            }
            // approximate mean
            meanv = meanv >> 3;
            // filtering
            int val = (max_weight_quarters * maxv + (4 - max_weight_quarters) * meanv) >> 2;
            val = val > maxv ? maxv : val;      // need clipping due to the approximation
            pDst[x] = (unsigned char)val;
		}
	}

	safeReleaseImage(&iplPadded);

	return true;
}

bool CImageUtility::maxbox3x3_int(IplImage *iplSrcImage, IplImage *iplDstImage, int max_weight_quarters)
//mixture of 3x3 max filter and boxing filter
// max_weight_quarters:  1 -- 1/4 max, 3/4 boxing, etc.
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S ||
        max_weight_quarters < 0 || max_weight_quarters > 4)  {
		showErrMsg("Invalid input argument in CImageUtility::maxbox3x3_int()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::maxbox3x3_int()!\n");
		return false;
	}
    int pBlock[9];

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		int *pSrc0 = (int *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		int *pSrc1 = (int *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		int *pSrc2 = (int *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            // get data block
            pBlock[0] = pSrc0[x]; pBlock[1] = pSrc0[x+1]; pBlock[2] = pSrc0[x+2];
            pBlock[3] = pSrc1[x]; pBlock[4] = pSrc1[x+1]; pBlock[5] = pSrc1[x+2];
            pBlock[6] = pSrc2[x]; pBlock[7] = pSrc2[x+1]; pBlock[8] = pSrc2[x+2];
            // calculate the maximum and mean
            int maxv = pBlock[0];
            int meanv = pBlock[0];
            for (int i=1; i<9; i++) {
                if (pBlock[i] > maxv) {
                    maxv = pBlock[i];
                }
                meanv += pBlock[i];
            }
            // approximate mean
            meanv = meanv >> 3;
            // filtering
            int val = (max_weight_quarters * maxv + (4 - max_weight_quarters) * meanv) >> 2;
            val = val > maxv ? maxv : val;      // need clipping due to the approximation
            pDst[x] = val;
		}
	}

	safeReleaseImage(&iplPadded);

	return true;
}

bool CImageUtility::contrast3x3(IplImage *iplSrcImage, IplImage *iplDstImage)
// calculate the local contrast, i.e. max-min, in 3x3 window
// by Luhong Liang
// July 28, 2014
// Nov. 4, 2014: added support on floating point images
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1)  {
		showErrMsg("Invalid input and/or output image(s) in CImageUtility::contrast3x3()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::contrast3x3()!\n");
		return false;
	}

    bool rlt = false;
    if (iplSrcImage->depth == SR_DEPTH_8U && iplDstImage->depth == SR_DEPTH_8U) {
        rlt = contrast3x3_o1_8U(iplPadded, iplDstImage);
    } else if (iplSrcImage->depth == SR_DEPTH_32F && iplDstImage->depth == SR_DEPTH_32F) {
        rlt = contrast3x3_o1_32f(iplPadded, iplDstImage);
    } else {
        showErrMsg("Unsupported input/output image data type in CImageUtility::contrast3x3()!\n");
		return false;
	}
    
    safeReleaseImage(&iplPadded);

	return rlt;
}

bool CImageUtility::contrast3x3_o1_8U(IplImage *iplSrcImage, IplImage *iplDstImage)
// calculate the local contrast, i.e. max-min, in 3x3 window
// Different to contrast3x3(), this function supposes the input image has been padded
// 1 pixel in each direction.// by Luhong Liang
// July 28, 2014
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || 
        iplSrcImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_8U ||
        iplSrcImage->width != iplDstImage->width + 2 ||
        iplSrcImage->height != iplDstImage->height + 2)  {
		showErrMsg("Invalid input argument in CImageUtility::contrast3x3_o1_8U()!\n");
		return false;
	}

	// line buffer
	unsigned char *pLineBuf = new unsigned char[iplSrcImage->width*2];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::contrast3x3_o1_8U()!\n");
		return false;
	}
    unsigned char *pMax = pLineBuf;
    unsigned char *pMin = pLineBuf + iplSrcImage->width;

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		unsigned char *pSrc0 = (unsigned char *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		unsigned char *pSrc1 = (unsigned char *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		unsigned char *pSrc2 = (unsigned char *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
            // max
            unsigned char maxv = pSrc0[x] > pSrc1[x] ? pSrc0[x] : pSrc1[x];
            maxv = maxv > pSrc2[x] ? maxv : pSrc2[x];
			pMax[x] = maxv;
            // min
            unsigned char minv = pSrc0[x] < pSrc1[x] ? pSrc0[x] : pSrc1[x];
            minv = minv < pSrc2[x] ? minv : pSrc2[x];
			pMin[x] = minv;
		}
		// convolution in X direction
		unsigned char *pDst = (unsigned char *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            // max
            unsigned char maxv = pMax[x] > pMax[x+1] ? pMax[x] : pMax[x+1];
            maxv = maxv > pMax[x+2] ? maxv : pMax[x+2];
            // min
            unsigned char minv = pMin[x] < pMin[x+1] ? pMin[x] : pMin[x+1];
            minv = minv < pMin[x+2] ? minv : pMin[x+2];
			pDst[x] = maxv - minv;
		}
	}

    delete [] pLineBuf;

	return true;
}

bool CImageUtility::contrast3x3_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// calculate the local contrast, i.e. max-min, in 3x3 window
// Different to contrast3x3(), this function supposes the input image has been padded
// 1 pixel in each direction.// by Luhong Liang
// Nov. 4, 2014
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || 
        iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width + 2 ||
        iplSrcImage->height != iplDstImage->height + 2)  {
		showErrMsg("Invalid input argument in CImageUtility::contrast3x3_o1_32f()!\n");
		return false;
	}

	// line buffer
	float *pLineBuf = new float[iplSrcImage->width*2];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::contrast3x3_o1_32f()!\n");
		return false;
	}
    float *pMax = pLineBuf;
    float *pMin = pLineBuf + iplSrcImage->width;

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		float *pSrc0 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		float *pSrc2 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
            // max
            float maxv = pSrc0[x] > pSrc1[x] ? pSrc0[x] : pSrc1[x];
            maxv = maxv > pSrc2[x] ? maxv : pSrc2[x];
			pMax[x] = maxv;
            // min
            float minv = pSrc0[x] < pSrc1[x] ? pSrc0[x] : pSrc1[x];
            minv = minv < pSrc2[x] ? minv : pSrc2[x];
			pMin[x] = minv;
		}
		// convolution in X direction
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            // max
            float maxv = pMax[x] > pMax[x+1] ? pMax[x] : pMax[x+1];
            maxv = maxv > pMax[x+2] ? maxv : pMax[x+2];
            // min
            float minv = pMin[x] < pMin[x+1] ? pMin[x] : pMin[x+1];
            minv = minv < pMin[x+2] ? minv : pMin[x+2];
			pDst[x] = maxv - minv;
		}
	}

    delete [] pLineBuf;

	return true;
}

bool CImageUtility::contrast5x5_32f(IplImage *iplSrcImage, IplImage *iplDstImage)
// calculate the local contrast, i.e. max-min, in 3x3 window
// by Luhong Liang
// Aug, 2014
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::contrast5x5_32f()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::contrast5x5_32f()!\n");
		return false;
	}

    bool rlt = contrast5x5_o1_32f(iplPadded, iplDstImage);

    safeReleaseImage(&iplPadded);

    return rlt;
}

bool CImageUtility::contrast5x5_o1_32f(IplImage *iplPadded, IplImage *iplDstImage)
// Calculate the local contrast, i.e. max-min, in 3x3 window
// Different to contrast5x5_32f(), this function supposes the input image has been padded
// 2 pixels in each direction.
// by Luhong Liang
// Aug, 2014
{
	if (iplPadded == NULL || iplDstImage == NULL ||
		iplPadded->nChannels != 1 || iplDstImage->nChannels != 1 || 
        iplPadded->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::contrast5x5_o1_32f()!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    return contrast5x5_o1_32f_SIMD(iplPadded, iplDstImage);
#endif      // #ifdef __SR_USE_SIMD

	// line buffer
	float *pLineBuf = new float[iplPadded->width*2];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::contrast5x5_o1_32f()!\n");
		return false;
	}
    float *pMax = pLineBuf;
    float *pMin = pLineBuf + iplPadded->width;

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		float *pSrc0 = (float *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		float *pSrc1 = (float *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		float *pSrc2 = (float *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
        float *pSrc3 = (float *)((char*)iplPadded->imageData + (y+3) * iplPadded->widthStep);
        float *pSrc4 = (float *)((char*)iplPadded->imageData + (y+4) * iplPadded->widthStep);
		for (int x=0; x<iplPadded->width; x++) {
            // max
            float maxv = pSrc0[x] > pSrc1[x] ? pSrc0[x] : pSrc1[x];
            maxv = maxv > pSrc2[x] ? maxv : pSrc2[x];
            maxv = maxv > pSrc3[x] ? maxv : pSrc3[x];
            maxv = maxv > pSrc4[x] ? maxv : pSrc4[x];
			pMax[x] = maxv;
            // min
            float minv = pSrc0[x] < pSrc1[x] ? pSrc0[x] : pSrc1[x];
            minv = minv < pSrc2[x] ? minv : pSrc2[x];
            minv = minv < pSrc3[x] ? minv : pSrc3[x];
            minv = minv < pSrc4[x] ? minv : pSrc4[x];
			pMin[x] = minv;
		}
		// convolution in X direction
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            // max
            float maxv = pMax[x] > pMax[x+1] ? pMax[x] : pMax[x+1];
            maxv = maxv > pMax[x+2] ? maxv : pMax[x+2];
            maxv = maxv > pMax[x+3] ? maxv : pMax[x+3];
            maxv = maxv > pMax[x+4] ? maxv : pMax[x+4];
            // min
            float minv = pMin[x] < pMin[x+1] ? pMin[x] : pMin[x+1];
            minv = minv < pMin[x+2] ? minv : pMin[x+2];
            minv = minv < pMin[x+3] ? minv : pMin[x+3];
            minv = minv < pMin[x+4] ? minv : pMin[x+4];
			pDst[x] = maxv - minv;
		}
	}

    delete [] pLineBuf;

	return true;
}

IplImage *CImageUtility::detIsoBulb5x5_32f(IplImage *iplSrcImage, bool normalize)
// Detect isolated bulb in a 5x5 window
// The filter is 
//   -1 -1 -1 -1 -1
//   -1 -1 -1 -1 -1
//   -1 -1 24 -1 -1 / factor
//   -1 -1 -1 -1 -1
//   -1 -1 -1 -1 -1
// When 'normalize' is true, factor = 24; otherwise factor = 1.
{
	if (iplSrcImage == NULL || iplSrcImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image in detIsoBulb5x5_32f()!\n");
		return NULL;
	}

	IplImage *iplDstImage = createImage(iplSrcImage->width, iplSrcImage->height, SR_DEPTH_32F, 1);
	if (iplDstImage == NULL) {
		showErrMsg("Fail to allcoate result image in detIsoBulb5x5_32f()!\n");
		return NULL;
	}

    if (!detIsoBulb5x5_32f(iplSrcImage, iplDstImage, normalize)) return NULL;

    return iplDstImage;
}

bool CImageUtility::detIsoBulb5x5_32f(IplImage *iplSrcImage, IplImage *iplDstImage, bool normalize)
// Detect isolated bulb in a 5x5 window
// The filter is 
//   -1 -1 -1 -1 -1
//   -1 -1 -1 -1 -1
//   -1 -1 24 -1 -1 / factor
//   -1 -1 -1 -1 -1
//   -1 -1 -1 -1 -1
// When 'normalize' is true, factor = 24; otherwise factor = 1.
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F)  {
		showErrMsg("Invalid input argument in CImageUtility::detIsoBulb5x5_32f()!\n");
		return false;
	}

	// padding
	const int padded = 2;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::detIsoBulb5x5_32f()!\n");
		return false;
	}

	// line buffer
	float *pLineBuf = new float[iplPadded->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::detIsoBulb5x5_32f()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		float *pSrc0 = (float *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		float *pSrc1 = (float *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		float *pSrc2 = (float *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
		float *pSrc3 = (float *)((char*)iplPadded->imageData + (y+3) * iplPadded->widthStep);
		float *pSrc4 = (float *)((char*)iplPadded->imageData + (y+4) * iplPadded->widthStep);
		for (int x=0; x<iplPadded->width; x++) {
			pLineBuf[x] = pSrc0[x] + pSrc1[x] + pSrc2[x] + pSrc3[x] + pSrc4[x];
		}
		// convolution in X direction
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        if (normalize) {
		    for (int x=0; x<iplDstImage->width; x++) {
			    float rlt = pLineBuf[x] + pLineBuf[x+1] + pLineBuf[x+2] + pLineBuf[x+3] + pLineBuf[x+4] - 25 * pSrc2[x+2];
                pDst[x] = (rlt > 0.0f ? rlt : -rlt) / 24;
		    }
        } else {
		    for (int x=0; x<iplDstImage->width; x++) {
			    float rlt = pLineBuf[x] + pLineBuf[x+1] + pLineBuf[x+2] + pLineBuf[x+3] + pLineBuf[x+4] - 25 * pSrc2[x+2];
                pDst[x] = rlt > 0.0f ? rlt : -rlt;
		    }
        }
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplPadded);

	return true;
}

IplImage *CImageUtility::detIsoBulb5x5_o1_32f(IplImage *iplSrcImage, IplImage *iplLocVar)
// Detect isolated bulb in a 5x5 window (faster implementation)
// The filter is 
//   -1 -1 -1 -1 -1
//   -1 -1 -1 -1 -1
//   -1 -1 24 -1 -1 / factor
//   -1 -1 -1 -1 -1
//   -1 -1 -1 -1 -1
// When 'normalize' is true, factor = 24; otherwise factor = 1.
// Compared with detIsoBulb5x5_32f(), this function:
//  (1) integrated the normalization by local variance into the function
// (2) remove the original normalization
{
	if (iplSrcImage == NULL || iplLocVar == NULL ||
		iplSrcImage->nChannels != 1 || iplLocVar->nChannels != 1 || 
        iplSrcImage->depth != SR_DEPTH_32F || iplLocVar->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplLocVar->width || iplSrcImage->height != iplLocVar->height)  {
		showErrMsg("Invalid input argument in CImageUtility::detIsoBulb5x5_o1_32f()!\n");
		return false;
	}

	IplImage *iplDstImage = createImage(iplSrcImage->width, iplSrcImage->height, SR_DEPTH_32F, 1);
	if (iplDstImage == NULL) {
		showErrMsg("Fail to allcoate result image in detIsoBulb5x5_32f()!\n");
		return NULL;
	}

    if (!detIsoBulb5x5_o1_32f(iplSrcImage, iplDstImage, iplLocVar)) return NULL;

    return iplDstImage;
}

bool CImageUtility::detIsoBulb5x5_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage, IplImage *iplLocVar)
// Detect isolated bulb in a 5x5 window (faster implementation)
// The filter is 
//   -1 -1 -1 -1 -1
//   -1 -1 -1 -1 -1
//   -1 -1 24 -1 -1 / factor
//   -1 -1 -1 -1 -1
//   -1 -1 -1 -1 -1
// When 'normalize' is true, factor = 24; otherwise factor = 1.
// Compared with detIsoBulb5x5_32f(), this function:
//  (1) integrated the normalization by local variance into the function
//  (2) remove the original normalization
{
	if (iplSrcImage == NULL || iplLocVar == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplLocVar->nChannels != 1 || iplDstImage->nChannels != 1 || 
        iplSrcImage->depth != SR_DEPTH_32F || iplLocVar->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplLocVar->width || iplSrcImage->height != iplLocVar->height ||
        iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height)  {
		showErrMsg("Invalid input argument in CImageUtility::detIsoBulb5x5_o1_32f()!\n");
		return false;
	}

	// padding
	const int padded = 2;
	IplImage *iplPadded = padding(iplSrcImage, padded, padded, padded, padded);
	if (iplPadded == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::detIsoBulb5x5_32f()!\n");
		return false;
	}

	// line buffer
	float *pLineBuf = new float[iplPadded->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::detIsoBulb5x5_32f()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

    const float bulb_th = 64.0f;

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
        // external local variance map
        float *pVar = (float *)(iplLocVar->imageData + y * iplLocVar->widthStep);
		// convolution in Y direction
		float *pSrc0 = (float *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
		float *pSrc1 = (float *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
		float *pSrc2 = (float *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
		float *pSrc3 = (float *)((char*)iplPadded->imageData + (y+3) * iplPadded->widthStep);
		float *pSrc4 = (float *)((char*)iplPadded->imageData + (y+4) * iplPadded->widthStep);
		for (int x=0; x<iplPadded->width; x++) {
			pLineBuf[x] = pSrc0[x] + pSrc1[x] + pSrc2[x] + pSrc3[x] + pSrc4[x];
		}
		// convolution in X direction
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        for (int x=0; x<iplDstImage->width; x++) {
            float bulb = pLineBuf[x] + pLineBuf[x+1] + pLineBuf[x+2] + pLineBuf[x+3] + pLineBuf[x+4] - 25 * pSrc2[x+2];
            float var = pVar[x];
            bulb = var <= 0.0f ? 0.0f : bulb/var;
            bulb = bulb > 0.0f ? bulb : -bulb;
            pDst[x] = bulb > bulb_th ? 1.0f : 0.0f;
        }
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplPadded);

	return true;
}

bool CImageUtility::calcMeanDev(IplImage *iplImage, float &mean, float &dev, int bit_depth)
// Calculate the mean and the sample standard deviation
// NOTE: The bit_depth is used to normalize the integer pixel intensitive to 0~255, when
//       the input image format is 32S. Must be 8~32
{
	if (iplImage == NULL || iplImage->nChannels != 1 || iplImage->width * iplImage->height < 2 || bit_depth < 8 || bit_depth > 32) {
		showErrMsg("Invalid input image in CImageUtility::calcMeanDev()!\n");
		return false;
	}

	mean = 0.0f;
	dev = 0.0f;
	int N = iplImage->width * iplImage->height;
	if (iplImage->depth == SR_DEPTH_32F) {
		// calculate mean
		for (int y=0; y<iplImage->height; y++) {
			float *pSrc = (float *)((char*)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0; x<iplImage->width; x++) {
				mean += pSrc[x];
			}
		}
		mean = mean / N;
		// calculate deviation
		for (int y=0; y<iplImage->height; y++) {
			float *pSrc = (float *)((char*)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0; x<iplImage->width; x++) {
				float diff = pSrc[x] - mean;
				dev += diff * diff;
			}
		}
		dev = sqrt( dev / (N-1) );
	} else 	if (iplImage->depth == SR_DEPTH_32S) {
		// calculate mean
		int factor = 1;
		factor = factor << (bit_depth - 8);
		for (int y=0; y<iplImage->height; y++) {
			int *pSrc = (int *)((char*)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0; x<iplImage->width; x++) {
				int val = pSrc[x];
				mean += (float)val / (float)factor;
			}
		}
		mean = mean / N;
		// calculate deviation
		for (int y=0; y<iplImage->height; y++) {
			int *pSrc = (int *)((char*)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0; x<iplImage->width; x++) {
				int val = pSrc[x];
				float diff = (float)val / (float)factor - mean;
				dev += diff * diff;
			}
		}
		dev = sqrt( dev / (N-1) );
	} else if (iplImage->depth == SR_DEPTH_8U) {
		// calculate mean
		for (int y=0; y<iplImage->height; y++) {
			unsigned char *pSrc = (unsigned char *)((char*)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0; x<iplImage->width; x++) {
				mean += pSrc[x];
			}
		}
		mean = mean / N;
		// calculate deviation
		for (int y=0; y<iplImage->height; y++) {
			unsigned char *pSrc = (unsigned char *)((char*)iplImage->imageData + y * iplImage->widthStep);
			for (int x=0; x<iplImage->width; x++) {
				float diff = pSrc[x] - mean;
				dev += diff * diff;
			}
		}
		dev = sqrt( dev / (N-1) );
	} else {
		showErrMsg("Unsupported image data type in CImageUtility::calcMeanDev()!\n");
		return false;
	}

	return true;
}

float CImageUtility::rms(IplImage *iplImage1, IplImage *iplImage2)
// cacluate the RMS between two images
{
	if (iplImage1 == NULL || iplImage1->nChannels != 1 || iplImage1->width * iplImage1->height < 2 || iplImage1->depth != iplImage2->depth ||
		iplImage2 == NULL || iplImage2->nChannels != 1 || iplImage1->width != iplImage2->width || iplImage1->height != iplImage2->height) {
		showErrMsg("Invalid input image in CImageUtility::rms()!\n");
		return -1.0f;
	}

	float rms = 0.0f;
	int N = iplImage1->width * iplImage1->height;
	if (iplImage1->depth == SR_DEPTH_32F) {
		// calculate mean
		for (int y=0; y<iplImage1->height; y++) {
			float *pSrc1 = (float *)((char*)iplImage1->imageData + y * iplImage1->widthStep);
			float *pSrc2 = (float *)((char*)iplImage2->imageData + y * iplImage2->widthStep);
			for (int x=0; x<iplImage1->width; x++) {
				float diff = pSrc1[x] - pSrc2[x];
				rms += diff * diff;
			}
		}
		rms = sqrt( rms / N );
	} else if (iplImage1->depth == SR_DEPTH_8U) {
		// calculate mean
		for (int y=0; y<iplImage1->height; y++) {
			unsigned char *pSrc1 = (unsigned char *)((char*)iplImage1->imageData + y * iplImage1->widthStep);
			unsigned char *pSrc2 = (unsigned char *)((char*)iplImage2->imageData + y * iplImage2->widthStep);
			for (int x=0; x<iplImage1->width; x++) {
				float diff = (float)pSrc1[x] - pSrc2[x];
				rms += diff * diff;
			}
		}
		rms = sqrt( rms / N );
	} else {
		showErrMsg("Unsupported image data type in CImageUtility::rms()!\n");
		return -1.0f;
	}

	return rms;
}

bool CImageUtility::filter2D_32f(IplImage *iplImage, IplImage *iplDstImage, float pFilter[], int wnd_width, int wnd_height, float factor)
// 2D filter
// This function supports the "in-place" operation (source and destination images are the same one)
// Argument:
//  iplImage -- [I] source image
//  iplDstImage -- [0] result image, must be the same type, size and channel number as the source image
//  pFilter -- [I] array of (wnd_width x wnd_height) to store the filter kernel matrix
//  wnd_width, wnd_height -- [I] size of the filter
//  factor -- [I] magnification factor of the result, i.e. result = srcImage * filter .* factor
// by Luhong Liang, ICD-ASD, ASTRI
// Jul. 5, 2013
{
	if (iplImage == NULL || iplDstImage == NULL ||          // TODO: complete check 
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1)  {
		showErrMsg("Invalid input argument in CImageUtility::filter2D_32f()!\n");
		return false;
	}

	// padding
	int pad_left = wnd_width / 2;
    int pad_right = wnd_width - pad_left - 1;
	int pad_top = wnd_height / 2;
    int pad_bottom = wnd_height - pad_top - 1;
	IplImage *iplSrcImage = padding(iplImage, pad_left, pad_right, pad_top, pad_bottom);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::filter2D_32f()!\n");
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			float val = 0;
			for (int yy=0; yy<wnd_height; yy++) {
				float *pF = pFilter + yy * wnd_width;
				float *pSrc = (float *)((char*)iplSrcImage->imageData + (y+yy) * iplSrcImage->widthStep) + x;
				for (int xx=0; xx<wnd_width; xx++) {
					val += pSrc[xx] * pF[xx];
				}
			}
			pDst[x] = val * factor;
		}
	}

	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::gaussian1_32f(IplImage *iplImage, IplImage *iplDstImage, int wnd_size, float sigma)
// Gaussian filter
// This function supports the "in-place" operation (source and destination images are the same one)
// This function does not use the decomposition algorithm and ignore the boundary effects
{
	if (iplImage == NULL || iplDstImage == NULL || wnd_size < 1 || sigma < 0)  {	// TODO: complete check here
		showErrMsg("Invalid input argument in CImageUtility::gaussian1_32f()!\n");
		return false;
	}

	// make filter
	float *pFilter = new float[wnd_size * wnd_size];
	if (pFilter == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian1_32f()!\n");
		return false;
	}
	int center = wnd_size >> 1;
	float div = 0.0f;
	float div_sigma_sq2 = 0.5f / (sigma * sigma);
	for (int y=0; y<wnd_size; y++) {
		float diff_y = (float)(y - center);
		diff_y = diff_y * diff_y;
		for (int x=0; x<wnd_size; x++) {
			int index = y * wnd_size + x;
			float diff_x = (float)(x - center);
			diff_x = diff_x * diff_x;
			float exp_num = - (diff_x + diff_y) * div_sigma_sq2;
			float value = exp(exp_num);
            value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
			pFilter[index] = value;
			div += value;
		}
	}
	for (int i=0; i<wnd_size*wnd_size; i++) {
		pFilter[i] = pFilter[i] / div;
	}

	// padding
	int wnd_radius = wnd_size >> 1;
	IplImage *iplSrcImage = padding(iplImage, wnd_radius, wnd_radius, wnd_radius, wnd_radius);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian1_32f()!\n");
		delete [] pFilter;
		return false;
	}

	// convolution
	float *pSrcImage = (float *)((char*)iplSrcImage->imageData);
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			float val = 0.0f;
			for (int yy=0; yy<wnd_size; yy++) {
				float *pF = pFilter + yy * wnd_size;
				float *pSrc = pSrcImage + (y+yy) * (iplSrcImage->width) + x;
				for (int xx=0; xx<wnd_size; xx++) {
					val += pSrc[xx] * pF[xx];
				}
			}
			pDst[x] = val;
		}
	}

	delete [] pFilter;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::kernelEpsGaussian(int wnd_rad, float sigma, float lamda, float gx, float gy, float *pFilter)
// Create a Gaussian kernel with ellipse shape, where (gx, gy) denotes the NORMAL direction of the long axis
// Argument:
//      wnd_rad -- [I] window radius
//      sigma -- [I] sigma of the Gaussian filter
//      lamda -- [I] ratio of the long and short axies of the Gaussian filter
//      gx, gy -- [I] normal direction of the log axis
//      pFilter -- [O] result filter, 1D array of size of (2*wnd_rad+1)*(2*wnd_rad+1)
// by Luhong Liang
// May 19, 2014
{
    int filter_size = (2*wnd_rad + 1) * (2*wnd_rad + 1);
    if (pFilter == NULL || filter_size < 1) {
        showErrMsg("Invalid buffer for filter or window size in CImageUtility::kernelEpsGaussian()!\n");
        return false;
    }

    // return a implus filter for zero gradient
    float divg = sqrt(gx*gx + gy*gy);
    if (divg < 0.0001f) {
        for (int i=0; i<filter_size; i++) {
            pFilter[i] = 0.0f;
        }
        int center = filter_size / 2;
        pFilter[center] = 1.0f;
        return true;
    }

    // calculate filter
    gx = gx / divg;
    gy = - gy / divg;   
    float lamda_sq = lamda * lamda;
    float div = 2 * sigma * sigma; 
    float gxx = gx * gx;
    float gyy = gy * gy;
    float a = (gxx + lamda_sq * gyy) / div;
    float b = (gyy + lamda_sq * gxx) / div;
    float c = ( - 2 * gx * gy * (1 - lamda_sq)) / div;

    float sum_k = 0.0f;
    int i = 0;
    for (int y=-wnd_rad; y<=wnd_rad; y++) {
        for (int x=-wnd_rad; x<=wnd_rad; x++) {
            float val = exp( - (a * (float)x * (float)x + b * (float)y * (float)y + c * (float)x * (float)y) );
            pFilter[i] = val;
            sum_k += val;
            i++;
        }
    }

    for (int i=0; i<filter_size; i++) {
        pFilter[i] = pFilter[i] / sum_k;
    }

    return true;
}

bool CImageUtility::kernelDirStep(int wnd_rad, float alpha, float gx, float gy, float *pFilter)
// Create a directional step filter, where (gx, gy) denotes the NORMAL direction of the long axis
// Argument:
//      wnd_rad -- [I] window radius
//      alpha -- [I] strength of the step filter
//      gx, gy -- [I] normal direction of the log axis
//      pFilter -- [O] result filter, 1D array of size of (2*wnd_rad+1)*(2*wnd_rad+1)
// by Luhong Liang
// May 19, 2014
{
    int filter_size = (2*wnd_rad + 1) * (2*wnd_rad + 1);
    if (pFilter == NULL || filter_size < 1) {
        showErrMsg("Invalid buffer for filter or window size in CImageUtility::kernelDirStep()!\n");
        return false;
    }

    // return a implus filter for zero gradient
    float divg = sqrt(gx*gx + gy*gy);
    if (divg < 0.0001f) {
        for (int i=0; i<filter_size; i++) {
            pFilter[i] = 0.0f;
        }
        int center = filter_size / 2;
        pFilter[center] = 1.0f;
        return true;
    }

    // calculate step filter
    float sin_theta = gx / divg;
    float cos_theta = - gy / divg;

    int i = 0;
    for (int y=-wnd_rad; y<=wnd_rad; y++) {
        for (int x=-wnd_rad; x<=wnd_rad; x++) {
            float rot_x = (float)x * cos_theta + (float)y * sin_theta;
            pFilter[i] = 1 / ( 1 + exp(alpha * rot_x) );
            i++;
        }
    }

    return true;
}

bool CImageUtility::gaussian_32f(IplImage *iplImage, IplImage *iplDstImage, int wnd_size, float sigma)
// Gaussian filter
// This function supports the "in-place" operation (source and destination images are the same one)
// This function uses the decomposition algorithm and ignore the boundary effects
{
	if (iplImage == NULL || iplDstImage == NULL || wnd_size < 1 || sigma < 0)  {	// TODO: complete check here
		showErrMsg("Invalid input argument in CImageUtility::gaussian_32f()!\n");
		return false;
	}

	// make filter
	float *pFilter = new float[wnd_size];
	if (pFilter == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian_32f()!\n");
		return false;
	}
    int center = wnd_size >> 1;
	float div = 0.0f;
	float div_sigma_sq2 = 0.5f / (sigma * sigma);
	for (int i=0; i<wnd_size; i++) {
		float diff = (float)(i - center);
		float exp_num = - diff * diff * div_sigma_sq2;
		float value = exp(exp_num);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
		pFilter[i] = value;
		div += value;
	}
	for (int i=0; i<wnd_size; i++) {
		pFilter[i] = pFilter[i] / div;
	}

	// padding
	int wnd_radius = wnd_size >> 1;
	IplImage *iplSrcImage = padding(iplImage, wnd_radius, wnd_size-wnd_radius-1, wnd_radius, wnd_size-wnd_radius-1);
    IplImage *iplInter = createImage(iplImage->width+wnd_size-1, iplImage->height, SR_DEPTH_32F, 1);
	if (iplSrcImage == NULL || iplInter == NULL) {
        showErrMsg("Fail to allocate buffer in CImageUtility::gaussian_32f()!\n");
		delete [] pFilter;
        safeReleaseImage(&iplSrcImage, &iplInter);
		return false;
	}

    //saveImage("_Src.bmp", iplSrcImage);
	// convolution in Y direction
	for (int y=0; y<iplInter->height; y++) {
		float *pDst = (float *)((char*)iplInter->imageData + y * iplInter->widthStep);
		for (int x=0; x<iplInter->width; x++) {
			float val = 0.0f;
			for (int yy=0; yy<wnd_size; yy++) {
                float *pSrc = (float *)((char*)iplSrcImage->imageData + (y+yy) * iplSrcImage->widthStep) + x;
                val += pSrc[0] * pFilter[yy];
			}
			pDst[x] = val;
		}
	}

    //saveImage("_gaussianY.bmp", iplInter);

    // convolution in X direction
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pSrc = (float *)((char*)iplInter->imageData + y * iplInter->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			float val = 0.0f;
            float *pSrcCol = pSrc + x;
			for (int xx=0; xx<wnd_size; xx++) {
                val += pSrcCol[xx] * pFilter[xx];
			}
			pDst[x] = val;
		}
	}

	delete [] pFilter;
	safeReleaseImage(&iplSrcImage, &iplInter);

	return true;
}

bool CImageUtility::gaussian3x3_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float sigma)
// Gaussian filter
// This function supports the "in-place" operation (source and destination images are the same one)
// This function does not use the decomposition algorithm and ignore the boundary effects
{
	if (iplSrcImage == NULL || iplDstImage == NULL || sigma < 0)  {	// TODO: complete check here
		showErrMsg("Invalid input argument in CImageUtility::gaussian3x3_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplPadded = padding(iplSrcImage, 1, 1, 1, 1);
	if (iplSrcImage == NULL) {
        showErrMsg("Fail to allocate buffer in CImageUtility::gaussian3x3_32f()!\n");
		return false;
	}

    bool rlt = gaussian3x3_o1_32f(iplPadded, iplDstImage, sigma);

    safeReleaseImage(&iplPadded);
     
    return rlt;
}

bool CImageUtility::gaussian3x3_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float sigma)
// Gaussian filter
// This function supposes the input image has been padded 1 pixel in each direction
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image, has been padded 1 pixel in each direction
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image
// by Luhong Liang
// Aug, 2014
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width+2 || iplSrcImage->height != iplDstImage->height+2)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian3x3_o1_32f()!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    return gaussian3x3_o1_32f_SIMD(iplSrcImage, iplDstImage, sigma);
#endif      // #ifdef __SR_USE_SIMD

	// make filter
	float pFilter[3];
	float div = 0.0f;
	float div_sigma_sq2 = 0.5f / (sigma * sigma);
	for (int i=0; i<3; i++) {
		float diff = (float)(i - 1);
		float exp_num = - diff * diff * div_sigma_sq2;
		float value = exp(exp_num);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
		pFilter[i] = value;
		div += value;
	}
	for (int i=0; i<3; i++) {
		pFilter[i] = pFilter[i] / div;
	}
    float f0 = pFilter[0];
    float f1 = pFilter[1];
    float f2 = pFilter[2];

	// padding
    float *pLine = new float[iplSrcImage->width];
	if (pLine == NULL) {
        showErrMsg("Fail to allocate buffer in CImageUtility::gaussian3x3_o1_32f()!\n");
		return false;
	}
  
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pSrc0 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
        float *pSrc2 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
        // convolution in Y direction
		for (int x=0; x<iplSrcImage->width; x++) {
			pLine[x] = pSrc0[x] * f0 + pSrc1[x] * f1 + pSrc2[x] * f2;
		}
        // convolution in X direction
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = pLine[x] * f0 + pLine[x+1] * f1 + pLine[x+2] * f2;
		}
	}

	delete [] pLine;

	return true;
}

bool CImageUtility::gaussian5x5_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float sigma)
// Gaussian filter
// This function supports the "in-place" operation (source and destination images are the same one)
// This function does not use the decomposition algorithm and ignore the boundary effects
{
	if (iplSrcImage == NULL || iplDstImage == NULL || sigma < 0)  {	// TODO: complete check here
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplPadded = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcImage == NULL) {
        showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_32f()!\n");
		return false;
	}

    bool rlt = gaussian5x5_o1_32f(iplPadded, iplDstImage, sigma);

    safeReleaseImage(&iplPadded);
     
    return rlt;
}

bool CImageUtility::gaussian5x5_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float sigma)
// Gaussian filter
// This function supposes the input image has been padded 2 pixels in each direction
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image, has been padded 2 pixels in each direction
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image
// by Luhong Liang
// July 30, 2014
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width+4 || iplSrcImage->height != iplDstImage->height+4)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_o1_32f()!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    return gaussian5x5_o1_32f_SIMD(iplSrcImage, iplDstImage, sigma);
#endif      // #ifdef __SR_USE_SIMD

	// make filter
	float pFilter[5];
	float div = 0.0f;
	float div_sigma_sq2 = 0.5f / (sigma * sigma);
	for (int i=0; i<5; i++) {
		float diff = (float)(i - 2);
		float exp_num = - diff * diff * div_sigma_sq2;
		float value = exp(exp_num);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
		pFilter[i] = value;
		div += value;
	}
	for (int i=0; i<5; i++) {
		pFilter[i] = pFilter[i] / div;
	}
    float f0 = pFilter[0];
    float f1 = pFilter[1];
    float f2 = pFilter[2];
    float f3 = pFilter[3];
    float f4 = pFilter[4];

	// padding
    float *pLine = new float[iplSrcImage->width];
	if (pLine == NULL) {
        showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_o1_32f()!\n");
		return false;
	}
   
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pSrc0 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
        float *pSrc2 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
        float *pSrc3 = (float *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
        float *pSrc4 = (float *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
        // convolution in Y direction
		for (int x=0; x<iplSrcImage->width; x++) {
			pLine[x] = pSrc0[x] * f0 + pSrc1[x] * f1 + pSrc2[x] * f2 + pSrc3[x] * f3 + pSrc4[x] * f4;
		}
        // convolution in X direction
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = pLine[x] * f0 + pLine[x+1] * f1 + pLine[x+2] * f2 + pLine[x+3] * f3 + pLine[x+4] * f4;
		}
	}

	delete [] pLine;

	return true;
}

bool CImageUtility::gaussian7x7_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float sigma)
// Gaussian filter
// This function supports the "in-place" operation (source and destination images are the same one)
// This function does not use the decomposition algorithm and ignore the boundary effects
{
	if (iplSrcImage == NULL || iplDstImage == NULL || sigma < 0)  {	// TODO: complete check here
		showErrMsg("Invalid input argument in CImageUtility::gaussian7x7_32f()!\n");
		return false;
	}

	// padding
	IplImage *iplPadded = padding(iplSrcImage, 3, 3, 3, 3);
	if (iplSrcImage == NULL) {
        showErrMsg("Fail to allocate buffer in CImageUtility::gaussian7x7_32f()!\n");
		return false;
	}

    bool rlt = gaussian7x7_o1_32f(iplPadded, iplDstImage, sigma);

    safeReleaseImage(&iplPadded);
     
    return rlt;
}

bool CImageUtility::gaussian7x7_o1_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float sigma)
// Gaussian filter
// This function supposes the input image has been padded 3 pixels in each direction
// Arguments:
//		iplSrcImage -- [I] input image; must be 32F floating point, 1-channel image, has been padded 3 pixels in each direction
//		iplDstImage -- [O] input image; must be 32F floating point, 1-channel image
// by Luhong Liang
// August, 2014
{
	if (iplSrcImage == NULL || iplDstImage == NULL ||
		iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F ||
        iplSrcImage->width != iplDstImage->width+6 || iplSrcImage->height != iplDstImage->height+6)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian7x7_o1_32f()!\n");
		return false;
	}

#ifdef __SR_USE_SIMD
    return gaussian7x7_o1_32f_SIMD(iplSrcImage, iplDstImage, sigma);
#endif      // #ifdef __SR_USE_SIMD

	// make filter
	float pFilter[7];
	float div = 0.0f;
	float div_sigma_sq2 = 0.5f / (sigma * sigma);
	for (int i=0; i<7; i++) {
		float diff = (float)(i - 3);
		float exp_num = - diff * diff * div_sigma_sq2;
		float value = exp(exp_num);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
		pFilter[i] = value;
		div += value;
	}
	for (int i=0; i<4; i++) {
		pFilter[i] = pFilter[i] / div;
	}
    float f0 = pFilter[0];
    float f1 = pFilter[1];
    float f2 = pFilter[2];
    float f3 = pFilter[3];

	// padding
    float *pLine = new float[iplSrcImage->width];
	if (pLine == NULL) {
        showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_o1_32f()!\n");
		return false;
	}
   
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pSrc0 = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        float *pSrc1 = (float *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
        float *pSrc2 = (float *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
        float *pSrc3 = (float *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
        float *pSrc4 = (float *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
        float *pSrc5 = (float *)((char*)iplSrcImage->imageData + (y+5) * iplSrcImage->widthStep);
        float *pSrc6 = (float *)((char*)iplSrcImage->imageData + (y+6) * iplSrcImage->widthStep);
        // convolution in Y direction
		for (int x=0; x<iplSrcImage->width; x++) {
			pLine[x] = pSrc0[x] * f0 + pSrc1[x] * f1 + pSrc2[x] * f2 + pSrc3[x] * f3 +
                            pSrc4[x] * f2 + pSrc5[x] * f1 + pSrc6[x] * f0;
		}
        // convolution in X direction
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = pLine[x] * f0 + pLine[x+1] * f1 + pLine[x+2] * f2 + pLine[x+3] * f3 + 
                           pLine[x+4] * f2 + pLine[x+5] * f1 + pLine[x+6] * f0;
		}
	}

	delete [] pLine;

	return true;
}

bool CImageUtility::gaussianRGB5x5_32f(IplImage *iplImage, IplImage *iplDstImage, float sigma)
// Gaussian filter
// This function supports the "in-place" operation (source and destination images are the same one)
// This function leaves 2 boundary pixels in each direction unchanged!
{
	if (iplImage == NULL || iplDstImage == NULL || sigma < 0 ||
        iplImage->nChannels != 3 || iplDstImage->nChannels != 3)  {	// TODO: complete check here
		showErrMsg("Invalid input argument in CImageUtility::gaussianRGB5x5_32f()!\n");
		return false;
	}

	// make filter
	float pFilter[5];
	float div = 0.0f;
	float div_sigma_sq2 = 0.5f / (sigma * sigma);
	for (int i=0; i<5; i++) {
		float diff = (float)(i - 2);
		float exp_num = - diff * diff * div_sigma_sq2;
		float value = exp(exp_num);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
		pFilter[i] = value;
		div += value;
	}
	for (int i=0; i<5; i++) {
		pFilter[i] = pFilter[i] / div;
	}
    float f0 = pFilter[0];
    float f1 = pFilter[1];
    float f2 = pFilter[2];
    float f3 = pFilter[3];
    float f4 = pFilter[4];

	// padding
    IplImage *iplPadded = padding(iplImage, 2, 2, 2, 2, 0);
    IplImage *iplInter = createImage(iplImage->width+4, iplImage->height, SR_DEPTH_32F, 3);
	if (iplPadded == NULL || iplInter == NULL) {
        showErrMsg("Fail to allocate buffer in CImageUtility::gaussianRGB5x5_32f()!\n");
        safeReleaseImage(&iplPadded, &iplInter);
		return false;
	}
    //saveImage("_gaussianYOrg0.bmp", iplImage);

	// convolution in Y direction
	for (int y=0; y<iplInter->height; y++) {
		float *pDst = (float *)((char*)iplInter->imageData + y * iplInter->widthStep);
        float *pSrc0 = (float *)((char*)iplPadded->imageData + y * iplPadded->widthStep);
        float *pSrc1 = (float *)((char*)iplPadded->imageData + (y+1) * iplPadded->widthStep);
        float *pSrc2 = (float *)((char*)iplPadded->imageData + (y+2) * iplPadded->widthStep);
        float *pSrc3 = (float *)((char*)iplPadded->imageData + (y+3) * iplPadded->widthStep);
        float *pSrc4 = (float *)((char*)iplPadded->imageData + (y+4) * iplPadded->widthStep);
		for (int x=0; x<iplInter->width; x++) {
            int xx = x*3;   
			pDst[xx] = pSrc0[xx] * f0 + pSrc1[xx] * f1 + pSrc2[xx] * f2 + pSrc3[xx] * f3 + pSrc4[xx] * f4;
            xx++;
            pDst[xx] = pSrc0[xx] * f0 + pSrc1[xx] * f1 + pSrc2[xx] * f2 + pSrc3[xx] * f3 + pSrc4[xx] * f4;
            xx++;
            pDst[xx] = pSrc0[xx] * f0 + pSrc1[xx] * f1 + pSrc2[xx] * f2 + pSrc3[xx] * f3 + pSrc4[xx] * f4;
		}
	}
    //saveImage("_gaussianY.bmp", iplInter);
    //saveImage("_gaussianYOrg1.bmp", iplImage);

    // convolution in X direction
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pSrc = (float *)((char*)iplInter->imageData + y * iplInter->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            int xx = x*3; 
			pDst[xx] = pSrc[xx] * f0 + pSrc[xx+3] * f1 + pSrc[xx+6] * f2 + pSrc[xx+9] * f3 + pSrc[xx+12] * f4;
            xx++;
            pDst[xx] = pSrc[xx] * f0 + pSrc[xx+3] * f1 + pSrc[xx+6] * f2 + pSrc[xx+9] * f3 + pSrc[xx+12] * f4;
            xx++;
            pDst[xx] = pSrc[xx] * f0 + pSrc[xx+3] * f1 + pSrc[xx+6] * f2 + pSrc[xx+9] * f3 + pSrc[xx+12] * f4;
		}
	}
    //saveImage("_gaussianYOrg2.bmp", iplImage);

	safeReleaseImage(&iplPadded, &iplInter);

	return true;
}

bool CImageUtility::gaussian9x9_32f(IplImage *iplImage, IplImage *iplDstImage, float sigma)
// Gaussian filter
// This function supports the "in-place" operation (source and destination images are the same one)
// This function does use the decomposition algorithm, so it is a fast version of gaussian_32f();
{
	if (iplImage == NULL || iplDstImage == NULL || iplImage->width < 9 || iplImage->height < 8 || sigma < 0)  {	// TODO: complete check here
		showErrMsg("Invalid input argument in CImageUtility::gaussian9x9_32f()!\n");
		return false;
	}

	// make filter
	float pFilter[9];
	const int wnd_size = 9;
	const int center = wnd_size >> 1;
	float div = 0.0f;
	float div_sigma_sq2 = 0.5f / (sigma * sigma);
	for (int i=0; i<wnd_size; i++) {
		float diff = (float)(i - center);
		float exp_num = - diff * diff * div_sigma_sq2;
		float value = exp(exp_num);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
		pFilter[i] = value;
		div += value;
	}
	for (int i=0; i<wnd_size; i++) {
		pFilter[i] = pFilter[i] / div;
	}
	float flt5 = pFilter[0] + pFilter[1] + pFilter[2] + pFilter[3] + pFilter[4];
	float flt4 = pFilter[0] + pFilter[1] + pFilter[2] + pFilter[3];
	float flt3 = pFilter[0] + pFilter[1] + pFilter[2];
	float flt2 = pFilter[0] + pFilter[1];

	// allocate intermeidate buffer
	IplImage *iplBuf = createImage(iplImage->width, iplImage->height, SR_DEPTH_32F, 1);
	if (iplBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian9x9_32f()!\n");
		return false;
	}

	// convolution in Y
	float *pSrc = (float *)((char*)iplImage->imageData);		// lines in IplImage is 32-bit aligned
	float *pDst = (float *)((char*)iplBuf->imageData);
	// first 4 lines
	float *pSrc0 = pSrc;					float *pSrc1 = pSrc0 + iplImage->widthStep/sizeof(float);	float *pSrc2 = pSrc1 + iplImage->widthStep/sizeof(float);
	float *pSrc3 = pSrc2 + iplImage->widthStep/sizeof(float);	float *pSrc4 = pSrc3 + iplImage->widthStep/sizeof(float); float *pSrc5 = pSrc4 + iplImage->widthStep/sizeof(float);
	float *pSrc6 = pSrc5 + iplImage->widthStep/sizeof(float); float *pSrc7 = pSrc6 + iplImage->widthStep/sizeof(float);
	float *pDst0 = pDst;					float *pDst1 = pDst0 + iplBuf->widthStep/sizeof(float);
	float *pDst2 = pDst1 + iplBuf->widthStep/sizeof(float);	float *pDst3 = pDst2 + iplBuf->widthStep/sizeof(float);
	for (int x=0; x<iplBuf->width; x++) {
		pDst0[x] = pSrc0[x]*flt5 + 
				   pSrc1[x]*pFilter[5] + pSrc2[x]*pFilter[6] + pSrc3[x]*pFilter[7] + pSrc4[x]*pFilter[8];
		pDst1[x] = pSrc0[x]*flt4 + pSrc1[x]*pFilter[4] + 
				   pSrc2[x]*pFilter[5] + pSrc3[x]*pFilter[6] + pSrc4[x]*pFilter[7] + pSrc5[x]*pFilter[8];
		pDst2[x] = pSrc0[x]*flt3 + pSrc1[x]*pFilter[3] + pSrc2[x]*pFilter[4] + 
				   pSrc3[x]*pFilter[5] + pSrc4[x]*pFilter[6] + pSrc5[x]*pFilter[7] + pSrc6[x]*pFilter[8];
		pDst3[x] = pSrc0[x]*flt2 + pSrc1[x]*pFilter[2] + pSrc2[x]*pFilter[3] + pSrc3[x]*pFilter[4] + 
				   pSrc4[x]*pFilter[5] + pSrc5[x]*pFilter[6] + pSrc6[x]*pFilter[7] + pSrc7[x]*pFilter[8];
	}
	// internal lines
	for (int y=4; y<iplBuf->height-center; y++) {
		float *pSrc0 = pSrc + (y-4) * iplImage->widthStep/sizeof(float);
		float *pSrc1 = pSrc0 + iplImage->widthStep/sizeof(float);	float *pSrc2 = pSrc1 + iplImage->widthStep/sizeof(float);	float *pSrc3 = pSrc2 + iplImage->widthStep/sizeof(float);
		float *pSrc4 = pSrc3 + iplImage->widthStep/sizeof(float);	float *pSrc5 = pSrc4 + iplImage->widthStep/sizeof(float);	float *pSrc6 = pSrc5 + iplImage->widthStep/sizeof(float);
		float *pSrc7 = pSrc6 + iplImage->widthStep/sizeof(float);	float *pSrc8 = pSrc7 + iplImage->widthStep/sizeof(float);	
		float *pDst0 = pDst + y * iplBuf->widthStep/sizeof(float);
		for (int x=0; x<iplBuf->width; x++) {
			pDst0[x] = pSrc0[x]*pFilter[0] + pSrc1[x]*pFilter[1] + pSrc2[x]*pFilter[2] + pSrc3[x]*pFilter[3] + pSrc4[x]*pFilter[4] + 
				       pSrc5[x]*pFilter[5] + pSrc6[x]*pFilter[6] + pSrc7[x]*pFilter[7] + pSrc8[x]*pFilter[8];
			//pDst0[x] = pSrc5[x];
		}
	}
	// last 4 lines
	pSrc0 = pSrc + (iplImage->height-1)*iplImage->widthStep/sizeof(float); pSrc1 = pSrc0 - iplImage->widthStep/sizeof(float);	pSrc2 = pSrc1 - iplImage->widthStep/sizeof(float);
	pSrc3 = pSrc2 - iplImage->widthStep/sizeof(float);	pSrc4 = pSrc3 - iplImage->widthStep/sizeof(float);	pSrc5 = pSrc4 - iplImage->widthStep/sizeof(float);
	pSrc6 = pSrc5 - iplImage->widthStep/sizeof(float);	pSrc7 = pSrc6 - iplImage->widthStep/sizeof(float);
	pDst0 = pDst + (iplBuf->height-1)*iplBuf->widthStep/sizeof(float);	pDst1 = pDst0 - iplBuf->widthStep/sizeof(float);
	pDst2 = pDst1 - iplBuf->widthStep/sizeof(float);						pDst3 = pDst2 - iplBuf->widthStep/sizeof(float);
	for (int x=0; x<iplBuf->width; x++) {
		pDst0[x] = pSrc0[x]*flt5 + 
				   pSrc1[x]*pFilter[5] + pSrc2[x]*pFilter[6] + pSrc3[x]*pFilter[7] + pSrc4[x]*pFilter[8];
		pDst1[x] = pSrc0[x]*flt4 + pSrc1[x]*pFilter[4] + 
				   pSrc2[x]*pFilter[5] + pSrc3[x]*pFilter[6] + pSrc4[x]*pFilter[7] + pSrc5[x]*pFilter[8];
		pDst2[x] = pSrc0[x]*flt3 + pSrc1[x]*pFilter[3] + pSrc2[x]*pFilter[4] + 
				   pSrc3[x]*pFilter[5] + pSrc4[x]*pFilter[6] + pSrc5[x]*pFilter[7] + pSrc6[x]*pFilter[8];
		pDst3[x] = pSrc0[x]*flt2 + pSrc1[x]*pFilter[2] + pSrc2[x]*pFilter[3] + pSrc3[x]*pFilter[4] + 
				   pSrc4[x]*pFilter[5] + pSrc5[x]*pFilter[6] + pSrc6[x]*pFilter[7] + pSrc7[x]*pFilter[8];
	}
	
	//saveImage("_Gaussian9x9Y.bmp", iplBuf,0, 255.0f);
	// convolution in X
	for (int y=0; y<iplDstImage->height; y++) {
		float *pSrc = (float *)((char*)iplBuf->imageData + y*iplBuf->widthStep);		// lines in IplImage is 32-bit aligned
		float *pDst = (float *)((char*)iplDstImage->imageData + y*iplDstImage->widthStep);
		// first 4 pixels
		pDst[0] = pSrc[0]*flt5 +
				  pSrc[1]*pFilter[5] + pSrc[2]*pFilter[6] + pSrc[3]*pFilter[7]  + pSrc[4]*pFilter[8];
		pDst[1] = pSrc[0]*flt4 + pSrc[1]*pFilter[4] + 
				  pSrc[2]*pFilter[5] + pSrc[3]*pFilter[6] + pSrc[4]*pFilter[7] + pSrc[5]*pFilter[8];
		pDst[2] = pSrc[0]*flt3 + pSrc[1]*pFilter[3] + pSrc[2]*pFilter[4] + 
				  pSrc[3]*pFilter[5] + pSrc[4]*pFilter[6] + pSrc[5]*pFilter[7] + pSrc[6]*pFilter[8];
		pDst[3] = pSrc[0]*flt2 + pSrc[1]*pFilter[2] + pSrc[2]*pFilter[3] + pSrc[3]*pFilter[4] + 
				  pSrc[4]*pFilter[5] + pSrc[5]*pFilter[6] + pSrc[6]*pFilter[7] + pSrc[7]*pFilter[8];
		// internal pixels
		for (int x=4; x<iplDstImage->width-4; x++) {
			float *pSrcL = pSrc + x - 4;
			pDst[x] = pSrcL[0]*pFilter[0] + pSrcL[1]*pFilter[1] + pSrcL[2]*pFilter[2] + pSrcL[3]*pFilter[3] + pSrcL[4]*pFilter[4] + 
					  pSrcL[5]*pFilter[5] + pSrcL[6]*pFilter[6] + pSrcL[7]*pFilter[7] + pSrcL[8]*pFilter[8];
			//pDst[x] = pSrcL[5];
		}
		// last 4 pixels
		pDst = pDst + (iplDstImage->widthStep/sizeof(float)-4);
		pSrc = pSrc + (iplBuf->widthStep/sizeof(float)-8);
		pDst[0] = pSrc[0]*pFilter[0] + pSrc[1]*pFilter[1] + pSrc[2]*pFilter[2] + pSrc[3]*pFilter[3] + pSrc[4]*pFilter[4] + 
				  pSrc[5]*pFilter[5] + pSrc[6]*pFilter[6] + pSrc[7]*flt2;
		pDst[1] = pSrc[1]*pFilter[0] + pSrc[2]*pFilter[1] + pSrc[3]*pFilter[2] + pSrc[4]*pFilter[3] + pSrc[5]*pFilter[4] + 
				  pSrc[6]*pFilter[5] + pSrc[7]*flt3;
		pDst[2] = pSrc[2]*pFilter[0] + pSrc[3]*pFilter[1] + pSrc[4]*pFilter[2] + pSrc[5]*pFilter[3] + pSrc[6]*pFilter[4] + 
				  pSrc[7]*flt4;
		pDst[3] = pSrc[3]*pFilter[0] + pSrc[4]*pFilter[1] + pSrc[5]*pFilter[2] + pSrc[6]*pFilter[3] + pSrc[7]*flt5;
	}
	
	safeReleaseImage(&iplBuf);

	return true;
}

bool CImageUtility::gaussian_int(IplImage *iplImage, IplImage *iplDstImage, int wnd_size, float sigma, int filter_bit_depth)
// A fixed-point implementation of the Gaussian filter
// This function supports the "in-place" operation (source and destination images are the same one)
// This function does not use the decomposition algorithm and ignore the boundary effects
{
	if (iplImage == NULL || iplDstImage == NULL || wnd_size < 1 || sigma < 0 ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian_int()!\n");
		return false;
	}
	if (filter_bit_depth > 15 || filter_bit_depth < 8) {
		showErrMsg("Only support bit depth 8~15!\n");
		return false;
	}

	// make filter
	float pFilter1[7 * 7];
	int mag_factor = 1;
	mag_factor = mag_factor << filter_bit_depth;

	// just to get the filter
	int center = wnd_size >> 1;
	float div = 0.0f;
	float div_sigma_sq2 = 0.5f / (sigma * sigma);
	for (int y=0; y<wnd_size; y++) {
		float diff_y = (float)(y - center);
		diff_y = diff_y * diff_y;
		for (int x=0; x<wnd_size; x++) {
			int index = y * wnd_size + x;
			float diff_x = (float)(x - center);
			diff_x = diff_x * diff_x;
			float exp_num = - (diff_x + diff_y) * div_sigma_sq2;
			float value = exp(exp_num);
            value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
			pFilter1[index] = value;
			div += value;
		}
	}
	float fTotal = 0;
	for (int i=0; i<wnd_size*wnd_size; i++) {
		pFilter1[i] = floor((pFilter1[i] / div) * mag_factor + 0.5f);
		fTotal += pFilter1[i];
	}

	// set filter used
	int pFilter9x9_1_12[] = { 0,   0,   0,   0,   0,   0,  0,   0,  0,		// add 4 "1" in the corners to keep the sum of elements 4096!
							  0,   1,   1,   4,   7,   4,  1,   1,  0,
							  0,   1,  12,  54,  88,  54, 12,   1,  0,
							  0,   4,  54, 240, 395, 240, 54,   4,  0, 
							  0,   7,  88, 395, 652, 395, 88,   7,  0,
							  0,   4,  54, 240, 395, 240, 54,   4,  0,
							  0,   1,  12,  54,  88,  54, 12,   1,  0,
							  0,   1,   1,   4,   7,   4,  1,   1,  0,
							  0,   0,   0,   0,   0,   0,  0,   0,  0 };

	int pFilter9x9_1_10[] = { 0,   0,   0,   0,   0,   0,  0,   0,  0,		// add 4 "1" to (2,2) corners and '1" to the center to keep the sum of elements 1024!
		                      0,   0,   0,   1,   2,   1,  0,   0,  0,
							  0,   0,   4,  13,  22,  13,  4,   0,  0,
							  0,   1,  13,  60,  99,  60, 13,   1,  0,
							  0,   2,  22,  99, 164,  99, 22,   2,  0,
							  0,   1,  13,  60,  99,  60, 13,   1,  0,
							  0,   0,   4,  13,  22,  13,  4,   0,  0,
							  0,   0,   0,   1,   2,   1,  0,   0,  0,
							  0,   0,   0,   0,   0,   0,  0,   0,  0 };

	//int pFilter3x3_05_12[] = { 47, 343, 47,
	//						   343, 2536, 343,
	//						   47, 343, 47 };

	//int pFilter3x3_05_10[] = { 12, 86, 12,
	//						   86, 632, 86,
	//						   12, 86, 12 };


	int *pFilter;
	if (sigma == 1.0f && filter_bit_depth == 12) {
		pFilter = pFilter9x9_1_12;
	} else 	if (sigma == 1.0f && filter_bit_depth == 10) {
		pFilter = pFilter9x9_1_10;
	} else {
		showErrMsg("Unsupported sigma or bit depth in CImageUtility::gaussian_int()!\n");
		return false;
	}
	//int nTotal = 0;
	//for (int i=0; i<81; i++) nTotal += pFilter[i];

	// padding
	int *pSrcImage = new int[(iplImage->width + wnd_size) * (iplImage->height + wnd_size)];
	if (pSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian_int()!\n");
		return false;
	}
	// x
	for (int y=0; y<iplImage->height; y++) {
		int *pSrc = (int *)((char*)iplImage->imageData + y * iplImage->widthStep);
		int *pDst = pSrcImage + (y+center) * (iplImage->width + wnd_size);
		for (int x=0; x<center; x++) {
			pDst[x] = pSrc[0];
		}
		pDst += center;
		for (int x=0; x<iplImage->width; x++) {
			pDst[x] = pSrc[x];
		}
		for (int x=iplImage->width; x<iplImage->width+wnd_size-center; x++) {
			pDst[x] = pSrc[iplImage->width-1];
		}
	}
	//visPatch("_PadX.bmp", pSrcImage, iplImage->width+wnd_size, iplImage->height+wnd_size, 1);
	// y
	for (int y=0; y<center; y++) {
		int *pSrc = pSrcImage + center * (iplImage->width + wnd_size);
		int *pDst = pSrcImage + y * (iplImage->width + wnd_size);
		for (int x=0; x<iplImage->width+wnd_size; x++) {
			pDst[x] = pSrc[x];
		}
	}
	for (int y=iplImage->height+center; y<iplImage->height+wnd_size; y++) {
		int *pSrc = pSrcImage + (iplImage->height+center-1) * (iplImage->width + wnd_size);
		int *pDst = pSrcImage + y * (iplImage->width + wnd_size);
		for (int x=0; x<iplImage->width+wnd_size; x++) {
			pDst[x] = pSrc[x];
		}
	}
	//visPatch("_PadY.bmp", pSrcImage, iplImage->width+wnd_size, iplImage->height+wnd_size, 1);

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			int val = 0;
			for (int yy=0; yy<wnd_size; yy++) {
				int *pF = pFilter + yy * wnd_size;
				int *pSrc = pSrcImage + (y+yy) * (iplImage->width + wnd_size) + x;
				for (int xx=0; xx<wnd_size; xx++) {
					val += (pSrc[xx] * pF[xx]) >> filter_bit_depth;
				}
			}
			pDst[x] = val;
		}
	}

	delete [] pSrcImage;

	return true;
}

bool CImageUtility::gaussian7x7_10_int(IplImage *iplImage, IplImage *iplDstImage, int filter_bit_depth)
// A fixed-point implementation of the Gaussian filter with 7x7 window and sigma = 1.0
// This function supports the "in-place" operation (source and destination images are the same one)
// This function does not use the decomposition algorithm and ignore the boundary effects
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian7x7_10_int()!\n");
		return false;
	}

	// set filter used
	int pFilter7x7_10_12bit[] = { 1,   1,   4,   7,   4,  1,   1,		// add 4 "1" in the corners to keep the sum of elements 4096!
							      1,  12,  54,  88,  54, 12,   1,
								  4,  54, 240, 395, 240, 54,   4, 
								  7,  88, 395, 652, 395, 88,   7,
								  4,  54, 240, 395, 240, 54,   4,
								  1,  12,  54,  88,  54, 12,   1,
								  1,   1,   4,   7,   4,  1,   1 };

	int pFilter7x7_10_10bit[] = { 0,   0,   1,   2,   1,  0,   0,		// add 4 "1" to (2,2) corners and '1" to the center to keep the sum of elements 1024!
							      0,   4,  13,  22,  13,  4,   0,
								  1,  13,  60,  99,  60, 13,   1,
								  2,  22,  99, 164,  99, 22,   2,
								  1,  13,  60,  99,  60, 13,   1,
								  0,   4,  13,  22,  13,  4,   0,
								  0,   0,   1,   2,   1,  0,   0 };

	int *pFilter = NULL;
	if (filter_bit_depth == 12) {
		pFilter = pFilter7x7_10_12bit;
	} else 	if (filter_bit_depth == 10) {
		pFilter = pFilter7x7_10_10bit;
	} else {
		showErrMsg("Unsupported sigma or bit depth in CImageUtility::gaussian7x7_10_int()!\n");
		return false;
	}

	// padding
	const int wnd_size = 7;
	const int padded = 3;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian7x7_10_int()!\n");
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			int val = 0;
			for (int yy=0; yy<wnd_size; yy++) {
				int *pF = pFilter + yy * wnd_size;
				int *pSrc = (int *)((char*)iplSrcImage->imageData + (y+yy) * iplSrcImage->widthStep) + x;
				for (int xx=0; xx<wnd_size; xx++) {
					val += pSrc[xx] * pF[xx];		// cannot shift here due to visible quality loss!
				}
			}
			pDst[x] = val >> filter_bit_depth;
		}
	}

	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::gaussian5x5_10_int_s1(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 5x5 window and sigma = 1.0
// This function uses a decomposed implementation with 7-bit filter (7, 31, 52, 31, 7) / 128
// This function supports the "in-place" operation (source and destination images are the same one)
// NOTE: the input bit-depth should be less than 17!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_10_int_s1()!\n");
		return false;
	}

	// padding
	const int padded = 2;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_10_int_s1()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_10_int_s1()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		int *pSrc2 = (int *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		int *pSrc3 = (int *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
		int *pSrc4 = (int *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			pLineBuf[x] = pSrc0[x]*7 + pSrc1[x]*31 + pSrc2[x]*52 + pSrc3[x]*31 + pSrc4[x]*7;		// (7, 31, 52, 31, 7) / 128, 7-bit + bit depth
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x]*7 + pLineBuf[x+1]*31 + pLineBuf[x+2]*52 + pLineBuf[x+3]*31 + pLineBuf[x+4]*7) >> 14;		// (7, 31, 52, 31, 7) / 128, 14-bit + bit depth
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::gaussian5x5_10_Int_s4(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 5x5 window and sigma = 1.0
// This function uses a decomposed implementation with 4-bit filter： (1, 4, 6, 4, 1) / 16
// This function supports the "in-place" operation (source and destination images are the same one)
// NOTE: the input bit-depth should be less than 17!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::adaptGaussian5x5_10_Int_s4()!\n");
		return false;
	}

	// padding
	const int padded = 2;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::adaptGaussian5x5_10_Int_s4()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::adaptGaussian5x5_10_Int_s4()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		int *pSrc2 = (int *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		int *pSrc3 = (int *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
		int *pSrc4 = (int *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			pLineBuf[x] = pSrc0[x] + pSrc1[x]*4 + pSrc2[x]*6 + pSrc3[x]*4 + pSrc4[x];		 //(1, 4, 6, 4, 1) / 16
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x] + pLineBuf[x+1]*4 + pLineBuf[x+2]*6 + pLineBuf[x+3]*4 + pLineBuf[x+4]) >> 8;		//  (1, 4, 6, 4, 1) / 16
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::gaussian5x5_10_8U_10U_s4(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 5x5 window and sigma = 1.0
// This function uses a decomposed implementation with 4-bit filter： (1, 4, 6, 4, 1) / 16
// This function supports the "in-place" operation (source and destination images are the same one)
// Different from gaussian5x5_10_Int_s4(), the input image in this function is 8U.
// Luhong Liang, IC-ASD, ASTRI
// July 2, 2014
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_10_8U_10U_s4()!\n");
		return false;
	}

	// padding
	const int padded = 2;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_10_8U_10U_s4()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_10_8U_10U_s4()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		unsigned char *pSrc0 = (unsigned char *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		unsigned char *pSrc1 = (unsigned char *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		unsigned char *pSrc2 = (unsigned char *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		unsigned char *pSrc3 = (unsigned char *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
		unsigned char *pSrc4 = (unsigned char *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			pLineBuf[x] = pSrc0[x] + pSrc1[x]*4 + pSrc2[x]*6 + pSrc3[x]*4 + pSrc4[x];		 //(1, 4, 6, 4, 1) / 16
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x] + pLineBuf[x+1]*4 + pLineBuf[x+2]*6 + pLineBuf[x+3]*4 + pLineBuf[x+4]) >> 6;		//  (1, 4, 6, 4, 1) / 16, 10-bit result
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::gaussian5x5_10_int_s5(IplImage *iplSrcImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 5x5 window and sigma = 1.0
// This function uses a decomposed implementation with 7-bit filter (7, 31, 52, 31, 7) / 128
// Different from gaussian5x5_10_int(), this function does not support "in-place" operation and supposes 
// the input image has been padded.
// NOTE: the input bit-depth should be less than 17!
// by Luhong Liang, ICD-ASD, ASTRI
// May 15, 2013
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || 
		iplDstImage->nChannels != 1 || iplSrcImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_10_int_s5()!\n");
		return false;
	}
	if (iplSrcImage->width != iplDstImage->width+4 || iplSrcImage->height != iplDstImage->height+4) {
		showErrMsg("Sizes of the input and output image do not match in CImageUtility::gaussian5x5_10_int_s5()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_10_int_s5()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		int *pSrc2 = (int *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		int *pSrc3 = (int *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
		int *pSrc4 = (int *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			pLineBuf[x] = pSrc0[x]*7 + pSrc1[x]*31 + pSrc2[x]*52 + pSrc3[x]*31 + pSrc4[x]*7;		// (7, 31, 52, 31, 7) / 128, 7-bit + bit depth
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x]*7 + pLineBuf[x+1]*31 + pLineBuf[x+2]*52 + pLineBuf[x+3]*31 + pLineBuf[x+4]*7) >> 14;		// (7, 31, 52, 31, 7) / 128, 14-bit + bit depth
		}
	}

	delete [] pLineBuf;

	return true;
}

bool CImageUtility::gaussian5x5_15_int_s1(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 5x5 window and sigma = 1.5
// This function uses a decomposed implementation with 7-bit filter (15, 30, 38, 30, 15) / 128
// This function supports the "in-place" operation (source and destination images are the same one)
// NOTE: (1) The input bit-depth should be less than 17! (2) The filter has relative large error as a
//           cost of implement 1.0 and 2.0 filter in one framework!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_15_int_s1()!\n");
		return false;
	}

	// padding
	const int padded = 2;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_15_int_s1()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_15_int_s1()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		int *pSrc2 = (int *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		int *pSrc3 = (int *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
		int *pSrc4 = (int *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			pLineBuf[x] = pSrc0[x]*15 + pSrc1[x]*30 + pSrc2[x]*38 + pSrc3[x]*30 + pSrc4[x]*15;		// (15, 30, 38, 30, 15) / 128, 7-bit + bit depth
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x]*15 + pLineBuf[x+1]*30 + pLineBuf[x+2]*38 + pLineBuf[x+3]*30 + pLineBuf[x+4]*15) >> 14;		// (15, 30, 38, 30, 15) / 128, 14-bit + bit depth
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::gaussian5x5_15_int_s5(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 5x5 window and sigma = 1.5
// This function uses a decomposed implementation with 7-bit filter (15, 30, 38, 30, 15) / 128
// Different from function gaussian5x5_15_int_s1(), this function suppose the input image has been padded, and 
// the output image is just the "valid" region of the filtered input image!
// NOTE: (1) The input bit-depth should be less than 17! (2) The filter has relative large error as a
//           cost of implement 1.0 and 2.0 filter in one framework!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_15_int_s5()!\n");
		return false;
	}
	if (iplImage->width != iplDstImage->width+4 && iplImage->height != iplDstImage->height+4) {
		showErrMsg("Invalid input or output image size in CImageUtility::gaussian5x5_15_int_s5()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_15_int_s5()!\n");
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplImage->imageData + y * iplImage->widthStep);
		int *pSrc1 = (int *)((char*)iplImage->imageData + (y+1) * iplImage->widthStep);
		int *pSrc2 = (int *)((char*)iplImage->imageData + (y+2) * iplImage->widthStep);
		int *pSrc3 = (int *)((char*)iplImage->imageData + (y+3) * iplImage->widthStep);
		int *pSrc4 = (int *)((char*)iplImage->imageData + (y+4) * iplImage->widthStep);
		for (int x=0; x<iplImage->width; x++) {
			pLineBuf[x] = pSrc0[x]*15 + pSrc1[x]*30 + pSrc2[x]*38 + pSrc3[x]*30 + pSrc4[x]*15;		// (15, 30, 38, 30, 15) / 128, 7-bit + bit depth
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x]*15 + pLineBuf[x+1]*30 + pLineBuf[x+2]*38 + pLineBuf[x+3]*30 + pLineBuf[x+4]*15) >> 14;		// (15, 30, 38, 30, 15) / 128, 14-bit + bit depth
		}
	}

	delete [] pLineBuf;

	return true;
}

bool CImageUtility::gaussian5x5_15_8U_10U_s5(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 5x5 window and sigma = 1.5
// This function uses a decomposed implementation with 7-bit filter (15, 30, 38, 30, 15) / 128
// Different from function gaussian5x5_15_int_s5(), the input image is 8U and the output image is 32S
// that represents 10U data.
// NOTE: (1) The input bit-depth should be less than 17! (2) The filter has relative large error as a
//           cost of implement 1.0 and 2.0 filter in one framework!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_15_8U_10U_s5()!\n");
		return false;
	}
	if (iplImage->width != iplDstImage->width+4 && iplImage->height != iplDstImage->height+4) {
		showErrMsg("Invalid input or output image size in CImageUtility::gaussian5x5_15_8U_10U_s5()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_15_8U_10U_s5()!\n");
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		unsigned char *pSrc0 = (unsigned char *)((char*)iplImage->imageData + y * iplImage->widthStep);
		unsigned char *pSrc1 = (unsigned char *)((char*)iplImage->imageData + (y+1) * iplImage->widthStep);
		unsigned char *pSrc2 = (unsigned char *)((char*)iplImage->imageData + (y+2) * iplImage->widthStep);
		unsigned char *pSrc3 = (unsigned char *)((char*)iplImage->imageData + (y+3) * iplImage->widthStep);
		unsigned char *pSrc4 = (unsigned char *)((char*)iplImage->imageData + (y+4) * iplImage->widthStep);
		for (int x=0; x<iplImage->width; x++) {
			pLineBuf[x] = pSrc0[x]*15 + pSrc1[x]*30 + pSrc2[x]*38 + pSrc3[x]*30 + pSrc4[x]*15;		// (15, 30, 38, 30, 15) / 128, 15-bit
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x]*15 + pLineBuf[x+1]*30 + pLineBuf[x+2]*38 + pLineBuf[x+3]*30 + pLineBuf[x+4]*15) >> 12;		// (15, 30, 38, 30, 15) / 128, 10-bit
		}
	}

	delete [] pLineBuf;

	return true;
}

bool CImageUtility::gaussian5x5_30_8U_10U(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 5x5 window and sigma = 3.0
// This function uses a decomposed implementation with 7-bit filter (23, 27, 28, 27, 23) / 128
// Arguments:
//      iplImage -- [I] input image, 1-channel, 8U
//      iplDstImage -- [O] output image, same size as iplImage, 1-channel, 32S (0~1023)
// Return:
//      Luhong Liang, IC-ASD, ASTRI
//      July 3, 2014
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || 
        iplImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_30_8U_10U()!\n");
		return false;
	}

	// padding
	const int padded = 2;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_30_8U_10U()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_30_8U_10U()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		unsigned char *pSrc0 = (unsigned char *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		unsigned char *pSrc1 = (unsigned char *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		unsigned char *pSrc2 = (unsigned char *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		unsigned char *pSrc3 = (unsigned char *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
		unsigned char *pSrc4 = (unsigned char *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			pLineBuf[x] = pSrc0[x]*23 + pSrc1[x]*27 + pSrc2[x]*28 + pSrc3[x]*27 + pSrc4[x]*23;		// (23, 27, 28, 27, 23) / 128, 15-bit unsigned
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x]*23 + pLineBuf[x+1]*27 + pLineBuf[x+2]*28 + pLineBuf[x+3]*27 + pLineBuf[x+4]*23) >> 12;		// to 10-bit
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::gaussian5x5_10n15_int_s1(IplImage *iplImage, IplImage *iplDstImage, bool is10)
// A fixed-point implementation of the Gaussian filter with 5x5 window and sigma = 1.0, 1.5
// This function uses a decomposed implementation with 7-bit filter  (7, 31, 52, 31, 7) / 128 and (15, 30, 38, 30, 15) / 128
// This function supports the "in-place" operation (source and destination images are the same one)
// NOTE: (1) The input bit-depth should be less than 17! (2) The filter has relative large error as a
//           cost of implement 1.0 and 2.0 filter in one framework!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_10n15_int_s1()!\n");
		return false;
	}

	// padding
	const int padded = 2;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_10n15_int_s1()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_15_int_s1()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	unsigned int mask = is10 ? 0x00000000 : 0xFFFFFFFF;
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		int *pSrc2 = (int *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		int *pSrc3 = (int *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
		int *pSrc4 = (int *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			// (7, 31, 52, 31, 7) / 128 and (15, 30, 38, 30, 15) / 128, 7-bit + bit depth
			pLineBuf[x] = (pSrc0[x] * 7 + pSrc1[x] * 31 + pSrc2[x] * 52 + pSrc3[x] * 31 + pSrc4[x] * 7) +		// filter1
						  ((pSrc0[x] * 8 - pSrc1[x] - pSrc2[x] * 14 - pSrc3[x] + pSrc4[x] * 8) & mask);			// (filter2 - filter1) & mask
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			// (7, 31, 52, 31, 7) / 128 and (15, 30, 38, 30, 15) 
			pDst[x] = ((pLineBuf[x] * 7 + pLineBuf[x+1] * 31 + pLineBuf[x+2] * 52 + pLineBuf[x+3] * 31 + pLineBuf[x+4] * 7) >> 14) +
					(((pLineBuf[x] * 8 - pLineBuf[x+1] - pLineBuf[x+2] * 14 - pLineBuf[x+3] + pLineBuf[x+4] * 8) >> 14) & mask);
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::gaussian5x5_08_int_s4(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 5x5 window and sigma = 0.8
// This function uses a decomposed implementation with 5-bit filter  (1, 7, 16, 7, 1) / 32
// This function supports the "in-place" operation (source and destination images are the same one)
// NOTE: (1) The input bit-depth should be less than 20!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_08_int_s4()!\n");
		return false;
	}

	// padding
	const int padded = 2;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_08_int_s4()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_08_int_s4()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		int *pSrc2 = (int *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		int *pSrc3 = (int *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
		int *pSrc4 = (int *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			//(1, 7, 16, 7, 1) / 32
			pLineBuf[x] = pSrc0[x] + pSrc1[x]*7 + pSrc2[x]*16 + pSrc3[x]*7 + pSrc4[x];
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			//(1, 7, 16, 7, 1) / 32
			pDst[x] = (pLineBuf[x] + pLineBuf[x+1]*7 + pLineBuf[x+2]*16 + pLineBuf[x+3]*7 + pLineBuf[x+4]) >> 10;
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::gaussian5x5_08_int_s5(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 5x5 window and sigma = 0.8
// This function uses a decomposed implementation with 5-bit filter  (1, 7, 16, 7, 1) / 32
// Different from gaussian5x5_08_int_s4(), this function supposes the input image has been padded, i.e.
// the output is the "valid" region of the filtered input image.
// NOTE: (1) The input bit-depth should be less than 20!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_08_int_s5()!\n");
		return false;
	}
	if (iplImage->width != iplDstImage->width+4 && iplImage->height != iplDstImage->height+4) {
		showErrMsg("Invalid input or output image size in CImageUtility::gaussian5x5_08_int_s5()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_08_int_s5()!\n");
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplImage->imageData + y * iplImage->widthStep);
		int *pSrc1 = (int *)((char*)iplImage->imageData + (y+1) * iplImage->widthStep);
		int *pSrc2 = (int *)((char*)iplImage->imageData + (y+2) * iplImage->widthStep);
		int *pSrc3 = (int *)((char*)iplImage->imageData + (y+3) * iplImage->widthStep);
		int *pSrc4 = (int *)((char*)iplImage->imageData + (y+4) * iplImage->widthStep);
		for (int x=0; x<iplImage->width; x++) {
			//(1, 7, 16, 7, 1) / 32
			pLineBuf[x] = pSrc0[x] + pSrc1[x]*7 + pSrc2[x]*16 + pSrc3[x]*7 + pSrc4[x];
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			//(1, 7, 16, 7, 1) / 32
			pDst[x] = (pLineBuf[x] + pLineBuf[x+1]*7 + pLineBuf[x+2]*16 + pLineBuf[x+3]*7 + pLineBuf[x+4]) >> 10;
		}
	}

	delete [] pLineBuf;

	return true;
}

bool CImageUtility::gaussian5x5_08_8U_10U_s5(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 5x5 window and sigma = 0.8
// This function uses a decomposed implementation with 5-bit filter  (1, 7, 16, 7, 1) / 32
// Different from function gaussian5x5_08_int_s5(), the input image is 8U and the output image is 32S
// that represents 10U data.
// NOTE: (1) The input bit-depth should be less than 20!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_08_8U_10U_s5()!\n");
		return false;
	}
	if (iplImage->width != iplDstImage->width+4 && iplImage->height != iplDstImage->height+4) {
		showErrMsg("Invalid input or output image size in CImageUtility::gaussian5x5_08_8U_10U_s5()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_08_8U_10U_s5()!\n");
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		unsigned char *pSrc0 = (unsigned char *)((char*)iplImage->imageData + y * iplImage->widthStep);
		unsigned char *pSrc1 = (unsigned char *)((char*)iplImage->imageData + (y+1) * iplImage->widthStep);
		unsigned char *pSrc2 = (unsigned char *)((char*)iplImage->imageData + (y+2) * iplImage->widthStep);
		unsigned char *pSrc3 = (unsigned char *)((char*)iplImage->imageData + (y+3) * iplImage->widthStep);
		unsigned char *pSrc4 = (unsigned char *)((char*)iplImage->imageData + (y+4) * iplImage->widthStep);
		for (int x=0; x<iplImage->width; x++) {
			//(1, 7, 16, 7, 1) / 32
			pLineBuf[x] = pSrc0[x] + pSrc1[x]*7 + pSrc2[x]*16 + pSrc3[x]*7 + pSrc4[x];
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			//(1, 7, 16, 7, 1) / 32
			pDst[x] = (pLineBuf[x] + pLineBuf[x+1]*7 + pLineBuf[x+2]*16 + pLineBuf[x+3]*7 + pLineBuf[x+4]) >> 8;
		}
	}

	delete [] pLineBuf;

	return true;
}

bool CImageUtility::gaussian7x7_10n15_int_s1(IplImage *iplImage, IplImage *iplDstImage, bool is10)
// A fixed-point implementation of the Gaussian filter with 7x7 window and sigma = 1.0, 1.44
// This function uses a decomposed implementation with 7-bit filter  (0, 7, 31, 52, 31, 7, 0) / 128 and (4, 14, 28, 36, 28, 14, 4) / 128
// This function supports the "in-place" operation (source and destination images are the same one)
// NOTE: (1) The input bit-depth should be less than 17! (2) The filter has relative large error as a
//           cost of implement 1.0 and 2.0 filter in one framework!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian7x7_10n15_int_s1()!\n");
		return false;
	}

	// padding
	const int padded = 3;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian7x7_10n15_int_s1()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian7x7_10n15_int_s1()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	int mask = is10 ? 0x00000000 : 0xFFFFFFFF;
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		int *pSrc2 = (int *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		int *pSrc3 = (int *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
		int *pSrc4 = (int *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
		int *pSrc5 = (int *)((char*)iplSrcImage->imageData + (y+5) * iplSrcImage->widthStep);
		int *pSrc6 = (int *)((char*)iplSrcImage->imageData + (y+6) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			// (0, 7, 31, 52, 31, 7, 0) / 128 and (4, 14, 28, 36, 28, 14, 4) / 128, 7-bit + bit depth
			pLineBuf[x] =             (pSrc1[x]*7 + pSrc2[x]*31 + pSrc3[x]*52 + pSrc4[x]*31 + pSrc5[x]*7) +						// filter1
						 ((pSrc0[x]*4 + pSrc1[x]*7 - pSrc2[x]*3 - pSrc3[x]*16 - pSrc4[x]*3 + pSrc5[x]*7 + pSrc6[x]*4) & mask);  // (filter2 - filter1) & mask
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			// (0, 7, 31, 52, 31, 7, 0) / 128 and (4, 14, 28, 36, 28, 14, 4) / 128 
			pDst[x] = (                (pLineBuf[x+1]*7 + pLineBuf[x+2]*31 + pLineBuf[x+3]*52 + pLineBuf[x+4]*31 + pLineBuf[x+5]*7) +								   // filter1
				       ((pLineBuf[x]*4 + pLineBuf[x+1]*7 - pLineBuf[x+2]*3 - pLineBuf[x+3]*16 - pLineBuf[x+4]*3 + pLineBuf[x+5]*7 + pLineBuf[x+6]*4) & mask)) >> 14;   // (filter2 - filter1) & mask
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::gaussian7x7_15_int_s4(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 7x7 window and sigma = 1.5
// This function uses a decomposed implementation with 5-bit filter  (1, 4, 7, 8, 7, 4, 1) / 32
// This function supports the "in-place" operation (source and destination images are the same one)
// NOTE: (1) The input bit-depth should be less than 20!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian7x7_15_int_s4()!\n");
		return false;
	}

	// padding
	const int padded = 3;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian7x7_15_int_s4()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian7x7_15_int_s4()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		int *pSrc2 = (int *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		int *pSrc3 = (int *)((char*)iplSrcImage->imageData + (y+3) * iplSrcImage->widthStep);
		int *pSrc4 = (int *)((char*)iplSrcImage->imageData + (y+4) * iplSrcImage->widthStep);
		int *pSrc5 = (int *)((char*)iplSrcImage->imageData + (y+5) * iplSrcImage->widthStep);
		int *pSrc6 = (int *)((char*)iplSrcImage->imageData + (y+6) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			// (1, 4, 7, 8, 7, 4, 1) / 32
			pLineBuf[x] = pSrc0[x] + pSrc1[x]*4 + pSrc2[x]*7 + pSrc3[x]*8 + pSrc4[x]*7 + pSrc5[x]*4 + pSrc6[x];
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			// (1, 4, 7, 8, 7, 4, 1) / 32
			pDst[x] = (pLineBuf[x] + pLineBuf[x+1]*4 + pLineBuf[x+2]*7 + pLineBuf[x+3]*8 + pLineBuf[x+4]*7 + pLineBuf[x+5]*4 + pLineBuf[x+6]) >> 10;
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::gaussian3x3_05_int(IplImage *iplImage, IplImage *iplDstImage, int filter_bit_depth)
// A fixed-point implementation of the Gaussian filter with 3x3 window and sigma = 0.5
// This function supports the "in-place" operation (source and destination images are the same one)
// This function does not use the decomposition algorithm and ignore the boundary effects
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian3x3_05_int()!\n");
		return false;
	}

	// set filter used
	int pFilter3x3_05_12bit[] = { 47, 343, 47,
							      343, 2536, 343,
								  47, 343, 47 };

	int pFilter3x3_05_9bit[] = { 6, 43, 6,
							     43, 316, 43,
								 6, 43, 6 };

	int pFilter3x3_05_8bit[] = { 3, 21, 3,
							     21, 160, 21,
								 3, 21, 3 };

	int *pFilter = NULL;
	if (filter_bit_depth == 12) {
		pFilter = pFilter3x3_05_12bit;
	} else 	if (filter_bit_depth == 10) {
		pFilter = pFilter3x3_05_9bit;
		filter_bit_depth = 9;
	} else 	if (filter_bit_depth == 9) {
		pFilter = pFilter3x3_05_9bit;
	} else 	if (filter_bit_depth == 8) {
		pFilter = pFilter3x3_05_8bit;
	} else {
		showErrMsg("Unsupported sigma or bit depth in CImageUtility::gaussian3x3_05_int()!\n");
		return false;
	}

	// padding
	const int wnd_size = 3;
	const int padded = 1;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian3x3_05_int()!\n");
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			int val = 0;
			for (int yy=0; yy<wnd_size; yy++) {
				int *pF = pFilter + yy * wnd_size;
				int *pSrc = (int *)((char*)iplSrcImage->imageData + (y+yy) * iplSrcImage->widthStep) + x;
				for (int xx=0; xx<wnd_size; xx++) {
					val += pSrc[xx] * pF[xx];		// cannot shift here due to visible quality loss!
				}
			}
			pDst[x] = val >> filter_bit_depth;
		}
	}

	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::gaussian3x3_08_int_s1(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 3x3 window and sigma = 0.8
// This function uses a decomposed implementation with 2-bit filter (1, 2, 1) / 4
// This function supports the "in-place" operation (source and destination images are the same one)
// NOTE: the input bit-depth should be less than 19!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian3x3_08_int_s1()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian3x3_08_int_s1()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian3x3_08_int_s1()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		int *pSrc2 = (int *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			pLineBuf[x] = pSrc0[x] + (pSrc1[x] << 1) + pSrc2[x];		//  (1, 2, 1) / 4, 2-bit + bit depth
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x] + (pLineBuf[x+1]<<1) + pLineBuf[x+2]) >> 4;		//  (1, 2, 1) / 4, 2-bit + bit depth
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::gaussian3x3_05_int_s1(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 3x3 window and sigma = 0.5
// This function uses a decomposed implementation with 6-bit filter (7, 50, 7) / 64
// This function supports the "in-place" operation (source and destination images are the same one)
// NOTE: the input bit-depth should be less than 19!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian3x3_05_int_s1()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian3x3_05_int_s1()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian3x3_05_int_s1()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		int *pSrc2 = (int *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			pLineBuf[x] = pSrc0[x]*7 + pSrc1[x]*50 + pSrc2[x]*7;		//  (7, 50, 7) / 64, 6-bit + bit depth
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x]*7 + pLineBuf[x+1]*50 + pLineBuf[x+2]*7) >> 12;		//  (7, 50, 7) / 64, 14-bit + bit depth
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::gaussian3x3_05_int_s4(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 3x3 window and sigma = 0.5
// This function uses a decomposed implementation with 6-bit filter (1, 6, 1) / 8
// This function supports the "in-place" operation (source and destination images are the same one)
// NOTE: the input bit-depth should be less than 26!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian3x3_05_int_s1()!\n");
		return false;
	}

	// padding
	const int padded = 1;
	IplImage *iplSrcImage = padding(iplImage, padded, padded, padded, padded);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian3x3_05_int_s1()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplSrcImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian3x3_05_int_s1()!\n");
		safeReleaseImage(&iplSrcImage);
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc0 = (int *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
		int *pSrc1 = (int *)((char*)iplSrcImage->imageData + (y+1) * iplSrcImage->widthStep);
		int *pSrc2 = (int *)((char*)iplSrcImage->imageData + (y+2) * iplSrcImage->widthStep);
		for (int x=0; x<iplSrcImage->width; x++) {
			pLineBuf[x] = pSrc0[x] + pSrc1[x]*6 + pSrc2[x];		//  (1, 6, 1) / 8
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x] + pLineBuf[x+1]*6 + pLineBuf[x+2]) >> 6;		//  (1, 6, 1) / 8
		}
	}

	delete [] pLineBuf;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::gaussian5x5_05_int_s5(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 3x3 window and sigma = 0.5
// This function uses a decomposed implementation with 6-bit filter (1, 6, 1) / 8
// Different from gaussian3x3_05_int_s4(), this function suppose the input image has been padded 2 more pixels in each direction, i.e.
// the output image is the "valid" region of the filtered input image. Moreover, the filter is actually (0, 1, 6, 1, 0) / 8!
// NOTE: (1) the input bit-depth should be less than 26!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_05_int_s5()!\n");
		return false;
	}
	if (iplImage->width != iplDstImage->width+4 && iplImage->height != iplDstImage->height+4) {
		showErrMsg("Invalid input or output image size in CImageUtility::gaussian5x5_05_int_s5()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_05_int_s5()!\n");
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		int *pSrc1 = (int *)((char*)iplImage->imageData + (y+1) * iplImage->widthStep);
		int *pSrc2 = (int *)((char*)iplImage->imageData + (y+2) * iplImage->widthStep);
		int *pSrc3 = (int *)((char*)iplImage->imageData + (y+3) * iplImage->widthStep);
		for (int x=0; x<iplImage->width; x++) {
			pLineBuf[x] = pSrc1[x] + pSrc2[x]*6 + pSrc3[x];		//  (0, 1, 6, 1, 0) / 8
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x+1] + pLineBuf[x+2]*6 + pLineBuf[x+3]) >> 6;		//  (0, 1, 6, 1, 0) / 8
		}
	}

	delete [] pLineBuf;

	return true;
}

bool CImageUtility::gaussian5x5_05_8U_10U_s5(IplImage *iplImage, IplImage *iplDstImage)
// A fixed-point implementation of the Gaussian filter with 3x3 window and sigma = 0.5
// This function uses a decomposed implementation with 6-bit filter (1, 6, 1) / 8
// Different from function gaussian5x5_05_int_s5(), the input image is 8U and the output image is 32S
// that represents 10U data.
// NOTE: (1) the input bit-depth should be less than 26!
{
	if (iplImage == NULL || iplDstImage == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplImage->depth != SR_DEPTH_8U || iplDstImage->depth != SR_DEPTH_32S)  {
		showErrMsg("Invalid input argument in CImageUtility::gaussian5x5_05_8U_10U_s5()!\n");
		return false;
	}
	if (iplImage->width != iplDstImage->width+4 && iplImage->height != iplDstImage->height+4) {
		showErrMsg("Invalid input or output image size in CImageUtility::gaussian5x5_05_8U_10U_s5()!\n");
		return false;
	}

	// line buffer
	int *pLineBuf = new int[iplImage->width];
	if (pLineBuf == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian5x5_05_8U_10U_s5()!\n");
		return false;
	}

	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		// convolution in Y direction
		unsigned char *pSrc1 = (unsigned char *)((char*)iplImage->imageData + (y+1) * iplImage->widthStep);
		unsigned char *pSrc2 = (unsigned char *)((char*)iplImage->imageData + (y+2) * iplImage->widthStep);
		unsigned char *pSrc3 = (unsigned char *)((char*)iplImage->imageData + (y+3) * iplImage->widthStep);
		for (int x=0; x<iplImage->width; x++) {
			pLineBuf[x] = pSrc1[x] + pSrc2[x]*6 + pSrc3[x];		//  (0, 1, 6, 1, 0) / 8
		}
		// convolution in X direction
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			pDst[x] = (pLineBuf[x+1] + pLineBuf[x+2]*6 + pLineBuf[x+3]) >> 4;		//  (0, 1, 6, 1, 0) / 8
		}
	}

	delete [] pLineBuf;

	return true;
}

bool CImageUtility::adaptGaussian_32f(IplImage *iplImage, IplImage *iplDstImage, IplImage *iplPrior, int wnd_size, 
									  float pSigmaList[], int filter_num)
// Adaptive Gaussian filter
// This function does not use the decomposition algorithm
// pSigmaList is a sigma value list. It looks up the list by pSigmaList16[(int)(iplPrior(x,y)*filter_num+0.49)]
// Memory leak check, June 27, 2013
{
	if (iplImage == NULL || iplDstImage == NULL || iplPrior == NULL || wnd_size < 3 || 
		pSigmaList == NULL || filter_num < 1)  {	// TODO: complete check here
		showErrMsg("Invalid input argument in CImageUtility::adaptGaussian_32f()!\n");
		return false;
	}

	// make filter bank
	float *pFilterBank = new float[wnd_size * wnd_size * filter_num];
	if (pFilterBank == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::adaptGaussian_32f()!\n");
		return false;
	}
	int center = wnd_size >> 1;
	for (int i=0; i<filter_num; i++) {
		float *pFilter = pFilterBank + i * wnd_size * wnd_size;
		float div = 0.0f;
		float div_sigma_sq2 = 0.5f / (pSigmaList[i] * pSigmaList[i]);
		for (int y=0; y<wnd_size; y++) {
			float diff_y = (float)(y - center);
			diff_y = diff_y * diff_y;
			for (int x=0; x<wnd_size; x++) {
				int index = y * wnd_size + x;
				float diff_x = (float)(x - center);
				diff_x = diff_x * diff_x;
				float exp_num = - (diff_x + diff_y) * div_sigma_sq2;
				float value = exp(exp_num);
                value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
				pFilter[index] = value;
				div += value;
			}
		}
		for (int ii=0; ii<wnd_size*wnd_size; ii++) {
			pFilter[ii] = pFilter[ii] / div;
		}
        //showErrMsg("Filter %d\n", i);
        //for (int y=0; y<wnd_size; y++) {
            //showErrMsg("     ");
            //for (int x=0; x<wnd_size; x++) {
             //   showErrMsg("%1.4f\t", pFilter[y*wnd_size+x]);
            //}
            //showErrMsg("\n");
        //}
	}

	// padding
	int pad_left = wnd_size >> 1;
	int pad_top = wnd_size >> 1;
	IplImage *iplSrcImage = padding(iplImage, pad_left, wnd_size-pad_left-1, pad_top, wnd_size-pad_top-1);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::adaptGaussian_32f()!\n");
		return false;
	}

    // int pHit[256]; for (int i=0; i<256; i++) pHit[i] = 0;     // for debug
	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		float *pPrior = (float *)((char*)iplPrior->imageData + y * iplPrior->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
            //if (((x==222) && (y==321)) || ((x==621)&&(y==479)))
            //    int p = 2;
			// select filter
			float pri = pPrior[x];
			pri = pri < 0.0f ? 0.0f : pri;
			pri = pri > 1.0f ? 1.0f : pri;
			int idx = (int)(pri*(filter_num-1) + 0.5f);		// rounding
            //pHit[idx] ++;        // for debug
			// Gaussian filter
			float *pFilter = pFilterBank + idx * wnd_size * wnd_size;
			float val = 0.0f;
			for (int yy=0; yy<wnd_size; yy++) {
				float *pF = pFilter + yy * wnd_size;
				float *pSrc = (float *)((char*)iplSrcImage->imageData + (y+yy) * iplSrcImage->widthStep) + x;
				for (int xx=0; xx<wnd_size; xx++) {
					val += pSrc[xx] * pF[xx];
				}
			}
			pDst[x] = val;
		}
	}

    // for debug only
    //for (int i=0; i<filter_num; i++) {
    //    showErrMsg("Sigma = %1.4f\t\tHit=%1.3f%\n", pSigmaList[i], (float)pHit[i]*100.0f/(iplDstImage->height*iplDstImage->width));
    //}

	delete [] pFilterBank;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::adaptGaussian7x7_32f(IplImage *iplImage, IplImage *iplDstImage, IplImage *iplPrior,
									     float pSigmaList[], int filter_num)
// Adaptive Gaussian filter. This function is an optimized version of adaptGaussian_32f();
// This function does not use the decomposition algorithm
// pSigmaList is a sigma value list. It looks up the list by pSigmaList16[(int)(iplPrior(x,y)*filter_num+0.49)]
// Aug 27, 2013
{
	if (iplImage == NULL || iplDstImage == NULL || iplPrior == NULL ||
		pSigmaList == NULL || filter_num < 1)  {	// TODO: complete check here
		showErrMsg("Invalid input argument in CImageUtility::adaptGaussian7x7_32f()!\n");
		return false;
	}

	// make filter bank
	float *pFilterBank = new float[7 * 7 * filter_num];
	if (pFilterBank == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::adaptGaussian7x7_32f()!\n");
		return false;
	}
	int center = 7 >> 1;
	for (int i=0; i<filter_num; i++) {
		float *pFilter = pFilterBank + i * 7 * 7;
		float div = 0.0f;
		float div_sigma_sq2 = 0.5f / (pSigmaList[i] * pSigmaList[i]);
		for (int y=0; y<7; y++) {
			float diff_y = (float)(y - center);
			diff_y = diff_y * diff_y;
			for (int x=0; x<7; x++) {
				int index = y * 7 + x;
				float diff_x = (float)(x - center);
				diff_x = diff_x * diff_x;
				float exp_num = - (diff_x + diff_y) * div_sigma_sq2;
				float value = exp(exp_num);
                value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
				pFilter[index] = value;
				div += value;
			}
		}
		for (int ii=0; ii<7*7; ii++) {
			pFilter[ii] = pFilter[ii] / div;
		}
        //showErrMsg("Filter %d\n", i);
        //for (int y=0; y<7; y++) {
        //    showErrMsg("     ");
        //    for (int x=0; x<7; x++) {
        //        showErrMsg("%1.4f\t", pFilter[y*7+x]);
        //    }
        //    showErrMsg("\n");
        //}
	}

	// padding
	IplImage *iplSrcImage = padding(iplImage, 3, 3, 3, 3);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::adaptGaussian7x7_32f()!\n");
		return false;
	}

    // int pHit[256]; for (int i=0; i<256; i++) pHit[i] = 0;     // for debug
	// convolution
	for (int y=0; y<iplDstImage->height; y++) {
		float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		float *pPrior = (float *)((char*)iplPrior->imageData + y * iplPrior->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			// select filter
			float pri = pPrior[x];
			pri = pri < 0.0f ? 0.0f : pri;
			pri = pri > 1.0f ? 1.0f : pri;
			int idx = (int)(pri*(filter_num-1) + 0.5f);		// rounding
            //pHit[idx] ++;        // for debug
			// Gaussian filter
			float *pFilter = pFilterBank + idx * 7 * 7;
			float val = 0.0f;
            float *pSrc = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep) + x;
			for (int yy=0; yy<7; yy++) {
                val += (pSrc[0] + pSrc[6]) * pFilter[0];
                val += (pSrc[1] + pSrc[5]) * pFilter[1];
                val += (pSrc[2] + pSrc[4]) * pFilter[2];
                val += pSrc[3] * pFilter[3];
                pSrc += iplSrcImage->width;
                pFilter += 7;
			}
			pDst[x] = val;
		}
	}

    // for debug only
    //for (int i=0; i<filter_num; i++) {
    //    showErrMsg("Sigma = %1.4f\t\tHit=%1.3f%\n", pSigmaList[i], (float)pHit[i]*100.0f/(iplDstImage->height*iplDstImage->width));
    //}

	delete [] pFilterBank;
	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::adaptGaussian7x7_Int_s4(IplImage *iplImage, IplImage *iplDstImage, IplImage *iplTexStruct, int filter_mode)
// A fixed-point implementation of the adaptive Gaussian filter
// This function uses a cascade of 3x3 Gaussian filters (sigam = 0.5) and control the filter on/off to realize the 
// 3x3, 5x5 and 7x7 filters in different pixels controled by the texture-structure map.
// This function supports the "in-place" operation (source and destination images are the same one)
// The filter_mode represents:
//		0 --- adaptive filter; 1 --- 5x5 filter; 2 --- 7x7 filter
// NOTE: (1) The input bit-depth should be less than 17!
//		 (2) iplTexStruct should be 8U data type and ranges 0~63
//		 (3) The sizes of source image and texture map should be 1:1, 9:4 or 15:8!
// Mar. 14, 2013
{
	if (iplImage == NULL || iplDstImage == NULL || iplTexStruct == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplTexStruct->nChannels != 1 || 
		iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S || iplTexStruct->depth != SR_DEPTH_8U)  {
		showErrMsg("Invalid input argument in CImageUtility::adaptGaussian7x7_Int_s4()!\n");
		return false;
	}

	if ( (iplImage->width != iplTexStruct->width || iplImage->height != iplTexStruct->height) && 
		 (iplImage->width*8 != iplTexStruct->width*15 || iplImage->height*8 != iplTexStruct->height*15) && 
		 (iplImage->width*4 != iplTexStruct->width*9 || iplImage->height*4 != iplTexStruct->height*9) ) {
		showErrMsg("Target image size and texture map size should be 1:1 or 15:8 in CSuperResInteger::adaptGaussian7x7_Int_s4()!\n");
		return false;
	}

	if (iplImage->width != iplDstImage->width || iplImage->height != iplDstImage->height) {
		showErrMsg("Target image size and source image size should be 1:1 in CSuperResInteger::adaptGaussian7x7_Int_s4()!\n");
		return false;
	}

	// make mask map for 5x5 and 3x3 filters
	IplImage *iplMask3x3 = createImage(iplImage->width, iplImage->height, SR_DEPTH_8U, 1);
	IplImage *iplMask5x5 = createImage(iplImage->width, iplImage->height, SR_DEPTH_8U, 1);
	if (iplMask3x3 == NULL || iplMask5x5 == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::adaptGaussian7x7_Int_s4()!\n");
		safeReleaseImage(&iplMask3x3, &iplMask5x5);
		return false;
	}
	int pLocLUT158[] = { 0, 0, 1, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6, 7, 7};		// 3-bit, 15-entry
	int pLocLUT94[] = { 0, 0, 1, 1, 1, 2, 2, 3, 3 };						// 3-bit, 9-entry
	int pLocLUT11[] = { 0 };												// 3-bit, 1-entry
	int *pLocLUT, lr_step, hr_step;
	if (iplDstImage->width == iplTexStruct->width && iplDstImage->height == iplTexStruct->height) {
		pLocLUT = pLocLUT11;
		hr_step = 1;
		lr_step = 1;
	} else if (iplDstImage->width*8 == iplTexStruct->width*15) {
		pLocLUT = pLocLUT158;
		hr_step = 15;
		lr_step = 8;
	} else {
		pLocLUT = pLocLUT94;
		hr_step = 9;
		lr_step = 4;
	}
	for (int y=0, top=0; y<iplDstImage->height; y+=hr_step, top+=lr_step) {
		for (int yy=0; yy<hr_step; yy++) {
			int rec_y = y + yy;
			int tex_y = top + pLocLUT[yy];
			if (rec_y >= iplDstImage->height) break;		// only for S/W implementation. for H/W (1920x1080), never overflow
			unsigned char *pMask3x3 = (unsigned char *)((char*)iplMask3x3->imageData + rec_y * iplMask3x3->widthStep);	
			//unsigned char *pMask5x5 = (unsigned char *)((char*)iplMask5x5->imageData + rec_y * iplMask5x5->widthStep);	
			unsigned char *pTensor = (unsigned char *)((char*)iplTexStruct->imageData + tex_y * iplTexStruct->widthStep);
			for (int x=0, left=0; x<iplDstImage->width; x+=hr_step, left+=lr_step) {
				for (int xx=0; xx<hr_step; xx++) {
					int rec_x = x + xx;
					int tex_x = left + pLocLUT[xx];
					if (rec_x >= iplDstImage->width) break;		// only for S/W implementation. for H/W (1920x1080), never overflow
					unsigned char tensor = pTensor[tex_x];
					// set masking
					// 0--adaptive; 1--5x5; 2--7x7
					if (filter_mode == 0) {
						// adaptive
						if (tensor > 40) {
							pMask3x3[rec_x] = 0xFF;	// 7x7 Gaussian (selective)
						} else {
							pMask3x3[rec_x] = 0x00;	// 5x5 Gaussian (selective)
						}
					} else if (filter_mode == 2) {
						// Always 7x7 Gaussian
						pMask3x3[rec_x] = 0xFF;		
					} else {
						// Always 5x5 Gaussian
						pMask3x3[rec_x] = 0x00;		
					}
				}
			}
		}
	}
	//saveImage("_AdaptiveGaussianMask3x3.bmp", iplMask3x3);

	// 5x5
	gaussian5x5_10_Int_s4(iplImage, iplDstImage);

	// adaptive 3x3
	//adaptGaussian3x3_05_Int_s4(iplDstImage, iplDstImage, iplMask3x3);
	adaptBox3x3_05_Int_s4(iplDstImage, iplDstImage, iplMask3x3);

	safeReleaseImage(&iplMask3x3, &iplMask5x5);

	return true;
}

bool CImageUtility::adaptGaussian7x7_Int_s5(IplImage *iplImage, IplImage *iplDstImage, IplImage *iplTexStruct, int filter_mode)
// A fixed-point implementation of the adaptive Gaussian filter
// This function uses a cascade of 3x3 Gaussian filters (sigam = 0.5) and control the filter on/off to realize the 
// 3x3, 5x5 and 7x7 filters in different pixels controled by the texture-structure map.
// This function supports the "in-place" operation (source and destination images are the same one)
// Different to adaptGaussian7x7_Int_s4(), this function supposes the size of source image and the size of texture map is 2:1 in 480p mode
// The filter_mode represents:
//		0 --- adaptive filter; 1 --- 5x5 filter; 2 --- 7x7 filter
// NOTE: (1) The input bit-depth should be less than 17!
//		 (2) iplTexStruct should be 8U data type and ranges 0~63
//		 (3) The sizes of source image and texture map should be 1:1, 2:1 or 15:8!
// April 9, 2013
{
	if (iplImage == NULL || iplDstImage == NULL || iplTexStruct == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplTexStruct->nChannels != 1 || 
		iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S || iplTexStruct->depth != SR_DEPTH_8U)  {
		showErrMsg("Invalid input argument in CImageUtility::adaptGaussian7x7_Int_s5()!\n");
		return false;
	}

	if ( (iplImage->width != iplTexStruct->width || iplImage->height != iplTexStruct->height) && 
		 (iplImage->width*8 != iplTexStruct->width*15 || iplImage->height*8 != iplTexStruct->height*15) && 
		 (iplImage->width != iplTexStruct->width*2 || iplImage->height*8 != iplTexStruct->height*15) ) {
		showErrMsg("Target image size and texture map size should be 1:1 or 15:8 in CSuperResInteger::adaptGaussian7x7_Int_s5()!\n");
		return false;
	}

	if (iplImage->width != iplDstImage->width || iplImage->height != iplDstImage->height) {
		showErrMsg("Target image size and source image size should be 1:1 in CSuperResInteger::adaptGaussian7x7_Int_s5()!\n");
		return false;
	}

	// make mask map for 5x5 and 3x3 filters
	IplImage *iplMask3x3 = createImage(iplImage->width, iplImage->height, SR_DEPTH_8U, 1);
	IplImage *iplMask5x5 = createImage(iplImage->width, iplImage->height, SR_DEPTH_8U, 1);
	if (iplMask3x3 == NULL || iplMask5x5 == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::adaptGaussian7x7_Int_s5()!\n");
		safeReleaseImage(&iplMask3x3, &iplMask5x5);
		return false;
	}
	int shift_y = 0;
	int pLocLUT158[] = { 0, 0, 1, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6, 7, 7};		// 3-bit, 15-entry
	int pLocLUT94[] = { 0, 0 };						// 1-bit, 2-entry
	int pLocLUT11[] = { 0 };												// 3-bit, 1-entry
	int *pLocLUT, lr_step, hr_step;
	if (iplDstImage->width == iplTexStruct->width && iplDstImage->height == iplTexStruct->height) {
		pLocLUT = pLocLUT11;
		hr_step = 1;
		lr_step = 1;
	} else if ((iplDstImage->width*8 == iplTexStruct->width*15) && (iplDstImage->height*8 == iplTexStruct->height*15)) {
		pLocLUT = pLocLUT158;
		hr_step = 15;
		lr_step = 8;
	} else {
		shift_y = (iplTexStruct->height * 2 - iplDstImage->height) / 2;
		pLocLUT = pLocLUT94;
		hr_step = 2;
		lr_step = 1;
	}
	for (int y=0, top=0; y<iplDstImage->height; y+=hr_step, top+=lr_step) {
		for (int yy=0; yy<hr_step; yy++) {
			int rec_y = y + yy;
			int tex_y = top + pLocLUT[yy] + (shift_y >> 1) + (yy * (shift_y & 0x00000001)); // NOTE: in H/W implementation, the shfit_y must be even, so the last item will not appear!
			if (rec_y >= iplDstImage->height) break;		// only for S/W implementation. for H/W (1920x1080), never overflow
			unsigned char *pMask3x3 = (unsigned char *)((char*)iplMask3x3->imageData + rec_y * iplMask3x3->widthStep);	
			//unsigned char *pMask5x5 = (unsigned char *)((char*)iplMask5x5->imageData + rec_y * iplMask5x5->widthStep);	
			unsigned char *pTensor = (unsigned char *)((char*)iplTexStruct->imageData + tex_y * iplTexStruct->widthStep);
			for (int x=0, left=0; x<iplDstImage->width; x+=hr_step, left+=lr_step) {
				for (int xx=0; xx<hr_step; xx++) {
					int rec_x = x + xx;
					int tex_x = left + pLocLUT[xx];
					if (rec_x >= iplDstImage->width) break;		// only for S/W implementation. for H/W (1920x1080), never overflow
					unsigned char tensor = pTensor[tex_x];
					// set masking
					// 0--adaptive; 1--5x5; 2--7x7
					if (filter_mode == 0) {
						// adaptive
						if (tensor > 40) {
							pMask3x3[rec_x] = 0xFF;	// 7x7 Gaussian (selective)
						} else {
							pMask3x3[rec_x] = 0x00;	// 5x5 Gaussian (selective)
						}
					} else if (filter_mode == 2) {
						// Always 7x7 Gaussian
						pMask3x3[rec_x] = 0xFF;		
					} else {
						// Always 5x5 Gaussian
						pMask3x3[rec_x] = 0x00;		
					}
				}
			}
		}
	}
	//saveImage("_AdaptiveGaussianMask3x3.bmp", iplMask3x3);

	// 5x5
	gaussian5x5_10_Int_s4(iplImage, iplDstImage);

	// adaptive 3x3
	//adaptGaussian3x3_05_Int_s4(iplDstImage, iplDstImage, iplMask3x3);
	adaptBox3x3_05_Int_s4(iplDstImage, iplDstImage, iplMask3x3);

	safeReleaseImage(&iplMask3x3, &iplMask5x5);

	return true;
}

bool CImageUtility::adaptGaussian7x7_Int_s5a(IplImage *iplImage, IplImage *iplDstImage, IplImage *iplTexStruct, int filter_mode)
// A fixed-point implementation of the adaptive Gaussian filter
// This function uses a cascade of 3x3 Gaussian filters (sigam = 0.5) and control the filter on/off to realize the 
// 3x3, 5x5 and 7x7 filters in different pixels controled by the texture-structure map.
// This function supports the "in-place" operation (source and destination images are the same one)
// Different to adaptGaussian7x7_Int_s5(), this function supposes the input image has been padded! More specifically, the sizes of the images are
//                          576p            480p            1080p
//      iplImage         1358x1088       1448x1088        1928x1088      
//      iplDstImage      1352x1082       1442x1082        1922x1082
//      iplTexStruct      722x578         722x578         1924x1084    
// The filter_mode represents:
//		0 --- adaptive filter; 1 --- 5x5 filter; 2 --- 7x7 filter
// NOTE: (1) The input bit-depth should be less than 17!
//		 (2) iplTexStruct should be 8U data type and ranges 0~63
//		 (3) The sizes of source image and texture map should be 1:1, 2:1 or 15:8!
// Aug 20, 2013
{
	if (iplImage == NULL || iplDstImage == NULL || iplTexStruct == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplTexStruct->nChannels != 1 || 
		iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S || iplTexStruct->depth != SR_DEPTH_8U)  {
		showErrMsg("Invalid input argument in CImageUtility::adaptGaussian7x7_Int_s5a()!\n");
		return false;
	}

	if ( (iplImage->width != iplTexStruct->width+4 || iplImage->height != iplTexStruct->height+4) &&                        // 1080p
		 ((iplImage->width-8)*8 != (iplTexStruct->width-2)*15 || (iplImage->height-8)*8 != (iplTexStruct->height-2)*15) &&  // 576p
		 ((iplImage->width-8) != (iplTexStruct->width-2)*2 || (iplImage->height-8)*8 != (iplTexStruct->height-2)*15) ) {    // 480p
		showErrMsg("Target image size and texture map size should be 1:1 or 15:8 in CSuperResInteger::adaptGaussian7x7_Int_s5a()!\n");
		return false;
	}

	if (iplImage->width != iplDstImage->width+6 || iplImage->height != iplDstImage->height+6) {
		showErrMsg("Invalid target image size or source image size in CSuperResInteger::adaptGaussian7x7_Int_s5a()!\n");
		return false;
	}

    // create buffer
	IplImage *iplMask3x3 = createImage(iplDstImage->width, iplDstImage->height, SR_DEPTH_8U, 1);
	IplImage *iplSmth5x5 = createImage(iplImage->width-4, iplImage->height-4, SR_DEPTH_32S, 1);
	if (iplMask3x3 == NULL || iplSmth5x5 == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::adaptGaussian7x7_Int_s5()!\n");
		safeReleaseImage(&iplMask3x3, &iplSmth5x5);
		return false;
	}

	// 5x5
	gaussian5x5_10_int_s5(iplImage, iplSmth5x5);

	// make mask map for 5x5 and 3x3 filters
    int shift_y = 0;
	int pLocLUT158[] = { 0, 0, 1, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6, 7, 7};      // 576p:  3-bit, 15-entry
	int pLocLUT21[] = { 0, 0 };                                             // 480p:  1-bit, 2-entry
	int pLocLUT11[] = { 0 };                                                // 1080p: 3-bit, 1-entry
	int *pLocLUT, lr_step, hr_step;
    IplImage *iplTexPad, *iplMskPad;
	if (iplDstImage->width+2 == iplTexStruct->width && iplDstImage->height+2 == iplTexStruct->height) {
        // 1080p
		pLocLUT = pLocLUT11;
		hr_step = 1;
		lr_step = 1;
        iplTexPad = clone(iplTexStruct);
        iplMskPad = createImage(iplMask3x3->width+2, iplMask3x3->height+2, SR_DEPTH_8U, 1);
	} else if (((iplDstImage->width-2)*8 == (iplTexStruct->width-2)*15) && ((iplDstImage->height-2)*8 == (iplTexStruct->height-2)*15)) {
        // 576p
		pLocLUT = pLocLUT158;
		hr_step = 15;
		lr_step = 8;
        iplTexPad = padding(iplTexStruct, 7, 7, 7, 7);
        iplMskPad = createImage(iplMask3x3->width+28, iplMask3x3->height+28, SR_DEPTH_8U, 1);
	} else {
		shift_y = ((576-480)/2) * 2 - ((576*2-480*2)/2 - 40);       // 40
		pLocLUT = pLocLUT21;
		hr_step = 2;
		lr_step = 1;
        iplTexPad = clone(iplTexStruct);
        iplMskPad = createImage(iplMask3x3->width+2, iplMask3x3->height+2, SR_DEPTH_8U, 1);
	}
    if (iplTexPad == NULL || iplMskPad == NULL) {
        showErrMsg("Fail to allocate buffer in CImageUtility::adaptGaussian7x7_Int_s5()!\n");
        safeReleaseImage(&iplMask3x3, &iplSmth5x5, &iplTexPad, &iplMskPad);
        return false;
    }
	for (int y=0, top=0; y<iplMskPad->height; y+=hr_step, top+=lr_step) {
		for (int yy=0; yy<hr_step; yy++) {
			int rec_y = y + yy;
			int tex_y = top + pLocLUT[yy] + (shift_y >> 1);
			if (rec_y >= iplDstImage->height) break;		// only for S/W implementation. for H/W (1920x1080), never overflow
			unsigned char *pMask3x3 = (unsigned char *)((char*)iplMskPad->imageData + rec_y * iplMskPad->widthStep);	
			unsigned char *pTensor = (unsigned char *)((char*)iplTexPad->imageData + tex_y * iplTexPad->widthStep);
			for (int x=0, left=0; x<iplMskPad->width; x+=hr_step, left+=lr_step) {
				for (int xx=0; xx<hr_step; xx++) {
					int rec_x = x + xx;
					int tex_x = left + pLocLUT[xx];
					if (rec_x >= iplDstImage->width) break;		// only for S/W implementation. for H/W (1920x1080), never overflow
					unsigned char tensor = pTensor[tex_x];
					// set masking
					// 0--adaptive; 1--5x5; 2--7x7
					if (filter_mode == 0) {
						// adaptive
						if (tensor > 40) {
							pMask3x3[rec_x] = 0xFF;	// 7x7 Gaussian (selective)
						} else {
							pMask3x3[rec_x] = 0x00;	// 5x5 Gaussian (selective)
						}
					} else if (filter_mode == 2) {
						// Always 7x7 Gaussian
						pMask3x3[rec_x] = 0xFF;		
					} else {
						// Always 5x5 Gaussian
						pMask3x3[rec_x] = 0x00;		
					}
				}
			}
		}
	}
	if (iplDstImage->width+2 == iplTexStruct->width && iplDstImage->height+2 == iplTexStruct->height) {
        // 1080p
        unpadding(iplMskPad, iplMask3x3, 1, 1);
	} else if (((iplDstImage->width-2)*8 == (iplTexStruct->width-2)*15) && ((iplDstImage->height-2)*8 == (iplTexStruct->height-2)*15)) {
        // 576p
        unpadding(iplMskPad, iplMask3x3, 14, 14);
    } else {
        // 480p
        unpadding(iplMskPad, iplMask3x3, 1, 1);
    }
    safeReleaseImage(&iplTexPad, &iplMskPad);

	// adaptive 3x3
	adaptBox3x3_05_Int_s4a(iplSmth5x5, iplDstImage, iplMask3x3);

	safeReleaseImage(&iplMask3x3, &iplSmth5x5);

	return true;
}

bool CImageUtility::adaptGaussian3x3_05_Int_s4(IplImage *iplImage, IplImage *iplDstImage, IplImage *iplMask)
// A fixed-point implementation of the Gaussian filter with 3x3 window and sigma = 0.5
//	Gauassian Filter	(1, 5, 1; 5, 40, 5; 1, 5, 1) / 64	if iplMask[x,y] == 0xFF
//	Bypass				(0, 0, 0; 0,  1, 0; 0, 0, 0)		if iplMask[x,y] == 0x00 (others)
// This function supports the "in-place" operation (source and destination images are the same one)
// NOTE: the input bit-depth should be less than 19!
{
	if (iplImage == NULL || iplDstImage == NULL || iplMask == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplMask->nChannels  != 1 ||
		iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S || iplMask->depth != SR_DEPTH_8U)  {
		showErrMsg("Invalid input argument in CImageUtility::adaptGaussian3x3_05_Int_s4()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcImage = padding(iplImage, 1, 1, 1, 1);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::adaptGaussian3x3_05_Int_s4()!\n");
		return false;
	}

	// convolution
	int pBlock[9];
	for (int y=0; y<iplDstImage->height; y++) {
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		unsigned char *pMsk = (unsigned char *)((char*)iplMask->imageData + y * iplMask->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			// get 3x3 block
			int i = 0;
			for (int yy=0; yy<3; yy++) {
				int *pSrc = (int *)((char*)iplSrcImage->imageData + (y+yy) * iplSrcImage->widthStep) + x;
				for (int xx=0; xx<3; xx++) {
					pBlock[i]= pSrc[xx];
					i++;
				}
			}
			// convolution
			int val;
			if (pMsk[x] == 0) {
				// by pass
				val = pBlock[4];
			} else {
				//(1, 5, 1; 5, 40, 5; 1, 5, 1) / 64
				val = ( (pBlock[0] + pBlock[2] + pBlock[6] + pBlock[8]) + 
					    (pBlock[1] + pBlock[3] + pBlock[5] + pBlock[7]) * 5 + pBlock[4] * 40 ) >> 6;
				//val = ( (pBlock[0] + pBlock[2] + pBlock[6] + pBlock[8]) + 
				//	    (pBlock[1] + pBlock[3] + pBlock[5] + pBlock[7]) + pBlock[4] ) / 9;
			}
			// write back
			pDst[x] = val;
		}
	}

	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::adaptBox3x3_05_Int_s4(IplImage *iplImage, IplImage *iplDstImage, IplImage *iplMask)
// A fixed-point implementation of the Boxing filter with 3x3 window. Note the boxing filter is actually an 
// approxmiated one to avoid division of 9.
//	Boxing Filter	(3, 4, 3; 4, 4, 4; 3, 4, 3) / 32	if iplMask[x,y] == 0xFF
//	Bypass			(0, 0, 0; 0, 1, 0; 0, 0, 0)			if iplMask[x,y] == 0x00 (others)
// This function supports the "in-place" operation (source and destination images are the same one)
// NOTE: the input bit-depth should be less than 19!
{
	if (iplImage == NULL || iplDstImage == NULL || iplMask == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplMask->nChannels  != 1 ||
		iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S || iplMask->depth != SR_DEPTH_8U)  {
		showErrMsg("Invalid input argument in CImageUtility::adaptBox3x3_05_Int_s4()!\n");
		return false;
	}

	// padding
	IplImage *iplSrcImage = padding(iplImage, 1, 1, 1, 1);
	if (iplSrcImage == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::adaptBox3x3_05_Int_s4()!\n");
		return false;
	}

	// convolution
	int pBlock[9];
	for (int y=0; y<iplDstImage->height; y++) {
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		unsigned char *pMsk = (unsigned char *)((char*)iplMask->imageData + y * iplMask->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			// get 3x3 block
			int i = 0;
			for (int yy=0; yy<3; yy++) {
				int *pSrc = (int *)((char*)iplSrcImage->imageData + (y+yy) * iplSrcImage->widthStep) + x;
				for (int xx=0; xx<3; xx++) {
					pBlock[i]= pSrc[xx];
					i++;
				}
			}
			// convolution
			int val;
			if (pMsk[x] == 0) {
				// bypass this pixel
				val = pBlock[4];
			} else {
				// (3, 4, 3; 4, 4, 4; 3, 4, 3) / 32
				val = ( (pBlock[0] + pBlock[2] + pBlock[6] + pBlock[8]) * 3 + 
					   ((pBlock[1] + pBlock[3] + pBlock[4] + pBlock[5] + pBlock[7]) << 2) ) >> 5;
			}
			// write back
			pDst[x] = val;
		}
	}

	safeReleaseImage(&iplSrcImage);

	return true;
}

bool CImageUtility::adaptBox3x3_05_Int_s4a(IplImage *iplImage, IplImage *iplDstImage, IplImage *iplMask)
// A fixed-point implementation of the Boxing filter with 3x3 window. Note the boxing filter is actually an 
// approxmiated one to avoid division of 9.
//	Boxing Filter	(3, 4, 3; 4, 4, 4; 3, 4, 3) / 32	if iplMask[x,y] == 0xFF
//	Bypass			(0, 0, 0; 0, 1, 0; 0, 0, 0)			if iplMask[x,y] == 0x00 (others)
// Different from adaptBox3x3_05_Int_s4(), this function supposes that the input image has been padded!
// NOTE: the input bit-depth should be less than 19!
{
	if (iplImage == NULL || iplDstImage == NULL || iplMask == NULL ||
		iplImage->nChannels != 1 || iplDstImage->nChannels != 1 || iplMask->nChannels  != 1 ||
		iplImage->depth != SR_DEPTH_32S || iplDstImage->depth != SR_DEPTH_32S || iplMask->depth != SR_DEPTH_8U)  {
		showErrMsg("Invalid input argument in CImageUtility::adaptBox3x3_05_Int_s4a()!\n");
		return false;
	}

	// convolution
	int pBlock[9];
	for (int y=0; y<iplDstImage->height; y++) {
		int *pDst = (int *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		unsigned char *pMsk = (unsigned char *)((char*)iplMask->imageData + y * iplMask->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			// get 3x3 block
			int i = 0;
			for (int yy=0; yy<3; yy++) {
				int *pSrc = (int *)((char*)iplImage->imageData + (y+yy) * iplImage->widthStep) + x;
				for (int xx=0; xx<3; xx++) {
					pBlock[i]= pSrc[xx];
					i++;
				}
			}
			// convolution
			int val;
			if (pMsk[x] == 0) {
				// bypass this pixel
				val = pBlock[4];
			} else {
				// (3, 4, 3; 4, 4, 4; 3, 4, 3) / 32
				val = ( (pBlock[0] + pBlock[2] + pBlock[6] + pBlock[8]) * 3 + 
					   ((pBlock[1] + pBlock[3] + pBlock[4] + pBlock[5] + pBlock[7]) << 2) ) >> 5;
			}
			// write back
			pDst[x] = val;
		}
	}

	return true;
}

bool CImageUtility::inter1to2BLBicubic_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float fSigmaRange)
// Interpolate image using bicubic function followed by a decomposed bilateral filter. 
// Interpolation filter is [ -0.0625 0.5625 0.5625  -0.0625 ]
// Spatial filter of BL is [ 1/16 15/16 15/16 1/16]
//		iplInitImage -- [I] initial interpolated image, sized Wl x Hl
//		iplDstImage -- [O] result image, sized Wh x Hh
//		fSigmaRange -- [I] range parameter
// by Luhong Liang, IC-ASD, ASTRI, Oct. 17, 2012
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels !=1) {
		showErrMsg("Invalid input image in inter1to2BLBicubic_32f()!\n");
		return false;
	}
	if (iplSrcImage->width * 2 != iplDstImage->width || 
		iplSrcImage->height * 2 != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in inter1to2BLBicubic_32f()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in inter1to2BLBicubic_32f()!\n");
		return false;
	}

	// allocate temp buffer
	IplImage *iplTemp = createImage( iplDstImage->width, iplSrcImage->height, SR_DEPTH_32F, 1 );
	if (iplTemp == NULL) {
		showErrMsg("Fail to allocate buffer in inter1to2BLBicubic_32f()!\n");
		return false;
	}

	// prepare LUT for range filter, TODO: can reduce the table size according to range sigma!
	float *pRangeLUT = new float[512];
	if (pRangeLUT == NULL) {
		showErrMsg("Fail to allocate buffer in inter1to2BLBicubic_32f()!\n");
		releaseImage(&iplTemp);
		return false;
	}
	float div = 1.0f / (2.0f * fSigmaRange * fSigmaRange);
	for (int i=0; i<256; i++) {
		float value = (float)exp(- i * i * div);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
        pRangeLUT[256+i] = value;
		pRangeLUT[256-i] = pRangeLUT[256+i];
	}

	// interpolate in X direction
	for (int y=0; y<iplSrcImage->height; y++) {
		float *pSrc = (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);	// NOTE: widthStep is counted by BYTE!
		float *pDst = (float*)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		// first & second point
		pDst[0] = pSrc[0];
		pDst[1] = pSrc[0] * 0.5f + pSrc[1] * 0.5625f - pSrc[2] * 0.0625f;
		// others
		for (int x=1; x<iplSrcImage->width-2; x++) {
			int xx = x * 2;
			pDst[xx] = pSrc[x];
			float init_pix =  - 0.0625f * ( pSrc[x-1] + pSrc[x+2] ) + 0.5625f * ( pSrc[x] + pSrc[x+1] );	// bicubic
            init_pix = init_pix < 0.0f ? 0.0f : init_pix;       // clipping (20140204)
            init_pix = init_pix > 255.0f ? 255.0f : init_pix;
			float wn = pRangeLUT[256+(int)(pSrc[x-1]-init_pix)];
			float w0 = pRangeLUT[256+(int)(pSrc[x]-init_pix)];
			float w1 = pRangeLUT[256+(int)(pSrc[x+1]-init_pix)];
			float w2 = pRangeLUT[256+(int)(pSrc[x+2]-init_pix)];
			//float div = - 0.0625f * ( wn + w2 ) + 0.5625f * ( w0 + w1 );	// Do NOT use bicubic here, since it is not convex any more!
			float div = 0.0625f * ( wn + w2 ) + 0.9375f * ( w0 + w1 );		// Gaussian filtering [1/16, 15/16, 15/16, 1/16]
			if (div <= 0.0f) {
				init_pix = init_pix;
			} else {
				//init_pix = ( -0.0625f * ( pSrc[x-1]*wn + pSrc[x+2]*w2 ) + 0.5625f * ( pSrc[x]*w0 + pSrc[x+1]*w1 )) / div; 
				init_pix = (0.0625f * ( pSrc[x-1]*wn + pSrc[x+2]*w2 ) + 0.9375f * ( pSrc[x]*w0 + pSrc[x+1]*w1 )) / div; 
			}
			pDst[xx+1] = init_pix; 
			// must apply clipping, otherwise, it may exceed the boundary of the LUT!!!
			//if (init_pix < 0.0f)
			//	pDst[xx+1] = 0.0f;
			//else if (init_pix > 255.0f) 
			//	pDst[xx+1] = 255.0f;
			//else
			//	pDst[xx+1] = init_pix; 
		}
		// remaining points
		int xx = (iplSrcImage->width-2) * 2;
		pDst[xx] = pSrc[iplSrcImage->width-2];
		pDst[xx+1] = - 0.0625f * pSrc[iplSrcImage->width-3] + 0.5625f * pSrc[iplSrcImage->width-2] + 0.5f * pSrc[iplSrcImage->width-1];
		pDst[xx+2] = pSrc[iplSrcImage->width-1];
		pDst[xx+3] = - 0.0625f * pSrc[iplSrcImage->width-2] + 1.0625f * pSrc[iplSrcImage->width-1];
	}

	//saveImage("_BiBicubic_X.bmp", iplTemp);

	// interpolate in Y direction
	memcpy(iplDstImage->imageData, iplTemp->imageData, iplDstImage->widthStep);

	float *pSrc0 = (float*)((char *)iplTemp->imageData);
	float *pSrc1 = (float*)((char *)iplTemp->imageData + iplTemp->widthStep);
	float *pSrc2 = (float*)((char *)iplTemp->imageData + 2 * iplTemp->widthStep);
	float *pDst = (float*)((char *)iplDstImage->imageData + iplDstImage->widthStep);
	for (int x=0; x<iplDstImage->width; x++) {
		pDst[x] = pSrc0[x] * 0.5f + pSrc1[x] * 0.5625f - pSrc2[x] * 0.0625f;
	}

	for (int y=1; y<iplTemp->height-2; y++) {
		float *pSrcN = (float*)((char *)iplTemp->imageData + (y-1) * iplTemp->widthStep);	
		float *pSrc0 = (float*)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		float *pSrc1 = (float*)((char *)iplTemp->imageData + (y+1) * iplTemp->widthStep);
		float *pSrc2 = (float*)((char *)iplTemp->imageData + (y+2) * iplTemp->widthStep);
		memcpy((unsigned char *)iplDstImage->imageData + 2 * y * iplDstImage->widthStep, (unsigned char *)pSrc0, iplDstImage->widthStep);
		float *pDst = (float*)((char *)iplDstImage->imageData + ( 2 * y + 1) * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			float init_pix = - 0.0625f * ( pSrcN[x] + pSrc2[x] ) + 0.5625f * ( pSrc0[x] + pSrc1[x] );
            init_pix = init_pix < 0.0f ? 0.0f : init_pix;       // clipping (20140204)
            init_pix = init_pix > 255.0f ? 255.0f : init_pix;
			float wn = pRangeLUT[256+(int)(pSrcN[x]-init_pix)];
			float w0 = pRangeLUT[256+(int)(pSrc0[x]-init_pix)];
			float w1 = pRangeLUT[256+(int)(pSrc1[x]-init_pix)];
			float w2 = pRangeLUT[256+(int)(pSrc2[x]-init_pix)];
			float div = 0.0625f * ( wn + w2 ) + 0.9375f * ( w0 + w1 );		// Gaussian filtering [1/16, 15/16, 15/16, 1/16]
			if (div <= 0.0f) {
				pDst[x] = init_pix;
			} else {
				pDst[x] = (0.0625f * ( pSrcN[x]*wn + pSrc2[x]*w2 ) + 0.9375f * ( pSrc0[x]*w0 + pSrc1[x]*w1 )) / div;
				//pDst[x] = (- 0.0625f * ( pSrcN[x]*wn + pSrc2[x]*w2 ) + 0.5625f * ( pSrc0[x]*w0 + pSrc1[x]*w1 )) / div;
			}
		}
	}
		
	int yy = (iplTemp->height-2) * 2;
	memcpy((unsigned char *)iplDstImage->imageData + yy * iplDstImage->widthStep, (unsigned char *)iplTemp->imageData + (iplTemp->height-2) * iplTemp->widthStep, iplDstImage->widthStep);

	float *pSrcN3 = (float*)((char *)iplTemp->imageData + (iplTemp->height-3) * iplTemp->widthStep);
	float *pSrcN2 = (float*)((char *)iplTemp->imageData + (iplTemp->height-2) * iplTemp->widthStep);
	float *pSrcN1 = (float*)((char *)iplTemp->imageData + (iplTemp->height-1) * iplTemp->widthStep);
	pDst = (float*)((char *)iplDstImage->imageData + (iplDstImage->height-3) * iplDstImage->widthStep);
	for (int x=0; x<iplDstImage->width; x++) {
		pDst[x] = - 0.0625f * pSrcN3[x] + 0.5625f * pSrcN2[x] + 0.5f * pSrcN1[x];
	}

	pDst = (float*)((char *)iplDstImage->imageData + (iplDstImage->height-2) * iplDstImage->widthStep);
	memcpy((unsigned char *)pDst, (unsigned char *)pSrcN1, iplDstImage->widthStep);

	pDst = (float*)((char *)iplDstImage->imageData + (iplDstImage->height-1) * iplDstImage->widthStep);
	for (int x=0; x<iplDstImage->width; x++) {
		pDst[x] = - 0.0625f * pSrcN2[x] + 1.0625f * pSrcN1[x];
	}

	releaseImage(&iplTemp);

	delete [] pRangeLUT;

	return true;
}

bool CImageUtility::inter1to2BLBicubic_32f(IplImage *iplSrcImage, IplImage *iplRangeImage, IplImage *iplDstImage, float fSigmaRange)
// Interpolate image using bicubic function followed by a decomposed bilateral filter. This function is specially designed for 
// Bilateral Interative Back-Projection (BLIBP), where the range filter is computed using a range image (iplRangeImage). In BLIBP,
// the input image is the difference image, and the iplRangeImage is the reconstructed HR image.
// Interpolation filter is [ -0.0625 0.5625 0.5625  -0.0625 ]
// Spatial filter of BL is [ 1/16 15/16 15/16 1/16]
//		iplInitImage -- [I] initial interpolated image, sized Wl x Hl
//		iplRangeImage -- [I] image to get range difference, sized Wh x Hh
//		iplDstImage -- [O] result image, sized Wh x Hh
//		fSigmaRange -- [I] range parameter
// by Luhong Liang, IC-ASD, ASTRI, Oct. 17, 2012
{
	// check input parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplRangeImage == NULL || iplSrcImage->nChannels !=1 || 
		iplDstImage->nChannels != 1 || iplRangeImage->nChannels !=1) {
		showErrMsg("Invalid input image in inter1to2BLBicubic_32f()!\n");
		return false;
	}
	if (iplSrcImage->width * 2 != iplDstImage->width || iplSrcImage->height * 2 != iplDstImage->height ||
		iplRangeImage->width != iplDstImage->width || iplRangeImage->height != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in inter1to2BLBicubic_32f()!\n");
		return false;
	}
	if (iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F || iplRangeImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in inter1to2BLBicubic_32f()!\n");
		return false;
	}

	// allocate temp buffer
	IplImage *iplTemp = createImage( iplDstImage->width, iplSrcImage->height, SR_DEPTH_32F, 1 );
	if (iplTemp == NULL) {
		showErrMsg("Fail to allocate buffer in inter1to2BLBicubic_32f()!\n");
		return false;
	}

	// prepare LUT for range filter, TODO: can reduce the table size according to range sigma!
	//float *pRangeLUT = new float[512];
	float pRangeLUT[512];
	//if (pRangeLUT == NULL) {
	//	showErrMsg("Fail to allocate buffer in inter1to2BLBicubic_32f()!\n");
	//	releaseImage(&iplTemp);
	//	return false;
	//}
	float div = 1.0f / (2.0f * fSigmaRange * fSigmaRange);
	for (int i=0; i<256; i++) {
		float factor = (float)exp(- i * i * div);
		factor = factor < 0.002f ? 0.0f : factor;
		pRangeLUT[256+i] = factor;
		pRangeLUT[256-i] = factor;
	}
	pRangeLUT[0] = 0.0f;

	//float *pTestDst = (float*)((char *)iplDstImage->imageData + 202 * iplDstImage->widthStep);

	// interpolate in X direction
	for (int y=0; y<iplSrcImage->height; y++) {
		float *pSrc = (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);	// NOTE: widthStep is counted by BYTE!
		float *pDst = (float*)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		float *pRange = (float*)((char *)iplRangeImage->imageData + (y<<1) * iplRangeImage->widthStep);
		// first & second point
		pDst[0] = pSrc[0];
		pDst[1] = pSrc[0] * 0.5f + pSrc[1] * 0.5625f - pSrc[2] * 0.0625f;
		// others
		for (int x=1; x<iplSrcImage->width-2; x++) {
			int xx = x * 2;
			pDst[xx] = pSrc[x];
			// get range difference from range image
			// o x o * o x o         <-- 'o' are original pixels, 'x' and '*' are interpolated pixels, '*' is current position
			float mid_pix = pRange[xx+1];
			float wn = pRangeLUT[256+(int)(pRange[xx-2]-mid_pix)];
			float w0 = pRangeLUT[256+(int)(pRange[xx]-mid_pix)];
			float w1 = pRangeLUT[256+(int)(pRange[xx+2]-mid_pix)];
			float w2 = pRangeLUT[256+(int)(pRange[xx+4]-mid_pix)];
			//float div = 0.0625f * ( wn + w2 ) + 0.9375f * ( w0 + w1 );		// Gaussian filtering [1/16, 15/16, 15/16, 1/16]
			float div = 0.125f * ( wn + w2 ) + 0.875f * ( w0 + w1 );			// Gaussian filtering [1/8, 7/8, 7/8, 1/8]
			if (div <= 0.0f) {
				pDst[xx+1] = - 0.0625f * ( pSrc[x-1] + pSrc[x+2] ) + 0.5625f * ( pSrc[x] + pSrc[x+1] );	// bicubic
			} else {
				//pDst[xx+1] = (0.0625f * ( pSrc[x-1]*wn + pSrc[x+2]*w2 ) + 0.9375f * ( pSrc[x]*w0 + pSrc[x+1]*w1 )) / div; 
				pDst[xx+1] = (0.125f * ( pSrc[x-1]*wn + pSrc[x+2]*w2 ) + 0.875f * ( pSrc[x]*w0 + pSrc[x+1]*w1 )) / div; 
			}
		}
		// remaining points
		int xx = (iplSrcImage->width-2) * 2;
		pDst[xx] = pSrc[iplSrcImage->width-2];
		pDst[xx+1] = - 0.0625f * pSrc[iplSrcImage->width-3] + 0.5625f * pSrc[iplSrcImage->width-2] + 0.5f * pSrc[iplSrcImage->width-1];
		pDst[xx+2] = pSrc[iplSrcImage->width-1];
		pDst[xx+3] = - 0.0625f * pSrc[iplSrcImage->width-2] + 1.0625f * pSrc[iplSrcImage->width-1];
	}

	//saveImage("_BiBicubic1_X.bmp", iplTemp);

	// interpolate in Y direction
	memcpy(iplDstImage->imageData, iplTemp->imageData, iplDstImage->widthStep);

	float *pSrc0 = (float*)((char *)iplTemp->imageData);
	float *pSrc1 = (float*)((char *)iplTemp->imageData + iplTemp->widthStep);
	float *pSrc2 = (float*)((char *)iplTemp->imageData + 2 * iplTemp->widthStep);
	float *pDst = (float*)((char *)iplDstImage->imageData + iplDstImage->widthStep);
	for (int x=0; x<iplDstImage->width; x++) {
		pDst[x] = pSrc0[x] * 0.5f + pSrc1[x] * 0.5625f - pSrc2[x] * 0.0625f;
	}

	for (int y=1; y<iplTemp->height-2; y++) {
		float *pSrcN = (float*)((char *)iplTemp->imageData + (y-1) * iplTemp->widthStep);	
		float *pSrc0 = (float*)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		float *pSrc1 = (float*)((char *)iplTemp->imageData + (y+1) * iplTemp->widthStep);
		float *pSrc2 = (float*)((char *)iplTemp->imageData + (y+2) * iplTemp->widthStep);
		float *pRaN = (float*)((char *)iplRangeImage->imageData + (y*2-2) * iplRangeImage->widthStep);
		float *pRa0 = (float*)((char *)iplRangeImage->imageData + (y*2) * iplRangeImage->widthStep);
		float *pRaX = (float*)((char *)iplRangeImage->imageData + (y*2+1) * iplRangeImage->widthStep);
		float *pRa1 = (float*)((char *)iplRangeImage->imageData + (y*2+2) * iplRangeImage->widthStep);
		float *pRa2 = (float*)((char *)iplRangeImage->imageData + (y*2+4) * iplRangeImage->widthStep);
		memcpy((unsigned char *)iplDstImage->imageData + 2 * y * iplDstImage->widthStep, (unsigned char *)pSrc0, iplDstImage->widthStep);
		float *pDst = (float*)((char *)iplDstImage->imageData + ( 2 * y + 1) * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			// get range difference from range image
			// o x o * o x o         <-- 'o' are original pixels, 'x' and '*' are interpolated pixels, '*' is current position
			float wn = pRangeLUT[256+(int)(pRaN[x]-pRaX[x])];
			float w0 = pRangeLUT[256+(int)(pRa0[x]-pRaX[x])];
			float w1 = pRangeLUT[256+(int)(pRa1[x]-pRaX[x])];
			float w2 = pRangeLUT[256+(int)(pRa2[x]-pRaX[x])];
			//float div = 0.0625f * ( wn + w2 ) + 0.9375f * ( w0 + w1 );		// Gaussian filtering [1/16, 15/16, 15/16, 1/16]
			float div = 0.125f * ( wn + w2 ) + 0.875f * ( w0 + w1 );			// Gaussian filtering [1/8, 7/8, 7/8, 1/8]
			if (div <= 0.0f) {
				pDst[x] = - 0.0625f * ( pSrcN[x] + pSrc2[x] ) + 0.5625f * ( pSrc0[x] + pSrc1[x] );		// bicubic
			} else {
				//pDst[x] = (0.0625f * ( pSrcN[x]*wn + pSrc2[x]*w2 ) + 0.9375f * ( pSrc0[x]*w0 + pSrc1[x]*w1 )) / div;		// bilateral-bicubic
				pDst[x] = (0.125f * ( pSrcN[x]*wn + pSrc2[x]*w2 ) + 0.875f * ( pSrc0[x]*w0 + pSrc1[x]*w1 )) / div;		// bilateral-bicubic
				//pDst[x] = (- 0.0625f * ( pSrcN[x]*wn + pSrc2[x]*w2 ) + 0.5625f * ( pSrc0[x]*w0 + pSrc1[x]*w1 )) / div;
			}
		}
	}
		
	int yy = (iplTemp->height-2) * 2;
	memcpy((unsigned char *)iplDstImage->imageData + yy * iplDstImage->widthStep, (unsigned char *)iplTemp->imageData + (iplTemp->height-2) * iplTemp->widthStep, iplDstImage->widthStep);

	float *pSrcN3 = (float*)((char *)iplTemp->imageData + (iplTemp->height-3) * iplTemp->widthStep);
	float *pSrcN2 = (float*)((char *)iplTemp->imageData + (iplTemp->height-2) * iplTemp->widthStep);
	float *pSrcN1 = (float*)((char *)iplTemp->imageData + (iplTemp->height-1) * iplTemp->widthStep);
	pDst = (float*)((char *)iplDstImage->imageData + (iplDstImage->height-3) * iplDstImage->widthStep);
	for (int x=0; x<iplDstImage->width; x++) {
		pDst[x] = - 0.0625f * pSrcN3[x] + 0.5625f * pSrcN2[x] + 0.5f * pSrcN1[x];
	}

	pDst = (float*)((char *)iplDstImage->imageData + (iplDstImage->height-2) * iplDstImage->widthStep);
	memcpy((unsigned char *)pDst, (unsigned char *)pSrcN1, iplDstImage->widthStep);

	pDst = (float*)((char *)iplDstImage->imageData + (iplDstImage->height-1) * iplDstImage->widthStep);
	for (int x=0; x<iplDstImage->width; x++) {
		pDst[x] = - 0.0625f * pSrcN2[x] + 1.0625f * pSrcN1[x];
	}

	releaseImage(&iplTemp);

	//delete [] pRangeLUT;

	return true;
}

bool CImageUtility::resize_1to2_BLbicu_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float fSigmaRange)
// Resize image of magification factor of 2 while a bilteral filter is applied to reduce artifacts. 
// The sampling location is the same as OpenCV! The sample locations are (1-D) as example:
//	 -2         -1          0           1            2  <-- original mage
//                       o     o     o     o     o		 <-- resized image
// The coefficients and indice are
// -0.0351563	0.2617188	0.8789063	-0.1054688		-2	-1	0	1
// -0.1054688	0.8789063	0.2617188	-0.0351563		-1	0	1	2
// The sigma of spatial filter is fixed to 1.0.
// Luhong Liang, IC-ASD, ASTRI
// Feb. 5, 2014
{
	// check parameters
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->nChannels != 1 || iplDstImage->nChannels != 1 ||
		iplSrcImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image type in CImageUtility::resize_1to2_BLbicu_32f()!\n");
		return false;
	}
	if (iplSrcImage->width*2 != iplDstImage->width || iplSrcImage->height*2 != iplDstImage->height) {
		showErrMsg("Only support 1:2 upsampling in CImageUtility::resize_1to2_BLbicu_32f()!\n");
		return false;
	}

	// prepare LUT for range filter, TODO: can reduce the table size according to range sigma!
	float *pRLBuffer = new float[516];      // more bins as barrier
    float *pRL = &(pRLBuffer[2]);
	if (pRL == NULL) {
		showErrMsg("Fail to allocate buffer in resize_1to2_BLbicu_32f()!\n");
		return false;
	}
	float div = 1.0f / (2.0f * fSigmaRange * fSigmaRange);
	for (int i=0; i<256; i++) {
		float value = (float)exp(- i * i * div);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
        pRL[256+i] = value;
		pRL[256-i] = pRL[256+i];
	}
    pRL[-1] = pRL[0]; pRL[-2] = pRL[0];
    pRL[512] = pRL[511]; pRL[513] = pRL[511];

    // clipping (half more level to preserve precision)
    for (int y=0; y<iplSrcImage->height; y++) {
        float *pSrc = (float*)((char *)iplSrcImage->imageData + y * iplSrcImage->widthStep);
        for (int x=0; x<iplSrcImage->width; x++) {
            float val = pSrc[x];
            val = val < -0.5f ? -0.5f : val;
            val = val > 255.5f ? 255.5f : val;
            pSrc[x] = val;
        }
    }

	// padding
	IplImage *iplSrcPad = padding(iplSrcImage, 2, 2, 2, 2);
	if (iplSrcPad == NULL) {
        delete [] pRL;
        return false;
    }

    // interpolation and filtering
    float B[16], val, px, weight;
    for (int y=0; y<=iplSrcImage->height; y++) {
        float *pSrc0 = (float*)((char *)iplSrcPad->imageData + y * iplSrcPad->widthStep);
        float *pSrc1 = (float*)((char *)iplSrcPad->imageData + (y+1) * iplSrcPad->widthStep);
        float *pSrc2 = (float*)((char *)iplSrcPad->imageData + (y+2) * iplSrcPad->widthStep);
        float *pSrc3 = (float*)((char *)iplSrcPad->imageData + (y+3) * iplSrcPad->widthStep);
        float *pDst0 = (float*)((char *)iplDstImage->imageData + (y*2-1) * iplDstImage->widthStep);
        float *pDst1 = (float*)((char *)iplDstImage->imageData + (y*2) * iplDstImage->widthStep);
        for (int x=0; x<=iplSrcImage->width; x++) {
            // fetch data
            B[0] = pSrc0[x];   B[1] = pSrc0[x+1];   B[2] = pSrc0[x+2];   B[3] = pSrc0[x+3];
            B[4] = pSrc1[x];   B[5] = pSrc1[x+1];   B[6] = pSrc1[x+2];   B[7] = pSrc1[x+3];
            B[8] = pSrc2[x];   B[9] = pSrc2[x+1];   B[10] = pSrc2[x+2];  B[11] = pSrc2[x+3];
            B[12] = pSrc3[x];  B[13] = pSrc3[x+1];  B[14] = pSrc3[x+2];  B[15] = pSrc3[x+3];

            //if (x==(1270/2) && (y==536/2)) 
            //    int p = 12;

            // A (upper left)
            if (y>=1 && x>=1) {
                px =            // bicubic for fallback
                    B[0]*0.0111237f - B[1]*0.0926971f - B[2]*0.0276031f + B[3]*0.0037079f       //0.0111237	-0.0926971	-0.0276031	0.0037079
                  - B[4]*0.0926971f + B[5]*0.7724762f + B[6]*0.2300262f - B[7]*0.0308990f       //-0.0926971	0.7724762	0.2300262	-0.0308990
                  - B[8]*0.0276031f + B[9]*0.2300262f + B[10]*0.0684967f - B[11]*0.0092010f     //-0.0276031	0.2300262	0.0684967	-0.0092010
                  + B[12]*0.0037079f - B[13]*0.0308990f - B[14]*0.0092010f + B[15]*0.0012360f;  //0.0037079	-0.0308990	-0.0092010	0.0012360
                px = px < -0.5f ? -0.5f : px;         // (half more level to preserve precision)
                px = px > 255.5f ? 255.5f : px;

                weight = 
                    pRL[256+(int)(B[0]-px)]*0.002362109f - pRL[256+(int)(B[1]-px)]*0.04167154f - pRL[256+(int)(B[2]-px)]*0.009664029f + pRL[256+(int)(B[3]-px)]*0.000371927f        //0.002362109	-0.04167154	-0.009664029	0.000371927
                  - pRL[256+(int)(B[4]-px)]*0.04167154f + pRL[256+(int)(B[5]-px)]*0.735155432f + pRL[256+(int)(B[6]-px)]*0.170489577f - pRL[256+(int)(B[7]-px)]*0.006561414f        //-0.04167154	0.735155432	0.170489577	-0.006561414
                  - pRL[256+(int)(B[8]-px)]*0.009664029f + pRL[256+(int)(B[9]-px)]*0.170489577f + pRL[256+(int)(B[10]-px)]*0.039538164f - pRL[256+(int)(B[11]-px)]*0.001521655f     //-0.009664029	0.170489577	0.039538164	-0.001521655
                  + pRL[256+(int)(B[12]-px)]*0.000371927f - pRL[256+(int)(B[13]-px)]*0.006561414f - pRL[256+(int)(B[14]-px)]*0.001521655f + pRL[256+(int)(B[15]-px)]*5.8562E-05f;   // 0.000371927	-0.006561414	-0.001521655	5.8562E-05

                val = 
                    pRL[256+(int)(B[0]-px)]*B[0]*0.002362109f - pRL[256+(int)(B[1]-px)]*B[1]*0.04167154f - pRL[256+(int)(B[2]-px)]*B[2]*0.009664029f + pRL[256+(int)(B[3]-px)]*B[3]*0.000371927f        //0.002362109	-0.04167154	-0.009664029	0.000371927
                  - pRL[256+(int)(B[4]-px)]*B[4]*0.04167154f + pRL[256+(int)(B[5]-px)]*B[5]*0.735155432f + pRL[256+(int)(B[6]-px)]*B[6]*0.170489577f - pRL[256+(int)(B[7]-px)]*B[7]*0.006561414f        //-0.04167154	0.735155432	0.170489577	-0.006561414
                  - pRL[256+(int)(B[8]-px)]*B[8]*0.009664029f + pRL[256+(int)(B[9]-px)]*B[9]*0.170489577f + pRL[256+(int)(B[10]-px)]*B[10]*0.039538164f - pRL[256+(int)(B[11]-px)]*B[11]*0.001521655f     //-0.009664029	0.170489577	0.039538164	-0.001521655
                  + pRL[256+(int)(B[12]-px)]*B[12]*0.000371927f - pRL[256+(int)(B[13]-px)]*B[13]*0.006561414f - pRL[256+(int)(B[14]-px)]*B[14]*0.001521655f + pRL[256+(int)(B[15]-px)]*B[15]*5.8562E-05f;   // 0.000371927	-0.006561414	-0.001521655	5.8562E-05

                if (weight <= 0.03125f) {
                    val = px;      // fallback
                } else if (weight <= 0.0625f) {
                    val = val / weight;
                    val = (val * (weight - 0.03125f) + px * (0.0625f - weight)) / 0.03125f;
                } else {
                    val = val / weight;
                }
                pDst0[x*2-1] = val;
            }

            // B (upper right)
            if (y>=1 && x<iplSrcImage->width) {
                px =            // bicubic for fallback
                    B[0]*0.0037079f - B[1]*0.0276031f - B[2]*0.0926971f + B[3]*0.0111237f       //0.0037079	-0.0276031	-0.0926971	0.0111237
                  - B[4]*0.0308990f + B[5]*0.2300262f + B[6]*0.7724762f - B[7]*0.0926971f       //-0.0308990	0.2300262	0.7724762	-0.0926971
                  - B[8]*0.0092010f + B[9]*0.0684967f + B[10]*0.2300262f - B[11]*0.0276031f     //-0.0092010	0.0684967	0.2300262	-0.0276031
                  + B[12]*0.0012360f - B[13]*0.0092010f - B[14]*0.0308990f + B[15]*0.0037079f;  //0.0012360	-0.0092010	-0.0308990	0.0037079
                px = px < -0.5f ? -0.5f : px;         // (half more level to preserve precision)
                px = px > 255.5f ? 255.5f : px;

                weight = 
                    pRL[256+(int)(B[0]-px)]*0.000371927f - pRL[256+(int)(B[1]-px)]*0.009664029f - pRL[256+(int)(B[2]-px)]*0.04167154f + pRL[256+(int)(B[3]-px)]*0.002362109f        // 0.000371927	-0.009664029	-0.04167154	0.002362109
                  - pRL[256+(int)(B[4]-px)]*0.006561414f + pRL[256+(int)(B[5]-px)]*0.170489577f + pRL[256+(int)(B[6]-px)]*0.735155432f - pRL[256+(int)(B[7]-px)]*0.04167154f        //-0.006561414	0.170489577	0.735155432	-0.04167154
                  - pRL[256+(int)(B[8]-px)]*0.001521655f + pRL[256+(int)(B[9]-px)]*0.039538164f + pRL[256+(int)(B[10]-px)]*0.170489577f - pRL[256+(int)(B[11]-px)]*0.009664029f     //-0.001521655	0.039538164	0.170489577	-0.009664029
                  + pRL[256+(int)(B[12]-px)]*5.8562E-05f - pRL[256+(int)(B[13]-px)]*0.001521655f - pRL[256+(int)(B[14]-px)]*0.006561414f + pRL[256+(int)(B[15]-px)]*0.000371927f;   //5.8562E-05	-0.001521655	-0.006561414	0.000371927

                val = 
                    pRL[256+(int)(B[0]-px)]*B[0]*0.000371927f - pRL[256+(int)(B[1]-px)]*B[1]*0.009664029f - pRL[256+(int)(B[2]-px)]*B[2]*0.04167154f + pRL[256+(int)(B[3]-px)]*B[3]*0.002362109f        // 0.000371927	-0.009664029	-0.04167154	0.002362109
                  - pRL[256+(int)(B[4]-px)]*B[4]*0.006561414f + pRL[256+(int)(B[5]-px)]*B[5]*0.170489577f + pRL[256+(int)(B[6]-px)]*B[6]*0.735155432f - pRL[256+(int)(B[7]-px)]*B[7]*0.04167154f        //-0.006561414	0.170489577	0.735155432	-0.04167154
                  - pRL[256+(int)(B[8]-px)]*B[8]*0.001521655f + pRL[256+(int)(B[9]-px)]*B[9]*0.039538164f + pRL[256+(int)(B[10]-px)]*B[10]*0.170489577f - pRL[256+(int)(B[11]-px)]*B[11]*0.009664029f     //-0.001521655	0.039538164	0.170489577	-0.009664029
                  + pRL[256+(int)(B[12]-px)]*B[12]*5.8562E-05f - pRL[256+(int)(B[13]-px)]*B[13]*0.001521655f - pRL[256+(int)(B[14]-px)]*B[14]*0.006561414f + pRL[256+(int)(B[15]-px)]*B[15]*0.000371927f;   //5.8562E-05	-0.001521655	-0.006561414	0.000371927

                if (weight <= 0.03125f) {
                    val = px;      // fallback
                } else if (weight <= 0.0625f) {
                    val = val / weight;
                    val = (val * (weight - 0.03125f) + px * (0.0625f - weight)) / 0.03125f;
                } else {
                    val = val / weight;
                }
                pDst0[x*2] = val;
            }

            // C (lower left)
            if (y<iplSrcImage->height && x>=1) {
                px =            // bicubic for fallback
                    B[0]*0.0037079f - B[1]*0.0308990f - B[2]*0.0092010f + B[3]*0.0012360f       //0.0037079	-0.0308990	-0.0092010	0.0012360
                  - B[4]*0.0276031f + B[5]*0.2300262f + B[6]*0.0684967f - B[7]*0.0092010f       //-0.0276031	0.2300262	0.0684967	-0.0092010
                  - B[8]*0.0926971f + B[9]*0.7724762f + B[10]*0.2300262f - B[11]*0.0308990f     //-0.0926971	0.7724762	0.2300262	-0.0308990
                  + B[12]*0.0111237f - B[13]*0.0926971f - B[14]*0.0276031f - B[15]*0.0037079f;  //0.0111237	-0.0926971	-0.0276031	0.0037079
                px = px < -0.5f ? -0.5f : px;         // (half more level to preserve precision)
                px = px > 255.5f ? 255.5f : px;

                weight = 
                    pRL[256+(int)(B[0]-px)]*0.000371927f - pRL[256+(int)(B[1]-px)]*0.006561414f - pRL[256+(int)(B[2]-px)]*0.001521655f + pRL[256+(int)(B[3]-px)]*5.8562E-05f        //0.000371927	-0.006561414	-0.001521655	5.8562E-05
                  - pRL[256+(int)(B[4]-px)]*0.009664029f + pRL[256+(int)(B[5]-px)]*0.170489577f + pRL[256+(int)(B[6]-px)]*0.039538164f - pRL[256+(int)(B[7]-px)]*0.001521655f       //-0.009664029	0.170489577	0.039538164	-0.001521655
                  - pRL[256+(int)(B[8]-px)]*0.04167154f + pRL[256+(int)(B[9]-px)]*0.735155432f + pRL[256+(int)(B[10]-px)]*0.170489577f - pRL[256+(int)(B[11]-px)]*0.006561414f      //-0.04167154	0.735155432	0.170489577	-0.006561414
                  + pRL[256+(int)(B[12]-px)]*0.002362109f - pRL[256+(int)(B[13]-px)]*0.04167154f - pRL[256+(int)(B[14]-px)]*0.009664029f + pRL[256+(int)(B[15]-px)]*0.000371927f;   //0.002362109	-0.04167154	-0.009664029	0.000371927

                val = 
                    pRL[256+(int)(B[0]-px)]*B[0]*0.000371927f - pRL[256+(int)(B[1]-px)]*B[1]*0.006561414f - pRL[256+(int)(B[2]-px)]*B[2]*0.001521655f + pRL[256+(int)(B[3]-px)]*B[3]*5.8562E-05f        //0.000371927	-0.006561414	-0.001521655	5.8562E-05
                  - pRL[256+(int)(B[4]-px)]*B[4]*0.009664029f + pRL[256+(int)(B[5]-px)]*B[5]*0.170489577f + pRL[256+(int)(B[6]-px)]*B[6]*0.039538164f - pRL[256+(int)(B[7]-px)]*B[7]*0.001521655f       //-0.009664029	0.170489577	0.039538164	-0.001521655
                  - pRL[256+(int)(B[8]-px)]*B[8]*0.04167154f + pRL[256+(int)(B[9]-px)]*B[9]*0.735155432f + pRL[256+(int)(B[10]-px)]*B[10]*0.170489577f - pRL[256+(int)(B[11]-px)]*B[11]*0.006561414f      //-0.04167154	0.735155432	0.170489577	-0.006561414
                  + pRL[256+(int)(B[12]-px)]*B[12]*0.002362109f - pRL[256+(int)(B[13]-px)]*B[13]*0.04167154f - pRL[256+(int)(B[14]-px)]*B[14]*0.009664029f + pRL[256+(int)(B[15]-px)]*B[15]*0.000371927f;   //0.002362109	-0.04167154	-0.009664029	0.000371927

                if (weight <= 0.03125f) {
                    val = px;      // fallback
                } else if (weight <= 0.0625f) {
                    val = val / weight;
                    val = (val * (weight - 0.03125f) + px * (0.0625f - weight)) / 0.03125f;
                } else {
                    val = val / weight;
                }
                pDst1[x*2-1] = val;
            }

            // D (lower right)
            if (y<iplSrcImage->height && x<iplSrcImage->width) {
                px =            // bicubic for fallback
                    B[0]*0.0012360f - B[1]*0.0092010f - B[2]*0.0308990f + B[3]*0.0037079f       //0.0012360	-0.0092010	-0.0308990	0.0037079
                  - B[4]*0.0092010f + B[5]*0.0684967f + B[6]*0.2300262f - B[7]*0.0276031f       //-0.0092010	0.0684967	0.2300262	-0.0276031
                  - B[8]*0.0308990f + B[9]*0.2300262f + B[10]*0.7724762f - B[11]*0.0926971f     //-0.0308990	0.2300262	0.7724762	-0.0926971
                  + B[12]*0.0037079f - B[13]*0.0276031f - B[14]*0.0926971f + B[15]*0.0111237f;  //0.0037079	-0.0276031	-0.0926971	0.0111237
                px = px < -0.5f ? -0.5f : px;         // (half more level to preserve precision)
                px = px > 255.5f ? 255.5f : px;

                weight = 
                    pRL[256+(int)(B[0]-px)]*5.8562E-05f - pRL[256+(int)(B[1]-px)]*0.001521655f - pRL[256+(int)(B[2]-px)]*0.006561414f + pRL[256+(int)(B[3]-px)]*0.000371927f        //5.8562E-05	-0.001521655	-0.006561414	0.000371927
                  - pRL[256+(int)(B[4]-px)]*0.001521655f + pRL[256+(int)(B[5]-px)]*0.039538164f + pRL[256+(int)(B[6]-px)]*0.170489577f - pRL[256+(int)(B[7]-px)]*0.009664029f       //-0.001521655	0.039538164	0.170489577	-0.009664029
                  - pRL[256+(int)(B[8]-px)]*0.006561414f + pRL[256+(int)(B[9]-px)]*0.170489577f + pRL[256+(int)(B[10]-px)]*0.735155432f - pRL[256+(int)(B[11]-px)]*0.04167154f      //-0.006561414	0.170489577	0.735155432	-0.04167154
                  + pRL[256+(int)(B[12]-px)]*0.000371927f - pRL[256+(int)(B[13]-px)]*0.009664029f - pRL[256+(int)(B[14]-px)]*0.04167154f + pRL[256+(int)(B[15]-px)]*0.002362109f;   //0.000371927	-0.009664029	-0.04167154	0.002362109

                val = 
                    pRL[256+(int)(B[0]-px)]*B[0]*5.8562E-05f - pRL[256+(int)(B[1]-px)]*B[1]*0.001521655f - pRL[256+(int)(B[2]-px)]*B[2]*0.006561414f + pRL[256+(int)(B[3]-px)]*B[3]*0.000371927f        //5.8562E-05	-0.001521655	-0.006561414	0.000371927
                  - pRL[256+(int)(B[4]-px)]*B[4]*0.001521655f + pRL[256+(int)(B[5]-px)]*B[5]*0.039538164f + pRL[256+(int)(B[6]-px)]*B[6]*0.170489577f - pRL[256+(int)(B[7]-px)]*B[7]*0.009664029f       //-0.001521655	0.039538164	0.170489577	-0.009664029
                  - pRL[256+(int)(B[8]-px)]*B[8]*0.006561414f + pRL[256+(int)(B[9]-px)]*B[9]*0.170489577f + pRL[256+(int)(B[10]-px)]*B[10]*0.735155432f - pRL[256+(int)(B[11]-px)]*B[11]*0.04167154f      //-0.006561414	0.170489577	0.735155432	-0.04167154
                  + pRL[256+(int)(B[12]-px)]*B[12]*0.000371927f - pRL[256+(int)(B[13]-px)]*B[13]*0.009664029f - pRL[256+(int)(B[14]-px)]*B[14]*0.04167154f + pRL[256+(int)(B[15]-px)]*B[15]*0.002362109f;   //0.000371927	-0.009664029	-0.04167154	0.002362109

                if (weight <= 0.03125f) {
                    val = px;      // fallback
                } else if (weight <= 0.0625f) {
                    val = val / weight;
                    val = (val * (weight - 0.03125f) + px * (0.0625f - weight)) / 0.03125f;
                } else {
                    val = val / weight;
                }
                pDst1[x*2] = val;
            }
        }
    }

    delete [] pRLBuffer;
    safeReleaseImage(&iplSrcPad);

    return true;
}

bool CImageUtility::bilatFilterXY_32f(IplImage *iplInitImage, IplImage *iplRangeImage, IplImage *iplDstImage, float fSigmaRange)
// X-Y decomposed bilateral filter. This function is specially designed for 
// Bilateral Interative Back-Projection (BLIBP), where the range filter is computed using a range image (iplRangeImage). In BLIBP,
// the input image is the difference image, and the iplRangeImage is the reconstructed HR image.
// Spatial filter of BL is [ 1/16 15/16 15/16 1/16]
// Arguments:
//		iplInitImage -- [I] initial interpolated image, sized Wh x Hh
//		iplRangeImage -- [I] image to get range difference, sized Wh x Hh
//		iplDstImage -- [O] result image, sized Wh x Hh
//		fSigmaRange -- [I] range parameter
// by Luhong Liang, IC-ASD, ASTRI, Oct. 17, 2012
{
	// check input parameters
	if (iplInitImage == NULL || iplDstImage == NULL || iplRangeImage == NULL || iplInitImage->nChannels !=1 || 
		iplDstImage->nChannels != 1 || iplRangeImage->nChannels !=1) {
		showErrMsg("Invalid input image in bilatFilterXY_32f()!\n");
		return false;
	}
	if (iplInitImage->width != iplDstImage->width || iplInitImage->height != iplDstImage->height ||
		iplRangeImage->width != iplDstImage->width || iplRangeImage->height != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in bilatFilterXY_32f()!\n");
		return false;
	}
	if (iplInitImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F || iplRangeImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in bilatFilterXY_32f()!\n");
		return false;
	}
	if (iplDstImage->height != ((iplDstImage->height>>1)<<1)) {
		showErrMsg("Invalid image size in bilatFilterXY_32f()!\n");
		return false;
	}

	// allocate temp buffer
	IplImage *iplTemp = createImage( iplDstImage->width, iplDstImage->height/2, SR_DEPTH_32F, 1 );
	if (iplTemp == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilterXY_32f()!\n");
		return false;
	}

	// prepare LUT for range filter, TODO: can reduce the table size according to range sigma!
	float *pRangeLUT = new float[512];
	if (pRangeLUT == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilterXY_32f()!\n");
		releaseImage(&iplTemp);
		return false;
	}
	float div = 1.0f / (2.0f * fSigmaRange * fSigmaRange);
	for (int i=0; i<256; i++) {
		float value = (float)exp(- i * i * div);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
        pRangeLUT[256+i] = value;
		pRangeLUT[256-i] = pRangeLUT[256+i];
	}

	// interpolate in X direction
	for (int y=0; y<iplTemp->height; y++) {
		float *pSrc = (float*)((char *)iplInitImage->imageData + (y<<1) * iplInitImage->widthStep);	// NOTE: widthStep is counted by BYTE!
		float *pDst = (float*)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		float *pRange = (float*)((char *)iplRangeImage->imageData + (y<<1) * iplRangeImage->widthStep);
		// first & second point
		pDst[0] = pSrc[0];
		pDst[1] = pSrc[1];
		// others
		for (int x=1; x<iplTemp->width-4; x+=2) {
			pDst[x] = pSrc[x];
			float init_pix =  pSrc[x+1];
			// get range difference from range image
			// o x o * o x o         <-- 'o' are original pixels, 'x' and '*' are interpolated pixels, '*' is current position
			float mid_pix = pRange[x+1];
			float wn = pRangeLUT[256+(int)(pRange[x-2]-mid_pix)];
			float w0 = pRangeLUT[256+(int)(pRange[x]-mid_pix)];
			float w1 = pRangeLUT[256+(int)(pRange[x+2]-mid_pix)];
			float w2 = pRangeLUT[256+(int)(pRange[x+4]-mid_pix)];
			float div = 0.0625f * ( wn + w2 ) + 0.9375f * ( w0 + w1 );		// Gaussian filtering [1/16, 15/16, 15/16, 1/16]
			if (div <= 0.0f) {
				pDst[x+1] = init_pix;
			} else {
				pDst[x+1] = (0.0625f * ( pSrc[x-2]*wn + pSrc[x+4]*w2 ) + 0.9375f * ( pSrc[x]*w0 + pSrc[x+2]*w1 )) / div; 
			}
		}
		// remaining points
		int xx = iplTemp->width - 4;
		pDst[xx] = pSrc[xx];
		pDst[xx+1] = pSrc[xx+1];
		pDst[xx+2] = pSrc[xx+2];
		pDst[xx+3] = pSrc[xx+3];
	}

	//saveImage("_BiBicubic1_X.bmp", iplTemp, 128, 4.0f);

	// interpolate in Y direction
	memcpy(iplDstImage->imageData, iplTemp->imageData, iplDstImage->widthStep);

	float *pSrc0 = (float*)((char *)iplTemp->imageData);
	float *pSrc1 = (float*)((char *)iplTemp->imageData + iplTemp->widthStep);
	float *pSrc2 = (float*)((char *)iplTemp->imageData + 2 * iplTemp->widthStep);
	float *pDst = (float*)((char *)iplDstImage->imageData + iplDstImage->widthStep);
	for (int x=0; x<iplDstImage->width; x++) {
		pDst[x] = pSrc0[x] * 0.5f + pSrc1[x] * 0.5625f - pSrc2[x] * 0.0625f;
	}

	for (int y=1; y<iplTemp->height-2; y++) {
		float *pSrcN = (float*)((char *)iplTemp->imageData + (y-1) * iplTemp->widthStep);	
		float *pSrc0 = (float*)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		float *pSrc1 = (float*)((char *)iplTemp->imageData + (y+1) * iplTemp->widthStep);
		float *pSrc2 = (float*)((char *)iplTemp->imageData + (y+2) * iplTemp->widthStep);
		float *pRaN = (float*)((char *)iplRangeImage->imageData + (y*2-2) * iplRangeImage->widthStep);
		float *pRa0 = (float*)((char *)iplRangeImage->imageData + (y*2) * iplRangeImage->widthStep);
		float *pRaX = (float*)((char *)iplRangeImage->imageData + (y*2+1) * iplRangeImage->widthStep);
		float *pRa1 = (float*)((char *)iplRangeImage->imageData + (y*2+2) * iplRangeImage->widthStep);
		float *pRa2 = (float*)((char *)iplRangeImage->imageData + (y*2+4) * iplRangeImage->widthStep);
		float *pCenter = (float*)((char *)iplInitImage->imageData + (y*2+1) * iplInitImage->widthStep);
		memcpy((unsigned char *)iplDstImage->imageData + 2*y * iplDstImage->widthStep, (unsigned char *)pSrc0, iplDstImage->widthStep);
		float *pDst = (float*)((char *)iplDstImage->imageData + (2*y+1) * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			// get range difference from range image
			// o x o * o x o         <-- 'o' are original pixels, 'x' and '*' are interpolated pixels, '*' is current position
			float wn = pRangeLUT[256+(int)(pRaN[x]-pRaX[x])];
			float w0 = pRangeLUT[256+(int)(pRa0[x]-pRaX[x])];
			float w1 = pRangeLUT[256+(int)(pRa1[x]-pRaX[x])];
			float w2 = pRangeLUT[256+(int)(pRa2[x]-pRaX[x])];
			float div = 0.0625f * ( wn + w2 ) + 0.9375f * ( w0 + w1 );		// Gaussian filtering [1/16, 15/16, 15/16, 1/16]
			if (div <= 0.0f) {
				pDst[x] = pCenter[x];
			} else {
				pDst[x] = (0.0625f * ( pSrcN[x]*wn + pSrc2[x]*w2 ) + 0.9775f * ( pSrc0[x]*w0 + pSrc1[x]*w1 )) / div;
				//pDst[x] = (- 0.0625f * ( pSrcN[x]*wn + pSrc2[x]*w2 ) + 0.5625f * ( pSrc0[x]*w0 + pSrc1[x]*w1 )) / div;
			}
		}
	}
		
	int offset = (iplDstImage->height-4) * iplDstImage->widthStep;
	memcpy((unsigned char *)iplDstImage->imageData + offset, (unsigned char *)iplInitImage->imageData + offset, iplInitImage->widthStep*4);

	releaseImage(&iplTemp);

	delete [] pRangeLUT;

	return true;
}

bool CImageUtility::bilatFilterXY_32f(IplImage *iplInitImage, IplImage *iplRangeImage, IplImage *iplEdgeImage, IplImage *iplDstImage, float fSigmaRange)
// X-Y decomposed bilateral filter. This function is specially designed for 
// Bilateral Interative Back-Projection (BLIBP), where the range filter is computed using a range image (iplRangeImage). In BLIBP,
// the input image is the difference image, and the iplRangeImage is the reconstructed HR image.
// Spatial filter of BL is [ 1/16 15/16 15/16 1/16]
// Arguments:
//		iplInitImage -- [I] initial interpolated image, sized Wh x Hh
//		iplRangeImage -- [I] image to get range difference, sized Wh x Hh
//		iplEdgeImage -- [I] edge image to guide the bilateral filter
//		iplDstImage -- [O] result image, sized Wh x Hh
//		fSigmaRange -- [I] range parameter
// by Luhong Liang, IC-ASD, ASTRI, Oct. 17, 2012
{
	// check input parameters
	if (iplInitImage == NULL || iplDstImage == NULL || iplRangeImage == NULL || iplEdgeImage == NULL || iplInitImage->nChannels !=1 || 
		iplDstImage->nChannels != 1 || iplRangeImage->nChannels !=1) {
		showErrMsg("Invalid input image in bilatFilterXY_32f()!\n");
		return false;
	}
	if (iplInitImage->width != iplDstImage->width || iplInitImage->height != iplDstImage->height ||
		iplInitImage->width != iplEdgeImage->width || iplInitImage->height != iplEdgeImage->height ||
		iplRangeImage->width != iplDstImage->width || iplRangeImage->height != iplDstImage->height) {
		showErrMsg("Destination image should be half size of the source image in bilatFilterXY_32f()!\n");
		return false;
	}
	if (iplInitImage->depth != SR_DEPTH_32F || iplDstImage->depth != SR_DEPTH_32F || 
		iplRangeImage->depth != SR_DEPTH_32F || iplEdgeImage->depth != SR_DEPTH_32F) {
		showErrMsg("Invalid input image data type! Should be single precision floating point in bilatFilterXY_32f()!\n");
		return false;
	}
	if (iplDstImage->height != ((iplDstImage->height>>1)<<1)) {
		showErrMsg("Invalid image size in bilatFilterXY_32f()!\n");
		return false;
	}

	// allocate temp buffer
	IplImage *iplTemp = createImage( iplDstImage->width, iplDstImage->height/2, SR_DEPTH_32F, 1 );
	if (iplTemp == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilterXY_32f()!\n");
		return false;
	}

	// prepare LUT for range filter, TODO: can reduce the table size according to range sigma!
	float *pRangeLUT = new float[512];
	if (pRangeLUT == NULL) {
		showErrMsg("Fail to allocate buffer in bilatFilterXY_32f()!\n");
		releaseImage(&iplTemp);
		return false;
	}
	float div = 1.0f / (2.0f * fSigmaRange * fSigmaRange);
	for (int i=0; i<256; i++) {
		float value = (float)exp(- i * i * div);
        value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
        pRangeLUT[256+i] = value;
		pRangeLUT[256-i] = pRangeLUT[256+i];
	}

	// interpolate in X direction
	for (int y=0; y<iplTemp->height; y++) {
		float *pSrc = (float*)((char *)iplInitImage->imageData + (y<<1) * iplInitImage->widthStep);	// NOTE: widthStep is counted by BYTE!
		float *pDst = (float*)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		float *pRange = (float*)((char *)iplRangeImage->imageData + (y<<1) * iplRangeImage->widthStep);
		float *pEdge = (float*)((char *)iplEdgeImage->imageData + (y<<1) * iplEdgeImage->widthStep);
		// first & second point
		pDst[0] = pSrc[0];
		pDst[1] = pSrc[1];
		// others
		for (int x=1; x<iplTemp->width-4; x+=2) {
			pDst[x] = pSrc[x];
			// get range difference from range image
			// o x o * o x o         <-- 'o' are original pixels, 'x' and '*' are interpolated pixels, '*' is current position
			float mid_pix = pRange[x+1];
			float wn = pRangeLUT[256+(int)(pRange[x-2]-mid_pix)];
			float w0 = pRangeLUT[256+(int)(pRange[x]-mid_pix)];
			float w1 = pRangeLUT[256+(int)(pRange[x+2]-mid_pix)];
			float w2 = pRangeLUT[256+(int)(pRange[x+4]-mid_pix)];
			float div = 0.0625f * ( wn + w2 ) + 0.9375f * ( w0 + w1 );		// Gaussian filtering [1/16, 15/16, 15/16, 1/16]
			if (pEdge[x+1] < 128.0f || div <= 0.0f) {
				pDst[x+1] = pSrc[x+1];
			} else {
				pDst[x+1] = (0.0625f * ( pSrc[x-2]*wn + pSrc[x+4]*w2 ) + 0.9375f * ( pSrc[x]*w0 + pSrc[x+2]*w1 )) / div; 
			}
		}
		// remaining points
		int xx = iplTemp->width - 4;
		pDst[xx] = pSrc[xx];
		pDst[xx+1] = pSrc[xx+1];
		pDst[xx+2] = pSrc[xx+2];
		pDst[xx+3] = pSrc[xx+3];
	}

	//saveImage("_BiBicubic1_X.bmp", iplTemp, 128, 4.0f);

	// interpolate in Y direction
	memcpy(iplDstImage->imageData, iplTemp->imageData, iplDstImage->widthStep);

	float *pSrc0 = (float*)((char *)iplTemp->imageData);
	float *pSrc1 = (float*)((char *)iplTemp->imageData + iplTemp->widthStep);
	float *pSrc2 = (float*)((char *)iplTemp->imageData + 2 * iplTemp->widthStep);
	float *pDst = (float*)((char *)iplDstImage->imageData + iplDstImage->widthStep);
	for (int x=0; x<iplDstImage->width; x++) {
		pDst[x] = pSrc0[x] * 0.5f + pSrc1[x] * 0.5625f - pSrc2[x] * 0.0625f;
	}

	for (int y=1; y<iplTemp->height-2; y++) {
		float *pSrcN = (float*)((char *)iplTemp->imageData + (y-1) * iplTemp->widthStep);	
		float *pSrc0 = (float*)((char *)iplTemp->imageData + y * iplTemp->widthStep);
		float *pSrc1 = (float*)((char *)iplTemp->imageData + (y+1) * iplTemp->widthStep);
		float *pSrc2 = (float*)((char *)iplTemp->imageData + (y+2) * iplTemp->widthStep);
		float *pRaN = (float*)((char *)iplRangeImage->imageData + (y*2-2) * iplRangeImage->widthStep);
		float *pRa0 = (float*)((char *)iplRangeImage->imageData + (y*2) * iplRangeImage->widthStep);
		float *pRaX = (float*)((char *)iplRangeImage->imageData + (y*2+1) * iplRangeImage->widthStep);
		float *pRa1 = (float*)((char *)iplRangeImage->imageData + (y*2+2) * iplRangeImage->widthStep);
		float *pRa2 = (float*)((char *)iplRangeImage->imageData + (y*2+4) * iplRangeImage->widthStep);
		float *pCenter = (float*)((char *)iplInitImage->imageData + (y*2+1) * iplInitImage->widthStep);
		float *pEdge = (float*)((char *)iplEdgeImage->imageData + (y*2+1) * iplEdgeImage->widthStep);
		memcpy((unsigned char *)iplDstImage->imageData + 2*y * iplDstImage->widthStep, (unsigned char *)pSrc0, iplDstImage->widthStep);
		float *pDst = (float*)((char *)iplDstImage->imageData + (2*y+1) * iplDstImage->widthStep);
		for (int x=0; x<iplDstImage->width; x++) {
			// get range difference from range image
			// o x o * o x o         <-- 'o' are original pixels, 'x' and '*' are interpolated pixels, '*' is current position
			float wn = pRangeLUT[256+(int)(pRaN[x]-pRaX[x])];
			float w0 = pRangeLUT[256+(int)(pRa0[x]-pRaX[x])];
			float w1 = pRangeLUT[256+(int)(pRa1[x]-pRaX[x])];
			float w2 = pRangeLUT[256+(int)(pRa2[x]-pRaX[x])];
			float div = 0.0625f * ( wn + w2 ) + 0.9375f * ( w0 + w1 );		// Gaussian filtering [1/16, 15/16, 15/16, 1/16]
			if (pEdge[x] < 128.0f || div <= 0.0f) {
				pDst[x] = pCenter[x];
			} else {
				pDst[x] = (0.0625f * ( pSrcN[x]*wn + pSrc2[x]*w2 ) + 0.9775f * ( pSrc0[x]*w0 + pSrc1[x]*w1 )) / div;
				//pDst[x] = (- 0.0625f * ( pSrcN[x]*wn + pSrc2[x]*w2 ) + 0.5625f * ( pSrc0[x]*w0 + pSrc1[x]*w1 )) / div;
			}
		}
	}
		
	int offset = (iplDstImage->height-4) * iplDstImage->widthStep;
	memcpy((unsigned char *)iplDstImage->imageData + offset, (unsigned char *)iplInitImage->imageData + offset, iplInitImage->widthStep*4);

	releaseImage(&iplTemp);

	delete [] pRangeLUT;

	return true;
}

bool CImageUtility::nlmFilter11x5_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float sigma)
// Non-local mean filter with 5x5 patch and 11x11 search window.
// This is a broute force implementation.
// This function supports "in-place" operation. The input and output image should be the same size and type.
// Arguments:
//      iplSrcImage -- [I] input image
//      iplDstImage -- [O] output image; same size and type as the input image
//      sigma -- [I] parameter sigma (standard deviation) in the filter, which controls the weight of each patch
// by Luhong Liang, August, 2014
// Make'sigma' identical to original method, by Luhong, 10/05/2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
		iplSrcImage->nChannels != iplDstImage->nChannels || iplSrcImage->nChannels != 1 || sigma <  0.0f) {
		showErrMsg("Invalide input image or parameter in CImageUtility::nlmFilter11x5_32f()!\n");
		return false;
	}

	if (sigma <= 0.0f) {		// May 7, 2015
		return copy(iplSrcImage, iplDstImage);
	}

    float sigma_denom = 1.0f / (sigma * sigma);

    // padding
    IplImage *iplPadded = padding(iplSrcImage, 7, 7, 7, 7);
    if (iplPadded == NULL) return false;

    /// LUT
    const int exp_lut_max = 128;        // must long engouth to avoid artifact in high contrast text content!
    const int exp_lut_amp = 8;
    const int lut_len = exp_lut_max * exp_lut_amp;
    float pLUT[lut_len];
    for (int i=0; i< lut_len; i++) {
        pLUT[i] = exp( - (float)i / (float)exp_lut_amp);
    }

    // filtering
    float pQuery[25];
    showMessage1("Non-local mean filtering ...");
    float fStartTime = (float)clock() / (float)CLOCKS_PER_SEC;
    for (int y=0; y<iplDstImage->height; y++) {
        float *pDst = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
        if (y%64==0) showMessage1("%d ", y);
        for (int x=0; x<iplDstImage->width; x++) {
            // get query patch
            int i=0;
            for (int yy=y+5; yy<y+10; yy++) {
                float *pQLine = (float *)(iplPadded->imageData + yy * iplPadded->widthStep);
                for (int xx=x+5; xx<x+10; xx++, i++) {
                    pQuery[i] = pQLine[xx];
                }
            }
            // search 11x11 window
            float w_max = 0.0f;
            float sweight = 0.0f;
            float average = 0.0f;
            for (int yy=y; yy<y+11; yy++) {
                float *pLine0 = (float *)(iplPadded->imageData + yy * iplPadded->widthStep);
                float *pLine1 = (float *)(iplPadded->imageData + (yy+1) * iplPadded->widthStep);
                float *pLine2 = (float *)(iplPadded->imageData + (yy+2) * iplPadded->widthStep);
                float *pLine3 = (float *)(iplPadded->imageData + (yy+3) * iplPadded->widthStep);
                float *pLine4 = (float *)(iplPadded->imageData + (yy+4) * iplPadded->widthStep);
                //if ((yy < y+5 || yy > y+7) && (yy-y)%2==1) continue;
                for (int xx=x; xx<x+11; xx++) {
                    //if ((xx < x+5 || xx > x+7) && (xx-x)%2==1) continue;
                    if (xx==x+5 && yy==y+5) continue;
                    // match a patch
                    float diff_total, diff;
                    diff = pQuery[0] - pLine0[xx]; diff = diff * diff; diff_total = diff;
                    diff = pQuery[1] - pLine0[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[2] - pLine0[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[3] - pLine0[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[4] - pLine0[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[5] - pLine1[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[6] - pLine1[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[7] - pLine1[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[8] - pLine1[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[9] - pLine1[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[10] - pLine2[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[11] - pLine2[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[12] - pLine2[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[13] - pLine2[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[14] - pLine2[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[15] - pLine3[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[16] - pLine3[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[17] - pLine3[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[18] - pLine3[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[19] - pLine3[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[20] - pLine4[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[21] - pLine4[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[22] - pLine4[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[23] - pLine4[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[24] - pLine4[xx+4]; diff = diff * diff; diff_total += diff;
                    // calculate weight
                    diff_total = diff_total * sigma_denom;
                    //float w = expf(-diff_total);
                    int idx = (int)(diff_total * exp_lut_amp + 0.5f);
                    idx = idx >=  lut_len ? lut_len - 1 : idx;
                    float w = pLUT[idx];
                    w_max = w > w_max ? w : w_max;
                    // accumulate
                    sweight += w;
                    average += w * pLine2[xx+2];
                }
            }
            // accumulate the central pont
            sweight += w_max;
            average += w_max * pQuery[12];
            // pixel value
            if (sweight > 0.0f) {
                pDst[x] = average / sweight;
            } else {
                pDst[x] = pQuery[12];
            }
        }
    }
    float fRunTime = (float)clock() / (float)CLOCKS_PER_SEC - fStartTime;
    showMessage1("%fs used in non-local mean searching.\n", fRunTime);

    safeReleaseImage(&iplPadded);

    return true;
}

bool CImageUtility::nlmFilter15x7_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float sigma)
// Non-local mean filter with 7x7 patch and 15x15 search window.
// This is a broute force implementation.
// This function supports "in-place" operation. The input and output image should be the same size and type.
// Arguments:
//      iplSrcImage -- [I] input image
//      iplDstImage -- [O] output image; same size and type as the input image
//      sigma -- [I] parameter sigma (standard deviation) in the filter, which controls the weight of each patch
// by Luhong Liang, August, 2014
// Make'sigma' identical to original method, by Luhong, 10/05/2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
		iplSrcImage->nChannels != iplDstImage->nChannels || iplSrcImage->nChannels != 1 || sigma <  0.0f) {
		showErrMsg("Invalide input image or parameter in CImageUtility::nlmFilter15x7_32f()!\n");
		return false;
	}

	if (sigma <= 0.0f) {		// May 7, 2015
		return copy(iplSrcImage, iplDstImage);
	}

    float sigma_denom = 1.0f / (sigma * sigma);

    // padding
    IplImage *iplPadded = padding(iplSrcImage, 10, 10, 10, 10);
    if (iplPadded == NULL) return false;

    /// LUT
    const int exp_lut_max = 128;        // must long engouth to avoid artifact in high contrast text content!
    const int exp_lut_amp = 8;
    const int lut_len = exp_lut_max * exp_lut_amp;
    float pLUT[lut_len];
    for (int i=0; i< lut_len; i++) {
        pLUT[i] = exp( - (float)i / (float)exp_lut_amp);
    }

    // filtering
    float pQuery[49];
    showMessage1("Non-local mean filtering ...");
    float fStartTime = (float)clock() / (float)CLOCKS_PER_SEC;
    for (int y=0; y<iplDstImage->height; y++) {
        float *pDst = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
        if (y%64==0) showMessage1("%d ", y);
        for (int x=0; x<iplDstImage->width; x++) {
            // get query patch
            int i=0;
            for (int yy=y+7; yy<y+14; yy++) {
                float *pQLine = (float *)(iplPadded->imageData + yy * iplPadded->widthStep);
                for (int xx=x+7; xx<x+14; xx++, i++) {
                    pQuery[i] = pQLine[xx];
                }
            }
            // search 15x15 window
            float w_max = 0.0f;
            float sweight = 0.0f;
            float average = 0.0f;
            for (int yy=y; yy<y+15; yy++) {
                float *pLine0 = (float *)(iplPadded->imageData + yy * iplPadded->widthStep);
                float *pLine1 = (float *)(iplPadded->imageData + (yy+1) * iplPadded->widthStep);
                float *pLine2 = (float *)(iplPadded->imageData + (yy+2) * iplPadded->widthStep);
                float *pLine3 = (float *)(iplPadded->imageData + (yy+3) * iplPadded->widthStep);
                float *pLine4 = (float *)(iplPadded->imageData + (yy+4) * iplPadded->widthStep);
                float *pLine5 = (float *)(iplPadded->imageData + (yy+5) * iplPadded->widthStep);
                float *pLine6 = (float *)(iplPadded->imageData + (yy+6) * iplPadded->widthStep);
                for (int xx=x; xx<x+15; xx++) {
                    if (xx==x+7 && yy==y+7) continue;
                    // match a patch
                    float diff_total, diff;
                    diff = pQuery[0] - pLine0[xx]; diff = diff * diff; diff_total = diff;
                    diff = pQuery[1] - pLine0[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[2] - pLine0[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[3] - pLine0[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[4] - pLine0[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[5] - pLine0[xx+5]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[6] - pLine0[xx+6]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[7] - pLine1[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[8] - pLine1[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[9] - pLine1[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[10] - pLine1[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[11] - pLine1[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[12] - pLine1[xx+5]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[13] - pLine1[xx+6]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[14] - pLine2[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[15] - pLine2[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[16] - pLine2[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[17] - pLine2[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[18] - pLine2[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[19] - pLine2[xx+5]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[20] - pLine2[xx+6]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[21] - pLine3[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[22] - pLine3[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[23] - pLine3[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[24] - pLine3[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[25] - pLine3[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[26] - pLine3[xx+5]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[27] - pLine3[xx+6]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[28] - pLine4[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[29] - pLine4[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[30] - pLine4[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[31] - pLine4[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[32] - pLine4[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[33] - pLine4[xx+5]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[34] - pLine4[xx+6]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[35] - pLine5[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[36] - pLine5[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[37] - pLine5[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[38] - pLine5[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[39] - pLine5[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[40] - pLine5[xx+5]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[41] - pLine5[xx+6]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[42] - pLine6[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[43] - pLine6[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[44] - pLine6[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[45] - pLine6[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[46] - pLine6[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[47] - pLine6[xx+5]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[48] - pLine6[xx+6]; diff = diff * diff; diff_total += diff;
                    // calculate weight
                    diff_total = diff_total * sigma_denom;
                    //float w = expf(-diff_total);
                    int idx = (int)(diff_total * exp_lut_amp + 0.5f);
                    idx = idx >=  lut_len ? lut_len - 1 : idx;
                    float w = pLUT[idx];
                    w_max = w > w_max ? w : w_max;
                    // accumulate
                    sweight += w;
                    average += w * pLine3[xx+3];        // bug fixed, Oct. 8, 2014
                }
            }
            // accumulate the central pont
            sweight += w_max;
            average += w_max * pQuery[24];
            // pixel value
            if (sweight > 0.0f) {
                pDst[x] = average / sweight;
            } else {
                pDst[x] = pQuery[24];
            }
        }
    }
    float fRunTime = (float)clock() / (float)CLOCKS_PER_SEC - fStartTime;
    showMessage1("%fs used in non-local mean searching.\n", fRunTime);

    safeReleaseImage(&iplPadded);

    return true;
}

bool CImageUtility::nlmFilterSP11x5_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float sigma_ra, float sigma_sp)
// Non-local mean filter with 5x5 patch and 11x11 search window.
// Compared with nlmFilter11x5_32f(), this function added a spatial Gaussian filter. (this feature may not be necessary due to little benefit).
// This is a broute force implementation.
// This function supports "in-place" operation. The input and output image should be the same size and type.
// Arguments:
//      iplSrcImage -- [I] input image
//      iplDstImage -- [O] output image; same size and type as the input image
//      sigma_ra -- [I] range sigma (standard deviation) in the filter, which controls the weight of each patch
//      sigma_sp -- [I] spatial sigma in the filter ,which controls the strength of the smoothing operation
// by Luhong Liang, September, 2014
// Make'sigma_ra' identical to original method, by Luhong, 10/05/2015
{
	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
		iplSrcImage->nChannels != iplDstImage->nChannels || iplSrcImage->nChannels != 1 || sigma_ra <  0.0f || sigma_sp < 0.0f) {
		showErrMsg("Invalide input image or parameter in CImageUtility::nlmFilter11x5_32f()!\n");
		return false;
	}

	if (sigma_ra <= 0.0f) {		// May 7, 2015
		return copy(iplSrcImage, iplDstImage);
	}

    float sigma_ra_denom = 1.0f / (sigma_ra * sigma_ra);

    // padding
    IplImage *iplPadded = padding(iplSrcImage, 7, 7, 7, 7);
    if (iplPadded == NULL) return false;

    /// LUT for range filter
    const int exp_lut_max = 128;        // must long engouth to avoid artifact in high contrast text content!
    const int exp_lut_amp = 8;
    const int lut_len = exp_lut_max * exp_lut_amp;
    float pLUT[lut_len];
    for (int i=0; i< lut_len; i++) {
        pLUT[i] = exp( - (float)i / (float)exp_lut_amp);
    }

    // LUT for spatial filter
    const int wnd_size = 11;
    float pFilter[wnd_size*wnd_size];
	int center = wnd_size >> 1;
	float div_sigma_sq2 = 0.5f / (sigma_sp * sigma_sp);
	for (int y=0; y<wnd_size; y++) {
		float diff_y = (float)(y - center);
		diff_y = diff_y * diff_y;
		for (int x=0; x<wnd_size; x++) {
			int index = y * wnd_size + x;
			float diff_x = (float)(x - center);
			diff_x = diff_x * diff_x;
			float exp_num = - (diff_x + diff_y) * div_sigma_sq2;
			float value = exp(exp_num);
            value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
			pFilter[index] = value;
		}
	}

    // filtering
    float pQuery[25];
    showMessage1("Non-local mean filtering ...");
    float fStartTime = (float)clock() / (float)CLOCKS_PER_SEC;
    for (int y=0; y<iplDstImage->height; y++) {
        float *pDst = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
        if (y%64==0) showMessage1("%d ", y);
        for (int x=0; x<iplDstImage->width; x++) {
            // get query patch
            int i=0;
            for (int yy=y+5; yy<y+10; yy++) {
                float *pQLine = (float *)(iplPadded->imageData + yy * iplPadded->widthStep);
                for (int xx=x+5; xx<x+10; xx++, i++) {
                    pQuery[i] = pQLine[xx];
                }
            }
            // search 11x11 window
            float w_max = 0.0f;
            float sweight = 0.0f;
            float average = 0.0f;
            i = 0;
            for (int yy=y; yy<y+11; yy++) {
                float *pLine0 = (float *)(iplPadded->imageData + yy * iplPadded->widthStep);
                float *pLine1 = (float *)(iplPadded->imageData + (yy+1) * iplPadded->widthStep);
                float *pLine2 = (float *)(iplPadded->imageData + (yy+2) * iplPadded->widthStep);
                float *pLine3 = (float *)(iplPadded->imageData + (yy+3) * iplPadded->widthStep);
                float *pLine4 = (float *)(iplPadded->imageData + (yy+4) * iplPadded->widthStep);
                //if ((yy < y+5 || yy > y+7) && (yy-y)%2==1) continue;
                for (int xx=x; xx<x+11; xx++, i++) {
                    //if ((xx < x+5 || xx > x+7) && (xx-x)%2==1) continue;
                    if (xx==x+5 && yy==y+5) continue;
                    // match a patch
                    float diff_total, diff;
                    diff = pQuery[0] - pLine0[xx]; diff = diff * diff; diff_total = diff;
                    diff = pQuery[1] - pLine0[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[2] - pLine0[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[3] - pLine0[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[4] - pLine0[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[5] - pLine1[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[6] - pLine1[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[7] - pLine1[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[8] - pLine1[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[9] - pLine1[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[10] - pLine2[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[11] - pLine2[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[12] - pLine2[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[13] - pLine2[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[14] - pLine2[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[15] - pLine3[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[16] - pLine3[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[17] - pLine3[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[18] - pLine3[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[19] - pLine3[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[20] - pLine4[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[21] - pLine4[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[22] - pLine4[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[23] - pLine4[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[24] - pLine4[xx+4]; diff = diff * diff; diff_total += diff;
                    // calculate weight
                    diff_total = diff_total * sigma_ra_denom;
                    //float w = expf(-diff_total);
                    int idx = (int)(diff_total * exp_lut_amp + 0.5f);
                    idx = idx >=  lut_len ? lut_len - 1 : idx;
                    float w = pLUT[idx];
                    w_max = w > w_max ? w : w_max;
                    // add spatial filter
                    float w_sp = w * pFilter[i];
                    // accumulate
                    sweight += w_sp;  
                    average += w_sp * pLine2[xx+2];
                }
            }
            // accumulate the central pont
            sweight += w_max;           // the spatial filter value is 1
            average += w_max * pQuery[12];
            // pixel value
            if (sweight > 0.0f) {
                pDst[x] = average / sweight;
            } else {
                pDst[x] = pQuery[12];
            }
        }
    }
    float fRunTime = (float)clock() / (float)CLOCKS_PER_SEC - fStartTime;
    showMessage1("%fs used in non-local mean searching.\n", fRunTime);

    safeReleaseImage(&iplPadded);

    return true;
}

bool CImageUtility::adaNLMFilter11x5_32f(IplImage *iplSrcImage, IplImage *iplDstImage, float sensitivity, 
                                         float hvsimpact, float adaptfactor, float sigma)
// Adaptive non-local mean filter with 5x5 patch and 11x11 search window.
// This function uses HVS model and edge detector to adaptively adjust the strength of the denoise
// This is a broute force implementation.
// This function supports "in-place" operation. The input and output image should be the same size and type.
// Arguments:
//      iplSrcImage -- [I] input image
//      iplDstImage -- [O] output image; same size and type as the input image
//      sensitivity -- [I] sensitivity to the edges; 0~1, larger value, stronger smoothing on edges and details
//      hvsimpact -- [I] impact factor of the HVS model. When hvsimpact == 0, the texture map is netrual (0.5), i.e. disabled.
//                       When hvsimpact = 0.5, original texture map is unchaged.
//                       When hvsimpact increases to 1, the texture map is evenly close to "texture" (1.0).
//                       When hvsimpact decreases to -1, the texture map is evenly close to "structure" (0.0).
//                       Key value of hvsimpact:    -1.0    -0.5        0.0     0.5     1.0
//                       Resutant HVS value:         0.0    0.5*hvs     0.5     hvs     1.0
//      adaptfactor -- [I] to control the adaptive. When adaptfactor == 0, the actual sigma is the constant original one denoted by parameter 'sigma'.
//                         When adaptfactor == 1, the actual 'sigma' is tuned by 'hvsimpact' and "adaptfactor', and between 'sigma' and 'sensitivity*sigma'.
//      sigma -- [I] parameter sigma (standard deviation) in the filter, which controls the weight of each patch
// by Luhong Liang, August, 2014
// May 7, 2015: add support on zero sigma
// Make'sigma' identical to original method, by Luhong, 10/05/2015
{
#ifdef __SR_USE_SIMD
    return adaNLMFilter11x5_32f_SIMD(iplSrcImage, iplDstImage, sensitivity, hvsimpact, adaptfactor, sigma);
#endif      // #ifdef __SR_USE_SIMD

	if (iplSrcImage == NULL || iplDstImage == NULL || iplSrcImage->width != iplDstImage->width || iplSrcImage->height != iplDstImage->height ||
		iplSrcImage->nChannels != iplDstImage->nChannels || iplSrcImage->nChannels != 1 || sigma <  0.0f || sensitivity < 0.0f || sensitivity > 1.0f) {
		showErrMsg("Invalide input image or parameter in CImageUtility::adaNLMFilter11x5_32f()!\n");
		return false;
	}

    showMessage1("Adaptive non-local mean filtering ...");

	if (sigma <= 0.0f) {
		copy(iplSrcImage, iplDstImage);
		return true;
	}

    // padding
    IplImage *iplPadded = padding(iplSrcImage, 7, 7, 7, 7);
    IplImage *iplSharp = createImage(iplDstImage);
    IplImage *iplHVS = createImage(iplDstImage);
    IplImage *iplLuma = createImage(iplDstImage);
    if (iplPadded == NULL || iplSharp == NULL || iplHVS == NULL || iplLuma == NULL) {
        safeReleaseImage(&iplPadded, &iplSharp, &iplHVS, &iplLuma);
        return false;
    }

    /// LUT of range filter
    const int exp_lut_max = 128;        // must long engouth to avoid artifact in high contrast text content!
    const int exp_lut_amp = 8;
    const int lut_len = exp_lut_max * exp_lut_amp;
    float pLUT[lut_len];
    for (int i=0; i< lut_len; i++) {
        pLUT[i] = exp( - (float)i / (float)exp_lut_amp);
    }

	//
	// Calculate edge sharpness (mixture of LoG and MAD)
	//

    // calculate LoG filter
    const float log_sigma = 2.5f;
    const int log_wnd_size = (int)(ceil(log_sigma * 2.5) * 2 + 1.0f);   // wnd_size=15
    filtLoG_32f(iplSrcImage, iplSharp, log_wnd_size, log_sigma, 3);
    //saveImage("_LoG4x32.bmp", iplSharp, 0, 32.0f);

    // calculate local gradient
    if (!extrMADMap5x5_o1_32f(iplSrcImage, iplHVS)) {
        safeReleaseImage(&iplPadded, &iplSharp, &iplHVS, &iplLuma);
        return false;
    }
    //saveImage("_MADx8.bmp", iplHVS, 0, 8.0f);

    // calculate luma
    boxing5x5_32f(iplSrcImage, iplLuma);

    // fusion MAD and LoG
    //saveImage("_Org.bmp", iplSrcImage);
    for (int y=0; y<iplSharp->height; y++) {
        float *pSharp = (float *)(iplSharp->imageData + y * iplSharp->widthStep);
        float *pMAD = (float *)(iplHVS->imageData + y * iplHVS->widthStep);
        float *pLuma = (float *)(iplLuma->imageData + y * iplLuma->widthStep);
        for (int x=0; x<iplSharp->width; x++) {
            float sharp = pSharp[x];
            float mad = pMAD[x];
            float luma = pLuma[x];
            // normalize
            luma = luma < 32.0f ? 32.0f : luma; 
            sharp = sharp * 32.0f / luma;
            mad = mad * 8.0f / luma;
            //pMAD[x] = mad;
            //pSharp[x] = sharp;
            // fusion
            sharp = sharp < mad ? sharp : mad;
            pSharp[x] = sharp;
        }
    }   
    //saveImage("_SharpnessLoGMAD.bmp", iplSharp, 0, 255.0f);

    // calculate adaptive weight map
    float log_weight_low = sensitivity;
    float log_weight_high = sensitivity + 0.25f;
    for (int y=0; y<iplSharp->height; y++) {
        float *pSharp = (float *)(iplSharp->imageData + y * iplSharp->widthStep);
        for (int x=0; x<iplSharp->width; x++) {
            // calculate sigma map
            float sharp = pSharp[x];
            sharp = sharp > log_weight_high ? log_weight_high : sharp;
            sharp = sharp < log_weight_low ? log_weight_low : sharp;
            sharp = (sharp - log_weight_low) * 4.0f;
            pSharp[x] = sharp;
        }
    }
    //saveImage("_SharpnessTunedBySensitivity.bmp", iplSharp, 0, 255.0f);

    // morphology process
    const float bulb_th_low = 0.0625f;
    const int bnd_num = 1;
    //rmIsoBulb9x9_32f(iplSharp, iplSharp, bulb_th_low, bnd_num);
    rmIsoBulb11x11_32f(iplSharp, iplSharp, bulb_th_low, bnd_num);
    //rmIsoBulb13x13_32f(iplSharp, iplSharp, bulb_th_low, bnd_num);
    //saveImage("_SharpnessPostProc.bmp", iplSharp, 0, 255.0f);

	//
    // calculate regularity and weight
	//
    if (adaptfactor != 0.0f) {
        if (hvsimpact != 0.0f) {
            extrStructMap5x5_32f(iplSrcImage, iplHVS, 1);
            max5x5_32f(iplHVS, iplHVS);
			//saveImage("_HVSMax.bmp", iplHVS, 0, 255.0f);
            float tex_lik_low = 0.0f;
            float tex_lik_high = 0.5f;
            for (int y=0; y<iplHVS->height; y++) {
                float *pHVS = (float *)(iplHVS->imageData + y * iplHVS->widthStep);
                for (int x=0; x<iplHVS->width; x++) {
                    // calculate sigma map
                    float tex_lik = 1.0f - pHVS[x];
                    tex_lik = tex_lik < tex_lik_low ? tex_lik_low : tex_lik;
                    tex_lik = tex_lik > tex_lik_high ? tex_lik_high : tex_lik;
                    pHVS[x] = (tex_lik - tex_lik_low) / (tex_lik_high - tex_lik_low);
                }
            }
            //saveImage("_HVSWeight1.bmp", iplHVS, 0, 255.0f);
            // tuning HVS
            float w1 = (hvsimpact + 1.0f);
            float w2 = 0.5f * (1.0f - (- 2.0f * hvsimpact));
            float w3 = (2.0f * hvsimpact);
            float w4 = 0.5f * (1.0f - (2.0f * hvsimpact));
            float w5 = (2.0f * (1.0f - hvsimpact));
            float w6 = 1.0f - w5;
            for (int y=0; y<iplSharp->height; y++) {
                float *pHVS = (float *)(iplHVS->imageData + y * iplHVS->widthStep);
                for (int x=0; x<iplSharp->width; x++) {
                    float hvs = pHVS[x];
                    if (hvsimpact < -0.5f) {
                        hvs = hvs * w1;               //hvs * 0.5f * (hvsimpact + 1.0f) * 2.0f;
                    } else if (hvsimpact < 0.0f) {
                        hvs = - hvs * hvsimpact + w2; //(hvs * 0.5f) * (- 2.0f * hvsimpact) + 0.5f * (1.0f - (- 2.0f * hvsimpact));
                    } else if (hvsimpact < 0.5f) {
                        hvs = hvs * w3 + w4;        // hvs * (2.0f * hvsimpact) + 0.5f * (1.0f - (2.0f * hvsimpact));
                    } else {
                        hvs = hvs * w5 + w6;        //hvs * (2.0f * (1.0f - hvsimpact)) + 1.0f * (1.0f - (2.0f * (1.0f - hvsimpact)))
                    }
                    pHVS[x] = hvs;
                }
            }
			//saveImage("_HVSTuned.bmp", iplHVS, 0, 255.0f);

            // fusion with HVS
            for (int y=0; y<iplSharp->height; y++) {
                float *pWsigma = (float *)(iplSharp->imageData + y * iplSharp->widthStep);
                float *pHVS = (float *)(iplHVS->imageData + y * iplHVS->widthStep);
                for (int x=0; x<iplSharp->width; x++) {
                    // calculate HVS term
                    float hvs = pHVS[x];
                    // min
                    float sharpness = pWsigma[x];
                    pWsigma[x] = sharpness < hvs ? sharpness : hvs;
                }
            }
            //saveImage("_SigmaWeight_HVS.bmp", iplSharp, 0, 255.0f);
        }
        // adaptive
        for (int y=0; y<iplSharp->height; y++) {
            float *pWsigma = (float *)(iplSharp->imageData + y * iplSharp->widthStep);
            for (int x=0; x<iplSharp->width; x++) {
                pWsigma[x] = adaptfactor * pWsigma[x] +  (1.0f - adaptfactor);
            }
        }
    } else {
        for (int y=0; y<iplSharp->height; y++) {
            float *pWsigma = (float *)(iplSharp->imageData + y * iplSharp->widthStep);
            for (int x=0; x<iplSharp->width; x++) {
                pWsigma[x] = 1.0f;
            }
        }
    }
	//saveImage("_SigmaWeight.bmp", iplSharp, 0, 255.0f);

    // smooth sigma weight map
    gaussian5x5_32f(iplSharp, iplSharp, 2.0f);
    //saveImage("_SigmaWeight_HVS_Smooth.bmp", iplSharp, 0, 255.0f);

    // calculate sigma map
	float min_sigma = sensitivity * sigma;
    const float sigma_eps = 0.01f;
    for (int y=0; y<iplSharp->height; y++) {
        float *pWsigma = (float *)(iplSharp->imageData + y * iplSharp->widthStep);
        for (int x=0; x<iplSharp->width; x++) {
            float w_sigma = pWsigma[x];
            float local_sigma = (sigma - min_sigma) * (1.0f - w_sigma) + min_sigma;
            pWsigma[x] = local_sigma + sigma_eps;
        }
    }
    //saveImage("_SigmaMap.bmp", iplSharp, 0, 255.0f/sigma);

    float fStartTime = (float)clock() / (float)CLOCKS_PER_SEC;
    // filtering
	const float eps = 0.00001f;
    float pQuery[25];
    for (int y=0; y<iplDstImage->height; y++) {
        float *pDst = (float *)(iplDstImage->imageData + y * iplDstImage->widthStep);
        float *pSigma = (float *)(iplSharp->imageData + y * iplSharp->widthStep);
		float *pLineC = (float *)(iplPadded->imageData + (y+7) * iplPadded->widthStep);
        if (y%64==0) showMessage1("%d ", y);
        for (int x=0; x<iplDstImage->width; x++) {
			//if (x==845 && y == 127) 
			//	int p = 1;
            // get local sigma
            float local_sigma = pSigma[x];
			if (local_sigma <= 0.0f) {		// May 7, 2015
				pDst[x] = pLineC[x+7];
				continue;
			}
            float sigma_denom = 1.0f / (local_sigma * local_sigma);

            // get query patch
            int i=0;
            for (int yy=y+5; yy<y+10; yy++) {
                float *pQLine = (float *)(iplPadded->imageData + yy * iplPadded->widthStep);
                for (int xx=x+5; xx<x+10; xx++, i++) {
                    pQuery[i] = pQLine[xx];
                }
            }

            // search 11x11 window
            float w_max = 0.0f;
            float sweight = 0.0f;
            float average = 0.0f;
            for (int yy=y; yy<y+11; yy++) {
                float *pLine0 = (float *)(iplPadded->imageData + yy * iplPadded->widthStep);
                float *pLine1 = (float *)(iplPadded->imageData + (yy+1) * iplPadded->widthStep);
                float *pLine2 = (float *)(iplPadded->imageData + (yy+2) * iplPadded->widthStep);
                float *pLine3 = (float *)(iplPadded->imageData + (yy+3) * iplPadded->widthStep);
                float *pLine4 = (float *)(iplPadded->imageData + (yy+4) * iplPadded->widthStep);
                //if ((yy < y+5 || yy > y+7) && (yy-y)%2==1) continue;
                for (int xx=x; xx<x+11; xx++) {
                    //if ((xx < x+5 || xx > x+7) && (xx-x)%2==1) continue;
                    if (xx==x+5 && yy==y+5) continue;
                    // match a patch
                    float diff_total, diff;
                    diff = pQuery[0] - pLine0[xx]; diff = diff * diff; diff_total = diff;
                    diff = pQuery[1] - pLine0[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[2] - pLine0[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[3] - pLine0[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[4] - pLine0[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[5] - pLine1[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[6] - pLine1[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[7] - pLine1[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[8] - pLine1[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[9] - pLine1[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[10] - pLine2[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[11] - pLine2[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[12] - pLine2[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[13] - pLine2[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[14] - pLine2[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[15] - pLine3[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[16] - pLine3[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[17] - pLine3[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[18] - pLine3[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[19] - pLine3[xx+4]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[20] - pLine4[xx]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[21] - pLine4[xx+1]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[22] - pLine4[xx+2]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[23] - pLine4[xx+3]; diff = diff * diff; diff_total += diff;
                    diff = pQuery[24] - pLine4[xx+4]; diff = diff * diff; diff_total += diff;
                    // calculate weight
                    diff_total = diff_total * sigma_denom;
                    //float w = expf(-diff_total);
                    //int idx = (int)(diff_total * exp_lut_amp + 0.5f);	// Overflow here! -- fixed on May 9, 2015
					float idx_f = diff_total * exp_lut_amp + 0.5f;
                    int idx = idx_f >= (float)lut_len ? lut_len - 1 : (int)(idx_f);
                    float w = pLUT[idx];
					//if (w > 0.01f) 
					//	int p2 = 1;
                    w_max = w > w_max ? w : w_max;
                    // accumulate
                    sweight += w;
                    average += w * pLine2[xx+2];
                }
            }
            // accumulate the central pont
            sweight += w_max;
            average += w_max * pQuery[12];
            // pixel value
            if (sweight > eps) {
                pDst[x] = average / sweight;
            } else {
                pDst[x] = pQuery[12];
            }
        }
    }
    float fRunTime = (float)clock() / (float)CLOCKS_PER_SEC - fStartTime;
    showMessage1("%fs used in non-local mean searching.\n", fRunTime);

    safeReleaseImage(&iplPadded, &iplSharp, &iplHVS, &iplLuma);

    return true;
}

// --------------------------------------------------
// Define watermark
// --------------------------------------------------

// ASTRI logo
const int g_WMWidth_ASTRI = 256;
const int g_WMHeight_ASTRI = 128;
const int g_WMFirstVal_ASTRI = 0;
const short g_WatermarkData_ASTRI[] = { 2253, 1, 255, 1, 255, 1, 254, 1, 255, 1, 12, 1, 241, 2, 12, 1, 241, 2, 11, 1, 242, 1, 12, 1, 241, 2, 12, 1, 241, 2,
									  11, 1, 241, 3, 11, 1, 241, 2, 11, 2, 241, 2, 11, 1, 241, 3, 10, 2, 9, 5, 2, 2, 3, 2, 218, 3, 10, 1, 10, 6,
									  1, 3, 1, 3, 218, 2, 10, 2, 12, 2, 3, 3, 1, 3, 217, 3, 10, 2, 12, 2, 3, 7, 217, 3, 9, 3, 12, 2, 3, 1,
						  			  1, 5, 216, 4, 9, 2, 13, 2, 3, 1, 1, 5, 216, 3, 9, 3, 13, 2, 3, 1, 2, 1, 2, 1, 216, 3, 9, 3, 240, 4,
						  		  	  8, 3, 241, 4, 8, 3, 240, 4, 8, 3, 241, 4, 8, 3, 227, 5, 9, 4, 7, 4, 226, 6, 8, 5, 7, 4, 226, 7, 7, 4,
						  			  7, 4, 226, 8, 7, 4, 7, 4, 226, 8, 6, 5, 6, 4, 227, 8, 6, 5, 6, 4, 227, 7, 6, 5, 6, 5, 227, 7, 6, 5,
									  6, 4, 228, 6, 7, 5, 5, 5, 228, 6, 6, 6, 5, 5, 230, 2, 8, 5, 5, 5, 213, 1, 26, 6, 5, 5, 10, 6, 199, 2,
									  23, 6, 4, 6, 9, 8, 199, 4, 20, 6, 4, 5, 9, 10, 199, 5, 17, 6, 4, 6, 8, 11, 201, 6, 14, 6, 4, 6, 8, 11,
									  202, 7, 12, 6, 3, 6, 9, 11, 203, 9, 8, 7, 3, 6, 9, 11, 205, 10, 6, 5, 3, 7, 9, 11, 206, 11, 6, 3, 3, 6,
									  10, 10, 208, 13, 8, 7, 10, 10, 210, 14, 5, 7, 11, 8, 212, 15, 3, 6, 12, 7, 195, 3, 16, 14, 3, 6, 15, 1, 200, 4,
									  15, 10, 5, 6, 217, 6, 13, 8, 6, 5, 220, 8, 10, 5, 8, 5, 2, 3, 216, 10, 9, 2, 10, 4, 2, 5, 216, 11, 18, 3,
									  3, 7, 215, 14, 14, 3, 2, 10, 215, 12, 2, 1, 12, 2, 2, 12, 214, 11, 2, 1, 12, 1, 3, 14, 213, 9, 3, 1, 12, 1,
									  2, 17, 113, 1, 3, 1, 27, 1, 27, 1, 14, 1, 24, 7, 2, 2, 15, 19, 54, 10, 20, 29, 2, 30, 2, 28, 10, 8, 19, 6,
									  2, 2, 15, 21, 51, 12, 18, 30, 2, 30, 2, 29, 9, 8, 21, 3, 3, 3, 17, 20, 49, 13, 16, 31, 2, 30, 2, 30, 8, 8,
									  22, 2, 2, 4, 10, 3, 8, 18, 46, 15, 15, 31, 2, 30, 2, 31, 7, 8, 26, 4, 8, 6, 10, 17, 43, 17, 13, 9, 36, 8,
									  13, 8, 15, 8, 7, 8, 26, 4, 6, 9, 13, 15, 40, 8, 2, 9, 12, 8, 37, 7, 14, 7, 17, 7, 7, 8, 13, 3, 9, 6,
									  4, 12, 14, 14, 37, 8, 4, 8, 12, 8, 37, 8, 13, 7, 17, 7, 7, 8, 12, 4, 9, 6, 2, 15, 16, 13, 34, 8, 5, 9,
									  11, 8, 37, 8, 13, 7, 16, 8, 7, 8, 11, 6, 8, 6, 3, 15, 18, 12, 32, 8, 6, 9, 10, 27, 18, 8, 13, 7, 3, 21,
									  7, 8, 11, 6, 7, 6, 5, 16, 20, 10, 29, 8, 8, 9, 10, 29, 15, 8, 13, 7, 2, 22, 7, 8, 11, 6, 7, 6, 8, 14,
									  22, 9, 26, 8, 10, 9, 9, 30, 14, 8, 13, 7, 2, 21, 8, 8, 11, 6, 7, 5, 3, 3, 4, 14, 24, 8, 23, 8, 12, 9,
									  9, 30, 13, 8, 13, 7, 2, 20, 9, 8, 11, 6, 6, 6, 3, 5, 4, 14, 26, 6, 20, 8, 13, 9, 11, 29, 12, 8, 13, 7,
									  2, 18, 11, 8, 11, 6, 6, 5, 4, 6, 5, 13, 28, 5, 17, 9, 4, 5, 5, 9, 31, 8, 12, 8, 13, 7, 8, 9, 14, 8,
									  11, 5, 7, 5, 3, 7, 7, 12, 30, 4, 15, 8, 5, 6, 5, 9, 30, 8, 12, 8, 13, 7, 9, 9, 13, 8, 12, 3, 7, 5,
									  4, 7, 9, 12, 31, 3, 12, 8, 5, 7, 6, 9, 29, 8, 12, 8, 13, 7, 10, 9, 12, 8, 22, 5, 4, 6, 12, 11, 44, 8,
									  6, 8, 5, 10, 28, 8, 12, 8, 13, 7, 11, 9, 11, 8, 22, 4, 5, 6, 14, 10, 42, 8, 7, 7, 7, 10, 2, 33, 12, 8,
									  13, 7, 12, 10, 9, 8, 21, 5, 4, 6, 17, 10, 39, 9, 8, 6, 8, 9, 3, 31, 13, 8, 13, 7, 14, 9, 8, 8, 21, 4,
									  5, 6, 19, 9, 37, 9, 10, 4, 10, 9, 3, 30, 13, 8, 13, 7, 15, 9, 7, 8, 21, 4, 5, 6, 21, 8, 36, 8, 26, 9,
									  3, 28, 14, 8, 13, 7, 16, 10, 5, 8, 20, 4, 6, 5, 24, 8, 33, 8, 27, 10, 3, 25, 16, 7, 14, 7, 17, 10, 5, 7,
									  20, 4, 5, 6, 26, 7, 208, 3, 6, 5, 29, 6, 206, 4, 6, 5, 31, 6, 204, 3, 7, 5, 8, 5, 20, 5, 203, 3, 6, 5,
									  8, 7, 20, 5, 202, 2, 7, 5, 7, 9, 22, 4, 199, 3, 7, 4, 8, 9, 23, 4, 198, 2, 8, 4, 8, 10, 24, 4, 196, 2,
									  7, 5, 7, 11, 26, 3, 194, 2, 8, 4, 8, 11, 28, 2, 193, 2, 8, 4, 8, 11, 30, 2, 191, 1, 9, 3, 10, 10, 32, 1,
									  189, 2, 8, 4, 10, 10, 222, 1, 9, 4, 10, 9, 223, 1, 9, 3, 12, 8, 222, 1, 10, 3, 13, 6, 223, 1, 9, 3, 16, 1,
									  236, 3, 242, 1, 10, 3, 242, 1, 10, 2, 253, 3, 242, 1, 10, 2, 254, 2, 254, 2, 253, 2, 254, 2, 254, 1, 255, 1, 254, 2,
									  254, 1, 255, 1, 2379 };


const int g_WMWidth_Trialout = 304;
const int g_WMHeight_Trialout = 64;
const int g_WMFirstVal_Trialout = 0;
const short g_WatermarkData_Trialout[] = { 1252, 5, 49, 3, 135, 3, 28, 4, 75, 8, 31, 3, 14, 4, 134, 4, 27, 5, 22, 4, 46, 11, 30, 4, 13, 5, 33, 3, 97, 5,
                                          27, 5, 20, 6, 42, 14, 30, 5, 13, 5, 32, 5, 56, 2, 37, 6, 16, 4, 6, 5, 18, 8, 39, 13, 34, 5, 13, 6, 32, 6,
                                          28, 5, 21, 4, 6, 4, 11, 2, 13, 5, 16, 5, 5, 5, 17, 9, 35, 13, 37, 6, 14, 6, 32, 7, 19, 13, 20, 5, 5, 4,
                                          10, 5, 11, 4, 18, 5, 4, 5, 5, 3, 7, 8, 35, 12, 41, 5, 15, 6, 33, 7, 10, 22, 20, 5, 5, 4, 8, 7, 10, 4,
                                          18, 5, 4, 4, 6, 3, 5, 8, 33, 13, 44, 5, 16, 5, 34, 7, 4, 27, 21, 6, 3, 4, 2, 13, 10, 4, 18, 5, 4, 4,
                                          6, 4, 2, 8, 31, 17, 43, 5, 17, 4, 36, 6, 4, 15, 33, 7, 2, 18, 11, 4, 19, 4, 4, 4, 6, 11, 31, 11, 3, 7,
                                          6, 3, 33, 4, 19, 3, 37, 5, 6, 4, 5, 4, 34, 6, 2, 17, 3, 3, 6, 4, 19, 4, 4, 4, 6, 9, 33, 6, 8, 7,
                                          6, 4, 31, 5, 28, 7, 25, 4, 15, 4, 35, 4, 3, 9, 4, 4, 3, 5, 4, 4, 19, 4, 4, 4, 6, 6, 49, 6, 8, 4,
                                          31, 4, 18, 19, 25, 3, 15, 4, 5, 3, 28, 3, 3, 4, 9, 4, 3, 6, 3, 4, 19, 4, 4, 4, 6, 5, 49, 6, 8, 5,
                                          30, 5, 6, 32, 42, 4, 5, 4, 27, 3, 3, 4, 9, 4, 4, 5, 3, 4, 19, 4, 4, 4, 6, 5, 48, 6, 8, 7, 29, 4,
                                          7, 26, 3, 3, 42, 4, 5, 5, 32, 4, 9, 4, 4, 5, 3, 4, 19, 4, 4, 4, 7, 4, 47, 5, 9, 8, 28, 5, 4, 2,
                                          2, 13, 49, 4, 7, 4, 5, 5, 32, 4, 2, 3, 4, 4, 4, 4, 4, 4, 19, 4, 4, 4, 6, 4, 47, 5, 9, 7, 30, 4,
                                          5, 3, 2, 3, 4, 5, 49, 5, 6, 4, 5, 5, 32, 4, 2, 4, 3, 4, 4, 4, 4, 4, 19, 4, 4, 4, 6, 4, 46, 5,
                                          9, 6, 31, 5, 5, 4, 8, 6, 49, 5, 5, 4, 4, 5, 33, 4, 2, 5, 2, 4, 4, 4, 4, 4, 19, 4, 4, 4, 6, 4,
                                          12, 3, 30, 5, 5, 10, 32, 4, 5, 6, 6, 7, 2, 3, 45, 5, 4, 4, 4, 5, 30, 7, 2, 6, 1, 4, 4, 4, 4, 4,
                                          19, 4, 4, 4, 2, 3, 1, 4, 11, 5, 28, 19, 33, 5, 5, 6, 6, 5, 4, 4, 32, 4, 8, 6, 3, 4, 4, 4, 18, 3,
                                          10, 7, 2, 6, 1, 4, 4, 4, 4, 4, 19, 4, 2, 11, 1, 4, 9, 8, 25, 20, 34, 4, 5, 6, 6, 5, 6, 4, 31, 5,
                                          8, 5, 3, 4, 3, 5, 18, 5, 8, 7, 2, 5, 2, 4, 4, 4, 4, 4, 19, 22, 1, 16, 25, 19, 34, 5, 1, 9, 7, 5,
                                          6, 5, 22, 14, 7, 6, 2, 4, 3, 4, 20, 5, 6, 8, 2, 5, 2, 4, 4, 4, 4, 4, 19, 38, 26, 8, 4, 6, 2, 3,
                                          28, 16, 7, 5, 8, 5, 18, 17, 8, 5, 2, 4, 3, 4, 21, 5, 5, 8, 2, 5, 2, 4, 4, 4, 4, 4, 19, 8, 10, 19,
                                          28, 4, 6, 6, 3, 5, 26, 15, 7, 5, 10, 5, 17, 16, 9, 4, 3, 4, 2, 4, 23, 6, 3, 3, 1, 4, 2, 5, 2, 4,
                                          4, 4, 4, 4, 18, 5, 14, 10, 5, 4, 36, 6, 5, 6, 26, 8, 1, 5, 7, 4, 11, 6, 18, 5, 4, 4, 10, 4, 3, 4,
                                          2, 4, 23, 6, 2, 4, 1, 4, 2, 5, 2, 4, 4, 4, 4, 4, 18, 5, 14, 4, 10, 5, 35, 6, 7, 7, 25, 4, 3, 5,
                                          7, 4, 8, 11, 26, 4, 11, 3, 3, 4, 2, 3, 5, 5, 15, 5, 2, 4, 1, 4, 2, 5, 2, 4, 4, 4, 4, 4, 18, 5,
                                          14, 7, 7, 5, 34, 6, 10, 6, 31, 5, 5, 26, 25, 4, 17, 4, 1, 15, 15, 4, 2, 4, 1, 4, 2, 5, 2, 4, 4, 4,
                                          4, 4, 18, 5, 14, 7, 7, 4, 34, 6, 12, 7, 28, 5, 5, 27, 25, 4, 17, 21, 14, 4, 1, 4, 2, 4, 2, 5, 2, 4,
                                          4, 4, 4, 4, 18, 5, 14, 8, 6, 4, 32, 6, 8, 14, 27, 4, 6, 18, 4, 5, 25, 4, 7, 31, 19, 4, 2, 4, 2, 5,
                                          2, 4, 4, 4, 4, 4, 18, 5, 5, 3, 6, 8, 5, 5, 31, 6, 2, 23, 24, 5, 7, 10, 3, 5, 3, 5, 25, 4, 3, 24,
                                          30, 4, 2, 4, 2, 4, 3, 4, 4, 4, 4, 4, 18, 5, 4, 5, 4, 5, 1, 4, 4, 5, 29, 22, 4, 7, 23, 5, 9, 3,
                                          2, 5, 2, 5, 4, 3, 26, 4, 3, 18, 35, 5, 2, 4, 2, 4, 3, 4, 4, 4, 4, 4, 18, 15, 3, 4, 2, 4, 4, 4,
                                          27, 19, 11, 6, 23, 4, 15, 5, 2, 5, 33, 4, 4, 5, 8, 4, 35, 4, 3, 4, 2, 4, 3, 4, 4, 4, 4, 4, 18, 15,
                                          3, 4, 3, 4, 2, 5, 27, 13, 1, 5, 12, 5, 22, 5, 4, 6, 5, 5, 2, 5, 32, 5, 17, 4, 35, 4, 3, 4, 2, 4,
                                          3, 4, 4, 4, 4, 4, 18, 14, 4, 4, 3, 4, 2, 5, 29, 5, 7, 6, 12, 3, 22, 16, 5, 4, 3, 5, 32, 5, 17, 4,
                                          34, 5, 3, 4, 2, 4, 3, 4, 4, 4, 4, 4, 18, 6, 3, 4, 5, 4, 4, 9, 43, 5, 35, 15, 7, 5, 3, 4, 33, 5,
                                          17, 4, 34, 4, 4, 4, 2, 4, 3, 4, 3, 5, 4, 4, 18, 4, 5, 4, 4, 5, 4, 9, 35, 3, 5, 4, 36, 12, 10, 4,
                                          4, 4, 33, 5, 16, 5, 34, 4, 3, 5, 2, 4, 2, 5, 3, 5, 4, 4, 17, 5, 5, 4, 4, 4, 6, 7, 36, 3, 5, 4,
                                          2, 4, 30, 9, 13, 4, 4, 4, 33, 5, 16, 5, 33, 5, 3, 5, 1, 5, 2, 5, 4, 4, 4, 4, 17, 5, 5, 4, 4, 4,
                                          6, 7, 35, 5, 4, 4, 2, 6, 29, 6, 15, 4, 4, 4, 33, 5, 6, 3, 7, 5, 33, 5, 4, 4, 1, 5, 3, 4, 4, 4,
                                          4, 4, 17, 5, 5, 4, 4, 4, 7, 5, 36, 5, 4, 4, 4, 5, 28, 3, 17, 5, 4, 4, 33, 5, 4, 5, 7, 5, 33, 4,
                                          5, 9, 4, 4, 5, 3, 4, 4, 17, 4, 6, 4, 3, 5, 7, 5, 35, 6, 4, 4, 5, 6, 40, 4, 2, 4, 5, 4, 33, 5,
                                          3, 5, 8, 5, 33, 4, 6, 8, 5, 3, 12, 4, 17, 4, 6, 4, 3, 4, 7, 7, 33, 7, 4, 4, 6, 7, 36, 6, 1, 5,
                                          5, 4, 33, 5, 2, 5, 9, 5, 32, 5, 9, 8, 17, 4, 16, 5, 6, 4, 3, 4, 7, 7, 32, 6, 6, 4, 7, 7, 32, 7,
                                          3, 5, 5, 4, 9, 4, 20, 11, 10, 5, 32, 5, 9, 9, 16, 4, 16, 4, 7, 4, 2, 4, 7, 9, 30, 6, 7, 4, 8, 8,
                                          28, 7, 4, 5, 6, 4, 9, 4, 20, 10, 11, 5, 25, 5, 2, 4, 9, 5, 1, 5, 15, 4, 16, 4, 7, 4, 2, 4, 6, 11,
                                          28, 6, 8, 4, 10, 8, 23, 8, 6, 5, 6, 4, 9, 4, 20, 9, 12, 5, 25, 11, 9, 5, 2, 6, 13, 4, 15, 5, 7, 4,
                                          1, 5, 5, 6, 2, 4, 27, 5, 10, 4, 11, 8, 19, 9, 7, 5, 7, 4, 9, 4, 20, 8, 13, 5, 26, 10, 8, 5, 4, 6,
                                          12, 4, 15, 4, 8, 4, 1, 4, 6, 5, 3, 5, 24, 6, 11, 4, 12, 7, 15, 11, 9, 5, 7, 4, 9, 4, 20, 7, 14, 5,
                                          27, 8, 9, 5, 5, 6, 11, 4, 15, 4, 8, 8, 6, 5, 5, 5, 22, 6, 12, 4, 13, 5, 15, 10, 10, 5, 8, 4, 9, 4,
                                          20, 6, 15, 4, 29, 7, 8, 5, 7, 6, 10, 4, 14, 5, 8, 8, 5, 5, 6, 5, 21, 6, 5, 5, 3, 4, 14, 4, 15, 8,
                                          11, 5, 9, 4, 9, 4, 20, 5, 16, 4, 30, 6, 7, 5, 8, 6, 2, 5, 3, 4, 14, 4, 8, 8, 5, 5, 8, 5, 19, 5,
                                          7, 6, 2, 4, 15, 3, 17, 5, 11, 5, 10, 4, 9, 4, 21, 3, 17, 4, 31, 5, 6, 6, 9, 5, 2, 6, 2, 4, 13, 5,
                                          8, 7, 5, 5, 9, 6, 16, 6, 10, 10, 36, 2, 12, 5, 11, 5, 8, 5, 40, 4, 32, 3, 6, 6, 11, 3, 5, 10, 13, 4,
                                          8, 8, 4, 5, 11, 6, 14, 5, 13, 9, 48, 6, 12, 6, 6, 6, 39, 5, 40, 6, 21, 9, 12, 4, 9, 7, 4, 5, 13, 7,
                                          12, 4, 15, 8, 47, 6, 13, 18, 39, 5, 39, 6, 23, 8, 12, 4, 10, 5, 4, 5, 14, 11, 28, 6, 46, 6, 16, 17, 40, 4,
                                          38, 6, 25, 6, 12, 4, 12, 3, 3, 6, 15, 11, 29, 5, 44, 6, 19, 14, 42, 4, 37, 5, 28, 5, 11, 4, 13, 3, 2, 5,
                                          17, 11, 30, 4, 44, 5, 77, 3, 36, 5, 30, 4, 11, 3, 18, 5, 107, 3, 80, 2, 36, 4, 31, 3, 33, 4, 1556 };



const int g_WMWidth_VEUHD = 200;
const int g_WMHeight_VEUHD = 72;
const int g_WMFirstVal_VEUHD = 1;
const short g_WatermarkData_VEUHD[] =  { 13, 5, 13, 2, 21, 4, 12, 4, 12, 5, 12, 4, 12, 5, 15, 62, 12, 5, 12, 3, 21, 4, 12, 4, 12, 5, 12, 4, 12, 5,
                                  22, 55, 12, 5, 12, 3, 21, 4, 12, 4, 12, 5, 12, 4, 12, 5, 24, 53, 12, 5, 12, 3, 21, 4, 12, 4, 12, 5, 12, 4,
                                  12, 5, 25, 52, 12, 5, 12, 3, 21, 4, 12, 4, 12, 5, 12, 4, 12, 5, 26, 51, 12, 5, 12, 3, 21, 4, 12, 4, 12, 5,
                                  12, 4, 12, 5, 27, 50, 12, 5, 12, 3, 21, 4, 12, 4, 12, 5, 12, 4, 12, 5, 27, 50, 12, 5, 12, 3, 21, 4, 12, 4,
                                  12, 5, 12, 4, 12, 5, 27, 51, 11, 5, 12, 3, 21, 4, 12, 4, 12, 5, 12, 4, 12, 5, 12, 3, 12, 51, 11, 5, 11, 4,
                                  21, 4, 12, 4, 12, 5, 12, 4, 12, 5, 12, 4, 11, 51, 11, 5, 11, 4, 12, 13, 12, 4, 12, 5, 12, 4, 12, 5, 12, 4,
                                  12, 50, 12, 3, 12, 4, 12, 13, 12, 4, 12, 5, 12, 4, 12, 5, 12, 4, 12, 50, 12, 3, 12, 4, 12, 13, 12, 4, 12, 5,
                                  12, 4, 12, 5, 12, 4, 12, 50, 12, 3, 12, 4, 12, 13, 12, 4, 12, 5, 12, 4, 12, 5, 12, 4, 12, 51, 11, 3, 12, 4,
                                  12, 13, 12, 4, 12, 5, 12, 4, 12, 5, 12, 4, 12, 51, 11, 3, 12, 4, 12, 13, 12, 4, 12, 5, 12, 4, 12, 5, 12, 4,
                                  12, 51, 11, 3, 11, 5, 12, 13, 12, 4, 12, 5, 12, 4, 12, 5, 12, 4, 12, 51, 11, 3, 11, 5, 12, 13, 12, 4, 12, 5,
                                  28, 5, 12, 4, 12, 51, 11, 3, 11, 5, 12, 13, 12, 4, 12, 5, 28, 5, 12, 4, 12, 51, 11, 3, 11, 5, 20, 5, 12, 4,
                                  12, 5, 28, 5, 12, 4, 12, 51, 11, 3, 11, 5, 20, 5, 12, 4, 12, 5, 28, 5, 12, 4, 12, 52, 10, 3, 11, 5, 20, 5,
                                  12, 4, 12, 5, 28, 5, 12, 4, 12, 52, 10, 3, 11, 5, 20, 5, 12, 4, 12, 5, 28, 5, 12, 4, 12, 52, 10, 3, 11, 5,
                                  20, 5, 12, 4, 12, 5, 28, 5, 12, 4, 12, 52, 10, 3, 10, 6, 20, 5, 12, 4, 12, 5, 28, 5, 12, 4, 12, 52, 11, 1,
                                  11, 6, 20, 5, 12, 4, 12, 5, 28, 5, 12, 4, 12, 52, 11, 1, 11, 6, 20, 5, 12, 4, 12, 5, 28, 5, 12, 4, 12, 53,
                                  10, 1, 11, 6, 20, 5, 12, 4, 12, 5, 12, 4, 12, 5, 12, 4, 12, 53, 10, 1, 11, 6, 12, 13, 12, 4, 12, 5, 12, 4,
                                  12, 5, 12, 4, 12, 53, 10, 1, 11, 6, 12, 13, 12, 4, 12, 5, 12, 4, 12, 5, 12, 4, 12, 53, 10, 1, 11, 6, 12, 13,
                                  12, 4, 12, 5, 12, 4, 12, 5, 12, 4, 12, 53, 10, 1, 10, 7, 12, 13, 12, 4, 12, 5, 12, 4, 12, 5, 12, 4, 12, 53,
                                  21, 7, 12, 13, 12, 4, 12, 5, 12, 4, 12, 5, 12, 4, 12, 53, 21, 7, 12, 13, 12, 4, 12, 5, 12, 4, 12, 5, 12, 4,
                                  12, 54, 20, 7, 12, 13, 12, 4, 12, 5, 12, 4, 12, 5, 12, 4, 12, 54, 20, 7, 12, 13, 12, 4, 12, 5, 12, 4, 12, 5,
                                  12, 4, 12, 54, 20, 7, 12, 14, 11, 4, 12, 5, 12, 4, 12, 5, 12, 4, 12, 54, 20, 7, 22, 4, 11, 4, 11, 6, 12, 4,
                                  12, 5, 12, 4, 12, 54, 20, 7, 22, 4, 11, 4, 11, 6, 12, 4, 12, 5, 12, 3, 12, 55, 19, 8, 22, 4, 11, 4, 11, 6,
                                  12, 4, 12, 5, 27, 56, 18, 8, 22, 4, 26, 6, 12, 4, 12, 5, 27, 56, 18, 8, 22, 5, 24, 7, 12, 4, 12, 5, 27, 56,
                                  18, 8, 22, 5, 24, 7, 12, 4, 12, 5, 27, 56, 18, 8, 22, 6, 22, 8, 12, 4, 12, 5, 26, 57, 18, 8, 22, 7, 20, 9,
                                  12, 4, 12, 5, 25, 58, 18, 8, 22, 8, 18, 10, 12, 4, 12, 5, 24, 59, 17, 9, 22, 10, 14, 12, 12, 4, 12, 5, 19, 127,
                                  5, 4925 };


float CImageUtility::addWatermark(IplImage *iplImage, int wm_content, int wm_style)
// Add watermark to the 1-channel image
// iplImage -- input and output image
// wm_code -- code to indicate the watermark content
//              0 -- ASTRI logo
//              1 -- Trial out version in Chinese
//              2 -- VEUHD on bottom right
// wm_style -- style of the watermark
//              0 -- white
//              1 -- black
//              2 -- purple
{
    if (iplImage == NULL) {
        showErrMsg("Invalid input image in CImageUtility::addWatermark()!\n");
        return false;
    }

    // Define watermark
    int watermark_width = 0;
    int watermark_height = 0;
    int first_val = 0;
    const short *wm_data = NULL;

    switch (wm_content) {
        case 0:
            // definition of watermark
            watermark_width = g_WMWidth_ASTRI;
            watermark_height = g_WMHeight_ASTRI;
            first_val = g_WMFirstVal_ASTRI;
            wm_data = g_WatermarkData_ASTRI;
            break;
        case 1:
            // definition of watermark
            watermark_width = g_WMWidth_Trialout;
            watermark_height = g_WMHeight_Trialout;
            first_val = g_WMFirstVal_Trialout;
            wm_data = g_WatermarkData_Trialout;
            break;
        case 2:
            // definition of watermark
            watermark_width = g_WMWidth_VEUHD;
            watermark_height = g_WMHeight_VEUHD;
            first_val = g_WMFirstVal_VEUHD;
            wm_data = g_WatermarkData_VEUHD;
            break;
        default:
            showErrMsg("Invalid watermark content in CImageUtility::addWatermark()!\n");
            return false;
    }

    int wm_val[3] = {-1, -1, -1};
    switch (wm_style) {
        case 0:
            wm_val[0] = 224;
            wm_val[1] = 224;
            wm_val[2] = 224;
            break;
        case 1:
            wm_val[0] = 32;
            wm_val[1] = 32;
            wm_val[2] = 32;
            break;
        case 2:
            wm_val[0] = 255;
            wm_val[1] = 128;
            wm_val[2] = 255;
            break;
        default:
            showErrMsg("Invalid watermark content in CImageUtility::addWatermark()!\n");
            return false;
    }

    if (iplImage->width < watermark_width || iplImage->height < watermark_height) {
        showErrMsg("Only support image wider than %d pixels in CImageUtility::addWatermark()!\n", watermark_width);
        return false;
    }

    // add watermark
    int height = iplImage->height > watermark_height ? watermark_height : iplImage->height > watermark_height;
    int wm_index = 0;
    int pixel_loc = 0;
    int wm_cur_pos = wm_data[0];
    int cur_val = first_val;
    if (wm_content == 0 || wm_content == 1) {
        if (iplImage->depth == SR_DEPTH_8U && iplImage->nChannels == 1) {
            for (int y=0; y<height; y++) {
                unsigned char *pImg = (unsigned char *)(iplImage->imageData + y * iplImage->widthStep);
                for (int x=0; x<iplImage->width; x++) {
			        if (x < watermark_width) {      // y <watermark_height && 
                        // decode one pixel
				        if (pixel_loc >= wm_cur_pos) {
					        wm_index ++;
					        wm_cur_pos += wm_data[wm_index];
					        cur_val = cur_val == 0 ? 1 : 0;
				        }
                        pixel_loc ++;
                        // style 1 and style 2
				        if (cur_val > 0) {
                            pImg[x] = (unsigned char)(wm_val[0]);
                        } 
			        }
                }
            }
        } else if (iplImage->depth == SR_DEPTH_32F && iplImage->nChannels == 1) {
            for (int y=0; y<height; y++) {
                float *pImg = (float *)(iplImage->imageData + y * iplImage->widthStep);
                for (int x=0; x<iplImage->width; x++) {
			        if (x < watermark_width) {      // y <watermark_height && 
                        // decode one pixel
				        if (pixel_loc >= wm_cur_pos) {
					        wm_index ++;
					        wm_cur_pos += wm_data[wm_index];
					        cur_val = cur_val == 0 ? 1 : 0;
				        }
                        pixel_loc ++;
                        // style 1 and style 2
				        if (cur_val > 0) {
                            pImg[x] = (float)wm_val[0];
                        }
			        }
                }
            }
        } else {
            showErrMsg("Invalid input date type in CImageUtility::addWatermark()!\n");
            return false;
        }
    } else if (wm_content == 2 && wm_style == 2) {
        if (iplImage->depth == SR_DEPTH_8U && iplImage->nChannels == 3) {
            for (int y=iplImage->height-watermark_height; y<iplImage->height; y++) {
                unsigned char *pImg = (unsigned char *)(iplImage->imageData + y * iplImage->widthStep);
                for (int x=iplImage->width-watermark_width; x<iplImage->width; x++) {
                    // decode one pixel
                    if (pixel_loc >= wm_cur_pos) {
                        wm_index ++;
                        wm_cur_pos += wm_data[wm_index];
                        cur_val = cur_val == 0 ? 1 : 0;
                    }
                    pixel_loc ++;
                    // style 1 and style 2
                    if (cur_val > 0) {
                        pImg[x*3] = (unsigned char)(wm_val[0]);
                        pImg[x*3+1] = (unsigned char)(wm_val[1]);
                        pImg[x*3+2] = (unsigned char)(wm_val[2]);
                    } 
                }
            }
        } else if (iplImage->depth == SR_DEPTH_32F && iplImage->nChannels == 3) {
            for (int y=iplImage->height-watermark_height; y<iplImage->height; y++) {
                float *pImg = (float *)(iplImage->imageData + y * iplImage->widthStep);
                for (int x=iplImage->width-watermark_width; x<iplImage->width; x++) {
                    // decode one pixel
                    if (pixel_loc >= wm_cur_pos) {
                        wm_index ++;
                        wm_cur_pos += wm_data[wm_index];
                        cur_val = cur_val == 0 ? 1 : 0;
                    }
                    pixel_loc ++;
                    // style 2
                    if (cur_val > 0) {
                        pImg[x*3] = (float)wm_val[0];
                        pImg[x*3+1] = (float)wm_val[1];
                        pImg[x*3+2] = (float)wm_val[2];
			        }
                }
            }
        } else {
            showErrMsg("Invalid input date type in CImageUtility::addWatermark()!\n");
            return false;
        }
    } else {
        showErrMsg("Invalid input date type or text font in CImageUtility::addWatermark()!\n");
        return false;
    }

    return true;
}

bool CImageUtility::cannyEdge_32f(IplImage *iplImage, IplImage *iplImgCannyEdge, float highThresh)
// Canny edge detection
// Original version was developed by by Kayton Cheung, IC-ASD, ASTRI
// Modified on March 5, 2015 (fixed the image misalignment problem by Luhong)
// Compared with the original version, this version:
//      (1). Use bilateral filter instead of Gaussian fitler for denoise
//      (2). Use
{
	float lowThresh = 0.4f * highThresh;
	//highThresh = -1;			//if user do not specify the highThresh (-1), the highThresh and lowThresh will be automatically calculated
	//float lowThresh = -1;

	const float sigma = 1.4142135623730950488016887242097f;
	const int wnd_rad = 4 * (int)ceil(sigma);   //wnd_size = 8 * (int)ceil(sigma) + 1;      // 16 --> 17, by Luhong, March 4, 2015
	//const int wnd_size = 16;
	IplImage *iplImage_norm = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplSX = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplSY = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGX = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGY = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGX_abs = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGY_abs = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplmagGrad = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	if (iplImage_norm == NULL || iplSX == NULL || iplSY == NULL || iplGX == NULL || iplGY == NULL || iplGX_abs == NULL || iplGY_abs == NULL || iplmagGrad == NULL)  {
		safeReleaseImage(&iplImage_norm, &iplSX, &iplSY, &iplGX, &iplGY, &iplmagGrad);
		safeReleaseImage(&iplGX_abs, &iplGY_abs);
		return NULL;
	}

    //saveImage("_GauSmoothOrg.bmp", iplImage);
    bilatFilter_32f(iplImage, iplImage_norm, 2, 1.0f, 25.0f);

    mulImage_32f(iplImage_norm, 1.0f/255.0f);

    //sobel_32f(iplImage_norm, iplGX, 0);
    //saveImage("_GradXs.bmp", iplGX, 128, 128.0f);
    //sobel_32f(iplImage_norm, iplGY, 1);
    //saveImage("_GradYs.bmp", iplGY, 128, 128.0f);
    //sobel_32f(iplImage_norm, iplmagGrad, 2);
    //saveImage("_GradMs.bmp", iplmagGrad, 0, 255.0f);

	//Calculate Smoothed Image
	//gaussian1D_32f(iplImage_norm, iplSX, wnd_rad, sigma, 0);
    copy(iplImage_norm, iplSX);
    //saveImage("_GauSmoothSx.bmp", iplSX, 0, 255.0f);
	//gaussian1D_32f(iplImage_norm, iplSY, wnd_rad, sigma, 1);
    copy(iplImage_norm, iplSY);
    //saveImage("_GauSmoothSy.bmp", iplSY, 0, 255.0f);


	//Calculate Gradient Image
	gradient1D_32f(iplSY, iplGX, wnd_rad, sigma, 0);	//MatLab smoothGradient() implementation: Smooth in Y + Gradient in X
	gradient1D_32f(iplSX, iplGY, wnd_rad, sigma, 1);	//MatLab smoothGradient() implementation: Smooth in X + Gradient in Y

    //Initialize Magnitude of Gradient
	for (int y=0; y<iplmagGrad->height; y++) {
		float *pmagGrad = (float *)((char*)iplmagGrad->imageData + y*iplmagGrad->widthStep);
		for (int x=0; x<iplmagGrad->width; x++) {
			pmagGrad[x] = 0;	
		}
	}

	//Calculate Magnitude of Gradient
	for (int y=0; y<iplmagGrad->height; y++) {
		float *pmagGrad = (float *)((char*)iplmagGrad->imageData + y*iplmagGrad->widthStep);
		float *pGX = (float *)((char*)iplGX->imageData + y*iplGX->widthStep);
		float *pGY = (float *)((char*)iplGY->imageData + y*iplGY->widthStep);
		for (int x=0; x<iplmagGrad->width; x++) {
			pmagGrad[x] = sqrt(pGX[x]*pGX[x] + pGY[x]*pGY[x]);	

		}
	}

    //saveImage("_GradX_new.bmp", iplGX, 128, 128.0f);
    //saveImage("_GradY_new.bmp", iplGY, 128, 128.0f);
    //saveImage("_GradM_new.bmp", iplmagGrad, 0, 255.0f);

	//Normalize for threshold selection
	float magmax = maxInImage_32f(iplmagGrad);
	for (int y=0; y<iplmagGrad->height; y++) {
		float *pmagGrad = (float *)((char*)iplmagGrad->imageData + y*iplmagGrad->widthStep);
		for (int x=0; x<iplmagGrad->width; x++) {
			if(magmax > 0){
				pmagGrad[x] = pmagGrad[x] / magmax;
			}
		}
	}

	//if (m_strPara.OutputLevel >= 2) {
	//	sprintf(stFilename, "%s_magGrad_norm.bmp", stFilePre);
	//	saveImage(stFilename, iplmagGrad, 0, 255.0f);
	//}

	//Determine Hysteresis Thresholds (highThresh = -1 indicates the user do not input highThresh value)
	if(highThresh == -1){
		float A=1;  //
		float n=64; //n specifies the number of bins used in the histogram.

		float hisCount[65];
		for (int p=1; p<=64; p++){
			hisCount[p] = 0;
		}

		for (int p=1; p<=64; p++){
			for (int y=0; y<iplmagGrad->height; y++) {
				float *pmagGrad = (float *)((char*)iplmagGrad->imageData + y*iplmagGrad->widthStep);
				for (int x=0; x<iplmagGrad->width; x++) {
					if((pmagGrad[x] >= A*(p-1.5)/(n-1)) && (pmagGrad[x] < A*(p-0.5)/(n-1))){
						hisCount[p] = hisCount[p] + 1;
					}
				}
			}
		}

		float PercentOfPixelsNotEdges = 0.7f;
		float ThresholdRatio = 0.4f;
		int TotalPercentOfPixelsNotEdges = (int)PercentOfPixelsNotEdges*iplImage->height*iplImage->width;
		int complete_flag = 0;
		float cumhisCount[65];
		for (int p=1; p<=64; p++){
			if (p==1){
				cumhisCount[p] = hisCount[p];
			}
			else{
				cumhisCount[p] = cumhisCount[p-1] + hisCount[p];
			}
		}

		for (int p=1; p<=64; p++){
			if (cumhisCount[p] > TotalPercentOfPixelsNotEdges && complete_flag != 1){
				highThresh = (float) p / 64;
				lowThresh = ThresholdRatio*highThresh;
				complete_flag = 1;
			}
		}
	}
	else{
		highThresh = highThresh;
		lowThresh = lowThresh;
	}
    
    //
	// Find magGradLocalMaxima, Weakedge, Strong
    //
	IplImage *iplidx1 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidx2 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidx3 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidx4 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxLocalMax1 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxLocalMax2 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxLocalMax3 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxLocalMax4 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxLocalMaxSum = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxWeak1 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxWeak2 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxWeak3 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxWeak4 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxWeakSum = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxStrong1 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxStrong2 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxStrong3 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxStrong4 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxStrongSum = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );

	findLocalMaxima(iplGX,iplGY,iplmagGrad,iplidx1,iplidxLocalMax1,iplidxWeak1,iplidxStrong1,lowThresh,highThresh,1);
	findLocalMaxima(iplGX,iplGY,iplmagGrad,iplidx2,iplidxLocalMax2,iplidxWeak2,iplidxStrong2,lowThresh,highThresh,2);
	findLocalMaxima(iplGX,iplGY,iplmagGrad,iplidx3,iplidxLocalMax3,iplidxWeak3,iplidxStrong3,lowThresh,highThresh,3);
	findLocalMaxima(iplGX,iplGY,iplmagGrad,iplidx4,iplidxLocalMax4,iplidxWeak4,iplidxStrong4,lowThresh,highThresh,4);
	
	//Initialize the Array
	for (int y=0; y<iplImage->height; y++) {
		float *pidxLocalMaxSum = (float *)((char*)iplidxLocalMaxSum->imageData + y*iplidxLocalMaxSum->widthStep);
		float *pidxWeakSum = (float *)((char*)iplidxWeakSum->imageData + y*iplidxWeakSum->widthStep);
		float *pidxStrongSum = (float *)((char*)iplidxStrongSum->imageData + y*iplidxStrongSum->widthStep);
		for (int x=0; x<iplImage->width; x++) {
			pidxLocalMaxSum[x] = 0;
			pidxWeakSum[x] = 0;
			pidxStrongSum[x] = 0;
		}
	}
	
	for (int y=0; y<iplImage->height; y++) {
		float *pidxLocalMax1 = (float *)((char*)iplidxLocalMax1->imageData + y*iplidxLocalMax1->widthStep);
		float *pidxLocalMax2 = (float *)((char*)iplidxLocalMax2->imageData + y*iplidxLocalMax2->widthStep);
		float *pidxLocalMax3 = (float *)((char*)iplidxLocalMax3->imageData + y*iplidxLocalMax3->widthStep);
		float *pidxLocalMax4 = (float *)((char*)iplidxLocalMax4->imageData + y*iplidxLocalMax4->widthStep);
		float *pidxLocalMaxSum = (float *)((char*)iplidxLocalMaxSum->imageData + y*iplidxLocalMaxSum->widthStep);
		float *pidxWeak1 = (float *)((char*)iplidxWeak1->imageData + y*iplidxWeak1->widthStep);
		float *pidxWeak2 = (float *)((char*)iplidxWeak2->imageData + y*iplidxWeak2->widthStep);
		float *pidxWeak3 = (float *)((char*)iplidxWeak3->imageData + y*iplidxWeak3->widthStep);
		float *pidxWeak4 = (float *)((char*)iplidxWeak4->imageData + y*iplidxWeak4->widthStep);
		float *pidxWeakSum = (float *)((char*)iplidxWeakSum->imageData + y*iplidxWeakSum->widthStep);
		float *pidxStrong1 = (float *)((char*)iplidxStrong1->imageData + y*iplidxStrong1->widthStep);
		float *pidxStrong2 = (float *)((char*)iplidxStrong2->imageData + y*iplidxStrong2->widthStep);
		float *pidxStrong3 = (float *)((char*)iplidxStrong3->imageData + y*iplidxStrong3->widthStep);
		float *pidxStrong4 = (float *)((char*)iplidxStrong4->imageData + y*iplidxStrong4->widthStep);
		float *pidxStrongSum = (float *)((char*)iplidxStrongSum->imageData + y*iplidxStrongSum->widthStep);
		for (int x=0; x<iplImage->width; x++) {
			if(pidxLocalMax1[x] == 1 || pidxLocalMax2[x] == 1 || pidxLocalMax3[x] == 1 || pidxLocalMax4[x] == 1){
				pidxLocalMaxSum[x] = 1;
			}

			if(pidxWeak1[x] == 1 || pidxWeak2[x] == 1 || pidxWeak3[x] == 1 || pidxWeak4[x] == 1){
				pidxWeakSum[x] = 1;
			}

			if(pidxStrong1[x] == 1 || pidxStrong2[x] == 1 || pidxStrong3[x] == 1 || pidxStrong4[x] == 1){
				pidxStrongSum[x] = 1;
			}
		}
	}

	//Initialize the Canny Edge Array
	for (int ir=0; ir<iplImgCannyEdge->height; ir++){
		float *pImgCannyEdge = (float *)((char*)iplImgCannyEdge->imageData + ir*iplImgCannyEdge->widthStep);
		//float *pidxStrongSum = (float *)((char*)iplidxStrongSum->imageData + ir*iplidxStrongSum->widthStep);
		for (int ic=0; ic<iplImgCannyEdge->width; ic++){
			//pImgCannyEdge[ic] = pidxStrongSum[ic];
			pImgCannyEdge[ic] = 0;
		}
	}

    // by Luhong, Sept. 10, 2013
    //saveImage("_StrongSum.bmp", iplidxStrongSum, 0, 255.0f);
    IplImage *iplBreakPoint = createImage(iplImgCannyEdge->width, iplImgCannyEdge->height, SR_DEPTH_8U, 1);     // TODO: check 
    bool bBreakPoint = false;
    setZero(iplBreakPoint);

	for (int ir=1; ir<iplImage->height-1; ir++){
		float *pidxStrongSum = (float *)((char*)iplidxStrongSum->imageData + ir*iplidxStrongSum->widthStep);
		for (int ic=1; ic<iplImage->width-1; ic++){
			if ( pidxStrongSum[ic] == 1){
				findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,ir,ic,8,0, iplBreakPoint, bBreakPoint);
			}
		}
	}

    // by Luhong, Sept. 10, 2013
    //saveImage("_CannyEdge0.bmp", iplImgCannyEdge, 0, 255.0f); 
    int max_iter = 8162;
    int iter_count = 0;
    while (bBreakPoint) {
        bBreakPoint = false;
        for (int y=0; y<iplBreakPoint->height; y++) {
            unsigned char *pMark = (unsigned char *)(iplBreakPoint->imageData + y * iplBreakPoint->widthStep);
            for (int x=0; x<iplBreakPoint->width; x++) {
                if (pMark[x] != 0) {
                    findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,y,x,8,0, iplBreakPoint, bBreakPoint);
                }
            }
        }
        iter_count ++;
        if (iter_count >= max_iter) {
            showErrMsg("Warning: Canny edge finder is overflow in CImageUtility::cannyedge_MatLab_32f()!\n");
            break;
        }
    }
	
	safeReleaseImage(&iplImage_norm, &iplSX, &iplSY, &iplGX, &iplGY);
	safeReleaseImage(&iplGX_abs, &iplGY_abs, &iplmagGrad);
	safeReleaseImage(&iplidx1, &iplidx2, &iplidx3, &iplidx4);
	safeReleaseImage(&iplidxLocalMax1, &iplidxLocalMax2, &iplidxLocalMax3, &iplidxLocalMax4, &iplidxLocalMaxSum);
	safeReleaseImage(&iplidxWeak1, &iplidxWeak2, &iplidxWeak3, &iplidxWeak4, &iplidxWeakSum);
	safeReleaseImage(&iplidxStrong1, &iplidxStrong2, &iplidxStrong3, &iplidxStrong4, &iplidxStrongSum);

    return true;
}

bool CImageUtility::cannyedge_MatLab_32f(IplImage *iplImage, IplImage *iplImgCannyEdge, float highThresh)
// by Kayton Cheung, IC-ASD, ASTRI
// Jul. 29, 2013 (Implemented complete MatLab Canny Edge Detection)
// Modified on March 4, 2015 (fixed the image misalignment problem by Luhong)
{
	float lowThresh = 0.4f * highThresh;
	//highThresh = -1;			//if user do not specify the highThresh (-1), the highThresh and lowThresh will be automatically calculated
	//float lowThresh = -1;

	const float sigma = 1.4142135623730950488016887242097f;
	const int wnd_rad = 4 * (int)ceil(sigma);   //wnd_size = 8 * (int)ceil(sigma) + 1;      // 16 --> 17, by Luhong, March 4, 2015
	//const int wnd_size = 16;
	IplImage *iplImage_norm = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplSX = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplSY = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGX = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGY = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGX_abs = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplGY_abs = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplmagGrad = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	if (iplImage_norm == NULL || iplSX == NULL || iplSY == NULL || iplGX == NULL || iplGY == NULL || iplGX_abs == NULL || iplGY_abs == NULL || iplmagGrad == NULL)  {
		safeReleaseImage(&iplImage_norm, &iplSX, &iplSY, &iplGX, &iplGY, &iplmagGrad);
		safeReleaseImage(&iplGX_abs, &iplGY_abs);
		return NULL;
	}

	//Image Normalization
	for (int y=0; y<iplImage_norm->height; y++) {
		float *pImage = (float *)((char*)iplImage->imageData + y*iplImage->widthStep);
		float *pImage_norm = (float *)((char*)iplImage_norm->imageData + y*iplImage_norm->widthStep);
		for (int x=0; x<iplImage_norm->width; x++) {
			pImage_norm[x] = pImage[x] / 255.0f;
		}
	}

	//KT Debug
	//float imgmax = maxInImage_32f(iplImage);
	//float imgmin = minInImage_32f(iplImage);
	//float imgmax_norm = maxInImage_32f(iplImage_norm);
	//float imgmin_norm = minInImage_32f(iplImage_norm);

	//Calculate Smoothed Image
    //saveImage("_GauSmoothOrg.bmp", iplImage_norm, 0, 255.0f);
	gaussian1D_32f(iplImage_norm, iplSX, wnd_rad, sigma, 0);
    //saveImage("_GauSmoothSx.bmp", iplSX, 0, 255.0f);
	gaussian1D_32f(iplImage_norm, iplSY, wnd_rad, sigma, 1);
    //saveImage("_GauSmoothSy.bmp", iplSY, 0, 255.0f);

	//KT Debug
	//for (int y=0; y<iplImage->height; y++) {
	//	float *pSX = (float *)((char*)iplSX->imageData + y*iplSX->widthStep);
	//	float *pSY = (float *)((char*)iplSY->imageData + y*iplSY->widthStep);
	//	for (int x=0; x<iplImage->width; x++) {
	//		if(x==128 && y==128){
	//			pSX[x] = pSX[x];
	//			pSY[x] = pSY[x];
	//		}
	//	}
	//}

	//Calculate Gradient Image
	gradient1D_32f(iplSY, iplGX, wnd_rad, sigma, 0);	//MatLab smoothGradient() implementation: Smooth in Y + Gradient in X
	gradient1D_32f(iplSX, iplGY, wnd_rad, sigma, 1);	//MatLab smoothGradient() implementation: Smooth in X + Gradient in Y
	//KT Debug
	//for (int y=0; y<iplImage->height; y++) {
	//	float *pGX = (float *)((char*)iplGX->imageData + y*iplGX->widthStep);
	//	float *pGY = (float *)((char*)iplGY->imageData + y*iplGY->widthStep);
	//	for (int x=0; x<iplImage->width; x++) {
	//		if(x==128 && y==128){
	//			pGX[x] = pGX[x];
	//			pGY[x] = pGY[x];
	//		}
	//	}
	//}
	//float GXmax = maxInImage_32f(iplGX);
	//float GYmax = maxInImage_32f(iplGY);
	//float GXmin = minInImage_32f(iplGX);
	//float GYmin = minInImage_32f(iplGY);*/

	//if (m_strPara.OutputLevel >= 2) {
	//	sprintf(stFilename, "%s_GaussianX.bmp", stFilePre);
	//	saveImage(stFilename, iplSX, 0, 255.0f);
	//	sprintf(stFilename, "%s_GaussianY.bmp", stFilePre);
	//	saveImage(stFilename, iplSY, 0, 255.0f);
	//	sprintf(stFilename, "%s_GradientX.bmp", stFilePre);
	//	saveImage(stFilename, iplGX, 0, 255.0f);
	//	sprintf(stFilename, "%s_GradientY.bmp", stFilePre);
	//	saveImage(stFilename, iplGY, 0, 255.0f);
	//}

	//Initialize Magnitude of Gradient
	for (int y=0; y<iplmagGrad->height; y++) {
		float *pmagGrad = (float *)((char*)iplmagGrad->imageData + y*iplmagGrad->widthStep);
		for (int x=0; x<iplmagGrad->width; x++) {
			pmagGrad[x] = 0;	
		}
	}

	//Calculate Magnitude of Gradient
	for (int y=0; y<iplmagGrad->height; y++) {
		float *pmagGrad = (float *)((char*)iplmagGrad->imageData + y*iplmagGrad->widthStep);
		float *pGX = (float *)((char*)iplGX->imageData + y*iplGX->widthStep);
		float *pGY = (float *)((char*)iplGY->imageData + y*iplGY->widthStep);
		//float *pGX_abs = (float *)((char*)iplGX_abs->imageData + y*iplGX_abs->widthStep);
		//float *pGY_abs = (float *)((char*)iplGY_abs->imageData + y*iplGY_abs->widthStep);
		for (int x=0; x<iplmagGrad->width; x++) {
			//pGX_abs[x] = pGX[x] < 0.0f ? -pGX[x] : pGX[x];
			//pGY_abs[x] = pGY[x] < 0.0f ? -pGY[x] : pGY[x];
			//pmagGrad[x] = sqrt(pGX_abs[x]*pGX_abs[x] + pGY_abs[x]*pGY_abs[x]);
			pmagGrad[x] = sqrt(pGX[x]*pGX[x] + pGY[x]*pGY[x]);	
			//if(x==0 && y==iplmagGrad->height-1)
			//	int p=0;
		}
	}

	//if (m_strPara.OutputLevel >= 2) {
	//	sprintf(stFilename, "%s_magGrad.bmp", stFilePre);
	//	saveImage(stFilename, iplmagGrad, 0, 255.0f);
	//}

	//Normalize for threshold selection
	float magmax = maxInImage_32f(iplmagGrad);
	for (int y=0; y<iplmagGrad->height; y++) {
		float *pmagGrad = (float *)((char*)iplmagGrad->imageData + y*iplmagGrad->widthStep);
		for (int x=0; x<iplmagGrad->width; x++) {
			if(magmax > 0){
				pmagGrad[x] = pmagGrad[x] / magmax;
			}
		}
	}

	//if (m_strPara.OutputLevel >= 2) {
	//	sprintf(stFilename, "%s_magGrad_norm.bmp", stFilePre);
	//	saveImage(stFilename, iplmagGrad, 0, 255.0f);
	//}

	//Determine Hysteresis Thresholds (highThresh = -1 indicates the user do not input highThresh value)
	if(highThresh == -1){
		float A=1;  //
		float n=64; //n specifies the number of bins used in the histogram.

		float hisCount[65];
		for (int p=1; p<=64; p++){
			hisCount[p] = 0;
		}

		for (int p=1; p<=64; p++){
			for (int y=0; y<iplmagGrad->height; y++) {
				float *pmagGrad = (float *)((char*)iplmagGrad->imageData + y*iplmagGrad->widthStep);
				for (int x=0; x<iplmagGrad->width; x++) {
					if((pmagGrad[x] >= A*(p-1.5)/(n-1)) && (pmagGrad[x] < A*(p-0.5)/(n-1))){
						hisCount[p] = hisCount[p] + 1;
					}
				}
			}
		}

		float PercentOfPixelsNotEdges = 0.7f;
		float ThresholdRatio = 0.4f;
		int TotalPercentOfPixelsNotEdges = (int)PercentOfPixelsNotEdges*iplImage->height*iplImage->width;
		int complete_flag = 0;
		float cumhisCount[65];
		for (int p=1; p<=64; p++){
			if (p==1){
				cumhisCount[p] = hisCount[p];
			}
			else{
				cumhisCount[p] = cumhisCount[p-1] + hisCount[p];
			}
		}

		for (int p=1; p<=64; p++){
			if (cumhisCount[p] > TotalPercentOfPixelsNotEdges && complete_flag != 1){
				highThresh = (float) p / 64;
				lowThresh = ThresholdRatio*highThresh;
				complete_flag = 1;
			}
		}
	}
	else{
		highThresh = highThresh;
		lowThresh = lowThresh;
	}

	//================================================

	//Find magGradLocalMaxima, Weakedge, Strong
	IplImage *iplidx1 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidx2 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidx3 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidx4 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxLocalMax1 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxLocalMax2 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxLocalMax3 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxLocalMax4 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxLocalMaxSum = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxWeak1 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxWeak2 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxWeak3 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxWeak4 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxWeakSum = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxStrong1 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxStrong2 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxStrong3 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxStrong4 = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );
	IplImage *iplidxStrongSum = createImage( iplImage->width, iplImage->height, SR_DEPTH_32F, 1 );

	findLocalMaxima(iplGX,iplGY,iplmagGrad,iplidx1,iplidxLocalMax1,iplidxWeak1,iplidxStrong1,lowThresh,highThresh,1);
	findLocalMaxima(iplGX,iplGY,iplmagGrad,iplidx2,iplidxLocalMax2,iplidxWeak2,iplidxStrong2,lowThresh,highThresh,2);
	findLocalMaxima(iplGX,iplGY,iplmagGrad,iplidx3,iplidxLocalMax3,iplidxWeak3,iplidxStrong3,lowThresh,highThresh,3);
	findLocalMaxima(iplGX,iplGY,iplmagGrad,iplidx4,iplidxLocalMax4,iplidxWeak4,iplidxStrong4,lowThresh,highThresh,4);
	
	//Initialize the Array
	for (int y=0; y<iplImage->height; y++) {
		float *pidxLocalMaxSum = (float *)((char*)iplidxLocalMaxSum->imageData + y*iplidxLocalMaxSum->widthStep);
		float *pidxWeakSum = (float *)((char*)iplidxWeakSum->imageData + y*iplidxWeakSum->widthStep);
		float *pidxStrongSum = (float *)((char*)iplidxStrongSum->imageData + y*iplidxStrongSum->widthStep);
		for (int x=0; x<iplImage->width; x++) {
			pidxLocalMaxSum[x] = 0;
			pidxWeakSum[x] = 0;
			pidxStrongSum[x] = 0;
		}
	}
	
	for (int y=0; y<iplImage->height; y++) {
		float *pidxLocalMax1 = (float *)((char*)iplidxLocalMax1->imageData + y*iplidxLocalMax1->widthStep);
		float *pidxLocalMax2 = (float *)((char*)iplidxLocalMax2->imageData + y*iplidxLocalMax2->widthStep);
		float *pidxLocalMax3 = (float *)((char*)iplidxLocalMax3->imageData + y*iplidxLocalMax3->widthStep);
		float *pidxLocalMax4 = (float *)((char*)iplidxLocalMax4->imageData + y*iplidxLocalMax4->widthStep);
		float *pidxLocalMaxSum = (float *)((char*)iplidxLocalMaxSum->imageData + y*iplidxLocalMaxSum->widthStep);
		float *pidxWeak1 = (float *)((char*)iplidxWeak1->imageData + y*iplidxWeak1->widthStep);
		float *pidxWeak2 = (float *)((char*)iplidxWeak2->imageData + y*iplidxWeak2->widthStep);
		float *pidxWeak3 = (float *)((char*)iplidxWeak3->imageData + y*iplidxWeak3->widthStep);
		float *pidxWeak4 = (float *)((char*)iplidxWeak4->imageData + y*iplidxWeak4->widthStep);
		float *pidxWeakSum = (float *)((char*)iplidxWeakSum->imageData + y*iplidxWeakSum->widthStep);
		float *pidxStrong1 = (float *)((char*)iplidxStrong1->imageData + y*iplidxStrong1->widthStep);
		float *pidxStrong2 = (float *)((char*)iplidxStrong2->imageData + y*iplidxStrong2->widthStep);
		float *pidxStrong3 = (float *)((char*)iplidxStrong3->imageData + y*iplidxStrong3->widthStep);
		float *pidxStrong4 = (float *)((char*)iplidxStrong4->imageData + y*iplidxStrong4->widthStep);
		float *pidxStrongSum = (float *)((char*)iplidxStrongSum->imageData + y*iplidxStrongSum->widthStep);
		for (int x=0; x<iplImage->width; x++) {
			if(pidxLocalMax1[x] == 1 || pidxLocalMax2[x] == 1 || pidxLocalMax3[x] == 1 || pidxLocalMax4[x] == 1){
				pidxLocalMaxSum[x] = 1;
			}

			if(pidxWeak1[x] == 1 || pidxWeak2[x] == 1 || pidxWeak3[x] == 1 || pidxWeak4[x] == 1){
				pidxWeakSum[x] = 1;
			}

			if(pidxStrong1[x] == 1 || pidxStrong2[x] == 1 || pidxStrong3[x] == 1 || pidxStrong4[x] == 1){
				pidxStrongSum[x] = 1;
			}
		}
	}

	//if (m_strPara.OutputLevel >= 2) {
	//	sprintf(stFilename, "%s_idx1.bmp", stFilePre);
	//	saveImage(stFilename, iplidx1, 0, 255.0f);
	//	sprintf(stFilename, "%s_idxLocalMax1.bmp", stFilePre);
	//	saveImage(stFilename, iplidxLocalMax1, 0, 255.0f);
	//	sprintf(stFilename, "%s_idxWeak1.bmp", stFilePre);
	//	saveImage(stFilename, iplidxWeak1, 0, 255.0f);
	//	sprintf(stFilename, "%s_idxStrong1.bmp", stFilePre);
	//	saveImage(stFilename, iplidxStrong1, 0, 255.0f);

	//	sprintf(stFilename, "%s_idx2.bmp", stFilePre);
	//	saveImage(stFilename, iplidx2, 0, 255.0f);
	//	sprintf(stFilename, "%s_idxLocalMax2.bmp", stFilePre);
	//	saveImage(stFilename, iplidxLocalMax2, 0, 255.0f);
	//	sprintf(stFilename, "%s_idxWeak2.bmp", stFilePre);
	//	saveImage(stFilename, iplidxWeak2, 0, 255.0f);
	//	sprintf(stFilename, "%s_idxStrong2.bmp", stFilePre);
	//	saveImage(stFilename, iplidxStrong2, 0, 255.0f);

	//	sprintf(stFilename, "%s_idx3.bmp", stFilePre);
	//	saveImage(stFilename, iplidx3, 0, 255.0f);
	//	sprintf(stFilename, "%s_idxLocalMax3.bmp", stFilePre);
	//	saveImage(stFilename, iplidxLocalMax3, 0, 255.0f);
	//	sprintf(stFilename, "%s_idxWeak3.bmp", stFilePre);
	//	saveImage(stFilename, iplidxWeak3, 0, 255.0f);
	//	sprintf(stFilename, "%s_idxStrong3.bmp", stFilePre);
	//	saveImage(stFilename, iplidxStrong3, 0, 255.0f);

	//	sprintf(stFilename, "%s_idx4.bmp", stFilePre);
	//	saveImage(stFilename, iplidx4, 0, 255.0f);
	//	sprintf(stFilename, "%s_idxLocalMax4.bmp", stFilePre);
	//	saveImage(stFilename, iplidxLocalMax4, 0, 255.0f);
	//	sprintf(stFilename, "%s_idxWeak4.bmp", stFilePre);
	//	saveImage(stFilename, iplidxWeak4, 0, 255.0f);
	//	sprintf(stFilename, "%s_idxStrong4.bmp", stFilePre);
	//	saveImage(stFilename, iplidxStrong4, 0, 255.0f);

	//	sprintf(stFilename, "%s_idxLocalMaxSum.bmp", stFilePre);
	//	saveImage(stFilename, iplidxLocalMaxSum, 0, 255.0f);
	//	sprintf(stFilename, "%s_idxWeakSum.bmp", stFilePre);
	//	saveImage(stFilename, iplidxWeakSum, 0, 255.0f);
	//	sprintf(stFilename, "%s_idxStrongSum.bmp", stFilePre);
	//	saveImage(stFilename, iplidxStrongSum, 0, 255.0f);
	//}

	//Initialize the Canny Edge Array
	for (int ir=0; ir<iplImgCannyEdge->height; ir++){
		float *pImgCannyEdge = (float *)((char*)iplImgCannyEdge->imageData + ir*iplImgCannyEdge->widthStep);
		//float *pidxStrongSum = (float *)((char*)iplidxStrongSum->imageData + ir*iplidxStrongSum->widthStep);
		for (int ic=0; ic<iplImgCannyEdge->width; ic++){
			//pImgCannyEdge[ic] = pidxStrongSum[ic];
			pImgCannyEdge[ic] = 0;
		}
	}

    // by Luhong, Sept. 10, 2013
    //saveImage("_StrongSum.bmp", iplidxStrongSum, 0, 255.0f);
    IplImage *iplBreakPoint = createImage(iplImgCannyEdge->width, iplImgCannyEdge->height, SR_DEPTH_8U, 1);     // TODO: check 
	if (iplBreakPoint == NULL) {
		safeReleaseImage(&iplImage_norm, &iplSX, &iplSY, &iplGX, &iplGY);
		safeReleaseImage(&iplGX_abs, &iplGY_abs, &iplmagGrad);
		safeReleaseImage(&iplidx1, &iplidx2, &iplidx3, &iplidx4);
		safeReleaseImage(&iplidxLocalMax1, &iplidxLocalMax2, &iplidxLocalMax3, &iplidxLocalMax4, &iplidxLocalMaxSum);
		safeReleaseImage(&iplidxWeak1, &iplidxWeak2, &iplidxWeak3, &iplidxWeak4, &iplidxWeakSum);
		safeReleaseImage(&iplidxStrong1, &iplidxStrong2, &iplidxStrong3, &iplidxStrong4, &iplidxStrongSum);
		return false;
	}
    bool bBreakPoint = false;
    setZero(iplBreakPoint);

	for (int ir=1; ir<iplImage->height-1; ir++){
		float *pidxStrongSum = (float *)((char*)iplidxStrongSum->imageData + ir*iplidxStrongSum->widthStep);
		for (int ic=1; ic<iplImage->width-1; ic++){
			if ( pidxStrongSum[ic] == 1){
				findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,ir,ic,8,0, iplBreakPoint, bBreakPoint);
			}
		}
	}

    // by Luhong, Sept. 10, 2013
    //saveImage("_CannyEdge0.bmp", iplImgCannyEdge, 0, 255.0f); 
    int max_iter = 8162;
    int iter_count = 0;
    while (bBreakPoint) {
        bBreakPoint = false;
        for (int y=0; y<iplBreakPoint->height; y++) {
            unsigned char *pMark = (unsigned char *)(iplBreakPoint->imageData + y * iplBreakPoint->widthStep);
            for (int x=0; x<iplBreakPoint->width; x++) {
                if (pMark[x] != 0) {
                    findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,y,x,8,0, iplBreakPoint, bBreakPoint);
                }
            }
        }
        iter_count ++;
        if (iter_count >= max_iter) {
            showErrMsg("Warning: Canny edge finder is overflow in CImageUtility::cannyedge_MatLab_32f()!\n");
            break;
        }
    }
    //saveImage("_CannyEdge.bmp", iplImgCannyEdge, 0, 255.0f); 

	safeReleaseImage(&iplBreakPoint);
	safeReleaseImage(&iplImage_norm, &iplSX, &iplSY, &iplGX, &iplGY);
	safeReleaseImage(&iplGX_abs, &iplGY_abs, &iplmagGrad);
	safeReleaseImage(&iplidx1, &iplidx2, &iplidx3, &iplidx4);
	safeReleaseImage(&iplidxLocalMax1, &iplidxLocalMax2, &iplidxLocalMax3, &iplidxLocalMax4, &iplidxLocalMaxSum);
	safeReleaseImage(&iplidxWeak1, &iplidxWeak2, &iplidxWeak3, &iplidxWeak4, &iplidxWeakSum);
	safeReleaseImage(&iplidxStrong1, &iplidxStrong2, &iplidxStrong3, &iplidxStrong4, &iplidxStrongSum);

    return true;
}

bool CImageUtility::gaussian1D_32f(IplImage *iplImage, IplImage *iplDstImage, int wnd_rad, float sigma, int direction)
// Gaussian filter
// This function supports the "in-place" operation (source and destination images are the same one)
// This function does not use the decomposition algorithm and ignore the boundary effects
// by Kayton Cheung, IC-ASD, ASTRI
// Jul. 29, 2013 (Implemented 1D gaussian convolution)
// Modified by Luhong Liang (solved the mis-alignment problem between original and gradient images)
{
	if (iplImage == NULL || iplDstImage == NULL || wnd_rad < 1 || sigma < 0)  {	// TODO: complete check here
		showErrMsg("Invalid input argument in CImageUtility::gaussian1D_32f()!\n");
		return false;
	}

	// make filter
    int wnd_size = wnd_rad * 2 + 1;     // by Luhong, March 4, 2015
	float *pFilter = new float[wnd_size];
	if (pFilter == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gaussian1D_32f()!\n");
		return false;
	}
	//int center = wnd_size >> 1;		//center = 17/2 = 8
	float div = 0.0f;
	float div_sigma_sq2 = 0.5f / (sigma * sigma);	//div_sigma_sq2 = 0.250
	for (int i=0; i<wnd_size; i++) {
		//float diff = (float)(i - center);
		float diff = (float)(i - (wnd_size-1.0)/2);		//X.K.Yang Implementation
		float exp_num = - diff * diff * div_sigma_sq2;
		float value = exp(exp_num);
		value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
		pFilter[i] = value;
		div += value;
	}
	for (int i=0; i<wnd_size; i++) {
		pFilter[i] = pFilter[i] / div;
	}

	// padding in both Left, Right, Top and Bottom (For 2D Convolution)
	//int wnd_radius = wnd_size >> 1;
	//IplImage *iplSrcImage = padding(iplImage, wnd_radius, wnd_size-wnd_radius-1, wnd_radius, wnd_size-wnd_radius-1);
	//IplImage *iplInter = createImage(iplImage->width+wnd_size-1, iplImage->height, SR_DEPTH_32F, 1);
	//if (iplSrcImage == NULL || iplInter == NULL) {
	//	showErrMsg("Fail to allocate buffer in CImageUtility::gaussian_32f()!\n");
	//	delete [] pFilter;
	//	safeReleaseImage(&iplSrcImage, &iplInter);
	//	return false;
	//}

	// convolution in X direction
	if(direction == 0){
		// padding in Left and Right Only (For 1D Horizontal Convolution)
		int wnd_radius = wnd_size >> 1;
		//IplImage *iplSrcImage = padding(iplImage, wnd_radius, wnd_radius, 0, 0);	//If the following pixel alignment is used for odd number wnd_size
		IplImage *iplSrcImage = padding(iplImage, wnd_radius, wnd_radius, 0, 0);  // (wnd_radius-1 --> wnd_radius) by Luhong, March 4, 2015
		if (iplSrcImage == NULL) {
			showErrMsg("Fail to allocate buffer in CImageUtility::gaussian1D_32f()!\n");
			delete [] pFilter;
			safeReleaseImage(&iplSrcImage);
			return false;
		}

		// convolution process
		for (int y=0; y<iplDstImage->height; y++) {
			float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
			float *pSrc = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				float val = 0.0f;
				float *pSrcCol = pSrc + x;
				for (int xx=0; xx<wnd_size; xx++) {
					//val += pSrcCol[xx] * pFilter[xx];
					val += pSrcCol[xx] * pFilter[wnd_size-1-xx];
				}
				pDst[x] = val;
			}
		}

		// align the pixel position to match MatLab convolution implementation
		//IplImage *iplDstImage_align = createImage( iplDstImage->width, iplDstImage->height), SR_DEPTH_32F, 1 );
		//for (int y=0; y<iplDstImage->height; y++) {
		//	float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		//	float *pDst_align = (float *)((char*)iplDstImage_align->imageData + y * iplDstImage_align->widthStep);
		//	for (int x=0; x<iplDstImage->width; x++) {
		//		pDst_align[x] = pDst[x+1];
		//	}
		//}
		//copy(iplDstImage_align, iplDstImage);

		safeReleaseImage(&iplSrcImage);
	}

	// convolution in Y direction
	else if(direction == 1){
		// padding in Top and Bottom Only (For 1D Vertical Convolution)
		int wnd_radius = wnd_size >> 1;
		//IplImage *iplSrcImage = padding(iplImage, 0, 0, wnd_radius, wnd_radius);	//If the following pixel alignment is used for odd number wnd_size
		IplImage *iplSrcImage = padding(iplImage, 0, 0, wnd_radius, wnd_radius);        // (wnd_radius-1 --> wnd_radius) by Luhong, March 4, 2015
		if (iplSrcImage == NULL) {
			showErrMsg("Fail to allocate buffer in CImageUtility::gaussian1D_32f()!\n");
			delete [] pFilter;
			safeReleaseImage(&iplSrcImage);
			return false;
		}

		// convolution process
		for (int y=0; y<iplDstImage->height; y++) {
			float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
			float *pSrc = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				float val = 0.0f;
				float *pSrcCol = pSrc + x;
				for (int yy=0; yy<wnd_size; yy++) {
					//val += pSrcCol[0] * pFilter[yy];
					val += pSrcCol[0] * pFilter[wnd_size-1-yy];
					pSrcCol += iplSrcImage->width;
				}
				pDst[x] = val;
			}
		}

		// align the pixel position to match MatLab convolution implementation
		//IplImage *iplDstImage_align = createImage( iplDstImage->width, iplDstImage->height), SR_DEPTH_32F, 1 );
		//for (int y=1; y<iplDstImage->height+1; y++) {
		//	float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
		//	float *pDst_align = (float *)((char*)iplDstImage_align->imageData + (y-1) * iplDstImage_align->widthStep);
		//	for (int x=0; x<iplDstImage->width; x++) {
		//		pDst_align[x] = pDst[x];
		//	}
		//}
		//copy(iplDstImage_align, iplDstImage);

		safeReleaseImage(&iplSrcImage);
	}

	delete [] pFilter;

	return true;
}

bool CImageUtility::gradient1D_32f(IplImage *iplImage, IplImage *iplDstImage, int wnd_rad, float sigma, int direction)
// Derivative of Gaussian filter
// This function supports the "in-place" operation (source and destination images are the same one)
// This function does not use the decomposition algorithm and ignore the boundary effects
// by Kayton Cheung, IC-ASD, ASTRI
// Jul. 29, 2013 (Implemented 1D derivative of gaussian convolution)
{
	if (iplImage == NULL || iplDstImage == NULL || wnd_rad < 1 || sigma < 0)  {	// TODO: complete check here
		showErrMsg("Invalid input argument in CImageUtility::gradient1D_32f()!\n");
		return false;
	}

	// make filter
    int wnd_size = wnd_rad * 2 + 1;     // by Luhong, March 4, 2015
	float *pFilter = new float[wnd_size];
	float *pFilter_deriv = new float[wnd_size];
	if (pFilter == NULL) {
		showErrMsg("Fail to allocate buffer in CImageUtility::gradient1D_32f()!\n");
		return false;
	}
	//int center = wnd_size >> 1;		//center = 16/2 = 8
	float div = 0.0f;
	float div_sigma_sq2 = 0.5f / (sigma * sigma);	//div_sigma_sq2 = 0.250
	for (int i=0; i<wnd_size; i++) {
		//float diff = (float)(i - center);
		float diff = (float)(i - (wnd_size-1.0)/2);		//X.K.Yang Implementation
		float exp_num = - diff * diff * div_sigma_sq2;
		float value = exp(exp_num);
		value = value < FLT_MIN ? 0.0f : value;     // it looks a bug in exp()? must check underflow here!
		pFilter[i] = value;
		div += value;
	}
	for (int i=0; i<wnd_size; i++) {
		pFilter[i] = pFilter[i] / div;
	}

	// make gradient filter
	for (int i=0; i<wnd_size; i++) {
		if(i==0){
			pFilter_deriv[i] = pFilter[i+1] - pFilter[i];
		}
		else if(i==wnd_size-1){
			pFilter_deriv[i] = pFilter[i] - pFilter[i-1];
		}
		else{
			pFilter_deriv[i] = (pFilter[i+1] - pFilter[i-1]) /2;
		}
	}

	// Normalize to ensure kernel sums to zero
	float pFilter_deriv_posVals_sum = 0;
	float pFilter_deriv_negVals_sum = 0;
	float pFilter_deriv_negVals_sum_abs = 0;
	for (int i=0; i<wnd_size; i++) {
		if(pFilter_deriv[i] > 0){
			pFilter_deriv_posVals_sum += pFilter_deriv[i];
		}else if(pFilter_deriv[i] < 0){
			pFilter_deriv_negVals_sum += pFilter_deriv[i];
		}
	}
	pFilter_deriv_negVals_sum_abs = pFilter_deriv_negVals_sum < 0? -pFilter_deriv_negVals_sum: pFilter_deriv_negVals_sum;
	
	for (int i=0; i<wnd_size; i++) {
		if(pFilter_deriv[i] > 0){
			pFilter_deriv[i] = pFilter_deriv[i] / pFilter_deriv_posVals_sum;
		}else if(pFilter_deriv[i] < 0){
			pFilter_deriv[i] = pFilter_deriv[i] / pFilter_deriv_negVals_sum_abs;
		}
        //printf("%.5f\n", pFilter_deriv[i]);
	}

	// convolution in X direction
	if(direction == 0){
		// padding in Left and Right Only (For 1D Horizontal Convolution)
		IplImage *iplSrcImage = padding(iplImage, wnd_rad, wnd_rad, 0, 0);    // by Luhong, March 4, 2015
		if (iplSrcImage == NULL) {
			showErrMsg("Fail to allocate buffer in CImageUtility::gradient1D_32f()!\n");
			delete [] pFilter;
			safeReleaseImage(&iplSrcImage);
			return false;
		}

		// convolution process
		for (int y=0; y<iplDstImage->height; y++) {
			float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
			float *pSrc = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				float val = 0.0f;
				float *pSrcCol = pSrc + x;	//Problem here if wnd_size is a odd number when y = iplDstImage->height-1 (last row)
				for (int xx=0; xx<wnd_size; xx++) {
					//val += pSrcCol[xx] * pFilter_deriv[xx];			//Dr.Liang version: Convolve from the 1st coefficient
					val += pSrcCol[xx] * pFilter_deriv[wnd_size-1-xx];	//Kayton version: Convolve from the last coefficient
				}
				pDst[x] = val;
			}
		}
		safeReleaseImage(&iplSrcImage);
	}

	// convolution in Y direction
	else if(direction == 1){
		// padding in Top and Bottom Only (For 1D Vertical Convolution)
		IplImage *iplSrcImage = padding(iplImage, 0, 0, wnd_rad, wnd_rad);  // by Luhong, March 4, 2015
		if (iplSrcImage == NULL) {
			showErrMsg("Fail to allocate buffer in CImageUtility::gradient1D_32f()!\n");
			delete [] pFilter;
			safeReleaseImage(&iplSrcImage);
			return false;
		}

		// convolution process
		for (int y=0; y<iplDstImage->height; y++) {
			float *pDst = (float *)((char*)iplDstImage->imageData + y * iplDstImage->widthStep);
			float *pSrc = (float *)((char*)iplSrcImage->imageData + y * iplSrcImage->widthStep);
			for (int x=0; x<iplDstImage->width; x++) {
				float val = 0.0f;
				float *pSrcCol = pSrc + x;	//Problem here if wnd_size is a odd number when y = iplDstImage->height-1 (last row)
				for (int yy=0; yy<wnd_size; yy++) {
					//val += pSrcCol[0] * pFilter_deriv[yy];			//Dr.Liang version: Convolve from the 1st coefficient
					val += pSrcCol[0] * pFilter_deriv[wnd_size-1-yy];	//Kayton version: Convolve from the last coefficient
					pSrcCol += iplSrcImage->width;
				}
				pDst[x] = val;
			}
		}
		safeReleaseImage(&iplSrcImage);
	}

	delete [] pFilter;
	delete [] pFilter_deriv;

	return true;
}

bool CImageUtility::findLocalMaxima(IplImage *iplGX, IplImage *iplGY, IplImage *iplmagGrad, IplImage *iplidx, IplImage *iplidxLocalMax, IplImage *iplidxWeak, IplImage *iplidxStrong, float lowThresh, float highThresh, int direction)
// Find Local Maxima according GX, GY
// Find Weak Edge, Strong Edge
// by Kayton Cheung, IC-ASD, ASTRI
// Jul. 29, 2013
{
	
	//IplImage *iplidx = createImage( iplmagGrad->width, iplmagGrad->height), SR_DEPTH_32F, 1 );
	IplImage *iplixv = createImage( iplGX->width, iplGX->height, SR_DEPTH_32F, 1 );
	IplImage *ipliyv = createImage( iplGY->width, iplGY->height, SR_DEPTH_32F, 1 );
	IplImage *iplixv_abs = createImage( iplGX->width, iplGX->height, SR_DEPTH_32F, 1 );
	IplImage *ipliyv_abs = createImage( iplGY->width, iplGY->height, SR_DEPTH_32F, 1 );
	IplImage *iplgradmag = createImage( iplmagGrad->width, iplmagGrad->height, SR_DEPTH_32F, 1 );
	IplImage *ipld = createImage( iplmagGrad->width, iplmagGrad->height, SR_DEPTH_32F, 1 );
	IplImage *iplgradmag1 = createImage( iplmagGrad->width, iplmagGrad->height, SR_DEPTH_32F, 1 );
	IplImage *iplgradmag2 = createImage( iplmagGrad->width, iplmagGrad->height, SR_DEPTH_32F, 1 );

	if (iplixv == NULL || ipliyv == NULL || iplixv_abs == NULL || ipliyv_abs == NULL || iplgradmag == NULL || ipld == NULL || iplgradmag1 == NULL || iplgradmag2 == NULL)  {
		safeReleaseImage(&iplixv, &ipliyv, &iplgradmag, &ipld);
		safeReleaseImage(&iplixv_abs, &ipliyv_abs, &iplgradmag1, &iplgradmag2);
		return NULL;
	}

	//Initialize the array
	//for (int y=0; y<iplmagGrad->height; y++) {
	//	float *pidx = (float *)((char*)iplidx->imageData + y*iplidx->widthStep);
	//	float *pixv = (float *)((char*)iplixv->imageData + y*iplixv->widthStep);
	//	float *piyv = (float *)((char*)ipliyv->imageData + y*ipliyv->widthStep);
	//	float *pgradmag = (float *)((char*)iplgradmag->imageData + y*iplgradmag->widthStep);
	//	float *pd = (float *)((char*)ipld->imageData + y*ipld->widthStep);
	//	float *pgradmag1 = (float *)((char*)iplgradmag1->imageData + y*iplgradmag1->widthStep);
	//	float *pgradmag2 = (float *)((char*)iplgradmag2->imageData + y*iplgradmag2->widthStep);
	//	float *pidxLocalMax = (float *)((char*)iplidxLocalMax->imageData + y*iplidxLocalMax->widthStep);
	//	float *pidxWeak = (float *)((char*)iplidxWeak->imageData + y*iplidxWeak->widthStep);
	//	float *pidxStrong = (float *)((char*)iplidxStrong->imageData + y*iplidxStrong->widthStep);
	//	for (int x=0; x<iplmagGrad->width; x++) {
	//		pidx[x] = pixv[x] = piyv[x] = pgradmag[x] = pd[x] = pgradmag1[x] = pgradmag2[x] = pidxLocalMax[x] = pidxWeak[x] = pidxStrong[x] = 0;
	//	}
	//}

	//Direction 1
	if (direction == 1){
		for (int y=0; y<iplmagGrad->height; y++) {
			float *pGX = (float *)((char*)iplGX->imageData + y*iplGX->widthStep);
			float *pGY = (float *)((char*)iplGY->imageData + y*iplGY->widthStep);
			float *pidx = (float *)((char*)iplidx->imageData + y*iplidx->widthStep);
			for (int x=0; x<iplmagGrad->width; x++) {
				if( (pGY[x] <=0 && pGX[x] > -pGY[x]) || (pGY[x] >=0 && pGX[x] < -pGY[x]) ){
					pidx[x] = 1;
				} else{
					pidx[x] = 0;
				}
			}
		}

		for (int y=1; y<iplmagGrad->height-1; y++) {
			float *pGX = (float *)((char*)iplGX->imageData + y*iplGX->widthStep);
			float *pGY = (float *)((char*)iplGY->imageData + y*iplGY->widthStep);
			float *pmagGrad0 = (float *)((char*)iplmagGrad->imageData + (y-1)*iplmagGrad->widthStep);
			float *pmagGrad1 = (float *)((char*)iplmagGrad->imageData + y*iplmagGrad->widthStep);
			float *pmagGrad2 = (float *)((char*)iplmagGrad->imageData + (y+1)*iplmagGrad->widthStep);

			float *pidx = (float *)((char*)iplidx->imageData + y*iplidx->widthStep);

			float *pixv = (float *)((char*)iplixv->imageData + y*iplixv->widthStep);
			float *piyv = (float *)((char*)ipliyv->imageData + y*ipliyv->widthStep);
			float *pixv_abs = (float *)((char*)iplixv_abs->imageData + y*iplixv_abs->widthStep);
			float *piyv_abs = (float *)((char*)ipliyv_abs->imageData + y*ipliyv_abs->widthStep);
			float *pgradmag = (float *)((char*)iplgradmag->imageData + y*iplgradmag->widthStep);
			float *pd = (float *)((char*)ipld->imageData + y*ipld->widthStep);
			float *pgradmag1 = (float *)((char*)iplgradmag1->imageData + y*iplgradmag1->widthStep);
			float *pgradmag2 = (float *)((char*)iplgradmag2->imageData + y*iplgradmag2->widthStep);

			float *pidxLocalMax = (float *)((char*)iplidxLocalMax->imageData + y*iplidxLocalMax->widthStep);
			float *pidxWeak = (float *)((char*)iplidxWeak->imageData + y*iplidxWeak->widthStep);
			float *pidxStrong = (float *)((char*)iplidxStrong->imageData + y*iplidxStrong->widthStep);

			for (int x=1; x<iplmagGrad->width-1; x++) {
				if( pidx[x]  ==  1){
					pixv[x] = pGX[x];
					piyv[x] = pGY[x];
					pgradmag[x] = pmagGrad1[x];

					pixv_abs[x] = pixv[x] < 0.0f ? -pixv[x] : pixv[x];
					piyv_abs[x] = piyv[x] < 0.0f ? -piyv[x] : piyv[x];

					pd[x] = piyv_abs[x] / pixv_abs[x];

					pgradmag1[x] = pmagGrad1[x+1]*(1-pd[x]) + pmagGrad0[x+1]*pd[x];
					pgradmag2[x] = pmagGrad1[x-1]*(1-pd[x]) + pmagGrad2[x-1]*pd[x];

					if(pgradmag[x] >= pgradmag1[x] && pgradmag[x] >= pgradmag2[x]){
						pidxLocalMax[x] = 1;
					}

					if( pidxLocalMax[x]  ==  1 && pmagGrad1[x] > lowThresh){
						pidxWeak[x] = 1;
					}

					if( pidxWeak[x]  ==  1 && pmagGrad1[x] > highThresh){
						pidxStrong[x] = 1;
					}
				}
			}
		}
	}

	//Direction 2
	else if (direction == 2){
		for (int y=0; y<iplmagGrad->height; y++) {
			float *pGX = (float *)((char*)iplGX->imageData + y*iplGX->widthStep);
			float *pGY = (float *)((char*)iplGY->imageData + y*iplGY->widthStep);
			//float *pmagGrad = (float *)((char*)iplmagGrad->imageData + y*iplmagGrad->widthStep);
			float *pidx = (float *)((char*)iplidx->imageData + y*iplidx->widthStep);
			for (int x=0; x<iplmagGrad->width; x++) {
				if( (pGX[x] > 0 && -pGY[x] >= pGX[x]) || (pGX[x] < 0 && -pGY[x] <= pGX[x]) ){
					pidx[x] = 1;
				} else{
					pidx[x] = 0;
				}
			}
		}

		for (int y=1; y<iplmagGrad->height-1; y++) {
			float *pGX = (float *)((char*)iplGX->imageData + y*iplGX->widthStep);
			float *pGY = (float *)((char*)iplGY->imageData + y*iplGY->widthStep);
			float *pmagGrad0 = (float *)((char*)iplmagGrad->imageData + (y-1)*iplmagGrad->widthStep);
			float *pmagGrad1 = (float *)((char*)iplmagGrad->imageData + y*iplmagGrad->widthStep);
			float *pmagGrad2 = (float *)((char*)iplmagGrad->imageData + (y+1)*iplmagGrad->widthStep);

			float *pidx = (float *)((char*)iplidx->imageData + y*iplidx->widthStep);

			float *pixv = (float *)((char*)iplixv->imageData + y*iplixv->widthStep);
			float *piyv = (float *)((char*)ipliyv->imageData + y*ipliyv->widthStep);
			float *pixv_abs = (float *)((char*)iplixv_abs->imageData + y*iplixv_abs->widthStep);
			float *piyv_abs = (float *)((char*)ipliyv_abs->imageData + y*ipliyv_abs->widthStep);
			float *pgradmag = (float *)((char*)iplgradmag->imageData + y*iplgradmag->widthStep);
			float *pd = (float *)((char*)ipld->imageData + y*ipld->widthStep);
			float *pgradmag1 = (float *)((char*)iplgradmag1->imageData + y*iplgradmag1->widthStep);
			float *pgradmag2 = (float *)((char*)iplgradmag2->imageData + y*iplgradmag2->widthStep);

			float *pidxLocalMax = (float *)((char*)iplidxLocalMax->imageData + y*iplidxLocalMax->widthStep);
			float *pidxWeak = (float *)((char*)iplidxWeak->imageData + y*iplidxWeak->widthStep);
			float *pidxStrong = (float *)((char*)iplidxStrong->imageData + y*iplidxStrong->widthStep);

			for (int x=1; x<iplmagGrad->width-1; x++) {
				if( pidx[x]  ==  1){
					pixv[x] = pGX[x];
					piyv[x] = pGY[x];
					pgradmag[x] = pmagGrad1[x];

					pixv_abs[x] = pixv[x] < 0.0f ? -pixv[x] : pixv[x];
					piyv_abs[x] = piyv[x] < 0.0f ? -piyv[x] : piyv[x];

					pd[x] = pixv_abs[x] / piyv_abs[x];

					pgradmag1[x] = pmagGrad0[x]*(1-pd[x]) + pmagGrad0[x+1]*pd[x];
					pgradmag2[x] = pmagGrad2[x]*(1-pd[x]) + pmagGrad2[x-1]*pd[x];

					if(pgradmag[x] >= pgradmag1[x] && pgradmag[x] >= pgradmag2[x]){
						pidxLocalMax[x] = 1;
					}

					if( pidxLocalMax[x]  ==  1 && pmagGrad1[x] > lowThresh){
						pidxWeak[x] = 1;
					}

					if( pidxWeak[x]  ==  1 && pmagGrad1[x] > highThresh){
						pidxStrong[x] = 1;
					}
				}
			}
		}
	}

	//Direction 3
	else if (direction == 3){
		for (int y=0; y<iplmagGrad->height; y++) {
			float *pGX = (float *)((char*)iplGX->imageData + y*iplGX->widthStep);
			float *pGY = (float *)((char*)iplGY->imageData + y*iplGY->widthStep);
			//float *pmagGrad = (float *)((char*)iplmagGrad->imageData + y*iplmagGrad->widthStep);
			float *pidx = (float *)((char*)iplidx->imageData + y*iplidx->widthStep);
			for (int x=0; x<iplmagGrad->width; x++) {
				if( (pGX[x] <= 0 && pGX[x] > pGY[x]) || (pGX[x] >= 0 && pGX[x] < pGY[x]) ){
					pidx[x] = 1;
				} else{
					pidx[x] = 0;
				}
			}
		}

		for (int y=1; y<iplmagGrad->height-1; y++) {
			float *pGX = (float *)((char*)iplGX->imageData + y*iplGX->widthStep);
			float *pGY = (float *)((char*)iplGY->imageData + y*iplGY->widthStep);
			float *pmagGrad0 = (float *)((char*)iplmagGrad->imageData + (y-1)*iplmagGrad->widthStep);
			float *pmagGrad1 = (float *)((char*)iplmagGrad->imageData + y*iplmagGrad->widthStep);
			float *pmagGrad2 = (float *)((char*)iplmagGrad->imageData + (y+1)*iplmagGrad->widthStep);

			float *pidx = (float *)((char*)iplidx->imageData + y*iplidx->widthStep);

			float *pixv = (float *)((char*)iplixv->imageData + y*iplixv->widthStep);
			float *piyv = (float *)((char*)ipliyv->imageData + y*ipliyv->widthStep);
			float *pixv_abs = (float *)((char*)iplixv_abs->imageData + y*iplixv_abs->widthStep);
			float *piyv_abs = (float *)((char*)ipliyv_abs->imageData + y*ipliyv_abs->widthStep);
			float *pgradmag = (float *)((char*)iplgradmag->imageData + y*iplgradmag->widthStep);
			float *pd = (float *)((char*)ipld->imageData + y*ipld->widthStep);
			float *pgradmag1 = (float *)((char*)iplgradmag1->imageData + y*iplgradmag1->widthStep);
			float *pgradmag2 = (float *)((char*)iplgradmag2->imageData + y*iplgradmag2->widthStep);

			float *pidxLocalMax = (float *)((char*)iplidxLocalMax->imageData + y*iplidxLocalMax->widthStep);
			float *pidxWeak = (float *)((char*)iplidxWeak->imageData + y*iplidxWeak->widthStep);
			float *pidxStrong = (float *)((char*)iplidxStrong->imageData + y*iplidxStrong->widthStep);

			for (int x=1; x<iplmagGrad->width-1; x++) {
				if( pidx[x]  ==  1){
					pixv[x] = pGX[x];
					piyv[x] = pGY[x];
					pgradmag[x] = pmagGrad1[x];

					pixv_abs[x] = pixv[x] < 0.0f ? -pixv[x] : pixv[x];
					piyv_abs[x] = piyv[x] < 0.0f ? -piyv[x] : piyv[x];

					pd[x] = pixv_abs[x] / piyv_abs[x];

					pgradmag1[x] = pmagGrad0[x]*(1-pd[x]) + pmagGrad0[x-1]*pd[x];
					pgradmag2[x] = pmagGrad2[x]*(1-pd[x]) + pmagGrad2[x+1]*pd[x];

					if(pgradmag[x] >= pgradmag1[x] && pgradmag[x] >= pgradmag2[x]){
						pidxLocalMax[x] = 1;
					}

					if( pidxLocalMax[x]  ==  1 && pmagGrad1[x] > lowThresh){
						pidxWeak[x] = 1;
					}

					if( pidxWeak[x]  ==  1 && pmagGrad1[x] > highThresh){
						pidxStrong[x] = 1;
					}
				}
			}
		}
	}

	//Direction 4
	else if (direction == 4){
		for (int y=0; y<iplmagGrad->height; y++) {
			float *pGX = (float *)((char*)iplGX->imageData + y*iplGX->widthStep);
			float *pGY = (float *)((char*)iplGY->imageData + y*iplGY->widthStep);
			//float *pmagGrad = (float *)((char*)iplmagGrad->imageData + y*iplmagGrad->widthStep);
			float *pidx = (float *)((char*)iplidx->imageData + y*iplidx->widthStep);
			for (int x=0; x<iplmagGrad->width; x++) {
				if( (pGY[x] < 0 && pGX[x] <= pGY[x]) || (pGY[x] > 0 && pGX[x] >= pGY[x]) ){
					pidx[x] = 1;
				} else{
					pidx[x] = 0;
				}
			}
		}

		for (int y=1; y<iplmagGrad->height-1; y++) {
			float *pGX = (float *)((char*)iplGX->imageData + y*iplGX->widthStep);
			float *pGY = (float *)((char*)iplGY->imageData + y*iplGY->widthStep);
			float *pmagGrad0 = (float *)((char*)iplmagGrad->imageData + (y-1)*iplmagGrad->widthStep);
			float *pmagGrad1 = (float *)((char*)iplmagGrad->imageData + y*iplmagGrad->widthStep);
			float *pmagGrad2 = (float *)((char*)iplmagGrad->imageData + (y+1)*iplmagGrad->widthStep);

			float *pidx = (float *)((char*)iplidx->imageData + y*iplidx->widthStep);

			float *pixv = (float *)((char*)iplixv->imageData + y*iplixv->widthStep);
			float *piyv = (float *)((char*)ipliyv->imageData + y*ipliyv->widthStep);
			float *pixv_abs = (float *)((char*)iplixv_abs->imageData + y*iplixv_abs->widthStep);
			float *piyv_abs = (float *)((char*)ipliyv_abs->imageData + y*ipliyv_abs->widthStep);
			float *pgradmag = (float *)((char*)iplgradmag->imageData + y*iplgradmag->widthStep);
			float *pd = (float *)((char*)ipld->imageData + y*ipld->widthStep);
			float *pgradmag1 = (float *)((char*)iplgradmag1->imageData + y*iplgradmag1->widthStep);
			float *pgradmag2 = (float *)((char*)iplgradmag2->imageData + y*iplgradmag2->widthStep);

			float *pidxLocalMax = (float *)((char*)iplidxLocalMax->imageData + y*iplidxLocalMax->widthStep);
			float *pidxWeak = (float *)((char*)iplidxWeak->imageData + y*iplidxWeak->widthStep);
			float *pidxStrong = (float *)((char*)iplidxStrong->imageData + y*iplidxStrong->widthStep);

			for (int x=1; x<iplmagGrad->width-1; x++) {
				if( pidx[x]  ==  1){
					pixv[x] = pGX[x];
					piyv[x] = pGY[x];
					pgradmag[x] = pmagGrad1[x];

					pixv_abs[x] = pixv[x] < 0.0f ? -pixv[x] : pixv[x];
					piyv_abs[x] = piyv[x] < 0.0f ? -piyv[x] : piyv[x];

					pd[x] = piyv_abs[x] / pixv_abs[x];

					pgradmag1[x] = pmagGrad1[x-1]*(1-pd[x]) + pmagGrad0[x-1]*pd[x];
					pgradmag2[x] = pmagGrad1[x+1]*(1-pd[x]) + pmagGrad2[x+1]*pd[x];

					if(pgradmag[x] >= pgradmag1[x] && pgradmag[x] >= pgradmag2[x]){
						pidxLocalMax[x] = 1;
					}

					if( pidxLocalMax[x]  ==  1 && pmagGrad1[x] > lowThresh){
						pidxWeak[x] = 1;
					}

					if( pidxWeak[x]  ==  1 && pmagGrad1[x] > highThresh){
						pidxStrong[x] = 1;
					}
				}
			}
		}
	}

	safeReleaseImage(&iplixv, &ipliyv, &iplgradmag, &ipld);
	safeReleaseImage(&iplixv_abs, &ipliyv_abs, &iplgradmag1, &iplgradmag2);

    return true;
}


bool CImageUtility::findConnectedComponents(IplImage *iplidxWeakSum, IplImage *iplImgCannyEdge, int ir, int  ic, int conn, int level, IplImage *iplBreakPoint, bool &has_breakpoint)
// Find Connected Components to link up the Weak Edge from Strong Edge
// by Kayton Cheung, IC-ASD, ASTRI
// Jul. 29, 2013
{
    // check index (by Luhong, 20150820)
    if (ir <= 0 || ir >= iplImgCannyEdge->height-1 || ic <= 0 || ic >= iplImgCannyEdge->width) {
        return false;
    }

    const int max_level = 128;      // by Luhong, Sept. 10, 2013
    if (level >= max_level) {
        unsigned char *pMark = (unsigned char *)(iplBreakPoint->imageData + ir * iplBreakPoint->widthStep);
        pMark[ic] = 1;
        has_breakpoint = true;
        return true; 
    }

	int a,b,c,d,e,f,g,h;
	int aa,bb,cc,dd,ee,ff,gg,hh;

	float *pImgCannyEdge0 = (float *)((char*)iplImgCannyEdge->imageData + (ir-1)*iplImgCannyEdge->widthStep);
	float *pImgCannyEdge1 = (float *)((char*)iplImgCannyEdge->imageData + ir*iplImgCannyEdge->widthStep);
	float *pImgCannyEdge2 = (float *)((char*)iplImgCannyEdge->imageData + (ir+1)*iplImgCannyEdge->widthStep);
	float *pidxWeakSum0 = (float *)((char*)iplidxWeakSum->imageData + (ir-1)*iplidxWeakSum->widthStep);
	float *pidxWeakSum1 = (float *)((char*)iplidxWeakSum->imageData + ir*iplidxWeakSum->widthStep);
	float *pidxWeakSum2 = (float *)((char*)iplidxWeakSum->imageData + (ir+1)*iplidxWeakSum->widthStep);

	if (iplImgCannyEdge == NULL || iplidxWeakSum == NULL)  {
		safeReleaseImage(&iplImgCannyEdge, &iplidxWeakSum);
		return NULL;
	}

	if (conn==4){
		//4 Connected Pixel's 1 or 0
		a = (int)pidxWeakSum2[ic];		// Bottom
		b = (int)pidxWeakSum0[ic];		// Top
		c = (int)pidxWeakSum1[ic+1];	// Right
		d = (int)pidxWeakSum1[ic-1];	// Left

		//4 Connected Pixel's Mark
		aa = (int)pImgCannyEdge2[ic];	// Bottom
		bb = (int)pImgCannyEdge0[ic];	// Top
		cc = (int)pImgCannyEdge1[ic+1];	// Right
		dd = (int)pImgCannyEdge1[ic-1];	// Left


		if((a==1)&&(aa==0)){     //if this pixels is 1 and no mark (0)
			pImgCannyEdge2[ic]=1;
			findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,ir+1,ic,conn, level+1, iplBreakPoint, has_breakpoint);
		}

		if((b==1)&&(bb==0)){
			pImgCannyEdge0[ic]=1;
			findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,ir-1,ic,conn, level+1, iplBreakPoint, has_breakpoint);
		}

		if((c==1)&&(cc==0)){
			pImgCannyEdge1[ic+1]=1;
			findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,ir,ic+1,conn, level+1, iplBreakPoint, has_breakpoint);
		}

		if((d==1)&&(dd==0)){
			pImgCannyEdge1[ic-1]=1;
			findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,ir,ic-1,conn, level+1, iplBreakPoint, has_breakpoint);
		}
	}

	else if (conn==8){
		//8 Connected Pixel's 1 or 0
		a = (int)pidxWeakSum2[ic];		// Bottom
		b = (int)pidxWeakSum0[ic];		// Top
		c = (int)pidxWeakSum1[ic+1];	// Right
		d = (int)pidxWeakSum1[ic-1];	// Left
		e = (int)pidxWeakSum2[ic+1];	// Bottom-Right
		f = (int)pidxWeakSum2[ic-1];	// Bottom-Left
		g = (int)pidxWeakSum0[ic+1];	// Top-Right
		h = (int)pidxWeakSum0[ic-1];	// Top-Left

		//8 Connected Pixel's Mark
		aa = (int)pImgCannyEdge2[ic];	// Bottom
		bb = (int)pImgCannyEdge0[ic];	// Top
		cc = (int)pImgCannyEdge1[ic+1];	// Right
		dd = (int)pImgCannyEdge1[ic-1];	// Left
		ee = (int)pImgCannyEdge2[ic+1];	// Bottom-Right
		ff = (int)pImgCannyEdge2[ic-1];	// Bottom-Left
		gg = (int)pImgCannyEdge0[ic+1];	// Top-Right
		hh = (int)pImgCannyEdge0[ic-1];	// Top-Left


		if((a==1)&&(aa==0)){     //if this pixels is 1 and no mark (0)
			pImgCannyEdge2[ic]=1;
			findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,ir+1,ic,conn, level+1, iplBreakPoint, has_breakpoint);
		}

		if((b==1)&&(bb==0)){
			pImgCannyEdge0[ic]=1;
			findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,ir-1,ic,conn, level+1, iplBreakPoint, has_breakpoint);
		}

		if((c==1)&&(cc==0)){
			pImgCannyEdge1[ic+1]=1;
			findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,ir,ic+1,conn, level+1, iplBreakPoint, has_breakpoint);
		}

		if((d==1)&&(dd==0)){
			pImgCannyEdge1[ic-1]=1;
			findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,ir,ic-1,conn, level+1, iplBreakPoint, has_breakpoint);
		}

		if((e==1)&&(ee==0)){
			pImgCannyEdge2[ic+1]=1;
			findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,ir+1,ic+1,conn, level+1, iplBreakPoint, has_breakpoint);
		}

		if((f==1)&&(ff==0)){
			pImgCannyEdge2[ic-1]=1;
			findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,ir+1,ic-1,conn, level+1, iplBreakPoint, has_breakpoint);
		}

		if((g==1)&&(gg==0)){
			pImgCannyEdge0[ic+1]=1;
			findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,ir-1,ic+1,conn, level+1, iplBreakPoint, has_breakpoint);
		}

		if((h==1)&&(hh==0)){
			pImgCannyEdge0[ic-1]=1;
			findConnectedComponents(iplidxWeakSum,iplImgCannyEdge,ir-1,ic-1,conn, level+1, iplBreakPoint, has_breakpoint);
		}

	}

	return false;
}

//
// Special funcations to support VEUHD DLL
//
#ifdef _ASTRI_ICDD_VEUHD4K_DLL

VEUHDImage *CImageUtility::createVEUHDImage( int width, int height, int depth, int colorfmt ) 
// Allocate a VEUHD image
//  width, height -- width and height of the image
// depth -- bit depth of the image; must be 8~16
// colorfmt -- color format code: 0--4:0:0(grayscale), 1--4:2:0, 2--4:2:2, 3--4:4:4
{
    VEUHDImage *vpImage = NULL;
    
	// allocate buffer for structure
	vpImage = (VEUHDImage *)new char[sizeof(*vpImage)];
    if( vpImage == NULL ) {
		showErrMsg("Fail to allocate buffer for image header in CImageUtility::createVEUHDImage()!\n");
		return NULL;
	}
    memset( vpImage, 0, sizeof(*vpImage) );
    
    // fill fields
    vpImage->nSize = sizeof( *vpImage );

    if (colorfmt == 0) {
        vpImage->channels = 1;
    } else if (colorfmt < 4) {
        vpImage->channels = 3;
    } else {
        showErrMsg("Invalid input color format in CImageUtility::createVEUHDImage()!\n");
        delete [] vpImage;
		return NULL;
	}

    if (depth >= 8 && depth <= 16) {
        vpImage->depth = depth;
    } else {
        showErrMsg("Only support bit depth 8~16 in CImageUtility::createVEUHDImage()!\n");
        delete [] vpImage;
		return NULL;
	}

    vpImage->colorsp[0] = 'Y';
    vpImage->colorsp[1] = 'U';
    vpImage->colorsp[2] = 'V';
    vpImage->colorsp[3] = 0;

    vpImage->align = 64;        // must be 64

    vpImage->width = width;

    int byte_per_pixel = depth<=8 ? 1 : 2;
    vpImage->widthStep[0] = ((width*byte_per_pixel + vpImage->align -1) / vpImage->align) * vpImage->align;
    if (vpImage->channels == 3) {
        if (colorfmt == 1 || colorfmt == 2) {       // 420 or 422
            if (width%2 != 0) {
                showErrMsg("The image width must be even when the format is 4:2:0 or 4:2:2 in CImageUtility::createVEUHDImage()!\n");
                delete [] vpImage;
                return NULL;
            }
            vpImage->widthStep[1] = (((width/2)*byte_per_pixel + vpImage->align -1) / vpImage->align) * vpImage->align;
            vpImage->widthStep[2] = vpImage->widthStep[1];
        } else {                                                // 444
            vpImage->widthStep[1] = vpImage->widthStep[0];
            vpImage->widthStep[2] = vpImage->widthStep[0];
        }
    }

    if (colorfmt ==1 && height%2 != 0) {
        showErrMsg("The height must be even when the format is 4:2:0 in CImageUtility::createVEUHDImage()!\n");
        delete [] vpImage;
        return NULL;
    }
    vpImage->height = height;

    vpImage->imageData[0] = (__declspec(align(64)) char *)_aligned_malloc(vpImage->widthStep[0]*vpImage->height, 64);
    if (vpImage->imageData[0] == NULL) {
        showErrMsg("Fail to allocate image buffer in CImageUtility::createVEUHDImage()!\n");
        delete [] vpImage;
        return NULL;
    }
    if (vpImage->channels == 3) {
        vpImage->imageData[1] = (__declspec(align(64)) char *)_aligned_malloc(vpImage->widthStep[1]*vpImage->height, 64);
        vpImage->imageData[2] = (__declspec(align(64)) char *)_aligned_malloc(vpImage->widthStep[2]*vpImage->height, 64);
        if (vpImage->imageData[1] == NULL || vpImage->imageData[2] == NULL) {
            showErrMsg("Fail to allocate image buffer in CImageUtility::createVEUHDImage()!\n");
            delete [] vpImage;
            _aligned_free(vpImage->imageData[0]);
            if (vpImage->imageData[1] != NULL) _aligned_free(vpImage->imageData[1]);
            if (vpImage->imageData[2] != NULL) _aligned_free(vpImage->imageData[2]);
            return NULL;
        }
    } else {
        vpImage->imageData[1] = NULL;
        vpImage->imageData[2] = NULL;
    }

    return vpImage;
}

void CImageUtility::releaseVEUHDImage(VEUHDImage **ppImg)
// Release a VEUHD image
{
	if (ppImg == NULL || (*ppImg)== NULL) return;

    if ((*ppImg)->imageData[0] != NULL) _aligned_free((*ppImg)->imageData[0]);
    if ((*ppImg)->channels == 3) {
        if ((*ppImg)->imageData[1] != NULL) _aligned_free((*ppImg)->imageData[1]);
        if ((*ppImg)->imageData[2] != NULL) _aligned_free((*ppImg)->imageData[2]);
    }

    delete [] (*ppImg);

	(*ppImg) = NULL;

	return;
}

bool CImageUtility::copy(VEUHDImage *vpSrcImage, VEUHDImage*vpDstImage)
// Copy a VEUHDImage to another and change the bit depth using rounding/multiplication in need.
{
    if (vpSrcImage == NULL || vpDstImage == NULL || vpSrcImage->channels != vpDstImage->channels ||
        vpSrcImage->width != vpDstImage->width || vpSrcImage->height != vpDstImage->height ||
        vpSrcImage->colorfmt != vpDstImage->colorfmt || 
        vpSrcImage->colorfmt < 0 || vpSrcImage->colorfmt > 3) {
        showErrMsg("Mismatched input and output VEUHD image in CImageUtility::copy()!\n");
        return false;
    }
    
    int width_uv, height_uv;
    if (vpSrcImage->colorfmt == 1) {                      // 4:2:0
        width_uv = (vpSrcImage->width/2);
        height_uv = (vpSrcImage->height/2);
    } else if (vpSrcImage->colorfmt == 2) {            // 4:2:2
        width_uv = (vpSrcImage->width/2);
        height_uv = vpSrcImage->height;
    } else { //if (vpSrcImage->colorfmt == 3) {            // 4:4:4
        width_uv = vpSrcImage->width;
        height_uv = vpSrcImage->height;
    }

    // copy
    if (vpSrcImage->depth == vpDstImage->depth) {
        // copy Y
        int width_step = vpSrcImage->widthStep[0] < vpDstImage->widthStep[0] ? vpSrcImage->widthStep[0] : vpDstImage->widthStep[0];
        for (int y=0; y<vpDstImage->height; y++) {
            memcpy(vpDstImage->imageData[0]+y*vpDstImage->widthStep[0], vpSrcImage->imageData[0]+y*vpSrcImage->widthStep[0], width_step);
        }
        // copy UV
        if (vpSrcImage->channels >= 3) {
            width_step = vpSrcImage->widthStep[1] < vpDstImage->widthStep[1] ? vpSrcImage->widthStep[1] : vpDstImage->widthStep[1];
            for (int y=0; y<height_uv; y++) {
                memcpy(vpDstImage->imageData[1]+y*vpDstImage->widthStep[1], vpSrcImage->imageData[1]+y*vpSrcImage->widthStep[1], width_step);
            }
            width_step = vpSrcImage->widthStep[2] < vpDstImage->widthStep[2] ? vpSrcImage->widthStep[2] : vpDstImage->widthStep[2];
            for (int y=0; y<height_uv; y++) {
                memcpy(vpDstImage->imageData[2]+y*vpDstImage->widthStep[2], vpSrcImage->imageData[2]+y*vpSrcImage->widthStep[2], width_step);
            }
        }
        return true;
    }

    // 8 bits to more bits
    if (vpSrcImage->depth == 8 && vpDstImage->depth > 8) {
        int shift_bit =  vpDstImage->depth -  vpSrcImage->depth;
        int mul_factor = 0x0001 << shift_bit;
        // convert Y
        for (int y=0; y<vpDstImage->height; y++) {
            unsigned char *pSrc = (unsigned char *)(vpSrcImage->imageData[0] + y*vpSrcImage->widthStep[0]);
            unsigned short *pDst = (unsigned short *)(vpDstImage->imageData[0] + y*vpDstImage->widthStep[0]);
            for (int x=0; x<vpDstImage->width; x++) {
                pDst[x] = (unsigned short)(pSrc[x] * mul_factor);
            }
        }
        if (vpSrcImage->channels >= 3) {
            // convert U
            for (int y=0; y<height_uv; y++) {
                unsigned char *pSrc = (unsigned char *)(vpSrcImage->imageData[1] + y*vpSrcImage->widthStep[1]);
                unsigned short *pDst = (unsigned short *)(vpDstImage->imageData[1] + y*vpDstImage->widthStep[1]);
                for (int x=0; x<width_uv; x++) {
                    pDst[x] = (unsigned short)(pSrc[x] * mul_factor);
                }
            }
            // convert V
            for (int y=0; y<height_uv; y++) {
                unsigned char *pSrc = (unsigned char *)(vpSrcImage->imageData[2] + y*vpSrcImage->widthStep[2]);
                unsigned short *pDst = (unsigned short *)(vpDstImage->imageData[2] + y*vpDstImage->widthStep[2]);
                for (int x=0; x<width_uv; x++) {
                    pDst[x] = (unsigned short)(pSrc[x] * mul_factor);
                }
            }
        }
        return true;
    }

    // more bits to 8 bits
    if (vpSrcImage->depth > 8 && vpDstImage->depth == 8) {
        int shift_bit_m1 =  vpSrcImage->depth -  vpDstImage->depth - 1;
        // convert Y
        for (int y=0; y<vpDstImage->height; y++) {
            unsigned short *pSrc = (unsigned short *)(vpSrcImage->imageData[0] + y*vpSrcImage->widthStep[0]);
            unsigned char *pDst = (unsigned char *)(vpDstImage->imageData[0] + y*vpDstImage->widthStep[0]);
            for (int x=0; x<vpDstImage->width; x++) {
                int pix = pSrc[x]  >> shift_bit_m1;     // 9-bit
                pDst[x] = rndclp_9Uto8U(pix);
            }
        }
        if (vpSrcImage->channels >= 3) {
            // convert U
            for (int y=0; y<height_uv; y++) {
                unsigned short *pSrc = (unsigned short *)(vpSrcImage->imageData[1] + y*vpSrcImage->widthStep[1]);
                unsigned char *pDst = (unsigned char *)(vpDstImage->imageData[1] + y*vpDstImage->widthStep[1]);
                for (int x=0; x<width_uv; x++) {
                    int pix = pSrc[x]  >> shift_bit_m1;     // 9-bit
                    pDst[x] = rndclp_9Uto8U(pix);
                }
            }
            // convert V
            for (int y=0; y<height_uv; y++) {
                unsigned short *pSrc = (unsigned short *)(vpSrcImage->imageData[2] + y*vpSrcImage->widthStep[2]);
                unsigned char *pDst = (unsigned char *)(vpDstImage->imageData[2] + y*vpDstImage->widthStep[2]);
                for (int x=0; x<width_uv; x++) {
                    int pix = pSrc[x]  >> shift_bit_m1;     // 9-bit
                    pDst[x] = rndclp_9Uto8U(pix);
                }
            }
        }
        return true;
    }

    // > 8-bit, to more bits
    if (vpSrcImage->depth > 8 && vpDstImage->depth > vpSrcImage->depth) {
        int shift_bit =  vpDstImage->depth -  vpSrcImage->depth;
        int mul_factor = 0x0001 << shift_bit;
        int max_val = (1 << vpDstImage->depth) - 1;
        // convert Y
        for (int y=0; y<vpDstImage->height; y++) {
            unsigned short *pSrc = (unsigned short *)(vpSrcImage->imageData[0] + y*vpSrcImage->widthStep[0]);
            unsigned short *pDst = (unsigned short *)(vpDstImage->imageData[0] + y*vpDstImage->widthStep[0]);
            for (int x=0; x<vpDstImage->width; x++) {
                pDst[x] = (unsigned short)clip_int(pSrc[x] * mul_factor, max_val, 0);
            }
        }
        if (vpSrcImage->channels >= 3) {
            // convert U
            for (int y=0; y<height_uv; y++) {
                unsigned short *pSrc = (unsigned short *)(vpSrcImage->imageData[1] + y*vpSrcImage->widthStep[1]);
                unsigned short *pDst = (unsigned short *)(vpDstImage->imageData[1] + y*vpDstImage->widthStep[1]);
                for (int x=0; x<width_uv; x++) {
                    pDst[x] = (unsigned short)clip_int(pSrc[x] * mul_factor, max_val, 0);
                }
            }
            // convert V
            for (int y=0; y<height_uv; y++) {
                unsigned short *pSrc = (unsigned short *)(vpSrcImage->imageData[2] + y*vpSrcImage->widthStep[2]);
                unsigned short *pDst = (unsigned short *)(vpDstImage->imageData[2] + y*vpDstImage->widthStep[2]);
                for (int x=0; x<width_uv; x++) {
                    pDst[x] = (unsigned short)clip_int(pSrc[x] * mul_factor, max_val, 0);
                }
            }
        }
        return true;
    }

    // > 8-bit, to less bits
    if (vpDstImage->depth > 8 && vpSrcImage->depth > vpDstImage->depth) {
        int shift_bit_m1 =  vpSrcImage->depth -  vpDstImage->depth - 1;
        // convert Y
        for (int y=0; y<vpDstImage->height; y++) {
            unsigned short *pSrc = (unsigned short *)(vpSrcImage->imageData[0] + y*vpSrcImage->widthStep[0]);
            unsigned short *pDst = (unsigned short *)(vpDstImage->imageData[0] + y*vpDstImage->widthStep[0]);
            for (int x=0; x<vpDstImage->width; x++) {
                int pix = pSrc[x]  >> shift_bit_m1;     // 9-bit
                pDst[x] = rndclp_9Uto8U(pix);
            }
        }
        if (vpSrcImage->channels >= 3) {
            // convert U
            for (int y=0; y<height_uv; y++) {
                unsigned short *pSrc = (unsigned short *)(vpSrcImage->imageData[1] + y*vpSrcImage->widthStep[1]);
                unsigned short *pDst = (unsigned short *)(vpDstImage->imageData[1] + y*vpDstImage->widthStep[1]);
                for (int x=0; x<width_uv; x++) {
                    int pix = pSrc[x]  >> shift_bit_m1;     // 9-bit
                    pDst[x] = rndclp_9Uto8U(pix);
                }
            }
            // convert V
            for (int y=0; y<height_uv; y++) {
                unsigned short *pSrc = (unsigned short *)(vpSrcImage->imageData[2] + y*vpSrcImage->widthStep[2]);
                unsigned short *pDst = (unsigned short *)(vpDstImage->imageData[2] + y*vpDstImage->widthStep[2]);
                for (int x=0; x<width_uv; x++) {
                    int pix = pSrc[x]  >> shift_bit_m1;     // 9-bit
                    pDst[x] = rndclp_9Uto8U(pix);
                }
            }
        }
        return true;
    }

    return false;
}

IplImage *CImageUtility::cvtVImgTo32F(VEUHDImage *vpImage, int plane)
// Extract one plane in VEUHDImage and converted to 32F IplImage.
// When the input image is grayscale, the parameter plane is ignored.
{
   if (vpImage==NULL || plane < 0 || plane > 3 || vpImage->colorfmt < 0 || vpImage->colorfmt > 3) {
        showErrMsg("Invalid input image or plane index in CImageUtility::cvtVImgTo32F()!\n");
        return NULL;
    }

   IplImage *iplImage = NULL;
    if (vpImage->depth == 8) {
        // 8U input
        if (vpImage->channels == 1 || plane == 0) {
            iplImage = CImageUtility::createImage(vpImage->width, vpImage->height, SR_DEPTH_32F, 1);
            if (iplImage == NULL) {
                showErrMsg("Fail to allocate image buffer in CImageUtility::cvtVImgTo32F()!\n");
                return NULL;
            }
            for (int y=0; y<iplImage->height; y++) {
                unsigned char *pSrc = (unsigned char *)(vpImage->imageData[0] + y*vpImage->widthStep[0]);
                float *pDst = (float *)(iplImage->imageData + y*iplImage->widthStep);
                for (int x=0; x<iplImage->width; x++) {
                    pDst[x] = pSrc[x];
                }
            }
        } else {
            int width_uv, height_uv;
            if (vpImage->colorfmt == 1) {                      // 4:2:0
                width_uv = (vpImage->width/2);
                height_uv = (vpImage->height/2);
            } else if (vpImage->colorfmt == 2) {            // 4:2:2
                width_uv = (vpImage->width/2);
                height_uv = vpImage->height;
            } else {//if (vpImage->colorfmt == 3) {            // 4:4:4
                width_uv = vpImage->width;
                height_uv = vpImage->height;
            }
            iplImage = CImageUtility::createImage(width_uv, height_uv, SR_DEPTH_32F, 1);
            if (iplImage == NULL) {
                showErrMsg("Fail to allocate image buffer in CImageUtility::cvtVImgTo32F()!\n");
                return NULL;
            }
            for (int y=0; y<iplImage->height; y++) {
                unsigned char *pSrc = (unsigned char *)(vpImage->imageData[plane] + y*vpImage->widthStep[plane]);
                float *pDst = (float *)(iplImage->imageData + y*iplImage->widthStep);
                for (int x=0; x<iplImage->width; x++) {
                    pDst[x] = pSrc[x];
                }
            }
        }
    } else {
        // 16U input
        int shift_bit =  vpImage->depth - 8;
        float div_factor = 1.0f / (float)(0x0001 << shift_bit);
        if (vpImage->channels == 1 || plane == 0) {
            iplImage = CImageUtility::createImage(vpImage->width, vpImage->height, SR_DEPTH_32F, 1);
            if (iplImage == NULL) {
                showErrMsg("Fail to allocate image buffer in CImageUtility::cvtVImgTo32F()!\n");
                return NULL;
            }
            for (int y=0; y<iplImage->height; y++) {
                unsigned short *pSrc = (unsigned short *)(vpImage->imageData[0] + y*vpImage->widthStep[0]);
                float *pDst = (float *)(iplImage->imageData + y*iplImage->widthStep);
                for (int x=0; x<iplImage->width; x++) {
                    pDst[x] = (float)pSrc[x] * div_factor;
                }
            }
        } else {
            int width_uv, height_uv;
            if (vpImage->colorfmt == 1) {                      // 4:2:0
                width_uv = (vpImage->width/2);
                height_uv = (vpImage->height/2);
            } else if (vpImage->colorfmt == 2) {            // 4:2:2
                width_uv = (vpImage->width/2);
                height_uv = vpImage->height;
            } else { //if (vpImage->colorfmt == 3) {            // 4:4:4
                width_uv = vpImage->width;
                height_uv = vpImage->height;
            }
            iplImage = CImageUtility::createImage(width_uv, height_uv, SR_DEPTH_32F, 1);
            if (iplImage == NULL) {
                showErrMsg("Fail to allocate image buffer in CImageUtility::cvtVImgTo32F()!\n");
                return NULL;
            }
            for (int y=0; y<iplImage->height; y++) {
                unsigned short *pSrc = (unsigned short *)(vpImage->imageData[plane] + y*vpImage->widthStep[plane]);
                float *pDst = (float *)(iplImage->imageData + y*iplImage->widthStep);
                for (int x=0; x<iplImage->width; x++) {
                    pDst[x] = (float)pSrc[x] * div_factor;
                }
            }
        }
    }

    return iplImage;
}

VEUHDImage *CImageUtility::cvt32FToVImg(IplImage *iplY, IplImage *iplU, IplImage *iplV, int bit_depth)
// Convert YUV planes in IplImage format to one VEUHDImage with denoted bit_depth.
// When bit_depth == 8, the VEUHDImage is 8U; while when bit_depth > 8 (and <= 16), 
// the VEUDHImage is 16U. Rounding and clipping is used.
// When the U/V is NULL, the converted image is a grayscale one.
{
    if (iplY==NULL || iplY->nChannels != 1 || iplY->depth != SR_DEPTH_32F ||
        bit_depth < 8 || bit_depth > 16) {
        showErrMsg("Invalid input image or bit depth in CImageUtility::cvt32FToVImg()!\n");
        return NULL;
    }
    
    // create new image
    VEUHDImage *vpImage = NULL;
    if (bit_depth == 8) {
        if (iplU == NULL || iplV == NULL) {     // grayscale image
            vpImage = createVEUHDImage(iplY->width, iplY->height, bit_depth, 0);        // 4:0:0 only
        } else {                                                // YUV image
            // check image format
            if (iplU->width != iplV->width || iplU->height != iplV->height ||
                iplU->depth != iplY->depth || iplV->depth != iplY->depth ||
                iplU->nChannels != iplY->nChannels || iplV->nChannels != iplY->nChannels) {
                showErrMsg("Invalid input U and/or V image in cvt32FToVImg()!\n");
                return NULL;
            }
            int colorfmt;
            if (iplU->width == iplY->width && iplU->height == iplY->height) {
                colorfmt = 3;       // 4:4:4
            } else if (iplU->width*2 == iplY->width && iplU->height == iplY->height) {
                colorfmt = 2;       // 4:2:2
            } else if (iplU->width*2 == iplY->width && iplU->height*2 == iplY->height) {
                colorfmt = 1;       // 4:2:0
            } else {
                showErrMsg("Invalid input U and/or V image in cvt32FToVImg()!\n");
                return NULL;
            }
            // create new image
            vpImage = createVEUHDImage(iplY->width, iplY->height, bit_depth, colorfmt);        // 4:0:0 only
        }
    } else {
        if (iplU == NULL || iplV == NULL) {     // grayscale image
            vpImage = createVEUHDImage(iplY->width, iplY->height, bit_depth, 0);        // 4:0:0 only
        } else {                                                // YUV image
            // check image format
            if (iplU->width != iplV->width || iplU->height != iplV->height ||
                iplU->depth != iplY->depth || iplV->depth != iplY->depth ||
                iplU->nChannels != iplY->nChannels || iplV->nChannels != iplY->nChannels) {
                showErrMsg("Invalid input U and/or V image in cloneToVImg()!\n");
                return NULL;
            }
            int colorfmt;
            if (iplU->width == iplY->width && iplU->height == iplY->height) {
                colorfmt = 3;       // 4:4:4
            } else if (iplU->width*2 == iplY->width && iplU->height == iplY->height) {
                colorfmt = 2;       // 4:2:2
            } else if (iplU->width*2 == iplY->width && iplU->height*2 == iplY->height) {
                colorfmt = 1;       // 4:2:0
            } else {
                showErrMsg("Invalid input U and/or V image in cloneToVImg()!\n");
                return NULL;
            }
            // create new image
            vpImage = createVEUHDImage(iplY->width, iplY->height, bit_depth, colorfmt);        // 4:0:0 only
        }
    }
    
    if (vpImage == NULL) {
        showErrMsg("Fail to allocate image buffer in cloneToVImg()!\n");
        return NULL;
    }

    if (!cvt32FToVImg(iplY, iplU, iplV, vpImage)) {
        releaseVEUHDImage(&vpImage);
        return NULL;
    }

    return vpImage;
}

bool CImageUtility::cvt32FToVImg(IplImage *iplY, IplImage *iplU, IplImage *iplV, VEUHDImage *vpImage)
// Convert YUV planes in IplImage format to one VEUHDImage.
// When the U/V is NULL, the converted image is a grayscale one.
{
    if (iplY==NULL || iplY->nChannels != 1 || iplY->depth != SR_DEPTH_32F || vpImage == NULL) {
        showErrMsg("Invalid input image or bit depth in CImageUtility::cvt32FToVImg()!\n");
        return NULL;
    }

    // check input/output images
    bool mismatch = false;
    if (iplU == NULL || iplV == NULL) {     // grayscale image
        if (vpImage->channels != 1 || vpImage->colorfmt != 0 ||
            vpImage->width != iplY->width || vpImage->height != iplY->height) {
            mismatch = true;
        }
    } else {                                                // YUV image
        if (iplU->width != iplV->width || iplU->height != iplV->height ||
            iplU->depth != iplY->depth || iplV->depth != iplY->depth ||
            iplU->nChannels != iplY->nChannels || iplV->nChannels != iplY->nChannels) {
            mismatch = true;
        }
        if (vpImage->channels != 3 ||
            vpImage->width != iplY->width || vpImage->height != iplY->height) {
            mismatch = true;
        }
        if (vpImage->colorfmt == 1) {               // 4:2:0
            if (iplY->width != iplU->width*2 || iplY->height != iplU->height*2) {
                mismatch = true;
            }
        } else if (vpImage->colorfmt == 2) {       // 4:2:2
            if (iplY->width != iplU->width*2 || iplY->height != iplU->height) {
                mismatch = true;
            }
        } else if (vpImage->colorfmt == 3) {       // 4:4:4
            if (iplY->width != iplU->width || iplY->height != iplU->height) {
                mismatch = true;
            }
        } else {
            mismatch = true;
        }
    }
    if (mismatch) {
        showErrMsg("Mismatched input and output imagesin CImageUtility::cvt32FToVImg()!\n");
        return NULL;
    }

    // convert
    if (vpImage->depth == 8) {
        // convert Y
        for (int y=0; y<iplY->height; y++) {
            float *pSrc = (float *)(iplY->imageData + y*iplY->widthStep);
            unsigned char *pDst = (unsigned char *)(vpImage->imageData[0] + y*vpImage->widthStep[0]);
            for (int x=0; x<iplY->width; x++) {
                int pix = (int)(pSrc[x] + 0.5f);
                pDst[x] = (unsigned char)clip_0_255(pix);
            }
        }
        // convert UV in need
        if (iplU != NULL && iplV != NULL) { 
            // convert U
            for (int y=0; y<iplU->height; y++) {
                float *pSrc = (float *)(iplU->imageData + y*iplU->widthStep);
                unsigned char *pDst = (unsigned char *)(vpImage->imageData[1] + y*vpImage->widthStep[1]);
                for (int x=0; x<iplU->width; x++) {
                    int pix = (int)(pSrc[x] + 0.5f);
                    pDst[x] = (unsigned char)clip_0_255(pix);
                }
            }
            // convert V
            for (int y=0; y<iplV->height; y++) {
                float *pSrc = (float *)(iplV->imageData + y*iplV->widthStep);
                unsigned char *pDst = (unsigned char *)(vpImage->imageData[2] + y*vpImage->widthStep[2]);
                for (int x=0; x<iplV->width; x++) {
                    int pix = (int)(pSrc[x] + 0.5f);
                    pDst[x] = (unsigned char)clip_0_255(pix);
                }
            }
        }
    } else {
        // To 16U output
        int max_value = (0x00000001 << vpImage->depth) - 1;
        int shift_bit =  vpImage->depth - 8;
        float mul_factor = (float)(0x0001 << shift_bit);
        // convert Y
        for (int y=0; y<iplY->height; y++) {
            float *pSrc = (float *)(iplY->imageData + y*iplY->widthStep);
            unsigned short *pDst = (unsigned short *)(vpImage->imageData[0] + y*vpImage->widthStep[0]);
            for (int x=0; x<iplY->width; x++) {
                int pix = (int)(pSrc[x]*mul_factor + 0.5f);
                pix = pix < 0 ? 0 : pix;
                pix = pix > max_value ? max_value : pix;
                pDst[x] = (unsigned short)pix;
            }
        }
        // convert UV in need
        if (iplU != NULL && iplV != NULL) { 
            // convert U
            for (int y=0; y<iplU->height; y++) {
                float *pSrc = (float *)(iplU->imageData + y*iplU->widthStep);
                unsigned short *pDst = (unsigned short *)(vpImage->imageData[1] + y*vpImage->widthStep[1]);
                for (int x=0; x<iplU->width; x++) {
                    int pix = (int)(pSrc[x]*mul_factor + 0.5f);
                    pix = pix < 0 ? 0 : pix;
                    pix = pix > max_value ? max_value : pix;
                    pDst[x] = (unsigned short)pix;
                }
            }
            // convert V
            for (int y=0; y<iplV->height; y++) {
                float *pSrc = (float *)(iplV->imageData + y*iplV->widthStep);
                unsigned short *pDst = (unsigned short *)(vpImage->imageData[2] + y*vpImage->widthStep[2]);
                for (int x=0; x<iplV->width; x++) {
                    int pix = (int)(pSrc[x]*mul_factor + 0.5f);
                    pix = pix < 0 ? 0 : pix;
                    pix = pix > max_value ? max_value : pix;
                    pDst[x] = (unsigned short)pix;
                }
            }
        }
    }

    return true;
}

#endif


//
// Other functions
//
#include "LanczosFast.cpp"

//
// SIMD implementation!
//
#ifdef __SR_USE_SIMD
#include "ImgProcUtilitySIMD.cpp"
#include "LanczosFastSIMD.cpp"
#endif      // #ifndef __SR_USE_SIMD

